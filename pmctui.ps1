# PMC TUI Self-Extracting Installer
# Generated: 2025-12-22 17:40:47
# Contains all program files needed to run PMC TUI

param(
    [Parameter(Mandatory=$true)]
    [string]$InstallPath,
    [switch]$Force
)

Write-Host "PMC TUI Installer" -ForegroundColor Cyan
Write-Host "=================" -ForegroundColor Cyan
Write-Host ""

if (Test-Path $InstallPath) {
    if (-not $Force) {
        Write-Host "ERROR: Path exists: $InstallPath" -ForegroundColor Red
        Write-Host "Use -Force to overwrite" -ForegroundColor Yellow
        exit 1
    }
    Write-Host "Removing existing installation..." -ForegroundColor Yellow
    Remove-Item -Path $InstallPath -Recurse -Force
}

$null = New-Item -ItemType Directory -Path $InstallPath -Force

# Extract embedded JSON data
$scriptContent = Get-Content $PSCommandPath -Raw
$startMarker = "___BEGIN_PMC_DATA___"
$endMarker = "___END_PMC_DATA___"
$startIdx = $scriptContent.LastIndexOf($startMarker)
$endIdx = $scriptContent.LastIndexOf($endMarker)

if ($startIdx -lt 0 -or $endIdx -lt 0) {
    Write-Host "ERROR: Data section not found in installer" -ForegroundColor Red
    exit 1
}

$jsonData = $scriptContent.Substring($startIdx + $startMarker.Length, $endIdx - $startIdx - $startMarker.Length)
$jsonData = $jsonData.Replace('##CLOSEBRACKET##', '#>')
$files = $jsonData | ConvertFrom-Json

Write-Host "Installing $($files.Count) files..." -ForegroundColor Green
Write-Host ""

$count = 0
foreach ($file in $files) {
    $count++
    $fullPath = Join-Path $InstallPath $file.path
    $dir = Split-Path $fullPath -Parent
    if (-not (Test-Path $dir)) { $null = New-Item -ItemType Directory -Path $dir -Force }
    Set-Content -Path $fullPath -Value $file.content -NoNewline
    if ($count % 25 -eq 0) { Write-Host "  Progress: $count / $($files.Count) files..." }
}

# Create data directories
$null = New-Item -ItemType Directory -Path (Join-Path $InstallPath "data/logs") -Force
$null = New-Item -ItemType Directory -Path (Join-Path $InstallPath "data/backups") -Force

# Create initial tasks.json with required settings property (at root, not data/)
$tasksJsonPath = Join-Path $InstallPath "tasks.json"
if (-not (Test-Path $tasksJsonPath)) {
    @{tasks=@();projects=@();notes=@();checklists=@();templates=@();settings=@{}} | ConvertTo-Json -Depth 10 | Set-Content -Path $tasksJsonPath -Encoding UTF8
}


Write-Host ""
Write-Host "======================================" -ForegroundColor Green
Write-Host "Installation complete! ($count files)" -ForegroundColor Green
Write-Host "======================================" -ForegroundColor Green
Write-Host ""
Write-Host "To run PMC TUI:" -ForegroundColor Cyan
Write-Host "  cd $InstallPath" -ForegroundColor White
Write-Host "  pwsh ./start.ps1" -ForegroundColor White
Write-Host ""

<#
___BEGIN_PMC_DATA___[{"path": "config.json", "content": "{\n  \"Display\": {\n    \"Icons\": {\n      \"Mode\": \"emoji\"\n    },\n    \"Theme\": {\n      \"Hex\": \"#ff00ff\",\n      \"Active\": \"synthwave\"\n    }\n  }\n}\n"}, {"path": "start.ps1", "content": "# start.ps1 - Portable entry point for PMC TUI\n# Works on both Windows and Linux - keeps all files within program folder\nparam(\n    [int]$debug = 0    # 0=off, 1=errors, 2=info, 3=verbose\n)\n\nSet-StrictMode -Version Latest\n\n# Determine application root (cross-platform)\n$script:AppRoot = $PSScriptRoot\n\n# Create data directory structure if needed\n$dataDir = Join-Path $script:AppRoot \"data\"\n$logDir = Join-Path $dataDir \"logs\"\n$backupDir = Join-Path $dataDir \"backups\"\n\nforeach ($dir in @($dataDir, $logDir, $backupDir)) {\n    if (-not (Test-Path $dir)) {\n        New-Item -ItemType Directory -Path $dir -Force | Out-Null\n    }\n}\n\n# Set global path for debug logging (replaces hardcoded /tmp/pmc-debug.log)\n$global:PmcDebugLogPath = Join-Path $logDir \"pmc-debug.log\"\n$global:PmcAppRoot = $script:AppRoot\n\n# Export for other modules\n$env:PMC_APP_ROOT = $script:AppRoot\n$env:PMC_LOG_PATH = $logDir\n\n# Launch TUI\ntry {\n    # Dot-source to load the function\n    . \"$script:AppRoot/module/Pmc.Strict/consoleui/Start-PmcTUI.ps1\"\n    \n    # Now call the function explicitly\n    Start-PmcTUI -debug $debug\n}\ncatch {\n    Write-Host \"PMC TUI Error: $_\" -ForegroundColor Red\n    Write-Host \"See log at: $global:PmcDebugLogPath\" -ForegroundColor Yellow\n    throw\n}\n"}, {"path": "lib/SpeedTUI/BorderHelper.ps1", "content": "#!/usr/bin/env pwsh\r\n# BorderHelper - Foolproof border drawing utility\r\n\r\nclass BorderHelper {\r\n    static [int]$ConsoleWidth = 80\r\n    static [int]$ConsoleHeight = 24\r\n    \r\n    static [void] UpdateDimensions() {\r\n        try {\r\n            [BorderHelper]::ConsoleWidth = [Console]::WindowWidth\r\n            [BorderHelper]::ConsoleHeight = [Console]::WindowHeight\r\n        } catch {\r\n            # Fallback to safe defaults\r\n            [BorderHelper]::ConsoleWidth = 80\r\n            [BorderHelper]::ConsoleHeight = 24\r\n        }\r\n    }\r\n    \r\n    static [string] TopBorder() {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = [BorderHelper]::ConsoleWidth\r\n        $content = \"╔\" + (\"═\" * ($width - 2)) + \"╗\"\r\n        return $content\r\n    }\r\n    \r\n    static [string] TopBorder([int]$customWidth) {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = $(if ($customWidth -gt 0) { $customWidth } else { [BorderHelper]::ConsoleWidth })\r\n        $content = \"╔\" + (\"═\" * ($width - 2)) + \"╗\"\r\n        return $content\r\n    }\r\n    \r\n    static [string] MiddleBorder() {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = [BorderHelper]::ConsoleWidth\r\n        $content = \"╠\" + (\"═\" * ($width - 2)) + \"╣\"\r\n        return $content\r\n    }\r\n    \r\n    static [string] MiddleBorder([int]$customWidth) {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = $(if ($customWidth -gt 0) { $customWidth } else { [BorderHelper]::ConsoleWidth })\r\n        $content = \"╠\" + (\"═\" * ($width - 2)) + \"╣\"\r\n        return $content\r\n    }\r\n    \r\n    static [string] BottomBorder() {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = [BorderHelper]::ConsoleWidth\r\n        $content = \"╚\" + (\"═\" * ($width - 2)) + \"╝\"\r\n        return $content\r\n    }\r\n    \r\n    static [string] BottomBorder([int]$customWidth) {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = $(if ($customWidth -gt 0) { $customWidth } else { [BorderHelper]::ConsoleWidth })\r\n        $content = \"╚\" + (\"═\" * ($width - 2)) + \"╝\"\r\n        return $content\r\n    }\r\n    \r\n    static [string] ContentLine([string]$text) {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = [BorderHelper]::ConsoleWidth\r\n        # \"║  \" (3) + content + \"  ║\" (3) = 6 chars overhead\r\n        $maxContentWidth = $width - 6\r\n        \r\n        # Truncate text if too long\r\n        if ($text.Length -gt $maxContentWidth) {\r\n            $text = $text.Substring(0, $maxContentWidth - 3) + \"...\"\r\n        }\r\n        \r\n        # Pad to exact width\r\n        $paddedText = $text.PadRight($maxContentWidth)\r\n        $content = \"║  \" + $paddedText + \"  ║\"\r\n        \r\n        return $content\r\n    }\r\n    \r\n    static [string] ContentLine([string]$text, [int]$customWidth) {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = $(if ($customWidth -gt 0) { $customWidth } else { [BorderHelper]::ConsoleWidth })\r\n        # \"║  \" (3) + content + \"  ║\" (3) = 6 chars overhead\r\n        $maxContentWidth = $width - 6\r\n        \r\n        # Truncate text if too long\r\n        if ($text.Length -gt $maxContentWidth) {\r\n            $text = $text.Substring(0, $maxContentWidth - 3) + \"...\"\r\n        }\r\n        \r\n        # Pad to exact width\r\n        $paddedText = $text.PadRight($maxContentWidth)\r\n        $content = \"║  \" + $paddedText + \"  ║\"\r\n        \r\n        return $content\r\n    }\r\n    \r\n    static [string] EmptyLine() {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = [BorderHelper]::ConsoleWidth\r\n        $spaces = \" \" * ($width - 2)\r\n        return \"║$spaces║\"\r\n    }\r\n    \r\n    static [string] EmptyLine([int]$customWidth) {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = $(if ($customWidth -gt 0) { $customWidth } else { [BorderHelper]::ConsoleWidth })\r\n        $spaces = \" \" * ($width - 2)\r\n        return \"║$spaces║\"\r\n    }\r\n    \r\n    static [string] StatusLine([string]$text) {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = [BorderHelper]::ConsoleWidth\r\n        # \"║  \" (3) + content + \"  ║\" (3) = 6 chars overhead\r\n        $maxContentWidth = $width - 6\r\n        \r\n        # Truncate if needed\r\n        if ($text.Length -gt $maxContentWidth) {\r\n            $text = $text.Substring(0, $maxContentWidth - 3) + \"...\"\r\n        }\r\n        \r\n        # Center the text\r\n        $padding = $maxContentWidth - $text.Length\r\n        $leftPad = [Math]::Floor($padding / 2)\r\n        $rightPad = $padding - $leftPad\r\n        $centeredText = (\" \" * $leftPad) + $text + (\" \" * $rightPad)\r\n        \r\n        return \"║  \" + $centeredText + \"  ║\"\r\n    }\r\n    \r\n    static [string] StatusLine([string]$text, [int]$customWidth) {\r\n        [BorderHelper]::UpdateDimensions()\r\n        $width = $(if ($customWidth -gt 0) { $customWidth } else { [BorderHelper]::ConsoleWidth })\r\n        # \"║  \" (3) + content + \"  ║\" (3) = 6 chars overhead\r\n        $maxContentWidth = $width - 6\r\n        \r\n        # Truncate if needed\r\n        if ($text.Length -gt $maxContentWidth) {\r\n            $text = $text.Substring(0, $maxContentWidth - 3) + \"...\"\r\n        }\r\n        \r\n        # Center the text\r\n        $padding = $maxContentWidth - $text.Length\r\n        $leftPad = [Math]::Floor($padding / 2)\r\n        $rightPad = $padding - $leftPad\r\n        $centeredText = (\" \" * $leftPad) + $text + (\" \" * $rightPad)\r\n        \r\n        return \"║  \" + $centeredText + \"  ║\"\r\n    }\r\n}\r\n\r\n# Test the border helper\r\nfunction Test-BorderHelper {\r\n    Write-Host \"Testing BorderHelper with current console dimensions...\" -ForegroundColor Cyan\r\n    \r\n    [BorderHelper]::UpdateDimensions()\r\n    Write-Host \"Console size: $([BorderHelper]::ConsoleWidth) x $([BorderHelper]::ConsoleHeight)\" -ForegroundColor Yellow\r\n    \r\n    # Test borders\r\n    $top = [BorderHelper]::TopBorder()\r\n    $middle = [BorderHelper]::MiddleBorder()\r\n    $bottom = [BorderHelper]::BottomBorder()\r\n    $empty = [BorderHelper]::EmptyLine()\r\n    $content = [BorderHelper]::ContentLine(\"Test content line\")\r\n    $status = [BorderHelper]::StatusLine(\"Centered status text\")\r\n    \r\n    Write-Host \"Actual lengths:\" -ForegroundColor Green\r\n    Write-Host \"  Top border: $($top.Length) chars\" -ForegroundColor Green\r\n    Write-Host \"  Content line: $($content.Length) chars\" -ForegroundColor Green\r\n    Write-Host \"  Bottom border: $($bottom.Length) chars\" -ForegroundColor Green\r\n    \r\n    Write-Host \"`nRendered output:\" -ForegroundColor Green\r\n    Write-Host $top -ForegroundColor Cyan\r\n    Write-Host $content -ForegroundColor White\r\n    Write-Host $middle -ForegroundColor Cyan\r\n    Write-Host $status -ForegroundColor Gray\r\n    Write-Host $empty -ForegroundColor White\r\n    Write-Host $bottom -ForegroundColor Cyan\r\n}"}, {"path": "lib/SpeedTUI/Core/CellBuffer.ps1", "content": "# SpeedTUI CellBuffer - 2D Cell-Based Terminal Buffer\r\n# This provides a high-performance cell-based buffer for terminal rendering\r\n# with support for RGB colors and text attributes\r\n\r\nusing namespace System.Collections.Generic\r\n\r\n<#\r\n.SYNOPSIS\r\nRepresents a single cell in the terminal buffer\r\n\r\n.DESCRIPTION\r\nA Cell contains:\r\n- Character (char): The displayed character\r\n- ForegroundRgb (int): Packed RGB foreground color (R<<16 | G<<8 | B)\r\n- BackgroundRgb (int): Packed RGB background color (R<<16 | G<<8 | B)\r\n- Attributes (byte): Bitfield for bold/underline/etc\r\n\r\nThis struct-like class is designed for minimal memory overhead and fast comparison.\r\n##CLOSEBRACKET##\r\nclass Cell {\r\n    [char]$Char = ' '           # Character to display\r\n    [int]$ForegroundRgb = -1    # Packed RGB: (R<<16)|(G<<8)|B, -1 = default\r\n    [int]$BackgroundRgb = -1    # Packed RGB: (R<<16)|(G<<8)|B, -1 = default\r\n    [byte]$Attributes = 0       # Bit 0: Bold, Bit 1: Underline, Bit 2: Italic\r\n\r\n    # Attribute bit flags\r\n    static [byte]$ATTR_BOLD = 0x01\r\n    static [byte]$ATTR_UNDERLINE = 0x02\r\n    static [byte]$ATTR_ITALIC = 0x04\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Creates a new Cell with default values (space, default colors)\r\n    ##CLOSEBRACKET##\r\n    Cell() {\r\n        $this.Char = ' '\r\n        $this.ForegroundRgb = -1\r\n        $this.BackgroundRgb = -1\r\n        $this.Attributes = 0\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Creates a new Cell with specified values\r\n\r\n    .PARAMETER char\r\n    Character to display\r\n\r\n    .PARAMETER fg\r\n    Packed foreground RGB (-1 for default)\r\n\r\n    .PARAMETER bg\r\n    Packed background RGB (-1 for default)\r\n\r\n    .PARAMETER attr\r\n    Attributes bitfield\r\n    ##CLOSEBRACKET##\r\n    Cell([char]$char, [int]$fg, [int]$bg, [byte]$attr) {\r\n        $this.Char = $char\r\n        $this.ForegroundRgb = $fg\r\n        $this.BackgroundRgb = $bg\r\n        $this.Attributes = $attr\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Check if this cell equals another cell\r\n\r\n    .DESCRIPTION\r\n    Two cells are equal if all their properties match. This is used\r\n    for differential rendering to skip unchanged cells.\r\n\r\n    .PARAMETER other\r\n    Other Cell to compare with (passed as [object] due to PowerShell limitations)\r\n\r\n    .OUTPUTS\r\n    Boolean indicating equality\r\n    ##CLOSEBRACKET##\r\n    [bool] Equals([object]$other) {\r\n        if ($null -eq $other) { return $false }\r\n        return $this.Char -eq $other.Char -and\r\n               $this.ForegroundRgb -eq $other.ForegroundRgb -and\r\n               $this.BackgroundRgb -eq $other.BackgroundRgb -and\r\n               $this.Attributes -eq $other.Attributes\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Copy values from another cell into this cell\r\n\r\n    .PARAMETER source\r\n    Source Cell to copy from (passed as [object] due to PowerShell limitations)\r\n    ##CLOSEBRACKET##\r\n    [void] CopyFrom([object]$source) {\r\n        $this.Char = $source.Char\r\n        $this.ForegroundRgb = $source.ForegroundRgb\r\n        $this.BackgroundRgb = $source.BackgroundRgb\r\n        $this.Attributes = $source.Attributes\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Reset cell to default values (space, default colors, no attributes)\r\n    ##CLOSEBRACKET##\r\n    [void] Reset() {\r\n        $this.Char = ' '\r\n        $this.ForegroundRgb = -1\r\n        $this.BackgroundRgb = -1\r\n        $this.Attributes = 0\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\n2D cell buffer for terminal rendering with differential updates\r\n\r\n.DESCRIPTION\r\nCellBuffer maintains a 2D array of Cell objects representing the terminal screen.\r\nIt provides:\r\n- Fast O(1) random access to any cell\r\n- Efficient differential rendering (BuildDiff)\r\n- Automatic resize handling\r\n- ANSI sequence parsing and emission\r\n\r\nDesign rationale:\r\n- Cell-based approach is more memory-efficient than string-based for sparse updates\r\n- Packed RGB integers reduce memory overhead (4 bytes vs 3 bytes + padding)\r\n- Differential rendering minimizes actual terminal writes (the bottleneck)\r\n- ANSI sequence grouping reduces escape code overhead\r\n\r\nPerformance characteristics:\r\n- SetCell: O(1)\r\n- GetCell: O(1)\r\n- Clear: O(width * height) - unavoidable, must touch all cells\r\n- BuildDiff: O(width * height) - but skips unchanged cells early\r\n- Memory: ~12 bytes per cell (char=2, int=4, int=4, byte=1, padding)\r\n\r\n.EXAMPLE\r\n$buffer = [CellBuffer]::new(80, 24)\r\n$buffer.SetCell(10, 5, 'X', 0xFF0000, -1, [Cell]::ATTR_BOLD)\r\n$buffer.GetCell(10, 5)\r\n##CLOSEBRACKET##\r\nclass CellBuffer {\r\n    # Buffer dimensions\r\n    [int]$Width\r\n    [int]$Height\r\n\r\n    # 2D array of cells: [row][col]\r\n    # We use row-major order for better cache locality when building diff by rows\r\n    # NOTE: Using [object] instead of [Cell[][]] due to PowerShell limitations with nested custom class arrays\r\n    hidden [object]$_cells\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Creates a new CellBuffer with specified dimensions\r\n\r\n    .PARAMETER width\r\n    Width in columns\r\n\r\n    .PARAMETER height\r\n    Height in rows\r\n    ##CLOSEBRACKET##\r\n    CellBuffer([int]$width, [int]$height) {\r\n        if ($width -le 0 -or $height -le 0) {\r\n            throw \"CellBuffer dimensions must be positive\"\r\n        }\r\n\r\n        $this.Width = $width\r\n        $this.Height = $height\r\n        $this._cells = [object[]]::new($height)\r\n\r\n        # Pre-allocate all cells to avoid null checks\r\n        for ($y = 0; $y -lt $height; $y++) {\r\n            $this._cells[$y] = [object[]]::new($width)\r\n            for ($x = 0; $x -lt $width; $x++) {\r\n                $this._cells[$y][$x] = [Cell]::new()\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set a cell at the specified position\r\n\r\n    .DESCRIPTION\r\n    Sets the character, colors, and attributes for a cell. Out-of-bounds\r\n    coordinates are silently ignored (defensive programming for resize races).\r\n\r\n    .PARAMETER x\r\n    X coordinate (0-based)\r\n\r\n    .PARAMETER y\r\n    Y coordinate (0-based)\r\n\r\n    .PARAMETER char\r\n    Character to display\r\n\r\n    .PARAMETER fg\r\n    Packed foreground RGB, or -1 for default\r\n\r\n    .PARAMETER bg\r\n    Packed background RGB, or -1 for default\r\n\r\n    .PARAMETER attr\r\n    Attributes bitfield (bold, underline, italic)\r\n    ##CLOSEBRACKET##\r\n    [void] SetCell([int]$x, [int]$y, [char]$char, [int]$fg, [int]$bg, [byte]$attr) {\r\n        # Bounds check - silently ignore out of bounds (defensive)\r\n        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {\r\n            return\r\n        }\r\n\r\n        $cell = $this._cells[$y][$x]\r\n        $cell.Char = $char\r\n        $cell.ForegroundRgb = $fg\r\n        $cell.BackgroundRgb = $bg\r\n        $cell.Attributes = $attr\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get a cell at the specified position\r\n\r\n    .PARAMETER x\r\n    X coordinate (0-based)\r\n\r\n    .PARAMETER y\r\n    Y coordinate (0-based)\r\n\r\n    .OUTPUTS\r\n    Cell object, or $null if out of bounds\r\n    ##CLOSEBRACKET##\r\n    [Cell] GetCell([int]$x, [int]$y) {\r\n        if ($x -lt 0 -or $x -ge $this.Width -or $y -lt 0 -or $y -ge $this.Height) {\r\n            return $null\r\n        }\r\n        return $this._cells[$y][$x]\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Clear the entire buffer to default state\r\n\r\n    .DESCRIPTION\r\n    Resets all cells to space character with default colors and no attributes.\r\n    This is O(width*height) but unavoidable - we must touch every cell.\r\n    ##CLOSEBRACKET##\r\n    [void] Clear() {\r\n        for ($y = 0; $y -lt $this.Height; $y++) {\r\n            for ($x = 0; $x -lt $this.Width; $x++) {\r\n                $this._cells[$y][$x].Reset()\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Resize the buffer to new dimensions\r\n\r\n    .DESCRIPTION\r\n    Creates a new buffer with the specified dimensions. Old content is\r\n    preserved where it fits, new areas are initialized to default cells.\r\n\r\n    This is called when terminal is resized. We allocate a fresh buffer\r\n    to avoid complex reallocation logic.\r\n\r\n    .PARAMETER newWidth\r\n    New width in columns\r\n\r\n    .PARAMETER newHeight\r\n    New height in rows\r\n    ##CLOSEBRACKET##\r\n    [void] Resize([int]$newWidth, [int]$newHeight) {\r\n        if ($newWidth -le 0 -or $newHeight -le 0) {\r\n            throw \"CellBuffer dimensions must be positive\"\r\n        }\r\n\r\n        # Create new buffer\r\n        $newCells = [object[]]::new($newHeight)\r\n        for ($y = 0; $y -lt $newHeight; $y++) {\r\n            $newCells[$y] = [object[]]::new($newWidth)\r\n            for ($x = 0; $x -lt $newWidth; $x++) {\r\n                $newCells[$y][$x] = [Cell]::new()\r\n            }\r\n        }\r\n\r\n        # Copy old content where it fits\r\n        $copyHeight = [Math]::Min($this.Height, $newHeight)\r\n        $copyWidth = [Math]::Min($this.Width, $newWidth)\r\n\r\n        for ($y = 0; $y -lt $copyHeight; $y++) {\r\n            for ($x = 0; $x -lt $copyWidth; $x++) {\r\n                $newCells[$y][$x].CopyFrom($this._cells[$y][$x])\r\n            }\r\n        }\r\n\r\n        # Update dimensions and replace buffer\r\n        $this.Width = $newWidth\r\n        $this.Height = $newHeight\r\n        $this._cells = $newCells\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Build minimal ANSI output representing differences between this buffer and another\r\n\r\n    .DESCRIPTION\r\n    This is the core of differential rendering. It compares this buffer (back buffer)\r\n    with the previous buffer (front buffer) and emits only the ANSI sequences needed\r\n    to transform the front buffer into the back buffer.\r\n\r\n    Optimization strategies:\r\n    1. Skip unchanged cells entirely (most common case)\r\n    2. Group adjacent cells with same colors to reduce escape codes\r\n    3. Pack RGB values for fast integer comparison\r\n    4. Use cursor positioning only when needed (track cursor position)\r\n    5. Emit reset only when colors actually change\r\n\r\n    Why this is faster than string-based:\r\n    - String-based: Must parse ANSI in every string, hard to optimize groups\r\n    - Cell-based: Cells already parsed, colors already integers, trivial to group\r\n\r\n    .PARAMETER previousBuffer\r\n    The previous CellBuffer state (front buffer)\r\n\r\n    .OUTPUTS\r\n    String containing minimal ANSI sequences to update the terminal\r\n    ##CLOSEBRACKET##\r\n    [string] BuildDiff([object]$previousBuffer) {\r\n        $sb = [System.Text.StringBuilder]::new(4096)\r\n\r\n        # Track current state to minimize escape sequences\r\n        $currentFg = -1\r\n        $currentBg = -1\r\n        $currentAttr = [byte]0\r\n        $cursorX = -1\r\n        $cursorY = -1\r\n\r\n        for ($y = 0; $y -lt $this.Height; $y++) {\r\n            $x = 0\r\n            while ($x -lt $this.Width) {\r\n                $cell = $this._cells[$y][$x]\r\n\r\n                # Check if cell changed\r\n                $prevCell = $(if ($previousBuffer -and\r\n                              $y -lt $previousBuffer.Height -and\r\n                              $x -lt $previousBuffer.Width) {\r\n                    $previousBuffer._cells[$y][$x]\r\n                } else {\r\n                    $null\r\n                })\r\n\r\n                # Skip if unchanged\r\n                if ($prevCell -and $cell.Equals($prevCell)) {\r\n                    $x++\r\n                    continue\r\n                }\r\n\r\n                # Cell changed - need to update\r\n                # First, move cursor if needed\r\n                if ($cursorX -ne $x -or $cursorY -ne $y) {\r\n                    [void]$sb.Append(\"`e[$($y + 1);$($x + 1)H\")\r\n                    $cursorX = $x\r\n                    $cursorY = $y\r\n                }\r\n\r\n                # Look ahead to group cells with same attributes\r\n                $runLength = 1\r\n                while (($x + $runLength) -lt $this.Width) {\r\n                    $nextCell = $this._cells[$y][$x + $runLength]\r\n\r\n                    # Can group if colors and attributes match\r\n                    if ($nextCell.ForegroundRgb -eq $cell.ForegroundRgb -and\r\n                        $nextCell.BackgroundRgb -eq $cell.BackgroundRgb -and\r\n                        $nextCell.Attributes -eq $cell.Attributes) {\r\n\r\n                        # Also check if changed from previous\r\n                        $nextPrevCell = $(if ($previousBuffer -and\r\n                                          $y -lt $previousBuffer.Height -and\r\n                                          ($x + $runLength) -lt $previousBuffer.Width) {\r\n                            $previousBuffer._cells[$y][$x + $runLength]\r\n                        } else {\r\n                            $null\r\n                        })\r\n\r\n                        if (-not $nextPrevCell -or -not $nextCell.Equals($nextPrevCell)) {\r\n                            $runLength++\r\n                        } else {\r\n                            break\r\n                        }\r\n                    } else {\r\n                        break\r\n                    }\r\n                }\r\n\r\n                # Emit attributes if changed\r\n                if ($cell.Attributes -ne $currentAttr) {\r\n                    # Reset first if we had attributes\r\n                    if ($currentAttr -ne 0) {\r\n                        [void]$sb.Append(\"`e[0m\")\r\n                        $currentFg = -1\r\n                        $currentBg = -1\r\n                    }\r\n\r\n                    # Apply new attributes\r\n                    if ($cell.Attributes -band [Cell]::ATTR_BOLD) {\r\n                        [void]$sb.Append(\"`e[1m\")\r\n                    }\r\n                    if ($cell.Attributes -band [Cell]::ATTR_UNDERLINE) {\r\n                        [void]$sb.Append(\"`e[4m\")\r\n                    }\r\n                    if ($cell.Attributes -band [Cell]::ATTR_ITALIC) {\r\n                        [void]$sb.Append(\"`e[3m\")\r\n                    }\r\n\r\n                    $currentAttr = $cell.Attributes\r\n                }\r\n\r\n                # Emit foreground color if changed\r\n                if ($cell.ForegroundRgb -ne $currentFg) {\r\n                    if ($cell.ForegroundRgb -eq -1) {\r\n                        [void]$sb.Append(\"`e[39m\")  # Default foreground\r\n                    } else {\r\n                        $r = ($cell.ForegroundRgb -shr 16) -band 0xFF\r\n                        $g = ($cell.ForegroundRgb -shr 8) -band 0xFF\r\n                        $b = $cell.ForegroundRgb -band 0xFF\r\n                        [void]$sb.Append(\"`e[38;2;$r;$g;${b}m\")\r\n                    }\r\n                    $currentFg = $cell.ForegroundRgb\r\n                }\r\n\r\n                # Emit background color if changed\r\n                if ($cell.BackgroundRgb -ne $currentBg) {\r\n                    if ($cell.BackgroundRgb -eq -1) {\r\n                        [void]$sb.Append(\"`e[49m\")  # Default background\r\n                    } else {\r\n                        $r = ($cell.BackgroundRgb -shr 16) -band 0xFF\r\n                        $g = ($cell.BackgroundRgb -shr 8) -band 0xFF\r\n                        $b = $cell.BackgroundRgb -band 0xFF\r\n                        [void]$sb.Append(\"`e[48;2;$r;$g;${b}m\")\r\n                    }\r\n                    $currentBg = $cell.BackgroundRgb\r\n                }\r\n\r\n                # Emit the characters for this run\r\n                for ($i = 0; $i -lt $runLength; $i++) {\r\n                    [void]$sb.Append($this._cells[$y][$x + $i].Char)\r\n                }\r\n\r\n                # Update cursor position\r\n                $cursorX = $x + $runLength\r\n                $x += $runLength\r\n            }\r\n        }\r\n\r\n        return $sb.ToString()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Copy entire contents from another buffer\r\n\r\n    .DESCRIPTION\r\n    This is used to swap buffers efficiently. Instead of swapping references\r\n    (which breaks encapsulation), we copy cell contents.\r\n\r\n    .PARAMETER source\r\n    Source CellBuffer to copy from\r\n    ##CLOSEBRACKET##\r\n    [void] CopyFrom([object]$source) {\r\n        if ($source.Width -ne $this.Width -or $source.Height -ne $this.Height) {\r\n            throw \"Cannot copy from buffer with different dimensions\"\r\n        }\r\n\r\n        for ($y = 0; $y -lt $this.Height; $y++) {\r\n            for ($x = 0; $x -lt $this.Width; $x++) {\r\n                $this._cells[$y][$x].CopyFrom($source._cells[$y][$x])\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Fill a rectangular region with a character and colors\r\n\r\n    .DESCRIPTION\r\n    Utility method for filling regions (useful for clearing areas or backgrounds)\r\n\r\n    .PARAMETER x\r\n    Starting X coordinate\r\n\r\n    .PARAMETER y\r\n    Starting Y coordinate\r\n\r\n    .PARAMETER width\r\n    Width of region\r\n\r\n    .PARAMETER height\r\n    Height of region\r\n\r\n    .PARAMETER char\r\n    Character to fill with\r\n\r\n    .PARAMETER fg\r\n    Foreground color (packed RGB or -1)\r\n\r\n    .PARAMETER bg\r\n    Background color (packed RGB or -1)\r\n\r\n    .PARAMETER attr\r\n    Attributes bitfield\r\n    ##CLOSEBRACKET##\r\n    [void] Fill([int]$x, [int]$y, [int]$width, [int]$height, [char]$char, [int]$fg, [int]$bg, [byte]$attr) {\r\n        $endX = [Math]::Min($x + $width, $this.Width)\r\n        $endY = [Math]::Min($y + $height, $this.Height)\r\n\r\n        for ($row = [Math]::Max(0, $y); $row -lt $endY; $row++) {\r\n            for ($col = [Math]::Max(0, $x); $col -lt $endX; $col++) {\r\n                $this.SetCell($col, $row, $char, $fg, $bg, $attr)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nPack RGB components into a single integer\r\n\r\n.DESCRIPTION\r\nPacks red, green, blue components (0-255 each) into a single 32-bit integer.\r\nFormat: 0x00RRGGBB\r\n\r\nThis reduces memory overhead and makes color comparison a single integer\r\ncomparison instead of three byte comparisons.\r\n\r\n.PARAMETER r\r\nRed component (0-255)\r\n\r\n.PARAMETER g\r\nGreen component (0-255)\r\n\r\n.PARAMETER b\r\nBlue component (0-255)\r\n\r\n.OUTPUTS\r\nPacked integer representing RGB color\r\n\r\n.EXAMPLE\r\n$color = Pack-RGB 255 128 64  # Returns 0x00FF8040\r\n##CLOSEBRACKET##\r\nfunction Pack-RGB {\r\n    param(\r\n        [Parameter(Mandatory)][int]$r,\r\n        [Parameter(Mandatory)][int]$g,\r\n        [Parameter(Mandatory)][int]$b\r\n    )\r\n\r\n    # Clamp to valid range\r\n    $r = [Math]::Max(0, [Math]::Min(255, $r))\r\n    $g = [Math]::Max(0, [Math]::Min(255, $g))\r\n    $b = [Math]::Max(0, [Math]::Min(255, $b))\r\n\r\n    return ($r -shl 16) -bor ($g -shl 8) -bor $b\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nUnpack RGB integer into components\r\n\r\n.DESCRIPTION\r\nExtracts red, green, blue components from a packed RGB integer.\r\n\r\n.PARAMETER packed\r\nPacked RGB integer (format: 0x00RRGGBB)\r\n\r\n.OUTPUTS\r\nHashtable with R, G, B keys\r\n\r\n.EXAMPLE\r\n$rgb = Unpack-RGB 0x00FF8040  # Returns @{R=255; G=128; B=64}\r\n##CLOSEBRACKET##\r\nfunction Unpack-RGB {\r\n    param([Parameter(Mandatory)][int]$packed)\r\n\r\n    return @{\r\n        R = ($packed -shr 16) -band 0xFF\r\n        G = ($packed -shr 8) -band 0xFF\r\n        B = $packed -band 0xFF\r\n    }\r\n}"}, {"path": "lib/SpeedTUI/Core/Component.ps1", "content": "# SpeedTUI Enhanced Component System - The new foundation for all SpeedTUI components\r\n# Combines performance optimizations with simple, clear APIs for easy development\r\n\r\nusing namespace System.Collections.Generic\r\n\r\n# Load performance optimizations (automatically improves string operations)\r\n. \"$PSScriptRoot/Internal/PerformanceCore.ps1\"\r\n\r\n<#\r\n.SYNOPSIS\r\nEnhanced base component class for all SpeedTUI UI elements\r\n\r\n.DESCRIPTION\r\nThe foundation class for all SpeedTUI components, providing:\r\n- Simple positioning and sizing with SetPosition(x, y) and SetSize(w, h)\r\n- Easy theming with SetTheme(name) and SetColor(role)\r\n- Automatic performance optimizations (string caching, render caching)\r\n- Event system integration\r\n- Layout helpers and constraints\r\n- Debug and development tools\r\n\r\n.EXAMPLE\r\n# Simple usage - clear and intuitive\r\n$button = [Button]::new(\"OK\", 0, 0)\r\n$button.SetPosition(10, 5)\r\n$button.SetSize(20, 3)\r\n$button.SetTheme(\"matrix\")\r\n$button.SetColor(\"primary\")\r\n\r\n# Automatic arrangement\r\n@($button1, $button2, $button3) | Arrange-Vertically -StartX 10 -StartY 5 -Spacing 2\r\n\r\n# Performance monitoring\r\n$button.EnableRenderCaching($true)\r\n$stats = $button.GetPerformanceStats()\r\n##CLOSEBRACKET##\r\nclass Component {\r\n    # === Core Properties ===\r\n    [string]$Id                    # Unique identifier\r\n    [Component]$Parent             # Parent in component hierarchy\r\n    [List[Component]]$Children     # Child components\r\n    \r\n    # === Layout Properties ===\r\n    [int]$X = 0                    # X position relative to parent\r\n    [int]$Y = 0                    # Y position relative to parent\r\n    [int]$Width = 0                # Width in characters\r\n    [int]$Height = 0               # Height in characters\r\n    [bool]$Visible = $true         # Visibility flag\r\n    \r\n    # === Focus Management ===\r\n    [bool]$CanFocus = $false       # Can receive keyboard focus\r\n    [bool]$HasFocus = $false        # Currently has focus\r\n    [int]$TabIndex = 0              # Tab order for navigation\r\n    \r\n    # === Event Handlers ===\r\n    [scriptblock]$OnFocus = {}     # Focus gained event\r\n    [scriptblock]$OnBlur = {}      # Focus lost event\r\n    [scriptblock]$OnKeyPress = {}  # Key press event\r\n    [scriptblock]$OnClick = {}     # Click/activation event\r\n    \r\n    # === Enhanced Features (Private) ===\r\n    hidden [string]$_regionId                    # Render region identifier\r\n    hidden [object]$_renderEngine                         # Rendering engine reference (supports both Optimized and Enhanced)\r\n    hidden [bool]$_needsRedraw = $true          # Redraw flag\r\n\r\n    # Performance and caching\r\n    hidden [bool]$_renderCacheEnabled = $false   # Enable render caching\r\n    hidden [string]$_cachedRenderResult = \"\"     # Cached output\r\n    hidden [int]$_renderCount = 0                # Total renders\r\n    hidden [int]$_cacheHitCount = 0              # Cache hits\r\n    hidden [bool]$_cacheInvalid = $true          # Cache invalidation flag (Praxis style)\r\n    hidden [string]$_cachedPosition = \"\"         # Pre-computed position ANSI\r\n\r\n    # Batch invalidation support (reduces cascades)\r\n    hidden static [bool]$_batchMode = $false\r\n    hidden static [object]$_batchInvalidated = $null\r\n    \r\n    # Theming system\r\n    hidden [string]$_themeName = \"default\"       # Current theme\r\n    hidden [string]$_currentColor = \"\"           # Current color role\r\n    hidden [hashtable]$_customColors = @{}      # Custom color overrides\r\n    \r\n    # Layout constraints\r\n    hidden [int]$_minWidth = 1                   # Minimum width\r\n    hidden [int]$_minHeight = 1                  # Minimum height\r\n    hidden [int]$_maxWidth = 1000                # Maximum width\r\n    hidden [int]$_maxHeight = 1000               # Maximum height\r\n    \r\n            # Logging and debugging\r\n            hidden [object]$_logger = $null\r\n            hidden [string]$_logModule = \"\"    \r\n    <#\r\n    .SYNOPSIS\r\n    Initialize a new component instance\r\n    \r\n    .DESCRIPTION\r\n    Sets up the component with enhanced features including:\r\n    - Performance optimizations\r\n    - Theme system integration\r\n    - Logging and debugging\r\n    - Render caching system\r\n    ##CLOSEBRACKET##\r\n    Component() {\r\n        # Generate unique identifier\r\n        $this.Id = [Guid]::NewGuid().ToString()\r\n        \r\n        # Initialize collections\r\n        $this.Children = [List[Component]]::new()\r\n        $this._customColors = @{}\r\n        \r\n        # Setup logging for debugging\r\n        # $this._logger = [object](Get-Logger) \r\n        $this._logModule = $this.GetType().Name\r\n        $this._regionId = \"component_$($this.Id)\"\r\n        \r\n        # Component created\r\n    }\r\n    \r\n    # === Enhanced Layout Methods (Simple and Clear) ===\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Set component position with clear, simple method\r\n    \r\n    .PARAMETER x\r\n    X coordinate (left edge)\r\n    \r\n    .PARAMETER y\r\n    Y coordinate (top edge)\r\n    \r\n    .EXAMPLE\r\n    $button.SetPosition(10, 5)  # Much clearer than SetBounds(10, 5, width, height)\r\n    ##CLOSEBRACKET##\r\n    [void] SetPosition([int]$x, [int]$y) {\r\n        # Input validation\r\n        [Guard]::NonNegative($x, \"x\")\r\n        [Guard]::NonNegative($y, \"y\")\r\n        \r\n        # Skip if no change (performance optimization)\r\n        if ($this.X -eq $x -and $this.Y -eq $y) {\r\n            return\r\n        }\r\n        \r\n        # Removed trace logging for performance\r\n        \r\n        # Update position\r\n        $this.X = $x\r\n        $this.Y = $y\r\n        \r\n        # Update render region if initialized\r\n        if ($null -ne $this._renderEngine -and $this.Width -gt 0 -and $this.Height -gt 0) {\r\n            # No region updates needed for simplified engine\r\n        }\r\n        \r\n        # Invalidate cached render\r\n        $this.InvalidateRenderCache()\r\n        $this.Invalidate()\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Set component size with clear, simple method\r\n    \r\n    .PARAMETER width\r\n    Width in characters\r\n    \r\n    .PARAMETER height\r\n    Height in characters\r\n    \r\n    .EXAMPLE\r\n    $button.SetSize(20, 3)  # Much clearer than SetBounds(x, y, 20, 3)\r\n    ##CLOSEBRACKET##\r\n    [void] SetSize([int]$width, [int]$height) {\r\n        # Input validation\r\n        [Guard]::Positive($width, \"width\")\r\n        [Guard]::Positive($height, \"height\")\r\n        \r\n        # Apply constraints\r\n        $constrainedWidth = [Math]::Max($this._minWidth, [Math]::Min($this._maxWidth, $width))\r\n        $constrainedHeight = [Math]::Max($this._minHeight, [Math]::Min($this._maxHeight, $height))\r\n        \r\n        # Skip if no change (performance optimization)\r\n        if ($this.Width -eq $constrainedWidth -and $this.Height -eq $constrainedHeight) {\r\n            return\r\n        }\r\n        \r\n        # Removed trace logging for performance\r\n        \r\n        # Update size\r\n        $this.Width = $constrainedWidth\r\n        $this.Height = $constrainedHeight\r\n        \r\n        # Update render region if initialized\r\n        if ($null -ne $this._renderEngine) {\r\n            # No region updates needed for simplified engine\r\n        }\r\n        \r\n        # Trigger layout update\r\n        $this.OnBoundsChanged()\r\n        $this.InvalidateRenderCache()\r\n        $this.Invalidate()\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Move component to new position (convenience method)\r\n    \r\n    .PARAMETER x\r\n    New X coordinate\r\n    \r\n    .PARAMETER y  \r\n    New Y coordinate\r\n    \r\n    .EXAMPLE\r\n    $button.MoveTo(15, 8)  # Simple movement\r\n    ##CLOSEBRACKET##\r\n    [void] MoveTo([int]$x, [int]$y) {\r\n        $this.SetPosition($x, $y)\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Resize component (convenience method)\r\n    \r\n    .PARAMETER width\r\n    New width\r\n    \r\n    .PARAMETER height\r\n    New height\r\n    \r\n    .EXAMPLE\r\n    $button.Resize(25, 4)  # Simple resizing\r\n    ##CLOSEBRACKET##\r\n    [void] Resize([int]$width, [int]$height) {\r\n        $this.SetSize($width, $height)\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Set size constraints for automatic layout\r\n    \r\n    .PARAMETER minWidth\r\n    Minimum width\r\n    \r\n    .PARAMETER minHeight\r\n    Minimum height\r\n    \r\n    .PARAMETER maxWidth\r\n    Maximum width\r\n    \r\n    .PARAMETER maxHeight\r\n    Maximum height\r\n    \r\n    .EXAMPLE\r\n    $input.SetSizeConstraints(10, 1, 50, 5)  # Min 10x1, max 50x5\r\n    ##CLOSEBRACKET##\r\n    [void] SetSizeConstraints([int]$minWidth, [int]$minHeight, [int]$maxWidth, [int]$maxHeight) {\r\n        [Guard]::Positive($minWidth, \"minWidth\")\r\n        [Guard]::Positive($minHeight, \"minHeight\")\r\n        [Guard]::Condition($maxWidth -ge $minWidth, \"maxWidth must be >= minWidth\")\r\n        [Guard]::Condition($maxHeight -ge $minHeight, \"maxHeight must be >= minHeight\")\r\n        \r\n        $this._minWidth = $minWidth\r\n        $this._minHeight = $minHeight\r\n        $this._maxWidth = $maxWidth\r\n        $this._maxHeight = $maxHeight\r\n        \r\n        # Re-apply current size to enforce constraints\r\n        $this.SetSize($this.Width, $this.Height)\r\n    }\r\n    \r\n    # === Enhanced Theming Methods (Simple and Powerful) ===\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Apply a theme to this component\r\n    \r\n    .PARAMETER themeName\r\n    Name of theme to apply (matrix, amber, electric, etc.)\r\n    \r\n    .EXAMPLE\r\n    $button.SetTheme(\"matrix\")    # Apply matrix theme (green on black)\r\n    $button.SetTheme(\"electric\")  # Apply electric theme (blue on dark)\r\n    ##CLOSEBRACKET##\r\n    [void] SetTheme([string]$themeName) {\r\n        if ([string]::IsNullOrWhiteSpace($themeName)) {\r\n            $themeName = \"default\"\r\n        }\r\n        \r\n        # Skip if no change\r\n        if ($this._themeName -eq $themeName) {\r\n            return\r\n        }\r\n        \r\n        # Removed trace logging for performance\r\n        \r\n        $this._themeName = $themeName\r\n        \r\n        # Clear custom colors when changing themes\r\n        $this._customColors.Clear()\r\n        \r\n        # Invalidate render cache since colors changed\r\n        $this.InvalidateRenderCache()\r\n        $this.Invalidate()\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Set the color role for this component within current theme\r\n    \r\n    .PARAMETER colorRole\r\n    Color role (primary, secondary, success, warning, error, etc.)\r\n    \r\n    .EXAMPLE\r\n    $button.SetColor(\"primary\")    # Use primary color from current theme\r\n    $button.SetColor(\"success\")    # Use success color (usually green)\r\n    ##CLOSEBRACKET##\r\n    [void] SetColor([string]$colorRole) {\r\n        if ([string]::IsNullOrWhiteSpace($colorRole)) {\r\n            $colorRole = \"text\"\r\n        }\r\n        \r\n        # Skip if no change\r\n        if ($this._currentColor -eq $colorRole) {\r\n            return\r\n        }\r\n        \r\n        # Removed trace logging for performance\r\n        \r\n        $this._currentColor = $colorRole\r\n        \r\n        # Invalidate render cache since color changed\r\n        $this.InvalidateRenderCache()\r\n        $this.Invalidate()\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Set custom RGB color for this component (overrides theme)\r\n    \r\n    .PARAMETER r\r\n    Red component (0-255)\r\n    \r\n    .PARAMETER g\r\n    Green component (0-255)\r\n    \r\n    .PARAMETER b\r\n    Blue component (0-255)\r\n    \r\n    .EXAMPLE\r\n    $button.SetCustomColor(255, 100, 50)  # Custom orange color\r\n    ##CLOSEBRACKET##\r\n    [void] SetCustomColor([int]$r, [int]$g, [int]$b) {\r\n        [Guard]::InRange($r, 0, 255, \"r\")\r\n        [Guard]::InRange($g, 0, 255, \"g\")\r\n        [Guard]::InRange($b, 0, 255, \"b\")\r\n        \r\n        # Use internal VT100 helper for optimized ANSI sequences\r\n        $customColor = [InternalVT100]::RGB($r, $g, $b)\r\n        $this._customColors[\"foreground\"] = $customColor\r\n        \r\n        # Removed trace logging for performance\r\n        \r\n        $this.InvalidateRenderCache()\r\n        $this.Invalidate()\r\n    }\r\n    \r\n    # === Performance and Caching Methods ===\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Enable or disable render caching for performance\r\n    \r\n    .PARAMETER enabled\r\n    Whether to enable render caching\r\n    \r\n    .EXAMPLE\r\n    $component.EnableRenderCaching($true)  # Cache render output for speed\r\n    ##CLOSEBRACKET##\r\n    [void] EnableRenderCaching([bool]$enabled) {\r\n        if ($this._renderCacheEnabled -eq $enabled) {\r\n            return\r\n        }\r\n        \r\n        $this._renderCacheEnabled = $enabled\r\n        \r\n        if (-not $enabled) {\r\n            # Clear cache when disabling\r\n            $this._cachedRenderResult = \"\"\r\n        }\r\n        \r\n        # Render caching toggled\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Invalidate render cache (call when visual properties change)\r\n    \r\n    .DESCRIPTION\r\n    Forces the component to re-render on next draw by clearing cached results.\r\n    Called automatically by SetPosition, SetSize, SetTheme, etc.\r\n    ##CLOSEBRACKET##\r\n    [void] InvalidateRenderCache() {\r\n        $this._cacheInvalid = $true\r\n        if ($this._renderCacheEnabled -and $this._cachedRenderResult.Length -gt 0) {\r\n            $this._cachedRenderResult = \"\"\r\n            # Cache cleared\r\n        }\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get performance statistics for this component\r\n    \r\n    .OUTPUTS\r\n    Hashtable with performance metrics\r\n    \r\n    .EXAMPLE\r\n    $stats = $component.GetPerformanceStats()\r\n    Write-Host \"Renders: $($stats.RenderCount), Cache hits: $($stats.CacheHits)\"\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetPerformanceStats() {\r\n        $cacheHitRate = $(if ($this._renderCount -gt 0) { \r\n            [Math]::Round(($this._cacheHitCount / $this._renderCount) * 100, 1) \r\n        } else { 0 })\r\n        \r\n        return @{\r\n            Id = $this.Id\r\n            Type = $this.GetType().Name\r\n            Position = \"$($this.X),$($this.Y)\"\r\n            Size = \"$($this.Width)x$($this.Height)\"\r\n            Theme = $this._themeName\r\n            Color = $this._currentColor\r\n            RenderCount = $this._renderCount\r\n            CacheHits = $this._cacheHitCount\r\n            CacheHitRate = $cacheHitRate\r\n            CacheEnabled = $this._renderCacheEnabled\r\n        }\r\n    }\r\n    \r\n    # === Existing Methods (Enhanced with Performance) ===\r\n    \r\n    # Initialize with render engine\r\n    [void] Initialize([object]$renderEngine) {\r\n        # Initializing component\r\n        \r\n        try {\r\n            [Guard]::NotNull($renderEngine, \"renderEngine\")\r\n            \r\n            $this._renderEngine = $renderEngine\r\n            \r\n            # No region definition needed for simplified engine\r\n            \r\n            # Initialize children\r\n            foreach ($child in $this.Children) {\r\n                $child.Initialize($renderEngine)\r\n            }\r\n            \r\n            # Component initialized successfully\r\n            \r\n        } catch {\r\n            $this._logger.Error($this._logModule, \"Initialize\", \"Initialization failed\", @{\r\n                Id = $this.Id\r\n                Exception = $_.Exception.Message\r\n            })\r\n            throw\r\n        }\r\n    }\r\n    \r\n    # Legacy SetBounds method (still works for existing code)\r\n    [void] SetBounds([int]$x, [int]$y, [int]$width, [int]$height) {\r\n        # Legacy SetBounds - use new methods internally\r\n        \r\n        # Use new enhanced methods internally\r\n        $this.SetPosition($x, $y)\r\n        $this.SetSize($width, $height)\r\n    }\r\n    \r\n    # Enhanced render method with Praxis-style aggressive caching\r\n    [string] Render() {\r\n        if (-not $this.Visible) { \r\n            return \"\"\r\n        }\r\n        \r\n        $this._renderCount++\r\n        \r\n        # Use cached result if available and valid (Praxis optimization)\r\n        if ($this._renderCacheEnabled -and -not $this._cacheInvalid -and $this._cachedRenderResult) {\r\n            $this._cacheHitCount++\r\n            return $this._cachedRenderResult\r\n        }\r\n        \r\n        # PERFORMANCE: Check if component implements direct engine rendering\r\n        # This is detected by checking if OnRenderToEngine was overridden\r\n        $hasFastPath = $this.GetType().GetMethod('OnRenderToEngine').DeclaringType.Name -ne 'Component'\r\n\r\n        if ($hasFastPath -and $null -ne $this._renderEngine) {\r\n            # FAST PATH: Component uses direct engine rendering\r\n            # No string building, no ANSI parsing - just direct WriteAt() calls\r\n            $this.OnRenderToEngine($this._renderEngine)\r\n\r\n            # Render children (they may also use fast path)\r\n            foreach ($child in $this.Children) {\r\n                if ($child.Visible) {\r\n                    $child.Render()  # Each child decides its own path\r\n                }\r\n            }\r\n\r\n            $this._needsRedraw = $false\r\n            # Return empty string to signal \"already rendered to engine\"\r\n            return \"\"\r\n        }\r\n\r\n        # LEGACY PATH: Build ANSI string (backward compatible)\r\n        $sb = Get-PooledStringBuilder 1024\r\n\r\n        # Render component (calls OnRender)\r\n        # No region clearing needed for simplified engine\r\n\r\n        # Get component-specific render output\r\n        $componentOutput = $this.OnRender()\r\n        if ($componentOutput) {\r\n            $sb.Append($componentOutput)\r\n        }\r\n\r\n        $this._needsRedraw = $false\r\n\r\n        # Render children\r\n        foreach ($child in $this.Children) {\r\n            $childOutput = $child.Render()\r\n            if ($childOutput) {\r\n                $sb.Append($childOutput)\r\n            }\r\n        }\r\n\r\n        # Cache the result\r\n        $result = $sb.ToString()\r\n        if ($this._renderCacheEnabled) {\r\n            $this._cachedRenderResult = $result\r\n            $this._cacheInvalid = $false\r\n        }\r\n\r\n        Return-PooledStringBuilder $sb\r\n        return $result\r\n    }\r\n    \r\n    # Virtual method for component-specific rendering\r\n    [string] OnRender() {\r\n        # Override in derived classes\r\n        # Base implementation returns empty string\r\n        return \"\"\r\n    }\r\n\r\n    # PERFORMANCE: Optional direct engine rendering (avoids ANSI string parsing)\r\n    # Override this method in derived classes for maximum performance\r\n    # When implemented, this completely bypasses string building and regex parsing\r\n    [void] OnRenderToEngine([object]$engine) {\r\n        # Override in derived classes for direct engine rendering\r\n        # Base implementation is no-op (falls back to OnRender)\r\n        #\r\n        # Example implementation:\r\n        # [void] OnRenderToEngine([object]$engine) {\r\n        #     $engine.WriteAt($this.X, $this.Y, \"Hello World\")\r\n        # }\r\n    }\r\n\r\n    # Virtual method called when bounds change\r\n    [void] OnBoundsChanged() {\r\n        # Override in derived classes for layout recalculation\r\n        # Good place to call PrecomputeRenderData()\r\n        $this.PrecomputeRenderData()\r\n    }\r\n    \r\n    # Pre-compute expensive values (Praxis optimization)\r\n    [void] PrecomputeRenderData() {\r\n        # Pre-compute position ANSI sequence\r\n        $this._cachedPosition = [InternalVT100]::MoveTo($this.X, $this.Y)\r\n        \r\n        # Override in derived classes to pre-compute:\r\n        # - Border strings\r\n        # - Padding calculations  \r\n        # - Color sequences\r\n        # - Any repeated calculations\r\n    }\r\n    \r\n    # Component invalidation\r\n    [void] Invalidate() {\r\n        # If in batch mode, queue invalidation instead of cascading immediately\r\n        if ([Component]::_batchMode) {\r\n            if ($null -eq [Component]::_batchInvalidated) {\r\n                [Component]::_batchInvalidated = [System.Collections.Generic.HashSet[Component]]::new()\r\n            }\r\n            [Component]::_batchInvalidated.Add($this)\r\n            return\r\n        }\r\n\r\n        # Normal immediate invalidation with cascade\r\n        $this._DoInvalidate()\r\n    }\r\n\r\n    # Internal method that performs actual invalidation with cascade\r\n    hidden [void] _DoInvalidate() {\r\n        $this._needsRedraw = $true\r\n        $this.InvalidateRenderCache()\r\n\r\n        # No dirty marking needed for simplified engine\r\n\r\n        # Propagate to parent\r\n        if ($null -ne $this.Parent) {\r\n            $this.Parent.Invalidate()\r\n        }\r\n    }\r\n\r\n    # Start batch invalidation mode (reduces cascade overhead)\r\n    static [void] BeginBatch() {\r\n        [Component]::_batchMode = $true\r\n        [Component]::_batchInvalidated = [System.Collections.Generic.HashSet[Component]]::new()\r\n    }\r\n\r\n    # End batch mode and flush all queued invalidations\r\n    static [void] EndBatch() {\r\n        if (-not [Component]::_batchMode) { return }\r\n\r\n        $components = [Component]::_batchInvalidated\r\n        [Component]::_batchMode = $false\r\n        [Component]::_batchInvalidated = $null\r\n\r\n        # Process all queued invalidations\r\n        if ($null -ne $components) {\r\n            foreach ($component in $components) {\r\n                $component._DoInvalidate()\r\n            }\r\n        }\r\n    }\r\n    \r\n    # Child management\r\n    [void] AddChild([Component]$child) {\r\n        [Guard]::NotNull($child, \"child\")\r\n        \r\n        if ($child.Parent -ne $null) {\r\n            throw [InvalidOperationException]::new(\"Component already has a parent\")\r\n        }\r\n        \r\n        $child.Parent = $this\r\n        $this.Children.Add($child)\r\n        \r\n        # Initialize if we're already initialized\r\n        if ($null -ne $this._renderEngine) {\r\n            $child.Initialize($this._renderEngine)\r\n        }\r\n        \r\n        $this.Invalidate()\r\n    }\r\n    \r\n    [void] RemoveChild([Component]$child) {\r\n        [Guard]::NotNull($child, \"child\")\r\n        \r\n        if ($this.Children.Remove($child)) {\r\n            $child.Parent = $null\r\n            \r\n            # No region removal needed for simplified engine\r\n            \r\n            $this.Invalidate()\r\n        }\r\n    }\r\n    \r\n    # Focus management\r\n    [void] Focus() {\r\n        if (-not $this.CanFocus -or $this.HasFocus) { \r\n            return \r\n        }\r\n        \r\n        $this.HasFocus = $true\r\n        \r\n        if ($this.OnFocus) {\r\n            & $this.OnFocus $this\r\n        }\r\n        \r\n        $this.Invalidate()\r\n    }\r\n    \r\n    [void] Blur() {\r\n        if (-not $this.HasFocus) { \r\n            return \r\n        }\r\n        \r\n        $this.HasFocus = $false\r\n        \r\n        if ($this.OnBlur) {\r\n            & $this.OnBlur $this\r\n        }\r\n        \r\n        $this.Invalidate()\r\n    }\r\n    \r\n    # Input handling\r\n    [bool] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo) {\r\n        [Guard]::NotNull($keyInfo, \"keyInfo\")\r\n        \r\n        # Let focused children handle first\r\n        foreach ($child in $this.Children) {\r\n            if ($child.HasFocus -and $child.HandleKeyPress($keyInfo)) {\r\n                return $true\r\n            }\r\n        }\r\n        \r\n        # Handle ourselves\r\n        if ($this.HasFocus -and $this.OnKeyPress) {\r\n            $result = & $this.OnKeyPress $this $keyInfo\r\n            if ($result) {\r\n                return $true\r\n            }\r\n        }\r\n        \r\n        return $false\r\n    }\r\n    \r\n    # Helper methods for rendering\r\n    hidden [void] WriteAt([int]$x, [int]$y, [string]$text) {\r\n        if ($null -eq $this._renderEngine) { return }\r\n        $this._renderEngine.WriteAt($this.X + $x, $this.Y + $y, $text)\r\n    }\r\n    \r\n    # Get pre-computed position string (Praxis optimization)\r\n    hidden [string] GetCachedPosition() {\r\n        if (-not $this._cachedPosition) {\r\n            $this._cachedPosition = [InternalVT100]::MoveTo($this.X, $this.Y)\r\n        }\r\n        return $this._cachedPosition\r\n    }\r\n    \r\n    hidden [void] DrawBox([int]$x, [int]$y, [int]$width, [int]$height) {\r\n        if ($null -eq $this._renderEngine) { return }\r\n        $this._renderEngine.DrawBox($this.X + $x, $this.Y + $y, $width, $height)\r\n    }\r\n    \r\n    hidden [void] DrawBox([int]$x, [int]$y, [int]$width, [int]$height, [string]$style) {\r\n        if ($null -eq $this._renderEngine) { return }\r\n        $this._renderEngine.DrawBox($this.X + $x, $this.Y + $y, $width, $height, $style)\r\n    }\r\n    \r\n    # Utility methods\r\n    [Component] FindById([string]$id) {\r\n        [Guard]::NotNullOrEmpty($id, \"id\")\r\n        \r\n        if ($this.Id -eq $id) { \r\n            return $this \r\n        }\r\n        \r\n        foreach ($child in $this.Children) {\r\n            $found = $child.FindById($id)\r\n            if ($null -ne $found) { \r\n                return $found \r\n            }\r\n        }\r\n        \r\n        return $null\r\n    }\r\n    \r\n    [List[Component]] GetFocusableComponents() {\r\n        $focusable = [List[Component]]::new()\r\n        \r\n        if ($this.CanFocus -and $this.Visible) {\r\n            $focusable.Add($this)\r\n        }\r\n        \r\n        foreach ($child in $this.Children) {\r\n            $childFocusable = $child.GetFocusableComponents()\r\n            $focusable.AddRange($childFocusable)\r\n        }\r\n        \r\n        return $focusable\r\n    }\r\n    \r\n    # Get current theme name for debugging\r\n    [string] GetThemeName() {\r\n        return $this._themeName\r\n    }\r\n    \r\n    # Get current color role for debugging\r\n    [string] GetCurrentColor() {\r\n        return $this._currentColor\r\n    }\r\n}\r\n\r\n# === Layout Helper Functions ===\r\n\r\n<#\r\n.SYNOPSIS\r\nArrange components vertically with automatic spacing\r\n\r\n.PARAMETER Components\r\nArray of components to arrange\r\n\r\n.PARAMETER StartX\r\nStarting X position\r\n\r\n.PARAMETER StartY\r\nStarting Y position\r\n\r\n.PARAMETER Spacing\r\nSpace between components\r\n\r\n.EXAMPLE\r\n@($button1, $button2, $button3) | Arrange-Vertically -StartX 10 -StartY 5 -Spacing 2\r\n##CLOSEBRACKET##\r\nfunction Arrange-Vertically {\r\n    param(\r\n        [Parameter(ValueFromPipeline = $true)]\r\n        [Component[]]$Components,\r\n        [int]$StartX = 0,\r\n        [int]$StartY = 0,\r\n        [int]$Spacing = 1\r\n    )\r\n    \r\n    begin {\r\n        $allComponents = @()\r\n    }\r\n    \r\n    process {\r\n        $allComponents += $Components\r\n    }\r\n    \r\n    end {\r\n        $currentY = $StartY\r\n        \r\n        foreach ($component in $allComponents) {\r\n            $component.SetPosition($StartX, $currentY)\r\n            $currentY += $component.Height + $Spacing\r\n        }\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nArrange components horizontally with automatic spacing\r\n\r\n.PARAMETER Components\r\nArray of components to arrange\r\n\r\n.PARAMETER StartX\r\nStarting X position\r\n\r\n.PARAMETER StartY\r\nStarting Y position\r\n\r\n.PARAMETER Spacing\r\nSpace between components\r\n\r\n.EXAMPLE\r\n@($label1, $label2, $label3) | Arrange-Horizontally -StartX 5 -StartY 10 -Spacing 3\r\n##CLOSEBRACKET##\r\nfunction Arrange-Horizontally {\r\n    param(\r\n        [Parameter(ValueFromPipeline = $true)]\r\n        [Component[]]$Components,\r\n        [int]$StartX = 0,\r\n        [int]$StartY = 0,\r\n        [int]$Spacing = 1\r\n    )\r\n    \r\n    begin {\r\n        $allComponents = @()\r\n    }\r\n    \r\n    process {\r\n        $allComponents += $Components\r\n    }\r\n    \r\n    end {\r\n        $currentX = $StartX\r\n        \r\n        foreach ($component in $allComponents) {\r\n            $component.SetPosition($currentX, $StartY)\r\n            $currentX += $component.Width + $Spacing\r\n        }\r\n    }\r\n}\r\n\r\n# Helper functions are available when this file is dot-sourced"}, {"path": "lib/SpeedTUI/Core/HybridRenderEngine.ps1", "content": "# SpeedTUI Hybrid Render Engine\n# \"The Best of Both Worlds\" - Combines Cell-based precision with Layer-based flexibility.\n#\n# ARCHITECTURAL OVERVIEW:\n# -----------------------\n# This engine represents the evolution of the SpeedTUI rendering pipeline. It merges the\n# robustness of the OptimizedRenderEngine (Z-Layers, Compatibility) with the high-performance\n# architecture of the EnhancedRenderEngine (Cell Buffers, Smart Diffing).\n#\n# KEY FEATURES:\n# 1. CELL-BASED RENDERING: Uses a grid of Cell objects (Char, Color, Attributes) instead of\n#    strings. This prevents text bleeding and allows precise merging of layers.\n# 2. Z-BUFFERING: Supports overlapping layers (popups over backgrounds) natively.\n#    Uses a Depth Buffer to determine which pixel wins at any given coordinate.\n# 3. VIEWPORT CLIPPING: Prevents UI components from drawing outside their bounds.\n#    Essential for scrollable lists and complex layouts.\n# 4. DIRTY RECTANGLE TRACKING: Only processes screen areas that actually changed,\n#    massively improving performance for small updates (like progress bars).\n# 5. OBJECT POOLING: reuses StringBuilder objects to minimize memory allocation pressure.\n#\n# USAGE:\n# $engine = [HybridRenderEngine]::new()\n# $engine.Initialize()\n# $engine.BeginFrame()\n# $engine.BeginLayer(10) # Draw on top\n# $engine.WriteAt(0,0, \"Popup\")\n# $engine.EndFrame()\n\nusing namespace System.Text\nusing namespace System.Collections.Generic\n\n# Ensure dependencies are loaded (CellBuffer, PerformanceCore)\n# These usually come from the module loader, but we depend on them here.\n\nclass LayoutRegion {\n    [string]$ID\n    [int]$X\n    [int]$Y\n    [int]$Width\n    [int]$Height\n    [int]$ZIndex\n    [string]$ParentID\n    [bool]$Clip\n\n    LayoutRegion([string]$id, [int]$x, [int]$y, [int]$width, [int]$height) {\n        $this.ID = $id\n        $this.X = $x\n        $this.Y = $y\n        $this.Width = $width\n        $this.Height = $height\n        $this.ZIndex = 0\n        $this.ParentID = \"\"\n        $this.Clip = $true\n    }\n}\n\nclass HybridRenderEngine {\n    # -- CORE BUFFERS --\n    # FrontBuffer: Represents exactly what is currently visible on the user's screen.\n    hidden [object]$_frontBuffer  # NativeCellBuffer or CellBuffer\n    # BackBuffer: The \"Canvas\" we are currently painting on for the next frame.\n    hidden [object]$_backBuffer   # NativeCellBuffer or CellBuffer\n    # ZBuffer: Stores the depth (layer index) of each cell. Used to decide if a new\n    # write should overwrite existing content or appear behind it.\n    hidden [int[][]] $_zBuffer\n\n    # -- STATE MANAGEMENT --\n    hidden [bool]$_initialized = $false\n    hidden [bool]$_inFrame = $false\n    \n    # -- RENDERING CONTEXT --\n    # Current Z-Index (Depth). Higher numbers appear on top.\n    hidden [int]$_currentZ = 0\n    # Clipping Stack: Stores active viewports. Content outside the top rect is discarded.\n    hidden [Stack[object]]$_clipStack\n    # Offset Stack: Stores coordinate translations. (0,0) becomes (OffsetX, OffsetY).\n    hidden [Stack[object]]$_offsetStack\n    # Dirty Bounds: Tracks the min/max X/Y coordinates that have been touched this frame.\n    # Used to optimize the Diffing phase (don't scan the whole screen if only one line changed).\n    hidden [object]$_dirtyBounds\n    # Cursor Logic: Where the cursor *should* be after rendering.\n    hidden [int]$_cursorX = -1\n    hidden [int]$_cursorY = -1\n\n    # -- DIMENSIONS --\n    [int]$Width\n    [int]$Height\n\n    # -- PERFORMANCE TRACKING --\n    hidden [int]$_frameCount = 0\n    hidden [int]$_cellsUpdated = 0\n\n    # -- CACHING --\n    static hidden [hashtable]$_ansiCache = @{}\n\n    # -- LAYOUT SYSTEM --\n    hidden [hashtable]$_regions = @{}\n\n    HybridRenderEngine() {\n        $this._clipStack = [Stack[object]]::new()\n        $this._offsetStack = [Stack[object]]::new()\n        $this.UpdateDimensions()\n        $this._InitializeBuffers()\n    }\n\n    # -------------------------------------------------------------------------\n    # LIFECYCLE METHODS\n    # -------------------------------------------------------------------------\n\n    [void] Initialize() {\n        if ($this._initialized) { return }\n\n        # Prepare the terminal\n        [Console]::Clear()\n        [Console]::CursorVisible = $false\n        [Console]::SetCursorPosition(0, 0)\n        \n        # Ensure internal performance caches are ready\n        # (InternalStringCache/InternalVT100 from PerformanceCore.ps1)\n        if (-not [InternalStringCache]::_initialized) {\n            [InternalStringCache]::Initialize()\n        }\n\n        $this._initialized = $true\n    }\n\n    [void] Cleanup() {\n        [Console]::CursorVisible = $true\n        [Console]::Clear()\n        $this._initialized = $false\n    }\n\n    [void] UpdateDimensions() {\n        try {\n            $newWidth = [Console]::WindowWidth\n            $newHeight = [Console]::WindowHeight\n            \n            # Only resize if actually changed to avoid overhead\n            if ($this.Width -ne $newWidth -or $this.Height -ne $newHeight) {\n                $this.Width = $newWidth\n                $this.Height = $newHeight\n                $this._InitializeBuffers()\n            }\n        }\n        catch {\n            # Safe fallbacks if running in non-interactive environment\n            $this.Width = 80\n            $this.Height = 24\n            $this._InitializeBuffers()\n        }\n    }\n\n    hidden [void] _InitializeBuffers() {\n        # Re-allocate all buffers to match new dimensions\n        # Use C# NativeCellBuffer for ~50-100x speedup (if loaded)\n        $nativeType = ([System.Management.Automation.PSTypeName]'NativeCellBuffer').Type\n        if ($nativeType) {\n            $this._frontBuffer = $nativeType::new($this.Width, $this.Height)\n            $this._backBuffer = $nativeType::new($this.Width, $this.Height)\n        } else {\n            $this._frontBuffer = [CellBuffer]::new($this.Width, $this.Height)\n            $this._backBuffer = [CellBuffer]::new($this.Width, $this.Height)\n        }\n        \n        # Z-Buffer is a primitive int array for speed\n        $this._zBuffer = [int[][]]::new($this.Height)\n        for ($y = 0; $y -lt $this.Height; $y++) {\n            $this._zBuffer[$y] = [int[]]::new($this.Width)\n        }\n        \n        # Reset Dirty Bounds to full screen initially\n        $this._ResetDirtyBounds($true)\n    }\n\n    # -------------------------------------------------------------------------\n    # FRAME MANAGEMENT\n    # -------------------------------------------------------------------------\n\n    [void] BeginFrame() {\n        if (-not $this._initialized) { throw \"Engine not initialized\" }\n        \n        $this._inFrame = $true\n        $this._currentZ = 0\n        $this._cellsUpdated = 0\n        \n        # Reset BackBuffer (Clear text/colors)\n        # Note: We don't allocate new memory, just reset values.\n        $this._backBuffer.Clear()\n\n        # Reset Z-Buffer to lowest possible value so Layer 0 can write\n        $minInt = [int]::MinValue\n        for ($y = 0; $y -lt $this.Height; $y++) {\n            # Array.Fill is faster than loop\n            # Check if PowerShell version supports it, otherwise loop\n            for ($x = 0; $x -lt $this.Width; $x++) {\n                $this._zBuffer[$y][$x] = $minInt\n            }\n        }\n        \n        # Reset Render State\n        $this._clipStack.Clear()\n        $this._offsetStack.Clear()\n        $this._ResetDirtyBounds($false) # Start with \"nothing changed\"\n    }\n\n    [void] EndFrame() {\n        if (-not $this._inFrame) { return }\n\n        # THE MAGIC HAPPENS HERE:\n        # Compare BackBuffer vs FrontBuffer and emit minimal ANSI.\n        # We assume _dirtyBounds contains the area that might have changed.\n        \n        $diff = $this._BuildOptimizedDiff()\n        \n        if ($diff.Length -gt 0) {\n            [Console]::Write($diff)\n        }\n\n        # Apply Logical Cursor Position (if set)\n        if ($this._cursorX -ge 0 -and $this._cursorY -ge 0) {\n            [Console]::SetCursorPosition($this._cursorX, $this._cursorY)\n        }\n\n        # Swap Buffers: BackBuffer becomes the new FrontBuffer\n        # We use CopyFrom because swapping references breaks if we hold references elsewhere,\n        # but for this engine, swapping content is safer.\n        $this._frontBuffer.CopyFrom($this._backBuffer)\n\n        $this._frameCount++\n        $this._inFrame = $false\n    }\n\n    # -------------------------------------------------------------------------\n    # Z-LAYER & CLIPPING API\n    # -------------------------------------------------------------------------\n\n    # Sets the current drawing layer. Higher Z = On Top.\n    [void] BeginLayer([int]$zIndex) {\n        $this._currentZ = $zIndex\n    }\n\n    [void] EndLayer() {\n        $this._currentZ = 0\n    }\n\n    # Restricts rendering to a specific rectangle. Useful for scrolling lists.\n    [void] PushClip([int]$x, [int]$y, [int]$width, [int]$height) {\n        # Calculate intersection with current clip (if any)\n        $newClip = @{ X = $x; Y = $y; R = ($x + $width); B = ($y + $height) }\n\n        if ($this._clipStack.Count -gt 0) {\n            $parent = $this._clipStack.Peek()\n            $newClip.X = [Math]::Max($newClip.X, $parent.X)\n            $newClip.Y = [Math]::Max($newClip.Y, $parent.Y)\n            $newClip.R = [Math]::Min($newClip.R, $parent.R)\n            $newClip.B = [Math]::Min($newClip.B, $parent.B)\n        }\n        \n        $this._clipStack.Push($newClip)\n    }\n\n    [void] PopClip() {\n        if ($this._clipStack.Count -gt 0) {\n            [void]$this._clipStack.Pop()\n        }\n    }\n\n    # Translates the coordinate system.\n    # PushOffset(10, 5) means WriteAt(0,0) will actually draw at Screen(10,5).\n    # Useful for reusable components that draw relative to their container.\n    [void] PushOffset([int]$x, [int]$y) {\n        $current = @{ X = 0; Y = 0 }\n        if ($this._offsetStack.Count -gt 0) {\n            $current = $this._offsetStack.Peek()\n        }\n        \n        $newOffset = @{ \n            X = $current.X + $x\n            Y = $current.Y + $y\n        }\n        \n        $this._offsetStack.Push($newOffset)\n    }\n\n    [void] PopOffset() {\n        if ($this._offsetStack.Count -gt 0) {\n            [void]$this._offsetStack.Pop()\n        }\n    }\n\n    # Sets where the hardware cursor should be placed at the end of the frame.\n    # Use -1, -1 to hide it (or leave it where drawing ended).\n    [void] SetCursor([int]$x, [int]$y) {\n        # Apply current offset to cursor position if needed?\n        # Typically cursor is set in local coordinates too.\n        $offsetX = 0\n        $offsetY = 0\n        if ($this._offsetStack.Count -gt 0) {\n            $current = $this._offsetStack.Peek()\n            $offsetX = $current.X\n            $offsetY = $current.Y\n        }\n\n        $this._cursorX = $x + $offsetX\n        $this._cursorY = $y + $offsetY\n    }\n\n    # Shows the hardware cursor (makes it visible on screen)\n    [void] ShowCursor() {\n        [Console]::CursorVisible = $true\n    }\n\n    # Hides the hardware cursor (makes it invisible)\n    [void] HideCursor() {\n        [Console]::CursorVisible = $false\n    }\n\n\n    # -------------------------------------------------------------------------\n    # DRAWING API\n    # -------------------------------------------------------------------------\n\n    [void] WriteAt([int]$x, [int]$y, [string]$content) {\n        if (-not $this._inFrame -or [string]::IsNullOrEmpty($content)) { return }\n\n        # Apply Offset (Coordinate Translation)\n        $offsetX = 0\n        $offsetY = 0\n        if ($this._offsetStack.Count -gt 0) {\n            $current = $this._offsetStack.Peek()\n            $offsetX = $current.X\n            $offsetY = $current.Y\n        }\n        \n        $finalX = $x + $offsetX\n        $finalY = $y + $offsetY\n\n        # 1. Parse ANSI content (Extract text + attributes)\n        # We reuse the logic style from EnhancedRenderEngine for parsing\n        # (This is simplified for brevity - assumes logic similar to Enhanced)\n        \n        # State tracking for the string\n        $currentFg = -1\n        $currentBg = -1\n        $currentAttr = 0\n        \n        $currentX = $finalX\n        $len = $content.Length\n        $i = 0\n        \n        # Check current clip bounds\n        $clip = $null\n        if ($this._clipStack.Count -gt 0) { $clip = $this._clipStack.Peek() }\n\n        while ($i -lt $len) {\n            # Check for ANSI escape sequence start\n            if ($content[$i] -eq \"`e\" -and ($i + 1) -lt $len -and $content[$i + 1] -eq '[') {\n                # -- ANSI PARSING BLOCK --\n                # (Ideally abstracted, but inline here for performance/portability)\n                $seqEnd = $i + 2\n                while ($seqEnd -lt $len -and $content[$seqEnd] -match '[0-9;]') { $seqEnd++ }\n                \n                if ($seqEnd -lt $len) {\n                    $cmd = $content[$seqEnd]\n                    $paramStr = $content.Substring($i + 2, $seqEnd - ($i + 2))\n                    \n                    # Update current color/attr state based on params\n                    # (Simplified logic: Calls a helper to update state vars)\n                    $this._ParseAnsiState($cmd, $paramStr, [ref]$currentFg, [ref]$currentBg, [ref]$currentAttr)\n                    \n                    $i = $seqEnd + 1\n                    continue\n                }\n            }\n            \n            # Normal Character Processing\n            # 1. Check Bounds (Screen)\n            if ($finalY -ge 0 -and $finalY -lt $this.Height -and $currentX -ge 0 -and $currentX -lt $this.Width) {\n                \n                # 2. Check Clipping (Viewport)\n                $isClipped = $false\n                if ($clip) {\n                    if ($currentX -lt $clip.X -or $currentX -ge $clip.R -or $finalY -lt $clip.Y -or $finalY -ge $clip.B) {\n                        $isClipped = $true\n                    }\n                }\n\n                # 3. Check Z-Index (Depth)\n                if (-not $isClipped) {\n                    if ($this._currentZ -ge $this._zBuffer[$finalY][$currentX]) {\n                        # ** WRITE IS ALLOWED **\n                        \n                        # Update Back Buffer\n                        $this._backBuffer.SetCell($currentX, $finalY, $content[$i], $currentFg, $currentBg, $currentAttr)\n                        \n                        # Update Z Buffer\n                        $this._zBuffer[$finalY][$currentX] = $this._currentZ\n                        \n                        # Update Dirty Rectangle (Grow to include this point)\n                        $this._UpdateDirtyBounds($currentX, $finalY)\n                    }\n                }\n            }\n            \n            $currentX++\n            $i++\n        }\n    }\n\n    [void] WriteAt([int]$x, [int]$y, [string]$content, [int]$fg, [int]$bg) {\n        if (-not $this._inFrame -or [string]::IsNullOrEmpty($content)) { return }\n\n        # Apply Offset\n        $offsetX = 0\n        $offsetY = 0\n        if ($this._offsetStack.Count -gt 0) {\n            $current = $this._offsetStack.Peek()\n            $offsetX = $current.X\n            $offsetY = $current.Y\n        }\n        \n        $finalX = $x + $offsetX\n        $finalY = $y + $offsetY\n        $currentX = $finalX\n        \n        # Check current clip bounds\n        $clip = $null\n        if ($this._clipStack.Count -gt 0) { $clip = $this._clipStack.Peek() }\n\n        $len = $content.Length\n        for ($i = 0; $i -lt $len; $i++) {\n            # Check Bounds\n            if ($finalY -ge 0 -and $finalY -lt $this.Height -and $currentX -ge 0 -and $currentX -lt $this.Width) {\n                \n                # Check Clipping\n                $isClipped = $false\n                if ($clip) {\n                    if ($currentX -lt $clip.X -or $currentX -ge $clip.R -or $finalY -lt $clip.Y -or $finalY -ge $clip.B) {\n                        $isClipped = $true\n                    }\n                }\n\n                # Check Z-Index\n                if (-not $isClipped) {\n                    if ($this._currentZ -ge $this._zBuffer[$finalY][$currentX]) {\n                        # Write\n                        $this._backBuffer.SetCell($currentX, $finalY, $content[$i], $fg, $bg, 0)\n                        $this._zBuffer[$finalY][$currentX] = $this._currentZ\n                        $this._UpdateDirtyBounds($currentX, $finalY)\n                    }\n                }\n            }\n            $currentX++\n        }\n    }\n\n    # Gradient WriteAt: Interpolates foreground color per character from fgStart to fgEnd\n    [void] WriteAt([int]$x, [int]$y, [string]$content, [int]$fgStart, [int]$fgEnd, [int]$bg) {\n        if (-not $this._inFrame -or [string]::IsNullOrEmpty($content)) { return }\n\n        # Apply Offset\n        $offsetX = 0\n        $offsetY = 0\n        if ($this._offsetStack.Count -gt 0) {\n            $current = $this._offsetStack.Peek()\n            $offsetX = $current.X\n            $offsetY = $current.Y\n        }\n        \n        $finalX = $x + $offsetX\n        $finalY = $y + $offsetY\n        $currentX = $finalX\n        \n        # Check current clip bounds\n        $clip = $null\n        if ($this._clipStack.Count -gt 0) { $clip = $this._clipStack.Peek() }\n\n        $len = $content.Length\n        for ($i = 0; $i -lt $len; $i++) {\n            # Calculate interpolation factor\n            $t = if ($len -eq 1) { 0.0 } else { [double]$i / ($len - 1) }\n            $fg = $this._LerpColor($fgStart, $fgEnd, $t)\n            \n            # Check Bounds\n            if ($finalY -ge 0 -and $finalY -lt $this.Height -and $currentX -ge 0 -and $currentX -lt $this.Width) {\n                \n                # Check Clipping\n                $isClipped = $false\n                if ($clip) {\n                    if ($currentX -lt $clip.X -or $currentX -ge $clip.R -or $finalY -lt $clip.Y -or $finalY -ge $clip.B) {\n                        $isClipped = $true\n                    }\n                }\n\n                # Check Z-Index\n                if (-not $isClipped) {\n                    if ($this._currentZ -ge $this._zBuffer[$finalY][$currentX]) {\n                        # Write with interpolated color\n                        $this._backBuffer.SetCell($currentX, $finalY, $content[$i], $fg, $bg, 0)\n                        $this._zBuffer[$finalY][$currentX] = $this._currentZ\n                        $this._UpdateDirtyBounds($currentX, $finalY)\n                    }\n                }\n            }\n            $currentX++\n        }\n    }\n\n    # Linear interpolation between two packed RGB colors\n    hidden [int] _LerpColor([int]$c1, [int]$c2, [double]$t) {\n        # Extract RGB components\n        $r1 = ($c1 -shr 16) -band 0xFF\n        $g1 = ($c1 -shr 8) -band 0xFF\n        $b1 = $c1 -band 0xFF\n        $r2 = ($c2 -shr 16) -band 0xFF\n        $g2 = ($c2 -shr 8) -band 0xFF\n        $b2 = $c2 -band 0xFF\n        \n        # Interpolate\n        $r = [int]($r1 + ($r2 - $r1) * $t)\n        $g = [int]($g1 + ($g2 - $g1) * $t)\n        $b = [int]($b1 + ($b2 - $b1) * $t)\n        \n        # Pack and return\n        return ($r -shl 16) -bor ($g -shl 8) -bor $b\n    }\n\n    [void] Clear([int]$x, [int]$y, [int]$width, [int]$height) {\n        # Helper to clear area using spaces\n        # We construct a string of spaces and use WriteAt so Z-Index/Clipping applies automatically\n        $spaces = \" \" * $width # (In prod: use InternalStringCache::GetSpaces($width))\n        for ($r = 0; $r -lt $height; $r++) {\n            $this.WriteAt($x, $y + $r, $spaces)\n        }\n    }\n\n    [void] Fill([int]$x, [int]$y, [int]$width, [int]$height, [string]$char, [int]$fg, [int]$bg) {\n        if ($width -le 0 -or $height -le 0) { return }\n        if ([string]::IsNullOrEmpty($char)) { $char = \" \" }\n        \n        # Create the fill string once\n        # If char is multi-character, we take the first char\n        $fillChar = $char[0]\n        $line = [string]$fillChar * $width\n        \n        for ($r = 0; $r -lt $height; $r++) {\n            $this.WriteAt($x, $y + $r, $line, $fg, $bg)\n        }\n    }\n\n    [void] RequestClear() {\n        # Force full redraw on next frame\n        $this.InvalidateCachedRegion(0, $this.Height - 1)\n        # Also clear the terminal immediately to prevent artifacts during transition\n        [Console]::Clear()\n    }\n\n    [void] DrawBox([int]$x, [int]$y, [int]$width, [int]$height, [int]$fg, [int]$bg) {\n        # Overload 2: Colors only (Default Style) - This fixes the 6-arg call\n        $this.DrawBox($x, $y, $width, $height, $fg, $bg, \"Single\")\n    }\n\n    [void] DrawBox([int]$x, [int]$y, [int]$width, [int]$height, [int]$fg, [int]$bg, [string]$style) {\n        if ($width -lt 2 -or $height -lt 2) { return }\n\n        # Get box characters from cache or define them\n        $chars = switch ($style) {\n            \"Double\" {\n                @{\n                    TL = \"╔\"; TR = \"╗\"; BL = \"╚\"; BR = \"╝\"\n                    V = \"║\"; H = \"═\"\n                }\n            }\n            \"Rounded\" {\n                @{\n                    TL = \"╭\"; TR = \"╮\"; BL = \"╰\"; BR = \"╯\"\n                    V = \"│\"; H = \"─\"\n                }\n            }\n            Default {\n                # Single\n                @{\n                    TL = \"┌\"; TR = \"┐\"; BL = \"└\"; BR = \"┘\"\n                    V = \"│\"; H = \"─\"\n                }\n            }\n        }\n\n        # Draw top border\n        $topLine = $chars.TL + ($chars.H * ($width - 2)) + $chars.TR\n        $this.WriteAt($x, $y, $topLine, $fg, $bg)\n\n        # Draw sides\n        $middleLine = $chars.V + (\" \" * ($width - 2)) + $chars.V\n        \n        for ($i = 1; $i -lt ($height - 1); $i++) {\n            $this.WriteAt($x, $y + $i, $middleLine, $fg, $bg)\n        }\n\n        # Draw bottom border\n        $bottomLine = $chars.BL + ($chars.H * ($width - 2)) + $chars.BR\n        $this.WriteAt($x, $y + $height - 1, $bottomLine, $fg, $bg)\n    }\n\n    [void] InvalidateCachedRegion([int]$minY, [int]$maxY) {\n        # Forcing a redraw is easy: Just corrupt the FrontBuffer in that area.\n        # This makes the Diff engine think \"Everything changed\" for those rows.\n        for ($y = $minY; $y -le $maxY; $y++) {\n            if ($y -ge 0 -and $y -lt $this.Height) {\n                for ($x = 0; $x -lt $this.Width; $x++) {\n                    # Set front buffer char to a specialized 'invalid' state\n                    # so it definitely mismatches whatever is in backbuffer\n                    $this._frontBuffer.SetCell($x, $y, [char]0, -1, -1, 0)\n                }\n            }\n        }\n\n        # VISUAL FIX: Also clear the lines on the terminal immediately\n        # This prevents artifacts (like old menu items) from remaining visible\n        # if the new frame doesn't write to those exact locations.\n        try {\n            $sb = [InternalStringBuilderPool]::Get()\n            for ($y = $minY; $y -le $maxY; $y++) {\n                if ($y -ge 0 -and $y -lt $this.Height) {\n                    [void]$sb.Append(\"`e[$($y + 1);1H\") # Move to start of line\n                    [void]$sb.Append(\"`e[2K\")           # Clear line\n                }\n            }\n            [Console]::Write($sb.ToString())\n            [InternalStringBuilderPool]::Recycle($sb)\n        }\n        catch {\n            # Ignore errors if console is not available\n        }\n\n        # Mark dirty so EndFrame scans it\n        $this._UpdateDirtyBounds(0, $minY)\n        $this._UpdateDirtyBounds($this.Width - 1, $maxY)\n    }\n\n    # -------------------------------------------------------------------------\n    # INTERNAL HELPERS\n    # -------------------------------------------------------------------------\n\n    hidden [void] _ResetDirtyBounds([bool]$fullScreen) {\n        if ($fullScreen) {\n            $this._dirtyBounds = @{ MinX = 0; MinY = 0; MaxX = $this.Width; MaxY = $this.Height }\n        }\n        else {\n            # Inverted bounds to start\n            $this._dirtyBounds = @{ MinX = $this.Width; MinY = $this.Height; MaxX = -1; MaxY = -1 }\n        }\n    }\n\n    hidden [void] _UpdateDirtyBounds([int]$x, [int]$y) {\n        if ($x -lt $this._dirtyBounds.MinX) { $this._dirtyBounds.MinX = $x }\n        if ($x -gt $this._dirtyBounds.MaxX) { $this._dirtyBounds.MaxX = $x }\n        if ($y -lt $this._dirtyBounds.MinY) { $this._dirtyBounds.MinY = $y }\n        if ($y -gt $this._dirtyBounds.MaxY) { $this._dirtyBounds.MaxY = $y }\n    }\n\n    # Core Diffing Logic - delegates to C# for performance\n    hidden [string] _BuildOptimizedDiff() {\n        # If nothing changed, return empty\n        if ($this._dirtyBounds.MaxX -lt 0) { return \"\" }\n\n        # Delegate to C# BuildDiff for ~50-100x speedup\n        if ($this._backBuffer.GetType().Name -eq 'NativeCellBuffer') {\n            return $this._backBuffer.BuildDiff($this._frontBuffer)\n        }\n\n        # PowerShell fallback - Clamp bounds to screen\n        $minX = [Math]::Max(0, $this._dirtyBounds.MinX)\n        $maxX = [Math]::Min($this.Width - 1, $this._dirtyBounds.MaxX)\n        $minY = [Math]::Max(0, $this._dirtyBounds.MinY)\n        $maxY = [Math]::Min($this.Height - 1, $this._dirtyBounds.MaxY)\n\n        # Use Pooled StringBuilder to save memory\n        $sb = [InternalStringBuilderPool]::Get()\n\n        $currentFg = -1\n        $currentBg = -1\n        $currentAttr = 0\n        $termCursorX = -1\n        $termCursorY = -1\n\n        for ($y = $minY; $y -le $maxY; $y++) {\n            $x = $minX\n            while ($x -le $maxX) {\n                # Get cells\n                $back = $this._backBuffer.GetCell($x, $y)\n                $front = $this._frontBuffer.GetCell($x, $y)\n\n                # Skip if identical\n                if ($back.Equals($front)) {\n                    $x++\n                    continue\n                }\n\n                # CHANGE DETECTED: We need to draw.\n                \n                # 1. Position Cursor (if needed)\n                if ($termCursorX -ne $x -or $termCursorY -ne $y) {\n                    # Optimized VT100 move\n                    [void]$sb.Append(\"`e[$($y + 1);$($x + 1)H\")\n                    $termCursorX = $x\n                    $termCursorY = $y\n                }\n\n                # 2. Look Ahead (Run Length Encoding)\n                # Find how many subsequent cells have same color/attr AND need updating\n                # (Or have same visual look, even if prev buffer matches... actually simpler:\n                # just group by Attribute/Color for the write)\n                \n                $runLen = 0\n                while (($x + $runLen) -le $maxX) {\n                    $nextBack = $this._backBuffer.GetCell($x + $runLen, $y)\n                    \n                    # Stop if colors/attrs change\n                    if (-not ($nextBack.ForegroundRgb -eq $back.ForegroundRgb -and \n                            $nextBack.BackgroundRgb -eq $back.BackgroundRgb -and \n                            $nextBack.Attributes -eq $back.Attributes)) {\n                        break\n                    }\n                    \n                    # Optimization: If the NEXT cell matches the front buffer (is unchanged),\n                    # we technically *could* skip it. But breaking the run to skip 1 char \n                    # usually costs more bytes (cursor move) than just overwriting it.\n                    # So we generally blast through unless there's a huge gap.\n                    $runLen++\n                }\n\n                # 3. Update Colors/Attrs (Only if changed from current terminal state)\n                if ($back.Attributes -ne $currentAttr) {\n                    # Reset first if needed (simplified)\n                    if ($currentAttr -ne 0) { \n                        [void]$sb.Append(\"`e[0m\")\n                        $currentFg = -1; $currentBg = -1\n                    }\n                    # Apply bits... (Bold, Underline, etc)\n                    if ($back.Attributes -band 1) { [void]$sb.Append(\"`e[1m\") } # Bold\n                    if ($back.Attributes -band 2) { [void]$sb.Append(\"`e[4m\") } # Underline\n                    $currentAttr = $back.Attributes\n                }\n\n                if ($back.ForegroundRgb -ne $currentFg) {\n                    # Emit RGB or Reset sequence\n                    if ($back.ForegroundRgb -eq -1) { [void]$sb.Append(\"`e[39m\") }\n                    else { \n                        $rgb = [HybridRenderEngine]::_UnpackRGB($back.ForegroundRgb)\n                        [void]$sb.Append(\"`e[38;2;$($rgb.R);$($rgb.G);$($rgb.B)m\") \n                    }\n                    $currentFg = $back.ForegroundRgb\n                }\n\n                if ($back.BackgroundRgb -ne $currentBg) {\n                    if ($back.BackgroundRgb -eq -1) { [void]$sb.Append(\"`e[49m\") }\n                    else { \n                        $rgb = [HybridRenderEngine]::_UnpackRGB($back.BackgroundRgb)\n                        [void]$sb.Append(\"`e[48;2;$($rgb.R);$($rgb.G);$($rgb.B)m\") \n                    }\n                    $currentBg = $back.BackgroundRgb\n                }\n\n                # 4. Write Characters\n                for ($k = 0; $k -lt $runLen; $k++) {\n                    [void]$sb.Append($this._backBuffer.GetCell($x + $k, $y).Char)\n                }\n\n                $x += $runLen\n                $termCursorX += $runLen\n            }\n        }\n        \n        # Reset color at end of burst to be safe (optional, but good for cursor)\n        if ($currentAttr -ne 0 -or $currentFg -ne -1 -or $currentBg -ne -1) {\n            [void]$sb.Append(\"`e[0m\")\n        }\n\n        $result = $sb.ToString()\n        [InternalStringBuilderPool]::Recycle($sb)\n        return $result\n    }\n\n    hidden [void] _ParseAnsiState([char]$cmd, [string]$params, [ref]$fg, [ref]$bg, [ref]$attr) {\n        # Helper to parse ANSI codes and update state integers\n        if ($cmd -ne 'm') { return }\n        \n        if ([string]::IsNullOrEmpty($params)) {\n            $fg.Value = -1; $bg.Value = -1; $attr.Value = 0\n            return\n        }\n\n        # Check cache\n        if ([HybridRenderEngine]::_ansiCache.ContainsKey($params)) {\n            $cached = [HybridRenderEngine]::_ansiCache[$params]\n            # If cached value is a hashtable with state changes, apply them\n            # However, since we need to update refs based on current state (accumulative?), \n            # actually ANSI codes like '31' are absolute for color, but '1' is additive for attr.\n            # Simple caching of the *parsing result* (the loop below) is hard because of 'parts'.\n            # But we can cache the *operations* for a param string.\n            \n            # For now, let's implement a simple cache for the most common single-code params\n            # which avoids splitting and looping.\n            if ($cached -is [hashtable]) {\n                if ($cached.ContainsKey('Fg')) { $fg.Value = $cached.Fg }\n                if ($cached.ContainsKey('Bg')) { $bg.Value = $cached.Bg }\n                if ($cached.ContainsKey('Attr')) { $attr.Value = $attr.Value -bor $cached.Attr }\n                if ($cached.ContainsKey('Reset')) { $fg.Value = -1; $bg.Value = -1; $attr.Value = 0 }\n                return\n            }\n        }\n\n        $parts = $params -split ';'\n        $i = 0\n        \n        # Track changes for caching (only for simple cases)\n        $cacheable = $true\n        $cachedChanges = @{}\n\n        while ($i -lt $parts.Length) {\n            $code = [int]$parts[$i]\n            switch ($code) {\n                0 { \n                    $fg.Value = -1; $bg.Value = -1; $attr.Value = 0 \n                    $cachedChanges['Reset'] = $true\n                }\n                1 { \n                    $attr.Value = $attr.Value -bor 1 \n                    $cachedChanges['Attr'] = ($cachedChanges['Attr'] -bor 1)\n                } # Bold\n                4 { \n                    $attr.Value = $attr.Value -bor 2 \n                    $cachedChanges['Attr'] = ($cachedChanges['Attr'] -bor 2)\n                } # Underline\n                38 { \n                    # FG RGB: 38;2;R;G;B\n                    $cacheable = $false # Don't cache complex RGB for now\n                    if ($i + 4 -lt $parts.Length -and $parts[$i + 1] -eq 2) {\n                        $fg.Value = [HybridRenderEngine]::_PackRGB($parts[$i + 2], $parts[$i + 3], $parts[$i + 4])\n                        $i += 4\n                    }\n                }\n                48 { \n                    # BG RGB: 48;2;R;G;B\n                    $cacheable = $false\n                    if ($i + 4 -lt $parts.Length -and $parts[$i + 1] -eq 2) {\n                        $bg.Value = [HybridRenderEngine]::_PackRGB($parts[$i + 2], $parts[$i + 3], $parts[$i + 4])\n                        $i += 4\n                    }\n                }\n                39 { \n                    $fg.Value = -1 \n                    $cachedChanges['Fg'] = -1\n                }\n                49 { \n                    $bg.Value = -1 \n                    $cachedChanges['Bg'] = -1\n                }\n                default {\n                    # Handle standard 16 colors\n                    if ($code -ge 30 -and $code -le 37) { \n                        # Standard FG (map to approximated RGB or special value? \n                        # CellBuffer uses int RGB. Let's map to -1 for now or implementation dependent.\n                        # For strictly RGB engine, we might ignore or map to standard palette.\n                        # This implementation seems to assume RGB or -1.\n                        # Let's mark not cacheable if we don't handle it fully here.\n                        $cacheable = $false\n                    }\n                }\n            }\n            $i++\n        }\n\n        # Cache simple results\n        if ($cacheable -and $parts.Length -eq 1) {\n            [HybridRenderEngine]::_ansiCache[$params] = $cachedChanges\n        }\n    }\n\n    hidden static [int] _PackRGB([int]$r, [int]$g, [int]$b) {\n        # Clamp to valid range\n        $r = [Math]::Max(0, [Math]::Min(255, $r))\n        $g = [Math]::Max(0, [Math]::Min(255, $g))\n        $b = [Math]::Max(0, [Math]::Min(255, $b))\n\n        return ($r -shl 16) -bor ($g -shl 8) -bor $b\n    }\n\n    hidden static [hashtable] _UnpackRGB([int]$packed) {\n        return @{\n            R = ($packed -shr 16) -band 0xFF\n            G = ($packed -shr 8) -band 0xFF\n            B = $packed -band 0xFF\n        }\n    }\n\n    # Helper to convert ANSI string (e.g. from Theme) to Int Color\n    static [int] AnsiColorToInt([string]$ansi) {\n        if ([string]::IsNullOrEmpty($ansi)) { return -1 }\n        \n        # Parse RGB: \\e[38;2;R;G;Bm or \\e[48;2;R;G;Bm\n        # We look for the sequence digit;digit;digit m\n        if ($ansi -match '(\\d+);(\\d+);(\\d+)m') {\n            $r = [int]$matches[1]\n            $g = [int]$matches[2]\n            $b = [int]$matches[3]\n            return [HybridRenderEngine]::_PackRGB($r, $g, $b)\n        }\n        \n        return -1\n    }\n\n    # -------------------------------------------------------------------------\n    # LAYOUT SYSTEM\n    # -------------------------------------------------------------------------\n\n    [void] DefineRegion([string]$id, [int]$x, [int]$y, [int]$width, [int]$height) {\n        $this.DefineRegion($id, $x, $y, $width, $height, 0, \"\")\n    }\n\n    [void] DefineRegion([string]$id, [int]$x, [int]$y, [int]$width, [int]$height, [int]$zIndex) {\n        $this.DefineRegion($id, $x, $y, $width, $height, $zIndex, \"\")\n    }\n\n    [void] DefineRegion([string]$id, [int]$x, [int]$y, [int]$width, [int]$height, [int]$zIndex, [string]$parentId) {\n        $region = [LayoutRegion]::new($id, $x, $y, $width, $height)\n        $region.ZIndex = $zIndex\n        $region.ParentID = $parentId\n        $this._regions[$id] = $region\n    }\n\n    [hashtable] GetRegionBounds([string]$id) {\n        if (-not $this._regions.ContainsKey($id)) { return $null }\n        \n        $region = $this._regions[$id]\n        $bounds = @{ X = $region.X; Y = $region.Y; Width = $region.Width; Height = $region.Height; ZIndex = $region.ZIndex }\n        \n        # Resolve parent offsets recursively\n        $current = $region\n        while (-not [string]::IsNullOrEmpty($current.ParentID)) {\n            if ($this._regions.ContainsKey($current.ParentID)) {\n                $parent = $this._regions[$current.ParentID]\n                $bounds.X += $parent.X\n                $bounds.Y += $parent.Y\n                $bounds.ZIndex += $parent.ZIndex\n                $current = $parent\n            }\n            else {\n                break\n            }\n        }\n        \n        return $bounds\n    }\n\n    [void] WriteToRegion([string]$regionId, [string]$content) {\n        $this.WriteToRegion($regionId, $content, -1, -1)\n    }\n\n    [void] WriteToRegion([string]$regionId, [string]$content, [int]$fg) {\n        $this.WriteToRegion($regionId, $content, $fg, -1)\n    }\n\n    [void] WriteToRegion([string]$regionId, [string]$content, [int]$fg, [int]$bg) {\n        $bounds = $this.GetRegionBounds($regionId)\n        if ($null -eq $bounds) { return }\n        \n        # Apply region z-index temporarily\n        $oldZ = $this._currentZ\n        $this._currentZ = $bounds.ZIndex\n        \n        # Set clip to region bounds\n        $this.PushClip($bounds.X, $bounds.Y, $bounds.Width, $bounds.Height)\n        \n        # Write at region origin (0,0 relative to region)\n        # Note: WriteAt handles clipping logic\n        if ($fg -ne -1 -or $bg -ne -1) {\n            $this.WriteAt($bounds.X, $bounds.Y, $content, $fg, $bg)\n        }\n        else {\n            $this.WriteAt($bounds.X, $bounds.Y, $content)\n        }\n        \n        $this.PopClip()\n        $this._currentZ = $oldZ\n    }\n\n    [void] WriteToRegion([string]$regionId, [string]$content, [int]$fgStart, [int]$fgEnd, [int]$bg) {\n        $bounds = $this.GetRegionBounds($regionId)\n        if ($null -eq $bounds) { return }\n        \n        # Apply region z-index temporarily\n        $oldZ = $this._currentZ\n        $this._currentZ = $bounds.ZIndex\n        \n        # Set clip to region bounds\n        $this.PushClip($bounds.X, $bounds.Y, $bounds.Width, $bounds.Height)\n        \n        # Write at region origin (0,0 relative to region) using Gradient WriteAt\n        $this.WriteAt($bounds.X, $bounds.Y, $content, $fgStart, $fgEnd, $bg)\n        \n        $this.PopClip()\n        $this._currentZ = $oldZ\n    }\n\n    # Define a grid of columns within a parent region\n    # columns: array of hashtables @{ Name='...'; Width=... } or just widths\n    # Returns: array of generated region IDs\n    [string[]] DefineGrid([string]$baseId, [int]$x, [int]$y, [int]$totalWidth, [int]$height, [array]$columns) {\n        $generatedIds = @()\n        $currentX = $x\n        \n        for ($i = 0; $i -lt $columns.Count; $i++) {\n            $col = $columns[$i]\n            $colWidth = 0\n            $colName = \"Col$i\"\n            \n            if ($col -is [hashtable]) {\n                if ($col.ContainsKey('Width')) { $colWidth = $col.Width }\n                if ($col.ContainsKey('Name')) { $colName = $col.Name }\n            }\n            elseif ($col -is [int]) {\n                $colWidth = $col\n            }\n            \n            # Create region for column content\n            $regionId = \"${baseId}_${colName}\"\n            # CRITICAL FIX: Set ParentID to baseId so GetChildRegions works!\n            $this.DefineRegion($regionId, $currentX, $y, $colWidth, $height, 0, $baseId)\n            $generatedIds += $regionId\n            \n            # Advance X (including 4-space gap which is NOT part of the region)\n            $currentX += $colWidth + 4\n        }\n        \n        return $generatedIds\n    }\n\n    # Get immediate child regions for a parent ID\n    [string[]] GetChildRegions([string]$parentId) {\n        $children = @()\n        foreach ($key in $this._regions.Keys) {\n            $region = $this._regions[$key]\n            if ($region.ParentID -eq $parentId) {\n                $children += $region.ID\n            }\n        }\n        # Sort by X to ensure column order\n        $sorted = $children | Sort-Object { $this._regions[$_].X }\n        return $sorted\n    }\n}"}, {"path": "lib/SpeedTUI/Core/Logger.ps1", "content": "# SpeedTUI Logger - Granular, module-specific logging with extensive null checks\r\nusing namespace System.Collections.Concurrent\r\nusing namespace System.IO\r\n\r\nenum LogLevel {\r\n    Trace = 0\r\n    Debug = 1\r\n    Info = 2\r\n    Warn = 3\r\n    Error = 4\r\n    Fatal = 5\r\n    None = 99\r\n}\r\n\r\nclass LogEntry {\r\n    [DateTime]$Timestamp\r\n    [LogLevel]$Level\r\n    [string]$Module\r\n    [string]$Component\r\n    [string]$Message\r\n    [hashtable]$Context\r\n    [string]$StackTrace\r\n    \r\n    [string] ToString() {\r\n        $ctx = $(if ($this.Context -and $this.Context.Count -gt 0) {\r\n                \" | \" + ($this.Context.GetEnumerator() | ForEach-Object { \"$($_.Key)=$($_.Value)\" }) -join \", \"\r\n            }\r\n            else { \"\" })\r\n        \r\n        return \"$($this.Timestamp.ToString('yyyy-MM-dd HH:mm:ss.fff')) [$($this.Level)] [$($this.Module)][$($this.Component)] $($this.Message)$ctx\"\r\n    }\r\n}\r\n\r\nclass Logger {\r\n    # Singleton instance\r\n    static [object]$Instance = $null\r\n    \r\n    # Configuration\r\n    [ConcurrentDictionary[string, LogLevel]]$ModuleLevels\r\n    [ConcurrentDictionary[string, LogLevel]]$ComponentLevels\r\n    [LogLevel]$GlobalLevel = [LogLevel]::Debug\r\n    [bool]$EnableConsole = $false\r\n    [bool]$EnableFile = $true\r\n    [string]$LogDirectory\r\n    [string]$LogFilePath\r\n    \r\n    # Performance\r\n    hidden [StreamWriter]$_fileWriter\r\n    hidden [ConcurrentQueue[LogEntry]]$_logQueue\r\n    hidden [System.Threading.Timer]$_flushTimer\r\n    hidden [object]$_writeLock = [object]::new()\r\n    \r\n    # Statistics\r\n    [ConcurrentDictionary[string, int]]$LogCounts\r\n    [ConcurrentDictionary[string, TimeSpan]]$PerformanceMetrics\r\n    \r\n    hidden Logger() {\r\n        $this.ModuleLevels = [ConcurrentDictionary[string, LogLevel]]::new()\r\n        $this.ComponentLevels = [ConcurrentDictionary[string, LogLevel]]::new()\r\n        $this.LogCounts = [ConcurrentDictionary[string, int]]::new()\r\n        $this.PerformanceMetrics = [ConcurrentDictionary[string, TimeSpan]]::new()\r\n        $this._logQueue = [ConcurrentQueue[LogEntry]]::new()\r\n        \r\n        # Set up log directory\r\n        $this.LogDirectory = Join-Path (Join-Path $PSScriptRoot \"..\") \"Logs\"\r\n        if (-not (Test-Path $this.LogDirectory)) {\r\n            New-Item -ItemType Directory -Path $this.LogDirectory -Force | Out-Null\r\n        }\r\n        \r\n        # Create log file with timestamp\r\n        $timestamp = [DateTime]::Now.ToString(\"yyyyMMdd_HHmmss\")\r\n        $this.LogFilePath = Join-Path $this.LogDirectory \"speedtui_$timestamp.log\"\r\n        \r\n        # Initialize file writer\r\n        $this.InitializeFileWriter()\r\n        \r\n        # No automatic timer - will flush synchronously for now\r\n    }\r\n    \r\n    static [object] GetInstance() {\r\n        if ($null -eq [Logger]::Instance) {\r\n            [Logger]::Instance = [Logger]::new()\r\n        }\r\n        return [Logger]::Instance\r\n    }\r\n    \r\n    hidden [void] InitializeFileWriter() {\r\n        try {\r\n            $this._fileWriter = [StreamWriter]::new($this.LogFilePath, $true)\r\n            $this._fileWriter.AutoFlush = $false\r\n        }\r\n        catch {\r\n            Write-Warning \"Failed to initialize log file writer: $_\"\r\n            $this.EnableFile = $false\r\n        }\r\n    }\r\n    \r\n    # Module-level configuration\r\n    [void] SetModuleLevel([string]$module, [LogLevel]$level) {\r\n        if ([string]::IsNullOrWhiteSpace($module)) { return }\r\n        $this.ModuleLevels[$module] = $level\r\n    }\r\n    \r\n    # Component-level configuration (more granular)\r\n    [void] SetComponentLevel([string]$module, [string]$component, [LogLevel]$level) {\r\n        if ([string]::IsNullOrWhiteSpace($module) -or [string]::IsNullOrWhiteSpace($component)) { return }\r\n        $key = \"$module.$component\"\r\n        $this.ComponentLevels[$key] = $level\r\n    }\r\n    \r\n    # Check if logging is enabled for given context\r\n    hidden [bool] ShouldLog([LogLevel]$level, [string]$module, [string]$component) {\r\n        if ($level -lt $this.GlobalLevel) { return $false }\r\n        \r\n        # Check component-specific level first (most specific)\r\n        if (-not [string]::IsNullOrWhiteSpace($component)) {\r\n            $componentKey = \"$module.$component\"\r\n            $componentLevel = $null\r\n            if ($this.ComponentLevels.ContainsKey($componentKey)) {\r\n                $componentLevel = $this.ComponentLevels[$componentKey]\r\n                return $level -ge $componentLevel\r\n            }\r\n        }\r\n        \r\n        # Check module-specific level\r\n        if (-not [string]::IsNullOrWhiteSpace($module)) {\r\n            $moduleLevel = $null\r\n            if ($this.ModuleLevels.ContainsKey($module)) {\r\n                $moduleLevel = $this.ModuleLevels[$module]\r\n                return $level -ge $moduleLevel\r\n            }\r\n        }\r\n        \r\n        # Fall back to global level\r\n        return $true\r\n    }\r\n    \r\n    # Core logging method with extensive null checks\r\n    [void] Log([LogLevel]$level, [string]$module, [string]$component, [string]$message, [hashtable]$context) {\r\n        # Null checks\r\n        if ($null -eq $module) { $module = \"Unknown\" }\r\n        if ($null -eq $component) { $component = \"Unknown\" }\r\n        if ($null -eq $message) { $message = \"\" }\r\n        if ($null -eq $context) { $context = @{} }\r\n        \r\n        # Check if we should log\r\n        if (-not $this.ShouldLog($level, $module, $component)) { return }\r\n        \r\n        # Create log entry\r\n        $entry = [LogEntry]@{\r\n            Timestamp  = [DateTime]::Now\r\n            Level      = $level\r\n            Module     = $module\r\n            Component  = $component\r\n            Message    = $message\r\n            Context    = $context\r\n            StackTrace = $(if ($level -ge [LogLevel]::Error) { (Get-PSCallStack | Out-String) } else { \"\" })\r\n        }\r\n        \r\n        # Queue for async write\r\n        $this._logQueue.Enqueue($entry)\r\n\r\n        # PERFORMANCE FIX: Only flush immediately for ERROR/FATAL, batch everything else\r\n        # This prevents 6000+ disk writes/sec in render loops\r\n        if ($level -ge [LogLevel]::Error) {\r\n            $this.FlushQueue()\r\n        }\r\n        # Flush periodically when queue gets large (100 entries)\r\n        elseif ($this._logQueue.Count -ge 100) {\r\n            $this.FlushQueue()\r\n        }\r\n        \r\n        # Update statistics\r\n        $statKey = \"$module.$component.$level\"\r\n        [void]$this.LogCounts.AddOrUpdate($statKey, 1, { param($k, $v) $v + 1 })\r\n        \r\n        # Console output for errors/warnings in debug mode\r\n        if ($this.EnableConsole -and $level -ge [LogLevel]::Warn) {\r\n            $this.WriteToConsole($entry)\r\n        }\r\n    }\r\n    \r\n    # Convenience methods for each log level\r\n    [void] Trace([string]$module, [string]$component, [string]$message) {\r\n        $this.Log([LogLevel]::Trace, $module, $component, $message, @{})\r\n    }\r\n    \r\n    [void] Trace([string]$module, [string]$component, [string]$message, [hashtable]$context) {\r\n        $this.Log([LogLevel]::Trace, $module, $component, $message, $context)\r\n    }\r\n    \r\n    [void] Debug([string]$module, [string]$component, [string]$message) {\r\n        $this.Log([LogLevel]::Debug, $module, $component, $message, @{})\r\n    }\r\n    \r\n    [void] Debug([string]$module, [string]$component, [string]$message, [hashtable]$context) {\r\n        $this.Log([LogLevel]::Debug, $module, $component, $message, $context)\r\n    }\r\n    \r\n    [void] Info([string]$module, [string]$component, [string]$message) {\r\n        $this.Log([LogLevel]::Info, $module, $component, $message, @{})\r\n    }\r\n    \r\n    [void] Info([string]$module, [string]$component, [string]$message, [hashtable]$context) {\r\n        $this.Log([LogLevel]::Info, $module, $component, $message, $context)\r\n    }\r\n    \r\n    [void] Warn([string]$module, [string]$component, [string]$message) {\r\n        $this.Log([LogLevel]::Warn, $module, $component, $message, @{})\r\n    }\r\n    \r\n    [void] Warn([string]$module, [string]$component, [string]$message, [hashtable]$context) {\r\n        $this.Log([LogLevel]::Warn, $module, $component, $message, $context)\r\n    }\r\n    \r\n    [void] Error([string]$module, [string]$component, [string]$message) {\r\n        $this.Log([LogLevel]::Error, $module, $component, $message, @{})\r\n    }\r\n    \r\n    [void] Error([string]$module, [string]$component, [string]$message, [hashtable]$context) {\r\n        $this.Log([LogLevel]::Error, $module, $component, $message, $context)\r\n    }\r\n    \r\n    [void] Fatal([string]$module, [string]$component, [string]$message) {\r\n        $this.Log([LogLevel]::Fatal, $module, $component, $message, @{})\r\n    }\r\n    \r\n    [void] Fatal([string]$module, [string]$component, [string]$message, [hashtable]$context) {\r\n        $this.Log([LogLevel]::Fatal, $module, $component, $message, $context)\r\n    }\r\n    \r\n    # Performance tracking\r\n    [IDisposable] MeasurePerformance([string]$module, [string]$operation) {\r\n        return [PerformanceTimer]::new($this, $module, $operation)\r\n    }\r\n    \r\n    # Flush queue to file\r\n    hidden [void] FlushQueue() {\r\n        if (-not $this.EnableFile -or $null -eq $this._fileWriter) { return }\r\n        \r\n        $entries = [System.Collections.Generic.List[LogEntry]]::new()\r\n        $entry = $null\r\n        \r\n        # Dequeue all pending entries\r\n        while ($this._logQueue.TryDequeue([ref]$entry)) {\r\n            $entries.Add($entry)\r\n        }\r\n        \r\n        if ($entries.Count -eq 0) { return }\r\n        \r\n        # Write to file\r\n        try {\r\n            [System.Threading.Monitor]::Enter($this._writeLock)\r\n            foreach ($e in $entries) {\r\n                $this._fileWriter.WriteLine($e.ToString())\r\n            }\r\n            $this._fileWriter.Flush()\r\n        }\r\n        catch {\r\n            Write-Warning \"Failed to write to log file: $_\"\r\n        }\r\n        finally {\r\n            [System.Threading.Monitor]::Exit($this._writeLock)\r\n        }\r\n    }\r\n    \r\n    # Console output with color coding\r\n    hidden [void] WriteToConsole([LogEntry]$entry) {\r\n        $color = switch ($entry.Level) {\r\n            Trace { \"DarkGray\" }\r\n            Debug { \"Gray\" }\r\n            Info { \"White\" }\r\n            Warn { \"Yellow\" }\r\n            Error { \"Red\" }\r\n            Fatal { \"DarkRed\" }\r\n            default { \"White\" }\r\n        }\r\n        \r\n        Write-Host $entry.ToString() -ForegroundColor $color\r\n    }\r\n    \r\n    # Get statistics\r\n    [hashtable] GetStatistics() {\r\n        return @{\r\n            LogCounts          = $this.LogCounts.ToArray()\r\n            PerformanceMetrics = $this.PerformanceMetrics.ToArray()\r\n            QueueSize          = $this._logQueue.Count\r\n            LogFilePath        = $this.LogFilePath\r\n        }\r\n    }\r\n    \r\n    # Cleanup\r\n    [void] Dispose() {\r\n        $this.FlushQueue()\r\n        \r\n        if ($null -ne $this._fileWriter) {\r\n            $this._fileWriter.Close()\r\n            $this._fileWriter.Dispose()\r\n            $this._fileWriter = $null\r\n        }\r\n    }\r\n}\r\n\r\n# Performance measurement helper\r\nclass PerformanceTimer : System.IDisposable {\r\n    hidden [object]$_logger\r\n    hidden [string]$_module\r\n    hidden [string]$_operation\r\n    hidden [System.Diagnostics.Stopwatch]$_stopwatch\r\n    \r\n    PerformanceTimer([object]$logger, [string]$module, [string]$operation) {\r\n        $this._logger = $logger\r\n        $this._module = $module\r\n        $this._operation = $operation\r\n        $this._stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        \r\n        $logger.Trace($module, \"Performance\", \"Starting operation: $operation\")\r\n    }\r\n    \r\n    [void] Dispose() {\r\n        $this._stopwatch.Stop()\r\n        $elapsed = $this._stopwatch.Elapsed\r\n        \r\n        $this._logger.Debug($this._module, \"Performance\", \"Completed operation: $($this._operation)\", @{\r\n                ElapsedMs = $elapsed.TotalMilliseconds\r\n                Operation = $this._operation\r\n            })\r\n        \r\n        # Store metric\r\n        $key = \"$($this._module).$($this._operation)\"\r\n        [void]$this._logger.PerformanceMetrics.AddOrUpdate($key, $elapsed, { \r\n                param($k, $v) \r\n                if ($elapsed -gt $v) { $elapsed } else { $v }\r\n            })\r\n    }\r\n}\r\n\r\n# Global logger instance helper\r\nfunction Get-Logger {\r\n    return [Logger]::GetInstance()\r\n}"}, {"path": "lib/SpeedTUI/Core/NativeRenderCore.ps1", "content": "# NativeRenderCore.ps1 - High-performance C# cell buffer and diff engine\n# This replaces the PowerShell CellBuffer with compiled C# for ~50-100x speedup\n\nSet-StrictMode -Version Latest\n\n# Only compile once\nif (-not ([System.Management.Automation.PSTypeName]'NativeCell').Type) {\n\n$csharpCode = @\"\nusing System;\nusing System.Text;\nusing System.Runtime.CompilerServices;\n\n/// <summary>\n/// Represents a single cell in the terminal buffer.\n/// Struct for stack allocation and cache-friendly memory layout.\n/// </summary>\npublic struct NativeCell : IEquatable<NativeCell>\n{\n    public char Char;\n    public int ForegroundRgb;  // Packed RGB: (R<<16)|(G<<8)|B, -1 = default\n    public int BackgroundRgb;  // Packed RGB: (R<<16)|(G<<8)|B, -1 = default\n    public byte Attributes;    // Bit 0: Bold, Bit 1: Underline, Bit 2: Italic\n\n    public const byte ATTR_BOLD = 0x01;\n    public const byte ATTR_UNDERLINE = 0x02;\n    public const byte ATTR_ITALIC = 0x04;\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public bool Equals(NativeCell other)\n    {\n        return Char == other.Char &&\n               ForegroundRgb == other.ForegroundRgb &&\n               BackgroundRgb == other.BackgroundRgb &&\n               Attributes == other.Attributes;\n    }\n\n    public void Reset()\n    {\n        Char = ' ';\n        ForegroundRgb = -1;\n        BackgroundRgb = -1;\n        Attributes = 0;\n    }\n}\n\n/// <summary>\n/// High-performance cell buffer with optimized differential rendering.\n/// All hot paths are in C# for maximum performance on large terminals.\n/// </summary>\npublic class NativeCellBuffer\n{\n    private NativeCell[,] _cells;\n    private int _width;\n    private int _height;\n\n    public int Width => _width;\n    public int Height => _height;\n\n    public NativeCellBuffer(int width, int height)\n    {\n        if (width <= 0 || height <= 0)\n            throw new ArgumentException(\"Dimensions must be positive\");\n\n        _width = width;\n        _height = height;\n        _cells = new NativeCell[height, width];\n        Clear();\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public void SetCell(int x, int y, char c, int fg, int bg, byte attr)\n    {\n        if (x < 0 || x >= _width || y < 0 || y >= _height) return;\n        \n        ref NativeCell cell = ref _cells[y, x];\n        cell.Char = c;\n        cell.ForegroundRgb = fg;\n        cell.BackgroundRgb = bg;\n        cell.Attributes = attr;\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public NativeCell GetCell(int x, int y)\n    {\n        if (x < 0 || x >= _width || y < 0 || y >= _height)\n            return new NativeCell { Char = ' ', ForegroundRgb = -1, BackgroundRgb = -1, Attributes = 0 };\n        return _cells[y, x];\n    }\n\n    public void Clear()\n    {\n        for (int y = 0; y < _height; y++)\n        {\n            for (int x = 0; x < _width; x++)\n            {\n                _cells[y, x].Reset();\n            }\n        }\n    }\n\n    public void Resize(int newWidth, int newHeight)\n    {\n        if (newWidth <= 0 || newHeight <= 0)\n            throw new ArgumentException(\"Dimensions must be positive\");\n\n        var newCells = new NativeCell[newHeight, newWidth];\n        \n        // Initialize new cells\n        for (int y = 0; y < newHeight; y++)\n        {\n            for (int x = 0; x < newWidth; x++)\n            {\n                newCells[y, x].Reset();\n            }\n        }\n\n        // Copy existing content\n        int copyWidth = Math.Min(_width, newWidth);\n        int copyHeight = Math.Min(_height, newHeight);\n        \n        for (int y = 0; y < copyHeight; y++)\n        {\n            for (int x = 0; x < copyWidth; x++)\n            {\n                newCells[y, x] = _cells[y, x];\n            }\n        }\n\n        _cells = newCells;\n        _width = newWidth;\n        _height = newHeight;\n    }\n\n    public void CopyFrom(NativeCellBuffer source)\n    {\n        if (source._width != _width || source._height != _height)\n            throw new ArgumentException(\"Buffer dimensions must match\");\n\n        Array.Copy(source._cells, _cells, _cells.Length);\n    }\n\n    public void Fill(int x, int y, int width, int height, char c, int fg, int bg, byte attr)\n    {\n        int endX = Math.Min(x + width, _width);\n        int endY = Math.Min(y + height, _height);\n        int startX = Math.Max(0, x);\n        int startY = Math.Max(0, y);\n\n        for (int row = startY; row < endY; row++)\n        {\n            for (int col = startX; col < endX; col++)\n            {\n                ref NativeCell cell = ref _cells[row, col];\n                cell.Char = c;\n                cell.ForegroundRgb = fg;\n                cell.BackgroundRgb = bg;\n                cell.Attributes = attr;\n            }\n        }\n    }\n\n    /// <summary>\n    /// Build minimal ANSI output representing differences between this buffer and another.\n    /// This is the CORE of differential rendering - the hottest path.\n    /// Optimizations:\n    /// 1. Skip unchanged cells immediately\n    /// 2. Run-length encoding for same-color sequences\n    /// 3. Cursor position tracking to minimize movement codes\n    /// 4. StringBuilder pre-sized to reduce allocations\n    /// </summary>\n    public string BuildDiff(NativeCellBuffer previousBuffer)\n    {\n        // Pre-size for typical diff (assume 20% changes = good estimate)\n        var sb = new StringBuilder(_width * _height / 5 * 20);\n\n        int currentFg = -1;\n        int currentBg = -1;\n        byte currentAttr = 0;\n        int cursorX = -1;\n        int cursorY = -1;\n\n        for (int y = 0; y < _height; y++)\n        {\n            int x = 0;\n            while (x < _width)\n            {\n                ref NativeCell cell = ref _cells[y, x];\n\n                // Check if cell changed from previous\n                bool changed = true;\n                if (previousBuffer != null && \n                    y < previousBuffer._height && \n                    x < previousBuffer._width)\n                {\n                    changed = !cell.Equals(previousBuffer._cells[y, x]);\n                }\n\n                if (!changed)\n                {\n                    x++;\n                    continue;\n                }\n\n                // Cell changed - need to update\n                // Move cursor if needed\n                if (cursorX != x || cursorY != y)\n                {\n                    sb.Append(\"\\x1b[\");\n                    sb.Append(y + 1);\n                    sb.Append(';');\n                    sb.Append(x + 1);\n                    sb.Append('H');\n                    cursorX = x;\n                    cursorY = y;\n                }\n\n                // Run-length encoding: find consecutive cells with same colors/attrs\n                int runLength = 1;\n                while ((x + runLength) < _width)\n                {\n                    ref NativeCell nextCell = ref _cells[y, x + runLength];\n                    \n                    // Can group if colors and attributes match\n                    if (nextCell.ForegroundRgb == cell.ForegroundRgb &&\n                        nextCell.BackgroundRgb == cell.BackgroundRgb &&\n                        nextCell.Attributes == cell.Attributes)\n                    {\n                        // Also check if changed from previous\n                        bool nextChanged = true;\n                        if (previousBuffer != null &&\n                            y < previousBuffer._height &&\n                            (x + runLength) < previousBuffer._width)\n                        {\n                            nextChanged = !nextCell.Equals(previousBuffer._cells[y, x + runLength]);\n                        }\n\n                        if (nextChanged)\n                        {\n                            runLength++;\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n\n                // Emit attributes if changed\n                if (cell.Attributes != currentAttr)\n                {\n                    if (currentAttr != 0)\n                    {\n                        sb.Append(\"\\x1b[0m\");\n                        currentFg = -1;\n                        currentBg = -1;\n                    }\n\n                    if ((cell.Attributes & NativeCell.ATTR_BOLD) != 0)\n                        sb.Append(\"\\x1b[1m\");\n                    if ((cell.Attributes & NativeCell.ATTR_UNDERLINE) != 0)\n                        sb.Append(\"\\x1b[4m\");\n                    if ((cell.Attributes & NativeCell.ATTR_ITALIC) != 0)\n                        sb.Append(\"\\x1b[3m\");\n\n                    currentAttr = cell.Attributes;\n                }\n\n                // Emit foreground color if changed\n                if (cell.ForegroundRgb != currentFg)\n                {\n                    if (cell.ForegroundRgb == -1)\n                    {\n                        sb.Append(\"\\x1b[39m\");\n                    }\n                    else\n                    {\n                        int r = (cell.ForegroundRgb >> 16) & 0xFF;\n                        int g = (cell.ForegroundRgb >> 8) & 0xFF;\n                        int b = cell.ForegroundRgb & 0xFF;\n                        sb.Append(\"\\x1b[38;2;\");\n                        sb.Append(r);\n                        sb.Append(';');\n                        sb.Append(g);\n                        sb.Append(';');\n                        sb.Append(b);\n                        sb.Append('m');\n                    }\n                    currentFg = cell.ForegroundRgb;\n                }\n\n                // Emit background color if changed\n                if (cell.BackgroundRgb != currentBg)\n                {\n                    if (cell.BackgroundRgb == -1)\n                    {\n                        sb.Append(\"\\x1b[49m\");\n                    }\n                    else\n                    {\n                        int r = (cell.BackgroundRgb >> 16) & 0xFF;\n                        int g = (cell.BackgroundRgb >> 8) & 0xFF;\n                        int b = cell.BackgroundRgb & 0xFF;\n                        sb.Append(\"\\x1b[48;2;\");\n                        sb.Append(r);\n                        sb.Append(';');\n                        sb.Append(g);\n                        sb.Append(';');\n                        sb.Append(b);\n                        sb.Append('m');\n                    }\n                    currentBg = cell.BackgroundRgb;\n                }\n\n                // Emit the characters for this run\n                for (int i = 0; i < runLength; i++)\n                {\n                    sb.Append(_cells[y, x + i].Char);\n                }\n\n                cursorX = x + runLength;\n                x += runLength;\n            }\n        }\n\n        return sb.ToString();\n    }\n\n    /// <summary>\n    /// Invalidate a row range by resetting it in the previous buffer comparison.\n    /// Used when forcing a redraw of specific areas.\n    /// </summary>\n    public void InvalidateRows(int minY, int maxY)\n    {\n        minY = Math.Max(0, minY);\n        maxY = Math.Min(_height - 1, maxY);\n\n        for (int y = minY; y <= maxY; y++)\n        {\n            for (int x = 0; x < _width; x++)\n            {\n                // Set to null char to ensure it differs from any real content\n                _cells[y, x].Char = '\\0';\n            }\n        }\n    }\n}\n\"@\n\n    Add-Type -TypeDefinition $csharpCode -Language CSharp -ErrorAction Stop\n    Write-Verbose \"NativeRenderCore: C# types compiled successfully\"\n}\n\n<#\n.SYNOPSIS\nCreate a new native cell buffer with specified dimensions\n\n.PARAMETER Width\nWidth in columns\n\n.PARAMETER Height  \nHeight in rows\n\n.OUTPUTS\nNativeCellBuffer instance\n##CLOSEBRACKET##\nfunction New-NativeCellBuffer {\n    param(\n        [Parameter(Mandatory)][int]$Width,\n        [Parameter(Mandatory)][int]$Height\n    )\n    return [NativeCellBuffer]::new($Width, $Height)\n}\n\n# Export for module use\n#Export-ModuleMember -Function New-NativeCellBuffer\n"}, {"path": "lib/SpeedTUI/Core/NullCheck.ps1", "content": "# SpeedTUI Null Check Utilities - Defensive programming helpers\r\n\r\nclass Guard {\r\n    static hidden [object]$_logger = $null\r\n    \r\n    static [object] GetLogger() {\r\n        if ($null -eq [Guard]::_logger) {\r\n            [Guard]::_logger = Get-Logger\r\n        }\r\n        return [Guard]::_logger\r\n    }\r\n    # Throw if null with detailed context\r\n    static [void] NotNull([object]$value, [string]$paramName) {\r\n        $logger = [Guard]::GetLogger()\r\n        $logger.Trace(\"Guard\", \"NotNull\", \"Validating parameter\", @{\r\n            ParamName = $paramName\r\n            IsNull = $null -eq $value\r\n        })\r\n        \r\n        if ($null -eq $value) {\r\n            $caller = (Get-PSCallStack)[1]\r\n            $errorMsg = \"Parameter '$paramName' cannot be null. Called from: $($caller.Command) at line $($caller.ScriptLineNumber)\"\r\n            \r\n            $logger.Error(\"Guard\", \"NotNull\", \"Null parameter validation failed\", @{\r\n                ParamName = $paramName\r\n                Caller = $caller.Command\r\n                LineNumber = $caller.ScriptLineNumber\r\n            })\r\n            \r\n            throw [System.ArgumentNullException]::new($paramName, $errorMsg)\r\n        }\r\n        \r\n        $logger.Trace(\"Guard\", \"NotNull\", \"Parameter validation passed\")\r\n    }\r\n    \r\n    # Throw if null or empty string\r\n    static [void] NotNullOrEmpty([string]$value, [string]$paramName) {\r\n        $logger = [Guard]::GetLogger()\r\n        $logger.Trace(\"Guard\", \"NotNullOrEmpty\", \"Validating string parameter\", @{\r\n            ParamName = $paramName\r\n            IsNullOrEmpty = [string]::IsNullOrEmpty($value)\r\n        })\r\n        \r\n        if ([string]::IsNullOrEmpty($value)) {\r\n            $caller = (Get-PSCallStack)[1]\r\n            $errorMsg = \"Parameter '$paramName' cannot be null or empty. Called from: $($caller.Command) at line $($caller.ScriptLineNumber)\"\r\n            \r\n            $logger.Error(\"Guard\", \"NotNullOrEmpty\", \"String validation failed\", @{\r\n                ParamName = $paramName\r\n                Caller = $caller.Command\r\n                LineNumber = $caller.ScriptLineNumber\r\n            })\r\n            \r\n            throw [System.ArgumentException]::new($errorMsg, $paramName)\r\n        }\r\n        \r\n        $logger.Trace(\"Guard\", \"NotNullOrEmpty\", \"String validation passed\")\r\n    }\r\n    \r\n    # Throw if null or whitespace\r\n    static [void] NotNullOrWhiteSpace([string]$value, [string]$paramName) {\r\n        $logger = [Guard]::GetLogger()\r\n        $logger.Trace(\"Guard\", \"NotNullOrWhiteSpace\", \"Validating whitespace parameter\", @{\r\n            ParamName = $paramName\r\n            IsNullOrWhiteSpace = [string]::IsNullOrWhiteSpace($value)\r\n        })\r\n        \r\n        if ([string]::IsNullOrWhiteSpace($value)) {\r\n            $caller = (Get-PSCallStack)[1]\r\n            $errorMsg = \"Parameter '$paramName' cannot be null, empty, or whitespace. Called from: $($caller.Command) at line $($caller.ScriptLineNumber)\"\r\n            \r\n            $logger.Error(\"Guard\", \"NotNullOrWhiteSpace\", \"Whitespace validation failed\", @{\r\n                ParamName = $paramName\r\n                Caller = $caller.Command\r\n                LineNumber = $caller.ScriptLineNumber\r\n            })\r\n            \r\n            throw [System.ArgumentException]::new($errorMsg, $paramName)\r\n        }\r\n        \r\n        $logger.Trace(\"Guard\", \"NotNullOrWhiteSpace\", \"Whitespace validation passed\")\r\n    }\r\n    \r\n    # Validate array not null or empty\r\n    static [void] NotNullOrEmptyArray([array]$value, [string]$paramName) {\r\n        $logger = [Guard]::GetLogger()\r\n        $isNullOrEmpty = $null -eq $value -or $value.Count -eq 0\r\n        \r\n        $logger.Trace(\"Guard\", \"NotNullOrEmptyArray\", \"Validating array parameter\", @{\r\n            ParamName = $paramName\r\n            IsNull = $null -eq $value\r\n            Count = $(if ($null -ne $value) { $value.Count } else { 0 })\r\n            IsNullOrEmpty = $isNullOrEmpty\r\n        })\r\n        \r\n        if ($isNullOrEmpty) {\r\n            $caller = (Get-PSCallStack)[1]\r\n            $errorMsg = \"Parameter '$paramName' cannot be null or empty array. Called from: $($caller.Command) at line $($caller.ScriptLineNumber)\"\r\n            \r\n            $logger.Error(\"Guard\", \"NotNullOrEmptyArray\", \"Array validation failed\", @{\r\n                ParamName = $paramName\r\n                Caller = $caller.Command\r\n                LineNumber = $caller.ScriptLineNumber\r\n            })\r\n            \r\n            throw [System.ArgumentException]::new($errorMsg, $paramName)\r\n        }\r\n        \r\n        $logger.Trace(\"Guard\", \"NotNullOrEmptyArray\", \"Array validation passed\")\r\n    }\r\n    \r\n    # Validate numeric range\r\n    static [void] InRange([int]$value, [int]$min, [int]$max, [string]$paramName) {\r\n        $logger = [Guard]::GetLogger()\r\n        $inRange = $value -ge $min -and $value -le $max\r\n        \r\n        $logger.Trace(\"Guard\", \"InRange\", \"Validating range parameter\", @{\r\n            ParamName = $paramName\r\n            Value = $value\r\n            Min = $min\r\n            Max = $max\r\n            InRange = $inRange\r\n        })\r\n        \r\n        if (-not $inRange) {\r\n            $caller = (Get-PSCallStack)[1]\r\n            $errorMsg = \"Parameter '$paramName' must be between $min and $max. Got: $value. Called from: $($caller.Command) at line $($caller.ScriptLineNumber)\"\r\n            \r\n            $logger.Error(\"Guard\", \"InRange\", \"Range validation failed\", @{\r\n                ParamName = $paramName\r\n                Value = $value\r\n                Min = $min\r\n                Max = $max\r\n                Caller = $caller.Command\r\n                LineNumber = $caller.ScriptLineNumber\r\n            })\r\n            \r\n            throw [System.ArgumentOutOfRangeException]::new($paramName, $value, $errorMsg)\r\n        }\r\n        \r\n        $logger.Trace(\"Guard\", \"InRange\", \"Range validation passed\")\r\n    }\r\n    \r\n    # Validate positive number\r\n    static [void] Positive([int]$value, [string]$paramName) {\r\n        $logger = [Guard]::GetLogger()\r\n        $isPositive = $value -gt 0\r\n        \r\n        $logger.Trace(\"Guard\", \"Positive\", \"Validating positive parameter\", @{\r\n            ParamName = $paramName\r\n            Value = $value\r\n            IsPositive = $isPositive\r\n        })\r\n        \r\n        if (-not $isPositive) {\r\n            $caller = (Get-PSCallStack)[1]\r\n            $errorMsg = \"Parameter '$paramName' must be positive. Got: $value. Called from: $($caller.Command) at line $($caller.ScriptLineNumber)\"\r\n            \r\n            $logger.Error(\"Guard\", \"Positive\", \"Positive validation failed\", @{\r\n                ParamName = $paramName\r\n                Value = $value\r\n                Caller = $caller.Command\r\n                LineNumber = $caller.ScriptLineNumber\r\n            })\r\n            \r\n            throw [System.ArgumentOutOfRangeException]::new($paramName, $value, $errorMsg)\r\n        }\r\n        \r\n        $logger.Trace(\"Guard\", \"Positive\", \"Positive validation passed\")\r\n    }\r\n    \r\n    # Validate non-negative number\r\n    static [void] NonNegative([int]$value, [string]$paramName) {\r\n        $logger = [Guard]::GetLogger()\r\n        $isNonNegative = $value -ge 0\r\n        \r\n        $logger.Trace(\"Guard\", \"NonNegative\", \"Validating non-negative parameter\", @{\r\n            ParamName = $paramName\r\n            Value = $value\r\n            IsNonNegative = $isNonNegative\r\n        })\r\n        \r\n        if (-not $isNonNegative) {\r\n            $caller = (Get-PSCallStack)[1]\r\n            $errorMsg = \"Parameter '$paramName' must be non-negative. Got: $value. Called from: $($caller.Command) at line $($caller.ScriptLineNumber)\"\r\n            \r\n            $logger.Error(\"Guard\", \"NonNegative\", \"Non-negative validation failed\", @{\r\n                ParamName = $paramName\r\n                Value = $value\r\n                Caller = $caller.Command\r\n                LineNumber = $caller.ScriptLineNumber\r\n            })\r\n            \r\n            throw [System.ArgumentOutOfRangeException]::new($paramName, $value, $errorMsg)\r\n        }\r\n        \r\n        $logger.Trace(\"Guard\", \"NonNegative\", \"Non-negative validation passed\")\r\n    }\r\n    \r\n    # Type validation\r\n    static [void] IsType([object]$value, [Type]$expectedType, [string]$paramName) {\r\n        $logger = [Guard]::GetLogger()\r\n        \r\n        $logger.Trace(\"Guard\", \"IsType\", \"Validating type parameter\", @{\r\n            ParamName = $paramName\r\n            ExpectedType = $expectedType.Name\r\n            ActualType = $(if ($null -ne $value) { $value.GetType().Name } else { \"null\" })\r\n        })\r\n        \r\n        try {\r\n            if ($null -eq $value) {\r\n                [Guard]::NotNull($value, $paramName)\r\n            }\r\n            \r\n            $actualType = $value.GetType()\r\n            $isCorrectType = $actualType -eq $expectedType -or $actualType.IsSubclassOf($expectedType)\r\n            \r\n            if (-not $isCorrectType) {\r\n                $caller = (Get-PSCallStack)[1]\r\n                $errorMsg = \"Parameter '$paramName' must be of type '$($expectedType.Name)'. Got: '$($actualType.Name)'. Called from: $($caller.Command) at line $($caller.ScriptLineNumber)\"\r\n                \r\n                $logger.Error(\"Guard\", \"IsType\", \"Type validation failed\", @{\r\n                    ParamName = $paramName\r\n                    ExpectedType = $expectedType.Name\r\n                    ActualType = $actualType.Name\r\n                    Caller = $caller.Command\r\n                    LineNumber = $caller.ScriptLineNumber\r\n                })\r\n                \r\n                throw [System.ArgumentException]::new($errorMsg, $paramName)\r\n            }\r\n            \r\n            $logger.Trace(\"Guard\", \"IsType\", \"Type validation passed\")\r\n        } catch {\r\n            $logger.Error(\"Guard\", \"IsType\", \"Type validation error\", @{\r\n                ParamName = $paramName\r\n                Exception = $_.Exception.Message\r\n            })\r\n            throw\r\n        }\r\n    }\r\n    \r\n    # Collection contains validation\r\n    static [void] Contains([System.Collections.IEnumerable]$collection, [object]$item, [string]$message) {\r\n        $logger = [Guard]::GetLogger()\r\n        \r\n        $logger.Trace(\"Guard\", \"Contains\", \"Validating collection contains item\", @{\r\n            HasCollection = $null -ne $collection\r\n            Item = $(if ($null -ne $item) { $item.ToString() } else { \"null\" })\r\n            Message = $message\r\n        })\r\n        \r\n        try {\r\n            [Guard]::NotNull($collection, \"collection\")\r\n            \r\n            $found = $false\r\n            $elementCount = 0\r\n            foreach ($element in $collection) {\r\n                $elementCount++\r\n                if ($element -eq $item) {\r\n                    $found = $true\r\n                    $logger.Debug(\"Guard\", \"Contains\", \"Item found in collection\", @{\r\n                        Item = $item\r\n                        Position = $elementCount\r\n                    })\r\n                    break\r\n                }\r\n            }\r\n            \r\n            if (-not $found) {\r\n                $caller = (Get-PSCallStack)[1]\r\n                $msg = $(if ($message) { $message } else { \"Collection does not contain required item: $item\" })\r\n                $errorMsg = \"$msg. Called from: $($caller.Command) at line $($caller.ScriptLineNumber)\"\r\n                \r\n                $logger.Error(\"Guard\", \"Contains\", \"Collection validation failed\", @{\r\n                    Item = $item\r\n                    CollectionSize = $elementCount\r\n                    Message = $message\r\n                    Caller = $caller.Command\r\n                    LineNumber = $caller.ScriptLineNumber\r\n                })\r\n                \r\n                throw [System.ArgumentException]::new($errorMsg)\r\n            }\r\n            \r\n            $logger.Trace(\"Guard\", \"Contains\", \"Collection validation passed\")\r\n        } catch {\r\n            $logger.Error(\"Guard\", \"Contains\", \"Collection validation error\", @{\r\n                Exception = $_.Exception.Message\r\n            })\r\n            throw\r\n        }\r\n    }\r\n    \r\n    # Custom condition validation\r\n    static [void] Condition([bool]$condition, [string]$message) {\r\n        $logger = [Guard]::GetLogger()\r\n        \r\n        $logger.Trace(\"Guard\", \"Condition\", \"Validating custom condition\", @{\r\n            Condition = $condition\r\n            Message = $message\r\n        })\r\n        \r\n        if (-not $condition) {\r\n            $caller = (Get-PSCallStack)[1]\r\n            $errorMsg = \"$message. Called from: $($caller.Command) at line $($caller.ScriptLineNumber)\"\r\n            \r\n            $logger.Error(\"Guard\", \"Condition\", \"Condition validation failed\", @{\r\n                Condition = $condition\r\n                Message = $message\r\n                Caller = $caller.Command\r\n                LineNumber = $caller.ScriptLineNumber\r\n            })\r\n            \r\n            throw [System.InvalidOperationException]::new($errorMsg)\r\n        }\r\n        \r\n        $logger.Trace(\"Guard\", \"Condition\", \"Condition validation passed\")\r\n    }\r\n}\r\n\r\n# Safe navigation helpers\r\nclass Safe {\r\n    static hidden [object]$_logger = $null\r\n    \r\n    static [object] GetLogger() {\r\n        if ($null -eq [Safe]::_logger) {\r\n            [Safe]::_logger = Get-Logger\r\n        }\r\n        return [Safe]::_logger\r\n    }\r\n    # Get property value safely\r\n    static [object] GetProperty([object]$obj, [string]$propertyName, [object]$defaultValue) {\r\n        $logger = [Safe]::GetLogger()\r\n        \r\n        $logger.Trace(\"Safe\", \"GetProperty\", \"Getting property safely\", @{\r\n            HasObject = $null -ne $obj\r\n            ObjectType = $(if ($null -ne $obj) { $obj.GetType().Name } else { \"null\" })\r\n            PropertyName = $propertyName\r\n            HasDefaultValue = $null -ne $defaultValue\r\n        })\r\n        \r\n        try {\r\n            if ($null -eq $obj) { \r\n                $logger.Debug(\"Safe\", \"GetProperty\", \"Object is null, returning default\")\r\n                return $defaultValue \r\n            }\r\n            if ([string]::IsNullOrEmpty($propertyName)) { \r\n                $logger.Debug(\"Safe\", \"GetProperty\", \"Property name is null/empty, returning default\")\r\n                return $defaultValue \r\n            }\r\n            \r\n            $value = $obj.$propertyName\r\n            $result = $(if ($null -ne $value) { $value } else { $defaultValue })\r\n            \r\n            $logger.Debug(\"Safe\", \"GetProperty\", \"Property retrieved successfully\", @{\r\n                PropertyName = $propertyName\r\n                HasValue = $null -ne $value\r\n                UsingDefault = $null -eq $value\r\n            })\r\n            \r\n            return $result\r\n        } catch {\r\n            $logger.Warn(\"Safe\", \"GetProperty\", \"Failed to get property, returning default\", @{\r\n                PropertyName = $propertyName\r\n                Exception = $_.Exception.Message\r\n            })\r\n            return $defaultValue\r\n        }\r\n    }\r\n    \r\n    # Invoke method safely\r\n    static [object] InvokeMethod([object]$obj, [string]$methodName, [object[]]$args) {\r\n        $logger = [Safe]::GetLogger()\r\n        \r\n        $logger.Trace(\"Safe\", \"InvokeMethod\", \"Invoking method safely\", @{\r\n            HasObject = $null -ne $obj\r\n            ObjectType = $(if ($null -ne $obj) { $obj.GetType().Name } else { \"null\" })\r\n            MethodName = $methodName\r\n            ArgCount = $(if ($null -ne $args) { $args.Count } else { 0 })\r\n        })\r\n        \r\n        try {\r\n            if ($null -eq $obj) { \r\n                $logger.Debug(\"Safe\", \"InvokeMethod\", \"Object is null, returning null\")\r\n                return $null \r\n            }\r\n            if ([string]::IsNullOrEmpty($methodName)) { \r\n                $logger.Debug(\"Safe\", \"InvokeMethod\", \"Method name is null/empty, returning null\")\r\n                return $null \r\n            }\r\n            \r\n            $result = $obj.$methodName.Invoke($args)\r\n            \r\n            $logger.Debug(\"Safe\", \"InvokeMethod\", \"Method invoked successfully\", @{\r\n                MethodName = $methodName\r\n                HasResult = $null -ne $result\r\n            })\r\n            \r\n            return $result\r\n        } catch {\r\n            $logger.Error(\"Safe\", \"InvokeMethod\", \"Failed to invoke method '$methodName'\", @{\r\n                ObjectType = $(if ($null -ne $obj) { $obj.GetType().Name } else { \"null\" })\r\n                Method = $methodName\r\n                Exception = $_.Exception.Message\r\n                StackTrace = $_.ScriptStackTrace\r\n            })\r\n            return $null\r\n        }\r\n    }\r\n    \r\n    # Execute scriptblock safely\r\n    static [object] Execute([scriptblock]$scriptBlock, [object]$defaultValue) {\r\n        $logger = [Safe]::GetLogger()\r\n        \r\n        $logger.Trace(\"Safe\", \"Execute\", \"Executing scriptblock safely\", @{\r\n            HasScriptBlock = $null -ne $scriptBlock\r\n            HasDefaultValue = $null -ne $defaultValue\r\n        })\r\n        \r\n        try {\r\n            if ($null -eq $scriptBlock) { \r\n                $logger.Debug(\"Safe\", \"Execute\", \"ScriptBlock is null, returning default\")\r\n                return $defaultValue \r\n            }\r\n            \r\n            $result = & $scriptBlock\r\n            $finalResult = $(if ($null -ne $result) { $result } else { $defaultValue })\r\n            \r\n            $logger.Debug(\"Safe\", \"Execute\", \"ScriptBlock executed successfully\", @{\r\n                HasResult = $null -ne $result\r\n                UsingDefault = $null -eq $result\r\n            })\r\n            \r\n            return $finalResult\r\n        } catch {\r\n            $logger.Error(\"Safe\", \"Execute\", \"Failed to execute scriptblock\", @{\r\n                Exception = $_.Exception.Message\r\n                StackTrace = $_.ScriptStackTrace\r\n            })\r\n            return $defaultValue\r\n        }\r\n    }\r\n    \r\n    # Try parse with default\r\n    static [int] ParseInt([string]$value, [int]$defaultValue) {\r\n        $logger = [Safe]::GetLogger()\r\n        \r\n        $logger.Trace(\"Safe\", \"ParseInt\", \"Parsing integer safely\", @{\r\n            Value = $value\r\n            DefaultValue = $defaultValue\r\n            IsNullOrWhiteSpace = [string]::IsNullOrWhiteSpace($value)\r\n        })\r\n        \r\n        try {\r\n            if ([string]::IsNullOrWhiteSpace($value)) { \r\n                $logger.Debug(\"Safe\", \"ParseInt\", \"Value is null/whitespace, returning default\")\r\n                return $defaultValue \r\n            }\r\n            \r\n            $result = 0\r\n            if ([int]::TryParse($value, [ref]$result)) {\r\n                $logger.Debug(\"Safe\", \"ParseInt\", \"Parse successful\", @{\r\n                    Value = $value\r\n                    Result = $result\r\n                })\r\n                return $result\r\n            }\r\n            \r\n            $logger.Debug(\"Safe\", \"ParseInt\", \"Parse failed, returning default\", @{\r\n                Value = $value\r\n                DefaultValue = $defaultValue\r\n            })\r\n            return $defaultValue\r\n        } catch {\r\n            $logger.Error(\"Safe\", \"ParseInt\", \"Parse operation failed\", @{\r\n                Value = $value\r\n                Exception = $_.Exception.Message\r\n            })\r\n            return $defaultValue\r\n        }\r\n    }\r\n    \r\n    # Safe array access\r\n    static [object] GetArrayElement([array]$array, [int]$index, [object]$defaultValue) {\r\n        $logger = [Safe]::GetLogger()\r\n        \r\n        $logger.Trace(\"Safe\", \"GetArrayElement\", \"Getting array element safely\", @{\r\n            HasArray = $null -ne $array\r\n            ArrayCount = $(if ($null -ne $array) { $array.Count } else { 0 })\r\n            Index = $index\r\n            HasDefaultValue = $null -ne $defaultValue\r\n        })\r\n        \r\n        try {\r\n            $isValidAccess = $null -ne $array -and $index -ge 0 -and $index -lt $array.Count\r\n            \r\n            if (-not $isValidAccess) {\r\n                $logger.Debug(\"Safe\", \"GetArrayElement\", \"Invalid array access, returning default\", @{\r\n                    HasArray = $null -ne $array\r\n                    Index = $index\r\n                    ArrayCount = $(if ($null -ne $array) { $array.Count } else { 0 })\r\n                    Reason = $(if ($null -eq $array) { \"ArrayIsNull\" } elseif ($index -lt 0) { \"IndexNegative\" } else { \"IndexOutOfBounds\" })\r\n                })\r\n                return $defaultValue\r\n            }\r\n            \r\n            $result = $array[$index]\r\n            \r\n            $logger.Debug(\"Safe\", \"GetArrayElement\", \"Array element retrieved successfully\", @{\r\n                Index = $index\r\n                HasResult = $null -ne $result\r\n            })\r\n            \r\n            return $result\r\n        } catch {\r\n            $logger.Error(\"Safe\", \"GetArrayElement\", \"Array access failed\", @{\r\n                Index = $index\r\n                Exception = $_.Exception.Message\r\n            })\r\n            return $defaultValue\r\n        }\r\n    }\r\n    \r\n    # Safe dictionary access\r\n    static [object] GetDictionaryValue([hashtable]$dict, [string]$key, [object]$defaultValue) {\r\n        $logger = [Safe]::GetLogger()\r\n        \r\n        $logger.Trace(\"Safe\", \"GetDictionaryValue\", \"Getting dictionary value safely\", @{\r\n            HasDict = $null -ne $dict\r\n            DictCount = $(if ($null -ne $dict) { $dict.Count } else { 0 })\r\n            Key = $key\r\n            HasDefaultValue = $null -ne $defaultValue\r\n        })\r\n        \r\n        try {\r\n            if ($null -eq $dict -or [string]::IsNullOrEmpty($key)) {\r\n                $logger.Debug(\"Safe\", \"GetDictionaryValue\", \"Invalid dictionary access, returning default\", @{\r\n                    HasDict = $null -ne $dict\r\n                    Key = $key\r\n                    Reason = $(if ($null -eq $dict) { \"DictIsNull\" } else { \"KeyNullOrEmpty\" })\r\n                })\r\n                return $defaultValue\r\n            }\r\n            \r\n            if ($dict.ContainsKey($key)) {\r\n                $result = $dict[$key]\r\n                \r\n                $logger.Debug(\"Safe\", \"GetDictionaryValue\", \"Dictionary value found\", @{\r\n                    Key = $key\r\n                    HasResult = $null -ne $result\r\n                })\r\n                \r\n                return $result\r\n            }\r\n            \r\n            $logger.Debug(\"Safe\", \"GetDictionaryValue\", \"Key not found, returning default\", @{\r\n                Key = $key\r\n                DictKeys = ($dict.Keys -join \", \")\r\n            })\r\n            \r\n            return $defaultValue\r\n        } catch {\r\n            $logger.Error(\"Safe\", \"GetDictionaryValue\", \"Dictionary access failed\", @{\r\n                Key = $key\r\n                Exception = $_.Exception.Message\r\n            })\r\n            return $defaultValue\r\n        }\r\n    }\r\n}\r\n\r\n# Result type for operations that can fail\r\nclass Result {\r\n    [bool]$Success\r\n    [object]$Value\r\n    [string]$Error\r\n    hidden [object]$_logger\r\n    \r\n    hidden Result([bool]$success, [object]$value, [string]$error) {\r\n        $this._logger = Get-Logger\r\n        $this.Success = $success\r\n        $this.Value = $value\r\n        $this.Error = $error\r\n        \r\n        $this._logger.Trace(\"Result\", \"Constructor\", \"Result created\", @{\r\n            Success = $success\r\n            HasValue = $null -ne $value\r\n            HasError = -not [string]::IsNullOrEmpty($error)\r\n        })\r\n    }\r\n    \r\n    static [Result] Ok([object]$value) {\r\n        $logger = Get-Logger\r\n        $logger.Trace(\"Result\", \"Ok\", \"Creating success result\", @{\r\n            HasValue = $null -ne $value\r\n            ValueType = $(if ($null -ne $value) { $value.GetType().Name } else { \"null\" })\r\n        })\r\n        \r\n        return [Result]::new($true, $value, $null)\r\n    }\r\n    \r\n    static [Result] Fail([string]$error) {\r\n        $logger = Get-Logger\r\n        $logger.Trace(\"Result\", \"Fail\", \"Creating failure result\", @{\r\n            Error = $error\r\n            HasError = -not [string]::IsNullOrEmpty($error)\r\n        })\r\n        \r\n        return [Result]::new($false, $null, $error)\r\n    }\r\n    \r\n    [bool] IsOk() { \r\n        $this._logger.Trace(\"Result\", \"IsOk\", \"Checking if result is success\", @{\r\n            Success = $this.Success\r\n        })\r\n        return $this.Success \r\n    }\r\n    \r\n    [bool] IsFail() { \r\n        $this._logger.Trace(\"Result\", \"IsFail\", \"Checking if result is failure\", @{\r\n            Success = $this.Success\r\n            IsFail = -not $this.Success\r\n        })\r\n        return -not $this.Success \r\n    }\r\n}"}, {"path": "lib/SpeedTUI/Core/PerformanceMonitor.ps1", "content": "# SpeedTUI Performance Monitor - Real-time performance tracking and metrics\r\n\r\nusing namespace System.Diagnostics\r\nusing namespace System.Collections.Concurrent\r\n\r\nclass PerformanceMetric {\r\n    [string]$Name\r\n    [DateTime]$Timestamp\r\n    [double]$Value\r\n    [string]$Unit\r\n    [hashtable]$Tags\r\n    \r\n    PerformanceMetric([string]$name, [double]$value, [string]$unit = \"\", [hashtable]$tags = @{}) {\r\n        $this.Name = $name\r\n        $this.Timestamp = [DateTime]::Now\r\n        $this.Value = $value\r\n        $this.Unit = $unit\r\n        $this.Tags = $tags\r\n    }\r\n    \r\n    [string] ToString() {\r\n        $tagStr = $(if ($this.Tags.Count -gt 0) {\r\n            \" (\" + ($this.Tags.GetEnumerator() | ForEach-Object { \"$($_.Key)=$($_.Value)\" }) -join \", \" + \")\"\r\n        } else { \"\" })\r\n        \r\n        return \"$($this.Timestamp.ToString('HH:mm:ss.fff')) $($this.Name): $($this.Value)$($this.Unit)$tagStr\"\r\n    }\r\n}\r\n\r\nclass TimingContext {\r\n    [string]$Operation\r\n    [Stopwatch]$Stopwatch\r\n    [hashtable]$Tags\r\n    [DateTime]$StartTime\r\n    \r\n    TimingContext([string]$operation, [hashtable]$tags = @{}) {\r\n        $this.Operation = $operation\r\n        $this.Tags = $tags\r\n        $this.StartTime = [DateTime]::Now\r\n        $this.Stopwatch = [Stopwatch]::StartNew()\r\n    }\r\n    \r\n    [void] Stop() {\r\n        $this.Stopwatch.Stop()\r\n    }\r\n    \r\n    [double] GetElapsedMilliseconds() {\r\n        return $this.Stopwatch.ElapsedMilliseconds\r\n    }\r\n}\r\n\r\nclass PerformanceMonitor {\r\n    [ConcurrentQueue[PerformanceMetric]]$Metrics\r\n    [ConcurrentDictionary[string, object]]$Counters\r\n    [bool]$Enabled = $true\r\n    [int]$MaxMetrics = 10000\r\n    [string]$LogFile\r\n    [object]$Logger\r\n    \r\n    static [PerformanceMonitor]$Instance\r\n    \r\n    PerformanceMonitor() {\r\n        $this.Metrics = [ConcurrentQueue[PerformanceMetric]]::new()\r\n        $this.Counters = [ConcurrentDictionary[string, object]]::new()\r\n        $this.LogFile = \"Logs/performance_$(Get-Date -Format 'yyyyMMdd').log\"\r\n        \r\n        # Ensure logs directory exists\r\n        $logsDir = Split-Path $this.LogFile -Parent\r\n        if (-not (Test-Path $logsDir)) {\r\n            New-Item -Path $logsDir -ItemType Directory -Force | Out-Null\r\n        }\r\n    }\r\n    \r\n    static [PerformanceMonitor] GetInstance() {\r\n        if (-not [PerformanceMonitor]::Instance) {\r\n            [PerformanceMonitor]::Instance = [PerformanceMonitor]::new()\r\n        }\r\n        return [PerformanceMonitor]::Instance\r\n    }\r\n    \r\n    [void] SetLogger([object]$logger) {\r\n        $this.Logger = $logger\r\n    }\r\n    \r\n    [void] RecordMetric([string]$name, [double]$value, [string]$unit = \"\", [hashtable]$tags = @{}) {\r\n        if (-not $this.Enabled) { return }\r\n        \r\n        $metric = [PerformanceMetric]::new($name, $value, $unit, $tags)\r\n        $this.Metrics.Enqueue($metric)\r\n        \r\n        # Maintain max metrics limit\r\n        while ($this.Metrics.Count -gt $this.MaxMetrics) {\r\n            $null = $this.Metrics.TryDequeue([ref]$null)\r\n        }\r\n        \r\n        # Log to file and logger if available\r\n        $this.LogMetric($metric)\r\n    }\r\n    \r\n    [TimingContext] StartTiming([string]$operation, [hashtable]$tags = @{}) {\r\n        return [TimingContext]::new($operation, $tags)\r\n    }\r\n    \r\n    [void] EndTiming([TimingContext]$context) {\r\n        if (-not $this.Enabled) { return }\r\n        \r\n        $context.Stop()\r\n        $elapsed = $context.GetElapsedMilliseconds()\r\n        \r\n        $this.RecordMetric(\r\n            \"timing.$($context.Operation)\", \r\n            $elapsed, \r\n            \"ms\", \r\n            $context.Tags\r\n        )\r\n    }\r\n    \r\n    [void] IncrementCounter([string]$name, [hashtable]$tags = @{}) {\r\n        if (-not $this.Enabled) { return }\r\n        \r\n        $key = $name\r\n        if ($tags.Count -gt 0) {\r\n            $tagStr = ($tags.GetEnumerator() | Sort-Object Key | ForEach-Object { \"$($_.Key)=$($_.Value)\" }) -join \",\"\r\n            $key = \"$name[$tagStr]\"\r\n        }\r\n        \r\n        $newValue = $this.Counters.AddOrUpdate($key, 1, { param($k, $v) $v + 1 })\r\n        $this.RecordMetric(\"counter.$name\", $newValue, \"count\", $tags)\r\n    }\r\n    \r\n    [void] SetGauge([string]$name, [double]$value, [hashtable]$tags = @{}) {\r\n        if (-not $this.Enabled) { return }\r\n        \r\n        $this.RecordMetric(\"gauge.$name\", $value, \"\", $tags)\r\n    }\r\n    \r\n    [void] RecordSystemMetrics() {\r\n        if (-not $this.Enabled) { return }\r\n        \r\n        try {\r\n            # Memory metrics\r\n            $processId = [System.Diagnostics.Process]::GetCurrentDoProcess().Id\r\n            $currentProcess = Get-Process -Id $processId\r\n            $this.SetGauge(\"system.memory.working_set\", $currentProcess.WorkingSet64 / 1MB, @{unit=\"MB\"})\r\n            $this.SetGauge(\"system.memory.private\", $currentProcess.PrivateMemorySize64 / 1MB, @{unit=\"MB\"})\r\n            \r\n            # CPU metrics\r\n            $this.SetGauge(\"system.cpu.time\", $currentProcess.TotalProcessorTime.TotalMilliseconds, @{unit=\"ms\"})\r\n            \r\n            # Thread metrics\r\n            $this.SetGauge(\"system.threads\", $currentProcess.Threads.Count, @{unit=\"count\"})\r\n            \r\n            # Handle metrics\r\n            $this.SetGauge(\"system.handles\", $currentProcess.HandleCount, @{unit=\"count\"})\r\n            \r\n            # GC metrics\r\n            $gen0 = [GC]::CollectionCount(0)\r\n            $gen1 = [GC]::CollectionCount(1)\r\n            $gen2 = [GC]::CollectionCount(2)\r\n            $totalMemory = [GC]::GetTotalMemory($false) / 1MB\r\n            \r\n            $this.SetGauge(\"system.gc.gen0\", $gen0, @{unit=\"count\"})\r\n            $this.SetGauge(\"system.gc.gen1\", $gen1, @{unit=\"count\"})\r\n            $this.SetGauge(\"system.gc.gen2\", $gen2, @{unit=\"count\"})\r\n            $this.SetGauge(\"system.gc.total_memory\", $totalMemory, @{unit=\"MB\"})\r\n            \r\n        } catch {\r\n            if ($this.Logger) {\r\n                $this.Logger.Error(\"PerformanceMonitor\", \"RecordSystemMetrics\", \"Failed to record system metrics: $($_.Exception.Message)\")\r\n            }\r\n        }\r\n    }\r\n    \r\n    [PerformanceMetric[]] GetMetrics([int]$limit = 100) {\r\n        $resultMetrics = [System.Collections.Generic.List[PerformanceMetric]]::new()\r\n        $tempQueue = [ConcurrentQueue[PerformanceMetric]]::new()\r\n        \r\n        # Dequeue metrics up to limit\r\n        $count = 0\r\n        $currentMetric = $null\r\n        while ($count -lt $limit -and $this.Metrics.TryDequeue([ref]$currentMetric)) {\r\n            $resultMetrics.Add($currentMetric)\r\n            $tempQueue.Enqueue($currentMetric)\r\n            $count++\r\n        }\r\n        \r\n        # Put them back\r\n        while ($tempQueue.TryDequeue([ref]$currentMetric)) {\r\n            $this.Metrics.Enqueue($currentMetric)\r\n        }\r\n        \r\n        return $resultMetrics.ToArray()\r\n    }\r\n    \r\n    [PerformanceMetric[]] GetMetricsByName([string]$name, [int]$limit = 100) {\r\n        $allMetrics = $this.GetMetrics(1000)  # Get more to filter\r\n        $filtered = $allMetrics | Where-Object { $_.Name -like \"*$name*\" } | Select-Object -First $limit\r\n        return $filtered\r\n    }\r\n    \r\n    [hashtable] GetCounters() {\r\n        $result = @{}\r\n        foreach ($kvp in $this.Counters.GetEnumerator()) {\r\n            $result[$kvp.Key] = $kvp.Value\r\n        }\r\n        return $result\r\n    }\r\n    \r\n    [hashtable] GetSummaryStats([string]$metricName) {\r\n        $foundMetrics = $this.GetMetricsByName($metricName, 1000)\r\n        \r\n        if ($foundMetrics.Count -eq 0) {\r\n            return @{\r\n                Count = 0\r\n                Min = 0\r\n                Max = 0\r\n                Average = 0\r\n                Total = 0\r\n                Latest = 0\r\n                Oldest = 0\r\n            }\r\n        }\r\n        \r\n        $values = $foundMetrics | ForEach-Object { $_.Value }\r\n        \r\n        return @{\r\n            Count = $foundMetrics.Count\r\n            Min = ($values | Measure-Object -Minimum).Minimum\r\n            Max = ($values | Measure-Object -Maximum).Maximum\r\n            Average = ($values | Measure-Object -Average).Average\r\n            Total = ($values | Measure-Object -Sum).Sum\r\n            Latest = $foundMetrics[0].Value\r\n            Oldest = $foundMetrics[-1].Value\r\n        }\r\n    }\r\n    \r\n    [void] LogMetric([PerformanceMetric]$metric) {\r\n        try {\r\n            # Log to file\r\n            Add-Content -Path $this.LogFile -Value $metric.ToString() -ErrorAction SilentlyContinue\r\n            \r\n            # Log to logger if available\r\n            if ($this.Logger) {\r\n                $this.Logger.Debug(\"PerformanceMonitor\", \"Metric\", $metric.ToString())\r\n            }\r\n        } catch {\r\n            # Silently fail to avoid recursion issues\r\n        }\r\n    }\r\n    \r\n    [string] GenerateReport() {\r\n        $report = @()\r\n        $report += \"SpeedTUI Performance Report\"\r\n        $report += \"==========================\"\r\n        $report += \"Generated: $(Get-Date)\"\r\n        $report += \"\"\r\n        \r\n        # System metrics summary\r\n        $report += \"System Metrics:\"\r\n        $systemMetrics = $this.GetMetricsByName(\"system\", 50) | Group-Object Name\r\n        foreach ($group in $systemMetrics) {\r\n            $latest = $group.Group | Sort-Object Timestamp -Descending | Select-Object -First 1\r\n            $report += \"  $($group.Name): $($latest.Value)$($latest.Unit)\"\r\n        }\r\n        $report += \"\"\r\n        \r\n        # Timing summary\r\n        $report += \"Performance Timings:\"\r\n        $timingMetrics = $this.GetMetricsByName(\"timing\", 100) | Group-Object Name\r\n        foreach ($group in $timingMetrics) {\r\n            $stats = $this.GetSummaryStats($group.Name)\r\n            $report += \"  $($group.Name):\"\r\n            $report += \"    Count: $($stats.Count)\"\r\n            $report += \"    Average: $([Math]::Round($stats.Average, 2))ms\"\r\n            $report += \"    Min: $([Math]::Round($stats.Min, 2))ms\"\r\n            $report += \"    Max: $([Math]::Round($stats.Max, 2))ms\"\r\n        }\r\n        $report += \"\"\r\n        \r\n        # Counter summary\r\n        $report += \"Counters:\"\r\n        $allCounters = $this.GetCounters()\r\n        foreach ($counter in $allCounters.GetEnumerator() | Sort-Object Key) {\r\n            $report += \"  $($counter.Key): $($counter.Value)\"\r\n        }\r\n        \r\n        return $report -join \"`n\"\r\n    }\r\n    \r\n    [void] ClearMetrics() {\r\n        while ($this.Metrics.TryDequeue([ref]$null)) { }\r\n        $this.Counters.Clear()\r\n    }\r\n    \r\n    [void] Enable() {\r\n        $this.Enabled = $true\r\n        if ($this.Logger) {\r\n            $this.Logger.Info(\"PerformanceMonitor\", \"Enable\", \"Performance monitoring enabled\")\r\n        }\r\n    }\r\n    \r\n    [void] Disable() {\r\n        $this.Enabled = $false\r\n        if ($this.Logger) {\r\n            $this.Logger.Info(\"PerformanceMonitor\", \"Disable\", \"Performance monitoring disabled\")\r\n        }\r\n    }\r\n}\r\n\r\n# Global function for easy access\r\nfunction Get-PerformanceMonitor {\r\n    return [PerformanceMonitor]::GetInstance()\r\n}\r\n\r\n# Helper functions for common operations\r\nfunction Start-PerformanceTiming {\r\n    param(\r\n        [string]$Operation,\r\n        [hashtable]$Tags = @{}\r\n    )\r\n    \r\n    $monitor = Get-PerformanceMonitor\r\n    return $monitor.StartTiming($Operation, $Tags)\r\n}\r\n\r\nfunction Stop-PerformanceTiming {\r\n    param(\r\n        [TimingContext]$Context\r\n    )\r\n    \r\n    $monitor = Get-PerformanceMonitor\r\n    $monitor.EndTiming($Context)\r\n}\r\n\r\nfunction Record-PerformanceMetric {\r\n    param(\r\n        [string]$Name,\r\n        [double]$Value,\r\n        [string]$Unit = \"\",\r\n        [hashtable]$Tags = @{}\r\n    )\r\n    \r\n    $monitor = Get-PerformanceMonitor\r\n    $monitor.RecordMetric($Name, $Value, $Unit, $Tags)\r\n}\r\n\r\nfunction Increment-PerformanceCounter {\r\n    param(\r\n        [string]$Name,\r\n        [hashtable]$Tags = @{}\r\n    )\r\n    \r\n    $monitor = Get-PerformanceMonitor\r\n    $monitor.IncrementCounter($Name, $Tags)\r\n}\r\n\r\n# Auto-initialize global instance\r\n$global:SpeedTUIPerformanceMonitor = [PerformanceMonitor]::GetInstance()"}, {"path": "lib/SpeedTUI/Core/SimplifiedTerminal.ps1", "content": "# SpeedTUI Simplified Terminal - Minimal terminal control with Praxis-style performance\n# Strips out unnecessary complexity while keeping essential functionality\n\nusing namespace System.Text\n\n# Load performance optimizations\n. \"$PSScriptRoot/Internal/PerformanceCore.ps1\"\n\n<#\n.SYNOPSIS\nSimplified terminal class focused on performance\n\n.DESCRIPTION\nProvides minimal terminal control with:\n- Direct console output\n- No complex caching or batching\n- Simple position and color methods\n- No unnecessary overhead\n\n.EXAMPLE\n$terminal = [SimplifiedTerminal]::GetInstance()\n$terminal.Initialize()\n$terminal.WriteAt(10, 5, \"Hello World\")\n##CLOSEBRACKET##\nclass SimplifiedTerminal {\n    # Singleton instance\n    static [SimplifiedTerminal]$Instance = $null\n    \n    # Basic state\n    [int]$Width\n    [int]$Height\n    [bool]$CursorVisible = $true\n    \n    # Private constructor\n    hidden SimplifiedTerminal() {\n        $this.UpdateDimensions()\n    }\n    \n    # Get singleton instance\n    static [SimplifiedTerminal] GetInstance() {\n        if ($null -eq [SimplifiedTerminal]::Instance) {\n            [SimplifiedTerminal]::Instance = [SimplifiedTerminal]::new()\n        }\n        return [SimplifiedTerminal]::Instance\n    }\n    \n    # Initialize terminal\n    [void] Initialize() {\n        # Clear screen\n        [Console]::Clear()\n        \n        # Hide cursor\n        try {\n            [Console]::CursorVisible = $false\n            $this.CursorVisible = $false\n        } catch {\n            # Ignore cursor errors\n        }\n        \n        # Update dimensions\n        $this.UpdateDimensions()\n    }\n    \n    # Cleanup terminal\n    [void] Cleanup() {\n        # Restore cursor\n        try {\n            [Console]::CursorVisible = $true\n            $this.CursorVisible = $true\n        } catch {\n            # Ignore cursor errors\n        }\n        \n        # Clear screen\n        [Console]::Clear()\n    }\n    \n    # Update terminal dimensions\n    [void] UpdateDimensions() {\n        try {\n            $this.Width = [Console]::WindowWidth\n            $this.Height = [Console]::WindowHeight\n        } catch {\n            # Fallback dimensions\n            $this.Width = 80\n            $this.Height = 24\n        }\n    }\n    \n    # Clear screen\n    [void] Clear() {\n        [Console]::Clear()\n        [Console]::SetCursorPosition(0, 0)\n    }\n    \n    # Write at position\n    [void] WriteAt([int]$x, [int]$y, [string]$text) {\n        if ([string]::IsNullOrEmpty($text)) { return }\n        \n        # Bounds check\n        if ($x -lt 0 -or $y -lt 0 -or $x -ge $this.Width -or $y -ge $this.Height) {\n            return\n        }\n        \n        # Position and write\n        [Console]::SetCursorPosition($x, $y)\n        [Console]::Write($text)\n    }\n    \n    # Write with color\n    [void] WriteAtColor([int]$x, [int]$y, [string]$text, [string]$foreground, [string]$background = \"\") {\n        if ([string]::IsNullOrEmpty($text)) { return }\n        \n        # Bounds check\n        if ($x -lt 0 -or $y -lt 0 -or $x -ge $this.Width -or $y -ge $this.Height) {\n            return\n        }\n        \n        # Build colored text\n        $colored = $foreground\n        if (-not [string]::IsNullOrEmpty($background)) {\n            $colored += $background\n        }\n        $colored += $text + [InternalVT100]::Reset()\n        \n        # Position and write\n        [Console]::SetCursorPosition($x, $y)\n        [Console]::Write($colored)\n    }\n    \n    # Fill area with character\n    [void] FillArea([int]$x, [int]$y, [int]$width, [int]$height, [char]$ch) {\n        $line = [string]::new($ch, $width)\n        \n        for ($row = 0; $row -lt $height; $row++) {\n            $this.WriteAt($x, $y + $row, $line)\n        }\n    }\n    \n    # Set cursor position\n    [void] SetCursorPosition([int]$x, [int]$y) {\n        if ($x -ge 0 -and $y -ge 0 -and $x -lt $this.Width -and $y -lt $this.Height) {\n            [Console]::SetCursorPosition($x, $y)\n        }\n    }\n    \n    # Show/hide cursor\n    [void] ShowCursor([bool]$visible) {\n        try {\n            [Console]::CursorVisible = $visible\n            $this.CursorVisible = $visible\n        } catch {\n            # Ignore cursor errors\n        }\n    }\n}"}, {"path": "lib/SpeedTUI/Core/Internal/PerformanceCore.ps1", "content": "# SpeedTUI Performance Core - Hidden optimization layer\r\n# This file contains performance optimizations that are completely transparent to developers\r\n# Developers write normal PowerShell code, but it runs fast under the hood\r\n\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Collections.Concurrent\r\nusing namespace System.Text\r\n\r\n<#\r\n.SYNOPSIS\r\nInternal string caching system for maximum performance\r\n\r\n.DESCRIPTION\r\nThis class provides transparent caching of commonly used strings like spaces,\r\nANSI sequences, and box drawing characters. Developers never interact with this\r\ndirectly - it's used internally to optimize string operations.\r\n\r\n.EXAMPLE\r\n# Developer writes normal code:\r\n$spaces = \" \" * 50\r\n\r\n# But internally, it's cached for performance\r\n##CLOSEBRACKET##\r\nclass InternalStringCache {\r\n    # Pre-cached common strings\r\n    static [hashtable]$_spaces = @{}\r\n    static [hashtable]$_ansiSequences = @{}\r\n    static [hashtable]$_boxDrawing = @{}\r\n    static [int]$_maxCacheSize = 200\r\n    static [bool]$_initialized = $false\r\n    \r\n    # Initialize the cache with common strings\r\n    static [void] Initialize() {\r\n        if ([InternalStringCache]::_initialized) { return }\r\n        \r\n        # Pre-cache common space strings (1-200 characters)\r\n        for ($i = 1; $i -le [InternalStringCache]::_maxCacheSize; $i++) {\r\n            [InternalStringCache]::_spaces[$i] = \" \" * $i\r\n        }\r\n        \r\n        # Pre-cache common ANSI sequences\r\n        [InternalStringCache]::_ansiSequences[\"reset\"] = \"`e[0m\"\r\n        [InternalStringCache]::_ansiSequences[\"clear\"] = \"`e[2J\"\r\n        [InternalStringCache]::_ansiSequences[\"clearline\"] = \"`e[2K\"\r\n        [InternalStringCache]::_ansiSequences[\"home\"] = \"`e[H\"\r\n        [InternalStringCache]::_ansiSequences[\"hidecursor\"] = \"`e[?25l\"\r\n        [InternalStringCache]::_ansiSequences[\"showcursor\"] = \"`e[?25h\"\r\n        \r\n        # Pre-cache box drawing characters\r\n        [InternalStringCache]::_boxDrawing[\"horizontal\"] = \"─\"\r\n        [InternalStringCache]::_boxDrawing[\"vertical\"] = \"│\"\r\n        [InternalStringCache]::_boxDrawing[\"topleft\"] = \"┌\"\r\n        [InternalStringCache]::_boxDrawing[\"topright\"] = \"┐\"\r\n        [InternalStringCache]::_boxDrawing[\"bottomleft\"] = \"└\"\r\n        [InternalStringCache]::_boxDrawing[\"bottomright\"] = \"┘\"\r\n        \r\n        [InternalStringCache]::_initialized = $true\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get cached spaces string for optimal performance\r\n    \r\n    .DESCRIPTION\r\n    Returns a string of spaces of the specified length. Uses pre-cached strings\r\n    for common lengths (1-200) to avoid repeated string multiplication.\r\n    \r\n    .PARAMETER count\r\n    Number of spaces needed\r\n    \r\n    .OUTPUTS\r\n    String of spaces\r\n    ##CLOSEBRACKET##\r\n    static [string] GetSpaces([int]$count) {\r\n        if ($count -le 0) { return \"\" }\r\n        \r\n        if ($count -le [InternalStringCache]::_maxCacheSize) {\r\n            return [InternalStringCache]::_spaces[$count]\r\n        }\r\n        \r\n        # For very large strings, build dynamically\r\n        return \" \" * $count\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get cached ANSI sequence for optimal performance\r\n    \r\n    .PARAMETER sequenceName\r\n    Name of the ANSI sequence (reset, clear, clearline, etc.)\r\n    \r\n    .OUTPUTS\r\n    ANSI escape sequence string\r\n    ##CLOSEBRACKET##\r\n    static [string] GetAnsiSequence([string]$sequenceName) {\r\n        if ([InternalStringCache]::_ansiSequences.ContainsKey($sequenceName)) {\r\n            return [InternalStringCache]::_ansiSequences[$sequenceName]\r\n        }\r\n        return \"\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get cached box drawing character\r\n    \r\n    .PARAMETER characterName\r\n    Name of the box drawing character (horizontal, vertical, topleft, etc.)\r\n    \r\n    .OUTPUTS\r\n    Box drawing character string\r\n    ##CLOSEBRACKET##\r\n    static [string] GetBoxDrawing([string]$characterName) {\r\n        if ([InternalStringCache]::_boxDrawing.ContainsKey($characterName)) {\r\n            return [InternalStringCache]::_boxDrawing[$characterName]\r\n        }\r\n        return \"\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Cache a custom string for later retrieval\r\n    \r\n    .PARAMETER key\r\n    Unique key for the cached string\r\n    \r\n    .PARAMETER value\r\n    String value to cache\r\n    ##CLOSEBRACKET##\r\n    static [void] CacheCustomString([string]$key, [string]$value) {\r\n        if (-not [InternalStringCache]::_ansiSequences.ContainsKey($key)) {\r\n            [InternalStringCache]::_ansiSequences[$key] = $value\r\n        }\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nInternal StringBuilder pooling for memory efficiency\r\n\r\n.DESCRIPTION\r\nThis class manages a pool of StringBuilder objects to reduce memory allocation\r\nand garbage collection pressure. Developers never see this - it's used internally\r\nto optimize string building operations.\r\n\r\n.EXAMPLE\r\n# Developer writes normal code:\r\n$content = \"\"\r\n$content += \"Hello\"\r\n$content += \" World\"\r\n\r\n# But internally, StringBuilder pooling is used for performance\r\n##CLOSEBRACKET##\r\nclass InternalStringBuilderPool {\r\n    static [ConcurrentQueue[StringBuilder]]$_pool = [ConcurrentQueue[StringBuilder]]::new()\r\n    static [int]$_maxPoolSize = 50\r\n    static [int]$_maxCapacity = 32768  # 32KB max before discarding\r\n    static [int]$_created = 0\r\n    static [int]$_reused = 0\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get a StringBuilder from the pool or create a new one\r\n    \r\n    .OUTPUTS\r\n    StringBuilder instance ready for use\r\n    ##CLOSEBRACKET##\r\n    static [StringBuilder] Get() {\r\n        $sb = $null\r\n        if ([InternalStringBuilderPool]::_pool.TryDequeue([ref]$sb)) {\r\n            $sb.Clear()\r\n            [InternalStringBuilderPool]::_reused++\r\n        } else {\r\n            $sb = [StringBuilder]::new()\r\n            [InternalStringBuilderPool]::_created++\r\n        }\r\n        return $sb\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get a StringBuilder with specific initial capacity\r\n    \r\n    .PARAMETER initialCapacity\r\n    Initial capacity for the StringBuilder\r\n    \r\n    .OUTPUTS\r\n    StringBuilder instance with specified capacity\r\n    ##CLOSEBRACKET##\r\n    static [StringBuilder] Get([int]$initialCapacity) {\r\n        $sb = $null\r\n        if ([InternalStringBuilderPool]::_pool.TryDequeue([ref]$sb)) {\r\n            $sb.Clear()\r\n            if ($sb.Capacity -lt $initialCapacity) {\r\n                $sb.Capacity = $initialCapacity\r\n            }\r\n            [InternalStringBuilderPool]::_reused++\r\n        } else {\r\n            $sb = [StringBuilder]::new($initialCapacity)\r\n            [InternalStringBuilderPool]::_created++\r\n        }\r\n        return $sb\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Return a StringBuilder to the pool for reuse\r\n    \r\n    .PARAMETER sb\r\n    StringBuilder to return to the pool\r\n    ##CLOSEBRACKET##\r\n    static [void] Recycle([StringBuilder]$sb) {\r\n        if (-not $sb) { return }\r\n        \r\n        # Don't pool if too large (prevents memory bloat)\r\n        if ($sb.Capacity -gt [InternalStringBuilderPool]::_maxCapacity) {\r\n            return\r\n        }\r\n        \r\n        # Don't pool if we're at max capacity\r\n        if ([InternalStringBuilderPool]::_pool.Count -ge [InternalStringBuilderPool]::_maxPoolSize) {\r\n            return\r\n        }\r\n        \r\n        $sb.Clear()\r\n        [InternalStringBuilderPool]::_pool.Enqueue($sb)\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get pool statistics for monitoring and debugging\r\n    \r\n    .OUTPUTS\r\n    Hashtable with pool statistics\r\n    ##CLOSEBRACKET##\r\n    static [hashtable] GetStats() {\r\n        return @{\r\n            PoolSize = [InternalStringBuilderPool]::_pool.Count\r\n            MaxPoolSize = [InternalStringBuilderPool]::_maxPoolSize\r\n            Created = [InternalStringBuilderPool]::_created\r\n            Reused = [InternalStringBuilderPool]::_reused\r\n            ReuseRate = $(if ([InternalStringBuilderPool]::_created -eq 0) { 0 } else { \r\n                [Math]::Round(([InternalStringBuilderPool]::_reused / ([InternalStringBuilderPool]::_created + [InternalStringBuilderPool]::_reused)) * 100, 2)\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nInternal VT100/ANSI optimization layer\r\n\r\n.DESCRIPTION\r\nProvides optimized VT100/ANSI escape sequence generation with caching\r\nand true color support. All sequences are pre-computed for maximum performance.\r\n##CLOSEBRACKET##\r\nclass InternalVT100 {\r\n    # Color cache for RGB sequences\r\n    static [hashtable]$_colorCache = @{}\r\n    static [int]$_maxColorCache = 500\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Generate optimized cursor movement sequence\r\n    \r\n    .PARAMETER x\r\n    X coordinate (0-based)\r\n    \r\n    .PARAMETER y  \r\n    Y coordinate (0-based)\r\n    \r\n    .OUTPUTS\r\n    ANSI cursor movement sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] MoveTo([int]$x, [int]$y) {\r\n        # Convert to 1-based for ANSI (terminals use 1-based coordinates)\r\n        return \"`e[$($y + 1);$($x + 1)H\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Generate optimized RGB foreground color sequence\r\n    \r\n    .PARAMETER r\r\n    Red component (0-255)\r\n    \r\n    .PARAMETER g\r\n    Green component (0-255)\r\n    \r\n    .PARAMETER b\r\n    Blue component (0-255)\r\n    \r\n    .OUTPUTS\r\n    ANSI RGB foreground color sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] RGB([int]$r, [int]$g, [int]$b) {\r\n        $key = \"fg_${r}_${g}_${b}\"\r\n        \r\n        if ([InternalVT100]::_colorCache.ContainsKey($key)) {\r\n            return [InternalVT100]::_colorCache[$key]\r\n        }\r\n        \r\n        $sequence = \"`e[38;2;$r;$g;${b}m\"\r\n        \r\n        # Cache if we have room\r\n        if ([InternalVT100]::_colorCache.Count -lt [InternalVT100]::_maxColorCache) {\r\n            [InternalVT100]::_colorCache[$key] = $sequence\r\n        }\r\n        \r\n        return $sequence\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Generate optimized RGB background color sequence\r\n    \r\n    .PARAMETER r\r\n    Red component (0-255)\r\n    \r\n    .PARAMETER g\r\n    Green component (0-255)\r\n    \r\n    .PARAMETER b\r\n    Blue component (0-255)\r\n    \r\n    .OUTPUTS\r\n    ANSI RGB background color sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] BgRGB([int]$r, [int]$g, [int]$b) {\r\n        $key = \"bg_${r}_${g}_${b}\"\r\n        \r\n        if ([InternalVT100]::_colorCache.ContainsKey($key)) {\r\n            return [InternalVT100]::_colorCache[$key]\r\n        }\r\n        \r\n        $sequence = \"`e[48;2;$r;$g;${b}m\"\r\n        \r\n        # Cache if we have room\r\n        if ([InternalVT100]::_colorCache.Count -lt [InternalVT100]::_maxColorCache) {\r\n            [InternalVT100]::_colorCache[$key] = $sequence\r\n        }\r\n        \r\n        return $sequence\r\n    }\r\n    \r\n    # Alias for backward compatibility\r\n    static [string] RGBBackground([int]$r, [int]$g, [int]$b) {\r\n        return [InternalVT100]::BgRGB($r, $g, $b)\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get reset sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] Reset() {\r\n        return \"`e[0m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get default color sequence  \r\n    ##CLOSEBRACKET##\r\n    static [string] Default() {\r\n        return \"`e[39m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get bold style sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] Bold() {\r\n        return \"`e[1m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get underline style sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] Underline() {\r\n        return \"`e[4m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get blue color sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] Blue() {\r\n        return \"`e[34m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get cyan color sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] Cyan() {\r\n        return \"`e[36m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get green color sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] Green() {\r\n        return \"`e[32m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get yellow color sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] Yellow() {\r\n        return \"`e[33m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get red color sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] Red() {\r\n        return \"`e[31m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get white color sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] White() {\r\n        return \"`e[37m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get black background sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] BgBlack() {\r\n        return \"`e[40m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get white background sequence\r\n    ##CLOSEBRACKET##\r\n    static [string] BgWhite() {\r\n        return \"`e[47m\"\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get spaces string\r\n    ##CLOSEBRACKET##\r\n    static [string] GetSpaces([int]$count) {\r\n        return [InternalStringCache]::GetSpaces($count)\r\n    }\r\n    \r\n    <#\r\n    .SYNOPSIS\r\n    Get common ANSI sequences\r\n    \r\n    .OUTPUTS\r\n    Hashtable with common ANSI sequences\r\n    ##CLOSEBRACKET##\r\n    static [hashtable] GetCommonSequences() {\r\n        return @{\r\n            Reset = \"`e[0m\"\r\n            Clear = \"`e[2J\"\r\n            ClearLine = \"`e[2K\"\r\n            Home = \"`e[H\"\r\n            HideCursor = \"`e[?25l\"\r\n            ShowCursor = \"`e[?25h\"\r\n            Bold = \"`e[1m\"\r\n            Dim = \"`e[2m\"\r\n            Italic = \"`e[3m\"\r\n            Underline = \"`e[4m\"\r\n        }\r\n    }\r\n}\r\n\r\n# Auto-initialize the performance systems\r\n[InternalStringCache]::Initialize()\r\n\r\n<#\r\n.SYNOPSIS\r\nGlobal helper functions for performance optimization (Internal use only)\r\n\r\n.DESCRIPTION\r\nThese functions provide easy access to the performance optimization systems\r\nwhile maintaining a clean, simple interface for internal SpeedTUI code.\r\n##CLOSEBRACKET##\r\n\r\nfunction Get-OptimizedSpaces {\r\n    <#\r\n    .SYNOPSIS\r\n    Get optimized spaces string (Internal use only)\r\n    \r\n    .PARAMETER Count\r\n    Number of spaces needed\r\n    \r\n    .OUTPUTS\r\n    Optimized string of spaces\r\n    ##CLOSEBRACKET##\r\n    param([int]$Count)\r\n    return [InternalStringCache]::GetSpaces($Count)\r\n}\r\n\r\nfunction Get-PooledStringBuilder {\r\n    <#\r\n    .SYNOPSIS\r\n    Get a pooled StringBuilder for efficient string building (Internal use only)\r\n    \r\n    .PARAMETER InitialCapacity\r\n    Optional initial capacity for the StringBuilder\r\n    \r\n    .OUTPUTS\r\n    StringBuilder instance from the pool\r\n    ##CLOSEBRACKET##\r\n    param([int]$InitialCapacity = 256)\r\n    \r\n    if ($InitialCapacity -gt 0) {\r\n        return [InternalStringBuilderPool]::Get($InitialCapacity)\r\n    } else {\r\n        return [InternalStringBuilderPool]::Get()\r\n    }\r\n}\r\n\r\nfunction Return-PooledStringBuilder {\r\n    <#\r\n    .SYNOPSIS\r\n    Return a StringBuilder to the pool for reuse (Internal use only)\r\n    \r\n    .PARAMETER StringBuilder\r\n    StringBuilder to return to the pool\r\n    ##CLOSEBRACKET##\r\n    param([StringBuilder]$StringBuilder)\r\n    [InternalStringBuilderPool]::Recycle($StringBuilder)\r\n}\r\n\r\nfunction Get-PerformanceStats {\r\n    <#\r\n    .SYNOPSIS\r\n    Get performance statistics for monitoring (Internal use only)\r\n    \r\n    .OUTPUTS\r\n    Hashtable with performance statistics\r\n    ##CLOSEBRACKET##\r\n    return @{\r\n        StringBuilderPool = [InternalStringBuilderPool]::GetStats()\r\n        ColorCacheSize = [InternalVT100]::_colorCache.Count\r\n        SpacesCacheSize = [InternalStringCache]::_spaces.Count\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/OPTIMIZATION.md", "content": "# Performance Optimization Implementation Plan\n\nThe PMC TUI application suffers from significant performance issues caused by architectural inefficiencies, not just surface-level string operations. This plan addresses the root causes in priority order.\n\n## User Review Required\n\n> [!IMPORTANT]\n> **Breaking Change Risk**: The layout caching (Phase 2) changes how `DataDisplay` handles resize events. Existing code that relies on per-frame recalculation may need adjustment.\n\n> [!WARNING]\n> **Scope Decision**: This plan has 4 phases. Phases 1-2 provide ~80% of the gains. Should we implement all 4, or start with 1-2 and measure before proceeding?\n\n---\n\n## Proposed Changes\n\n### Phase 1: Terminal Dimension Singleton (High Impact, Low Effort)\n\n**Goal**: Eliminate redundant `[Console]::WindowWidth/Height` syscalls (currently 64+ call sites)\n\n#### [MODIFY] [PmcTerminalService](file:///home/teej/ztest/module/Pmc.Strict/src/TerminalDimensions.ps1)\n\n- Add frame-rate limited refresh (max 1 check per 100ms instead of per-call)\n- Add `OnResize` event for listeners\n- Change from 500ms cache to event-driven + 100ms fallback poll\n\n```diff\n static [hashtable] GetDimensions() {\n     $now = [datetime]::Now\n-    if (($now - [PmcTerminalService]::LastUpdate).TotalMilliseconds -lt [PmcTerminalService]::CacheValidityMs -and\n+    # Only refresh cache if explicitly invalidated or 100ms passed\n+    if (($now - [PmcTerminalService]::LastUpdate).TotalMilliseconds -lt 100 -and\n         [PmcTerminalService]::CachedWidth -gt 0) {\n         return @{ Width = ...; IsCached = $true }\n     }\n```\n\n#### [MODIFY] [PmcApplication.ps1](file:///home/teej/ztest/module/Pmc.Strict/consoleui/PmcApplication.ps1)\n\n- Replace inline `[Console]::WindowWidth` checks with single `PmcTerminalService` call\n- Move resize check to once per 10 iterations (already partially done, complete it)\n\n#### [MODIFY] Multiple widget files\n\nFiles with direct `[Console]::WindowWidth` calls to convert:\n- `PmcWidget.ps1:634`\n- `InlineEditor.ps1:1071`\n- `DatePicker.ps1:276`\n- `ProjectPicker.ps1:443`\n- `TimeListScreen.ps1:653`\n- `ExcelImportScreen.ps1:647`\n\n---\n\n### Phase 2: Layout Pre-computation and Caching (Very High Impact, Medium Effort)\n\n**Goal**: Compute column widths and static elements once on data load/resize, not every frame\n\n#### [MODIFY] [DataDisplay.ps1](file:///home/teej/ztest/module/Pmc.Strict/src/DataDisplay.ps1)\n\nAdd cached layout state:\n\n```powershell\n# New properties\nhidden [hashtable]$_cachedWidths = @{}\nhidden [string]$_cachedHeaderLine = \"\"\nhidden [string]$_cachedSeparatorLine = \"\"\nhidden [bool]$_layoutDirty = $true\n\n# New method\n[void] InvalidateLayout() {\n    $this._layoutDirty = $true\n}\n\n# Modified BuildInteractiveLines()\n[object[]] BuildInteractiveLines() {\n    # Only recalc layout when dirty\n    if ($this._layoutDirty) {\n        $this._cachedWidths = $this.GetColumnWidths($this.CurrentData)\n        $this._cachedHeaderLine = $this.FormatRow($null, $this._cachedWidths, $true, -1, $false)\n        $this._cachedSeparatorLine = $this._BuildSeparatorLine($this._cachedWidths)\n        $this._layoutDirty = $false\n    }\n    # Use cached values instead of recalculating\n    ...\n}\n```\n\nCall `InvalidateLayout()` from:\n- `RefreshData()` (data changed)\n- Resize handler (terminal dimensions changed)\n- `ApplyDoFilter()` (filtered data may have different widths)\n\n---\n\n### Phase 3: Row Caching System (Very High Impact, Medium Effort)\n\n**Goal**: Cache formatted row strings, only rebuild changed rows\n\n#### [MODIFY] [DataDisplay.ps1](file:///home/teej/ztest/module/Pmc.Strict/src/DataDisplay.ps1)\n\nAdd row cache:\n\n```powershell\nhidden [hashtable]$_rowCache = @{}  # Key: row index, Value: formatted string\nhidden [hashtable]$_rowHashes = @{} # Key: row index, Value: data hash for invalidation\n\n[string] GetCachedRow([int]$index, [object]$item, [hashtable]$widths, [bool]$isSelected) {\n    $hash = $this._ComputeRowHash($item, $isSelected)\n    \n    if ($this._rowCache.ContainsKey($index) -and $this._rowHashes[$index] -eq $hash) {\n        return $this._rowCache[$index]\n    }\n    \n    $formatted = $this.FormatRow($item, $widths, $false, $index, $isSelected)\n    $this._rowCache[$index] = $formatted\n    $this._rowHashes[$index] = $hash\n    return $formatted\n}\n\n[void] InvalidateRowCache() {\n    $this._rowCache.Clear()\n    $this._rowHashes.Clear()\n}\n```\n\n---\n\n### Phase 4: StringBuilder/List[T] Conversions (Medium Impact, Easy Effort)\n\n**Goal**: Replace O(n²) string/array concatenation with O(n) operations\n\n#### [MODIFY] [TerminalDimensions.ps1](file:///home/teej/ztest/module/Pmc.Strict/src/TerminalDimensions.ps1)\n\nConvert `TruncateWithAnsi` and `EnforceContentBounds`:\n\n```diff\n static [string] TruncateWithAnsi([string]$Text, [int]$MaxWidth) {\n-    $result = \"\"\n+    $sb = [System.Text.StringBuilder]::new($Text.Length)\n     ...\n     foreach ($part in $parts) {\n         if ($part -match $ansiPattern) {\n-            $result += $part\n+            [void]$sb.Append($part)\n         }\n     }\n-    return $result\n+    return $sb.ToString()\n }\n```\n\n#### [MODIFY] [DataDisplay.ps1](file:///home/teej/ztest/module/Pmc.Strict/src/DataDisplay.ps1)\n\nConvert `ApplyDoFilter`:\n\n```diff\n [void] ApplyDoFilter() {\n-    $filtered = @()\n+    $filtered = [System.Collections.Generic.List[object]]::new()\n     foreach ($it in $this.AllData) {\n         ...\n-        if ($hay.Contains($q)) { $filtered += $it }\n+        if ($hay.Contains($q)) { $filtered.Add($it) }\n     }\n+    $this.CurrentData = $filtered.ToArray()\n }\n```\n\n---\n\n## Verification Plan\n\n### Automated Tests\n\nExisting Pester tests to run after each phase:\n\n```bash\n# Run all Pester tests\ncd /home/teej/ztest/module/Pmc.Strict/consoleui/tests\npwsh -Command \"Invoke-Pester -Path . -Output Detailed\"\n```\n\nSpecific tests relevant to changes:\n- `TaskStore.Tests.ps1` - data operations\n- `PmcApplication.Tests.ps1` - render loop\n- `UIFunctional.Tests.ps1` - UI interactions\n\n### Manual Verification\n\n**Phase 1 (Terminal caching):**\n1. Launch TUI: `pwsh /home/teej/ztest/module/Pmc.Strict/consoleui/Start-PmcTUI.ps1`\n2. Resize terminal window multiple times rapidly\n3. Verify UI redraws correctly without lag or corruption\n4. Navigate through menus - should feel snappier\n\n**Phase 2 (Layout caching):**\n1. Load task list with 50+ tasks\n2. Scroll up/down rapidly\n3. Resize terminal - columns should adjust\n4. Add/edit task - verify layout updates\n\n**Phase 3 (Row caching):**\n1. Scroll through list\n2. Verify no visual corruption\n3. Edit a task inline - verify that row updates while others remain stable\n4. Use arrow keys - cursor movement should be instant\n\n**Phase 4 (StringBuilder):**\n1. Open task list with tasks containing long text (100+ chars)\n2. Apply filter with complex query\n3. Verify no truncation bugs\n4. Resize terminal - verify ANSI codes still render correctly\n\n### Performance Benchmarking\n\nCreate a simple timing script (to be added) that measures:\n- Time to render 100 items\n- Time to scroll 50 rows\n- Memory usage before/after large list load\n\n---\n\n## Implementation Order\n\n| Phase | Effort | Impact | Dependencies |\n|-------|--------|--------|--------------|\n| 1. Terminal Singleton | 2 hours | High | None |\n| 2. Layout Caching | 4 hours | Very High | Phase 1 |\n| 3. Row Caching | 4 hours | Very High | Phase 2 |\n| 4. StringBuilder | 2 hours | Medium | None (can parallelize) |\n\n**Recommended approach**: Implement Phase 1 + 4 together (easy wins), then Phase 2, then Phase 3. Measure after each phase.\n"}, {"path": "module/Pmc.Strict/Pmc.Strict.psd1", "content": "@{\n    RootModule        = 'Pmc.Strict.psm1'\n    ModuleVersion     = '0.1.0'\n    GUID              = '5b2d6a0a-8a8f-4e2a-9d0d-3a3b0e2a3b6f'\n    Author            = 'pmc'\n    CompanyName       = 'pmc'\n    Copyright         = '(c) pmc'\n    Description       = 'Strict, homogeneous domain-action command engine for pmc.'\n    PowerShellVersion = '5.1'\n    TypesToProcess    = @()\n    FunctionsToExport = @(\n        'Invoke-PmcCommand',\n        'Initialize-PmcEnhancedCommandProcessor',\n        'Get-PmcEnhancedCommandProcessor',\n        'Invoke-PmcEnhancedCommand',\n        'Get-PmcSchema',\n        'Get-PmcHelp',\n        'Get-PmcHelpData',\n        'Show-PmcHelpUI',\n        'Show-PmcHelpDomain',\n        'Show-PmcHelpCommand',\n        'Show-PmcHelpQuery',\n        'Show-PmcHelpAll',\n        'Start-PmcProjectWizard',\n        'Set-PmcConfigProvider',\n        'Enable-PmcInteractiveMode',\n        'Disable-PmcInteractiveMode',\n        'Get-PmcInteractiveStatus',\n        'Read-PmcCommand',\n        'Write-PmcDebug',\n        'Get-PmcDebugStatus',\n        'Show-PmcDebugLog',\n        'Measure-PmcOperation',\n        'Initialize-PmcDebugSystem',\n        'Initialize-PmcSecuritySystem',\n        'Initialize-PmcThemeSystem',\n        'Update-PmcDebugFromConfig',\n        'Update-PmcSecurityFromConfig',\n        'Get-PmcConfig',\n        'Save-PmcConfig',\n        'Get-PmcConfigProviders',\n        'Set-PmcConfigProviders',\n        'Get-PmcState',\n        'Set-PmcState',\n        'ConvertTo-PmcTokens',\n        'ConvertTo-PmcDate',\n        'Show-PmcSmartHelp',\n        'Write-PmcStyled',\n        'Get-PmcStyle',\n        'Get-PmcColorPalette',\n        'Get-PmcColorSequence',\n        'ConvertFrom-PmcHex',\n        'Test-PmcInputSafety',\n        'Test-PmcPathSafety',\n        'Invoke-PmcSecureFileOperation',\n        'Protect-PmcUserInput',\n        'Get-PmcSecurityStatus',\n        'Set-PmcSecurityLevel',\n        # TASK DOMAIN HANDLERS\n        'Add-PmcTask',\n        'Get-PmcTaskList',\n        'Show-PmcTask',\n        'Set-PmcTask',\n        'Complete-PmcTask',\n        'Remove-PmcTask',\n        'Move-PmcTask',\n        'Set-PmcTaskPostponed',\n        'Copy-PmcTask',\n        'Add-PmcTaskNote',\n        'Edit-PmcTask',\n        'Find-PmcTask',\n        'Set-PmcTaskPriority',\n        'Show-PmcAgenda',\n        'Show-PmcWeekTasks',\n        'Show-PmcMonthTasks',\n        # PROJECT DOMAIN HANDLERS\n        'Invoke-PmcCreateProjectCore',\n        'Add-PmcProject',\n        'Get-PmcProjectList',\n        'Show-PmcProject',\n        'Set-PmcProject',\n        'Rename-PmcProject',\n        'Remove-PmcProject',\n        'Set-PmcProjectArchived',\n        'Set-PmcProjectFields',\n        'Show-PmcProjectFields',\n        'Get-PmcProjectStats',\n        'Show-PmcProjectInfo',\n        'Get-PmcRecentProjects',\n        # TIME/TIMER DOMAIN HANDLERS\n        'Add-PmcTimeEntry',\n        'Get-PmcTimeReport',\n        'Get-PmcTimeList',\n        'Edit-PmcTimeEntry',\n        'Remove-PmcTimeEntry',\n        'Start-PmcTimer',\n        'Stop-PmcTimer',\n        'Get-PmcTimerStatus',\n        # ACTIVITY DOMAIN\n        'Get-PmcActivityList',\n        # TEMPLATE DOMAIN\n        'Save-PmcTemplate',\n        'Invoke-PmcTemplate',\n        'Get-PmcTemplateList',\n        'Remove-PmcTemplate',\n        # RECURRING DOMAIN\n        'Add-PmcRecurringTask',\n        # ALIAS DOMAIN\n        'Add-PmcAlias',\n        'Remove-PmcAlias',\n        # DEPENDENCY DOMAIN\n        'Add-PmcDependency',\n        'Remove-PmcDependency',\n        'Show-PmcDependencies',\n        'Show-PmcDependencyGraph',\n        # FOCUS DOMAIN\n        'Set-PmcFocus',\n        'Clear-PmcFocus',\n        'Get-PmcFocusStatus',\n        # SYSTEM DOMAIN\n        'Invoke-PmcUndo',\n        'Invoke-PmcRedo',\n        'New-PmcBackup',\n        'Clear-PmcCompletedTasks',\n        # VIEW DOMAIN\n        'Show-PmcTodayTasks',\n        'Show-PmcTomorrowTasks',\n        'Show-PmcOverdueTasks',\n        'Show-PmcUpcomingTasks',\n        'Show-PmcBlockedTasks',\n        'Show-PmcNoDueDateTasks',\n        'Show-PmcProjectsView',\n        'Show-PmcNextTasks',\n        # EXCEL DOMAIN\n        'Import-PmcExcelData',\n        'Show-PmcExcelPreview',\n        'Get-PmcLatestExcelFile',\n        # THEME DOMAIN\n        'Reset-PmcTheme',\n        'Edit-PmcTheme',\n        'Get-PmcThemeList',\n        'Apply-PmcTheme',\n        'Show-PmcThemeInfo',\n        # CONFIG DOMAIN\n        'Show-PmcConfig',\n        'Edit-PmcConfig',\n        'Set-PmcConfigValue',\n        'Reload-PmcConfig',\n        'Validate-PmcConfig',\n        'Set-PmcIconMode',\n        # IMPORT/EXPORT DOMAIN\n        'Import-PmcTasks',\n        'Export-PmcTasks',\n        # SHOW DOMAIN\n        'Get-PmcAliasList',\n        'Show-PmcCommands',\n        # HELP DOMAIN\n        'Show-PmcCommandBrowser',\n        'Show-PmcHelpExamples',\n        'Show-PmcHelpGuide',\n        # SHORTCUT-ONLY FUNCTIONS\n        'Get-PmcStats',\n        'Show-PmcBurndown',\n        'Get-PmcVelocity',\n        'Set-PmcTheme',\n        'Show-PmcPreferences',\n        'Invoke-PmcShortcutNumber',\n        'Start-PmcReview',\n        # XFLOW (Excel flow lite)\n        'Set-PmcXFlowSourcePathInteractive',\n        'Set-PmcXFlowDestPathInteractive',\n        'Show-PmcXFlowPreview',\n        'Invoke-PmcXFlowRun',\n        'Export-PmcXFlowText',\n        'Import-PmcXFlowMappingsFromFile',\n        'Set-PmcXFlowLatestFromFile',\n        'Show-PmcXFlowConfig',\n        # CONSOLE UI\n        'Start-PmcConsoleUI',\n        # DATA DISPLAY SYSTEM\n        'Show-PmcDataGrid',\n        # UNIVERSAL DISPLAY SYSTEM\n        'Show-PmcData',\n        'Get-PmcDefaultColumns',\n        'Register-PmcUniversalCommands',\n        'Get-PmcUniversalCommands',\n        'Ensure-PmcUniversalDisplay',\n        # Interactive view entrypoints\n        'Show-PmcTodayTasksInteractive',\n        'Show-PmcOverdueTasksInteractive',\n        'Show-PmcAgendaInteractive',\n        'Show-PmcProjectsInteractive',\n        'Show-PmcAllTasksInteractive',\n        # QUERY DOMAIN\n        'Invoke-PmcQuery',\n        'Invoke-PmcEnhancedQuery',\n        'Get-PmcQueryPerformanceStats',\n        'Initialize-PmcEnhancedQueryEngine',\n        'Evaluate-PmcQuery',\n        'Get-PmcComputedRegistry',\n        'Get-PmcQueryAlias',\n        'Set-PmcQueryAlias',\n        'Show-PmcCustomGrid',\n        # SCREEN MANAGEMENT SYSTEM\n        'Initialize-PmcScreen',\n        'Clear-PmcContentArea',\n        'Get-PmcContentBounds',\n        'Set-PmcHeader',\n        'Set-PmcInputPrompt',\n        'Hide-PmcCursor',\n        'Show-PmcCursor',\n        'Reset-PmcScreen',\n        'Write-PmcAtPosition',\n        # DATA ACCESS\n        'Get-PmcAllData',\n        'Get-PmcDataProvider'\n    )\n    AliasesToExport   = @()\n    CmdletsToExport   = @()\n    VariablesToExport = @('PmcCommandMap', 'PmcShortcutMap', 'PmcCommandMeta')\n}\n"}, {"path": "module/Pmc.Strict/Pmc.Strict.psm1", "content": "# Pmc.Strict module - strict domain-action engine\r\n\r\n# NOTE: Completions use plain strings; no PmcCompletionItem class is used anymore.\r\n\r\nenum PmcCompletionMode {\r\n    Domain      # Completing domain names (task, project, time)\r\n    Action      # Completing actions (add, list, done)\r\n    Arguments   # Completing arguments (@project, due:date, p1)\r\n    FreeText    # No completions available\r\n}\r\n\r\nclass PmcEditorState {\r\n    [string] $Buffer = \"\"\r\n    [int] $CursorPos = 0\r\n    [bool] $InCompletion = $false\r\n    [string] $OriginalBuffer = \"\"\r\n    [string[]] $Completions = @()\r\n    [int] $CompletionIndex = -1\r\n    [PmcCompletionMode] $Mode = [PmcCompletionMode]::Domain\r\n    [string] $CurrentToken = \"\"\r\n    [int] $TokenStart = 0\r\n    [int] $TokenEnd = 0\r\n\r\n    # History and undo/redo\r\n    [string[]] $History = @()\r\n    [int] $HistoryIndex = -1\r\n    [string[]] $UndoStack = @()\r\n    [string[]] $RedoStack = @()\r\n    [int] $MaxUndoItems = 50\r\n    [int] $MaxHistoryItems = 100\r\n}\r\n\r\n# Template specification and renderer - moved to module scope for proper class export\r\nclass PmcTemplate {\r\n    [string]$Name\r\n    [string]$Type        # 'grid', 'list', 'card', 'summary'\r\n    [string]$Header      # Header template\r\n    [string]$Row         # Row/item template\r\n    [string]$Footer      # Footer template\r\n    [hashtable]$Settings # Width, alignment, etc.\r\n\r\n    PmcTemplate([string]$name, [hashtable]$config) {\r\n        $this.Name = $name\r\n        $this.Type = $(if ($config.ContainsKey('type')) { $config.type } else { 'list' })\r\n        $this.Header = $(if ($config.ContainsKey('header')) { $config.header } else { '' })\r\n        $this.Row = $(if ($config.ContainsKey('row')) { $config.row } else { '' })\r\n        $this.Footer = $(if ($config.ContainsKey('footer')) { $config.footer } else { '' })\r\n        $this.Settings = $(if ($config.ContainsKey('settings')) { $config.settings } else { @{} })\r\n    }\r\n}\r\n\r\n# Dot-source internal components with debug tracing\r\n# Module loading in progress...\r\n\r\ntry {\r\n    # Loading Types.ps1...\r\n    . $PSScriptRoot/src/Types.ps1\r\n    # [OK] Types.ps1 loaded\r\n} catch {\r\n    Write-Host \"[ERROR] PMC module loading failed: Types.ps1 - $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n# Load terminal dimension service early as many modules depend on it\r\ntry {\r\n    # Loading TerminalDimensions.ps1...\r\n    . $PSScriptRoot/src/TerminalDimensions.ps1\r\n    # [OK] TerminalDimensions.ps1 loaded\r\n} catch {\r\n    Write-Host \"[ERROR] PMC module loading failed: TerminalDimensions.ps1 - $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n# Ensure centralized state is available before any consumer\r\ntry {\r\n    # Loading State.ps1...\r\n    . $PSScriptRoot/src/State.ps1\r\n    # [OK] State.ps1 loaded\r\n} catch {\r\n    Write-Host \"[ERROR] PMC module loading failed: State.ps1 - $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n# Config providers and helpers before Debug/Security which consult config\r\ntry {\r\n    # Loading Config.ps1...\r\n    . $PSScriptRoot/src/Config.ps1\r\n    # [OK] Config.ps1 loaded\r\n} catch {\r\n    Write-Host \"[ERROR] PMC module loading failed: Config.ps1 - $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n# Now load Debug and Security modules (no auto-init inside files)\r\ntry {\r\n    # Loading Debug.ps1...\r\n    . $PSScriptRoot/src/Debug.ps1\r\n    # [OK] Debug.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Debug.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Security.ps1...\r\n    . $PSScriptRoot/src/Security.ps1\r\n    # [OK] Security.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Security.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Storage.ps1...\r\n    . $PSScriptRoot/src/Storage.ps1\r\n    # [OK] Storage.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Storage.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n# Create Save-StrictData alias for backward compatibility\r\n# Used by Focus.ps1, Aliases.ps1, and other modules\r\nSet-Alias -Name Save-StrictData -Value Save-PmcData\r\n\r\ntry {\r\n    # Loading UI.ps1...\r\n    . $PSScriptRoot/src/UI.ps1\r\n    # [OK] UI.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] UI.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading ScreenManager.ps1...\r\n    . $PSScriptRoot/src/ScreenManager.ps1\r\n    # [OK] ScreenManager.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] ScreenManager.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Resolvers.ps1...\r\n    . $PSScriptRoot/src/Resolvers.ps1\r\n    # [OK] Resolvers.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Resolvers.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading CommandMap.ps1...\r\n    . $PSScriptRoot/src/CommandMap.ps1\r\n    # [OK] CommandMap.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] CommandMap.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Schemas.ps1...\r\n    . $PSScriptRoot/src/Schemas.ps1\r\n    # [OK] Schemas.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Schemas.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n## moved earlier\r\n\r\ntry {\r\n    # Loading AstCommandParser.ps1...\r\n    . $PSScriptRoot/src/AstCommandParser.ps1\r\n    # [OK] AstCommandParser.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] AstCommandParser.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading AstCompletion.ps1...\r\n    . $PSScriptRoot/src/AstCompletion.ps1\r\n    # [OK] AstCompletion.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] AstCompletion.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading TemplateDisplay.ps1...\r\n    . $PSScriptRoot/src/TemplateDisplay.ps1\r\n    # [OK] TemplateDisplay.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] TemplateDisplay.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Execution.ps1...\r\n    . $PSScriptRoot/src/Execution.ps1\r\n    # [OK] Execution.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Execution.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n\r\ntry {\r\n    # Loading Help.ps1...\r\n    . $PSScriptRoot/src/Help.ps1\r\n    # [OK] Help.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Help.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Interactive.ps1...\r\n    . $PSScriptRoot/src/Interactive.ps1\r\n    # [OK] Interactive.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Interactive.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Dependencies.ps1...\r\n    . $PSScriptRoot/src/Dependencies.ps1\r\n    # [OK] Dependencies.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Dependencies.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Focus.ps1...\r\n    . $PSScriptRoot/src/Focus.ps1\r\n    # [OK] Focus.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Focus.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Time.ps1...\r\n    . $PSScriptRoot/src/Time.ps1\r\n    # [OK] Time.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Time.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading UndoRedo.ps1...\r\n    . $PSScriptRoot/src/UndoRedo.ps1\r\n    # [OK] UndoRedo.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] UndoRedo.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n\r\n\r\n# Views.ps1 functionality migrated to UniversalDisplay.ps1 during technical debt cleanup\r\n\r\ntry {\r\n    # Loading Aliases.ps1...\r\n    . $PSScriptRoot/src/Aliases.ps1\r\n    # [OK] Aliases.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Aliases.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Analytics.ps1...\r\n    . $PSScriptRoot/src/Analytics.ps1\r\n    # [OK] Analytics.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Analytics.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Theme.ps1...\r\n    . $PSScriptRoot/src/Theme.ps1\r\n    # [OK] Theme.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Theme.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Excel.ps1...\r\n    . $PSScriptRoot/src/Excel.ps1\r\n    # [OK] Excel.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Excel.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n# Excel Flow Lite (interactive path pickers for source/dest)\r\ntry {\r\n    # Loading ExcelFlowLite.ps1...\r\n    . $PSScriptRoot/src/ExcelFlowLite.ps1\r\n    # [OK] ExcelFlowLite.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] ExcelFlowLite.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading ImportExport.ps1...\r\n    . $PSScriptRoot/src/ImportExport.ps1\r\n    # [OK] ImportExport.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] ImportExport.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Shortcuts.ps1...\r\n    . $PSScriptRoot/src/Shortcuts.ps1\r\n    # [OK] Shortcuts.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Shortcuts.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Review.ps1...\r\n    . $PSScriptRoot/src/Review.ps1\r\n    # [OK] Review.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Review.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n# Initialize help content data structure - organized from reference doc\r\n$Script:PmcHelpContent = @{\r\n    'Query Language' = @{\r\n        Description = 'Filter, sort, and display tasks, projects, and time logs'\r\n        Items = @(\r\n            @{ Type='Basic'; Command='q tasks'; Description='Show all tasks' }\r\n            @{ Type='Filter'; Command='q tasks p1'; Description='High priority tasks' }\r\n            @{ Type='Filter'; Command='q tasks due:today'; Description='Tasks due today' }\r\n            @{ Type='Filter'; Command='q tasks @webapp'; Description='Tasks for webapp project' }\r\n            @{ Type='Filter'; Command='q tasks #urgent'; Description='Tasks tagged urgent' }\r\n            @{ Type='Filter'; Command='q tasks overdue'; Description='Overdue tasks' }\r\n            @{ Type='Filter'; Command='q tasks \"database\"'; Description='Text search for \"database\"' }\r\n            @{ Type='View'; Command='q tasks group:status'; Description='Kanban board by status' }\r\n            @{ Type='View'; Command='q tasks cols:id,text,due'; Description='Custom columns' }\r\n            @{ Type='View'; Command='q tasks sort:due+'; Description='Sort by due date ascending' }\r\n            @{ Type='Combo'; Command='q tasks @webapp p<=2 due:+7'; Description='Multiple filters combined' }\r\n            @{ Type='Save'; Command='q tasks p1 due:today save:urgent'; Description='Save query as \"urgent\"' }\r\n            @{ Type='Load'; Command='q load:urgent'; Description='Load saved query' }\r\n        )\r\n    }\r\n    'Priority Filters' = @{\r\n        Description = 'Filter tasks by priority level'\r\n        Items = @(\r\n            @{ Type='Basic'; Command='q tasks p1'; Description='Priority 1 (highest)' }\r\n            @{ Type='Basic'; Command='q tasks p2'; Description='Priority 2 (medium)' }\r\n            @{ Type='Basic'; Command='q tasks p3'; Description='Priority 3 (lowest)' }\r\n            @{ Type='Range'; Command='q tasks p<=2'; Description='Priority 2 or higher' }\r\n            @{ Type='Range'; Command='q tasks p1..3'; Description='Priority range 1 to 3' }\r\n        )\r\n    }\r\n    'Date Filters' = @{\r\n        Description = 'Filter tasks by dates and deadlines'\r\n        Items = @(\r\n            @{ Type='Relative'; Command='q tasks due:today'; Description='Due today' }\r\n            @{ Type='Relative'; Command='q tasks due:tomorrow'; Description='Due tomorrow' }\r\n            @{ Type='Relative'; Command='q tasks due:+7'; Description='Due in 7 days' }\r\n            @{ Type='Relative'; Command='q tasks due:eow'; Description='Due end of week (Sunday)' }\r\n            @{ Type='Relative'; Command='q tasks due:eom'; Description='Due end of month' }\r\n            @{ Type='Relative'; Command='q tasks due:1m'; Description='Due in 1 month' }\r\n            @{ Type='Absolute'; Command='q tasks due:20251225'; Description='Due Dec 25, 2025 (yyyymmdd)' }\r\n            @{ Type='Absolute'; Command='q tasks due:1225'; Description='Due Dec 25 (current year)' }\r\n            @{ Type='Status'; Command='q tasks overdue'; Description='Overdue tasks' }\r\n        )\r\n    }\r\n    'Project Filters' = @{\r\n        Description = 'Filter by project names and assignments'\r\n        Items = @(\r\n            @{ Type='Basic'; Command='q tasks @webapp'; Description='Tasks for project \"webapp\"' }\r\n            @{ Type='Quoted'; Command='q tasks @\"project name\"'; Description='Projects with spaces' }\r\n            @{ Type='Multiple'; Command='q tasks @webapp @api'; Description='Tasks from multiple projects' }\r\n            @{ Type='Negative'; Command='q tasks -@archived'; Description='Exclude archived project' }\r\n        )\r\n    }\r\n    'Tag Filters' = @{\r\n        Description = 'Filter by tags and labels'\r\n        Items = @(\r\n            @{ Type='Basic'; Command='q tasks #urgent'; Description='Has \"urgent\" tag' }\r\n            @{ Type='Multiple'; Command='q tasks #web #api'; Description='Has both \"web\" and \"api\" tags' }\r\n            @{ Type='Negative'; Command='q tasks -#blocked'; Description='Does NOT have \"blocked\" tag' }\r\n        )\r\n    }\r\n    'Display Options' = @{\r\n        Description = 'Control how results are displayed'\r\n        Items = @(\r\n            @{ Type='Columns'; Command='q tasks cols:id,text,due'; Description='Show only specified columns' }\r\n            @{ Type='Columns'; Command='q tasks cols:id,text,due,priority'; Description='Include priority column' }\r\n            @{ Type='Sort'; Command='q tasks sort:due+'; Description='Sort by due date ascending' }\r\n            @{ Type='Sort'; Command='q tasks sort:priority-'; Description='Sort by priority descending' }\r\n            @{ Type='Sort'; Command='q tasks sort:due+,priority-'; Description='Multi-column sort' }\r\n            @{ Type='View'; Command='q tasks view:kanban'; Description='Display as Kanban board' }\r\n            @{ Type='View'; Command='q tasks view:list'; Description='Display as list (default)' }\r\n            @{ Type='Group'; Command='q tasks group:status'; Description='Group by status' }\r\n            @{ Type='Group'; Command='q tasks group:project'; Description='Group by project' }\r\n        )\r\n    }\r\n    'Advanced Features' = @{\r\n        Description = 'Metrics, relations, and saved queries'\r\n        Items = @(\r\n            @{ Type='Metrics'; Command='q tasks metrics:time_week'; Description='Add time logged this week' }\r\n            @{ Type='Metrics'; Command='q tasks metrics:time_today'; Description='Add time logged today' }\r\n            @{ Type='Metrics'; Command='q tasks metrics:overdue_days'; Description='Add days overdue' }\r\n            @{ Type='Relations'; Command='q tasks with:project'; Description='Include related project data' }\r\n            @{ Type='Relations'; Command='q projects with:tasks'; Description='Include related tasks' }\r\n            @{ Type='Save'; Command='q tasks p1 due:today save:myquery'; Description='Save query as \"myquery\"' }\r\n            @{ Type='Load'; Command='q load:myquery'; Description='Load saved query' }\r\n        )\r\n    }\r\n    'Quick Tasks' = @{\r\n        Description = 'Common task management commands'\r\n        Items = @(\r\n            @{ Type='View'; Command='today'; Description='Tasks due today' }\r\n            @{ Type='View'; Command='overdue'; Description='Overdue tasks' }\r\n            @{ Type='View'; Command='agenda'; Description='Agenda view' }\r\n            @{ Type='Add'; Command='add \"Task text\" @project p1 due:today'; Description='Add new task' }\r\n            @{ Type='Edit'; Command='edit 123'; Description='Edit task by ID' }\r\n            @{ Type='Complete'; Command='done 123'; Description='Mark task complete' }\r\n        )\r\n    }\r\n    'Projects' = @{\r\n        Description = 'Project management commands'\r\n        Items = @(\r\n            @{ Type='View'; Command='projects'; Description='List all projects' }\r\n            @{ Type='Add'; Command='project add \"Project Name\"'; Description='Create new project' }\r\n            @{ Type='View'; Command='project show webapp'; Description='Show project details' }\r\n            @{ Type='Edit'; Command='project edit webapp'; Description='Edit project settings' }\r\n        )\r\n    }\r\n    'Time Tracking' = @{\r\n        Description = 'Time logging and reports'\r\n        Items = @(\r\n            @{ Type='Start'; Command='timer start @project \"Working on feature\"'; Description='Start timer' }\r\n            @{ Type='Stop'; Command='timer stop'; Description='Stop current timer' }\r\n            @{ Type='Status'; Command='timer status'; Description='Show timer status' }\r\n            @{ Type='Add'; Command='time add 2h @project \"Meeting\"'; Description='Log time manually' }\r\n            @{ Type='Report'; Command='time report week'; Description='Weekly time report' }\r\n        )\r\n    }\r\n}\r\n\r\n# Help data provider function - needs to be in same scope as $Script:PmcHelpContent\r\nfunction Get-PmcHelpData {\r\n    param([PmcCommandContext]$Context)\r\n    # Return help categories as domain data for universal display system\r\n    $helpCategories = @()\r\n\r\n    if ($Script:PmcHelpContent -and $Script:PmcHelpContent.Count -gt 0) {\r\n        $id = 1\r\n        foreach ($categoryEntry in $Script:PmcHelpContent.GetEnumerator()) {\r\n            $helpCategories += [PSCustomObject]@{\r\n                id = $id++\r\n                Category = $categoryEntry.Key\r\n                CommandCount = $categoryEntry.Value.Items.Count\r\n                Description = $categoryEntry.Value.Description\r\n            }\r\n        }\r\n    }\r\n\r\n    return $helpCategories\r\n}\r\n\r\ntry {\r\n    # Loading HelpUI.ps1...\r\n    . $PSScriptRoot/src/HelpUI.ps1\r\n    # [OK] HelpUI.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] HelpUI.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading TaskEditor.ps1...\r\n    . $PSScriptRoot/src/TaskEditor.ps1\r\n    # [OK] TaskEditor.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] TaskEditor.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading ProjectWizard.ps1...\r\n    . $PSScriptRoot/src/ProjectWizard.ps1\r\n    # [OK] ProjectWizard.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] ProjectWizard.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Projects.ps1...\r\n    . $PSScriptRoot/src/Projects.ps1\r\n    # [OK] Projects.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Projects.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Tasks.ps1...\r\n    . $PSScriptRoot/src/Tasks.ps1\r\n    # [OK] Tasks.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Tasks.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Views.ps1...\r\n    . $PSScriptRoot/src/Views.ps1\r\n    # [OK] Views.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Views.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading PraxisVT.ps1...\r\n    . $PSScriptRoot/src/PraxisVT.ps1\r\n    # [OK] PraxisVT.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] PraxisVT.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading PraxisStringBuilder.ps1...\r\n    . $PSScriptRoot/src/PraxisStringBuilder.ps1\r\n    # [OK] PraxisStringBuilder.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] PraxisStringBuilder.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading FieldSchemas.ps1...\r\n    . $PSScriptRoot/src/FieldSchemas.ps1\r\n    # [OK] FieldSchemas.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] FieldSchemas.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading QuerySpec.ps1...\r\n    . $PSScriptRoot/src/QuerySpec.ps1\r\n    # [OK] QuerySpec.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] QuerySpec.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Query.ps1...\r\n    . $PSScriptRoot/src/Query.ps1\r\n    # [OK] Query.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Query.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n# Query engine dependencies (computed fields, evaluator, kanban renderer)\r\ntry {\r\n    # Loading ComputedFields.ps1...\r\n    . $PSScriptRoot/src/ComputedFields.ps1\r\n    # [OK] ComputedFields.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] ComputedFields.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading QueryEvaluator.ps1...\r\n    . $PSScriptRoot/src/QueryEvaluator.ps1\r\n    # [OK] QueryEvaluator.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] QueryEvaluator.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n\r\ntry {\r\n    # Loading PraxisFrameRenderer.ps1...\r\n    . $PSScriptRoot/src/PraxisFrameRenderer.ps1\r\n    # [OK] PraxisFrameRenderer.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] PraxisFrameRenderer.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading DataDisplay.ps1...\r\n    . $PSScriptRoot/src/DataDisplay.ps1\r\n    # [OK] DataDisplay.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] DataDisplay.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n# DISABLED: KanbanRenderer has syntax errors\r\n# try {\r\n#     # Loading KanbanRenderer.ps1...\r\n#     . $PSScriptRoot/src/KanbanRenderer.ps1\r\n#     # [OK] KanbanRenderer.ps1 loaded\r\n# } catch {\r\n#     Write-Host \"  [ERROR] KanbanRenderer.ps1 failed: $_\" -ForegroundColor Red\r\n#     throw\r\n# }\r\n\r\ntry {\r\n    # Loading UniversalDisplay.ps1...\r\n    . $PSScriptRoot/src/UniversalDisplay.ps1\r\n    # [OK] UniversalDisplay.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] UniversalDisplay.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n# Load Core enhanced systems for improved performance and security\r\ntry {\r\n    # Loading Core/EnhancedQueryEngine.ps1...\r\n    . $PSScriptRoot/Core/EnhancedQueryEngine.ps1\r\n    # [OK] Core/EnhancedQueryEngine.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Core/EnhancedQueryEngine.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\ntry {\r\n    # Loading Core/EnhancedCommandProcessor.ps1...\r\n    . $PSScriptRoot/Core/EnhancedCommandProcessor.ps1\r\n    # [OK] Core/EnhancedCommandProcessor.ps1 loaded\r\n} catch {\r\n    Write-Host \"  [ERROR] Core/EnhancedCommandProcessor.ps1 failed: $_\" -ForegroundColor Red\r\n    throw\r\n}\r\n\r\n \r\n\r\n\r\n# Clear screen after module loading completes\r\nif (Get-Command Reset-PmcScreen -ErrorAction SilentlyContinue) {\r\n    Reset-PmcScreen\r\n}\r\n\r\n# Define Get-PmcData wrapper - MUST be before Export-ModuleMember\r\nfunction Get-PmcData {\r\n    # Forward to Storage.ps1's implementation if it exists, otherwise load directly\r\n    $file = Get-PmcTaskFilePath\r\n    if (-not (Test-Path $file)) {\r\n        $root = Split-Path $file -Parent\r\n        try { if (-not (Test-Path $root)) { New-Item -ItemType Directory -Path $root -Force | Out-Null } } catch {}\r\n        $init = @{\r\n            tasks=@(); deleted=@(); completed=@(); timelogs=@(); activityLog=@(); projects=@(@{ name='inbox'; description='Default inbox'; aliases=@(); created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss') });\r\n            currentContext='inbox'; schema_version=1; preferences=@{ autoBackup=$true }\r\n        } | ConvertTo-Json -Depth 10\r\n        $init | Set-Content -Path $file -Encoding UTF8\r\n    }\r\n    # KR-M1 FIX: Add type validation before casting JSON boolean field\r\n    $cfg = Get-PmcConfig; $strict = $true\r\n    try {\r\n        if ($cfg.Behavior -and $cfg.Behavior.StrictDataMode -ne $null) {\r\n            # Validate and safely convert to boolean\r\n            if ($cfg.Behavior.StrictDataMode -is [bool]) {\r\n                $strict = $cfg.Behavior.StrictDataMode\r\n            } elseif ($cfg.Behavior.StrictDataMode -is [string]) {\r\n                $strict = $cfg.Behavior.StrictDataMode -eq 'true'\r\n            } elseif ($cfg.Behavior.StrictDataMode -is [int]) {\r\n                $strict = $cfg.Behavior.StrictDataMode -ne 0\r\n            } else {\r\n                $strict = [bool]$cfg.Behavior.StrictDataMode\r\n            }\r\n        }\r\n    } catch {}\r\n    try {\r\n        $raw = Get-Content $file -Raw\r\n        $data = $raw | ConvertFrom-Json\r\n        $data = Normalize-PmcData $data\r\n        $data = Initialize-PmcDataSchema $data\r\n        return $data\r\n    } catch {\r\n        if ($strict) { throw }\r\n        return @{\r\n            schema_version = 1; tasks=@(); projects=@(); timelogs=@(); deleted=@(); completed=@(); activityLog=@(); templates=@(); recurringTemplates=@(); aliases=@{}; currentContext='inbox'; preferences=@{ autoBackup=$true }\r\n        }\r\n    }\r\n}\r\n\r\n# FakeTUI function loaded from src/FakeTUICommand.ps1\r\n\r\nWrite-Host \"[OK] PMC loaded\" -ForegroundColor Green\r\n\r\n# Ensure required public functions are exported (override narrow exports in sub-files)\r\nExport-ModuleMember -Function `\r\n    Invoke-PmcCommand, `\r\n    Initialize-PmcEnhancedCommandProcessor, `\r\n    Get-PmcEnhancedCommandProcessor, `\r\n    Invoke-PmcEnhancedCommand, `\r\n    Get-PmcSchema, `\r\n    Get-PmcFieldSchema, Get-PmcFieldSchemasForDomain, `\r\n    Invoke-PmcQuery, `\r\n    Invoke-PmcEnhancedQuery, `\r\n    Get-PmcQueryPerformanceStats, `\r\n    Initialize-PmcEnhancedQueryEngine, `\r\n    Get-PmcHelp, `\r\n    Get-PmcHelpData, `\r\n    Set-PmcConfigProvider, `\r\n    Get-PmcConfig, `\r\n    Save-PmcConfig, `\r\n    Ensure-PmcUniversalDisplay, `\r\n    Write-PmcDebug, `\r\n    Get-PmcDebugStatus, `\r\n    Show-PmcDebugLog, `\r\n    Measure-PmcOperation, `\r\n    Initialize-PmcDebugSystem, `\r\n    Initialize-PmcSecuritySystem, `\r\n    Initialize-PmcThemeSystem, `\r\n    Write-PmcStyled, Show-PmcHeader, Show-PmcSeparator, Show-PmcTable, `\r\n    Get-PmcColorPalette, Get-PmcColorSequence, ConvertFrom-PmcHex, `\r\n    Test-PmcInputSafety, `\r\n    Test-PmcPathSafety, `\r\n    Invoke-PmcSecureFileOperation, `\r\n    Protect-PmcUserInput, `\r\n    Get-PmcSecurityStatus, `\r\n    Set-PmcSecurityLevel, `\r\n    Enable-PmcInteractiveMode, `\r\n    Disable-PmcInteractiveMode, `\r\n    Get-PmcInteractiveStatus, `\r\n    Read-PmcCommand, `\r\n    Show-PmcSmartHelp, `\r\n    Show-PmcHelpDomain, `\r\n    Show-PmcHelpCommand, `\r\n    Show-PmcHelpUI, `\r\n    Show-PmcCommandBrowser, `\r\n    Show-PmcHelpExamples, `\r\n    Show-PmcHelpGuide, `\r\n    Show-PmcHelpSearch, `\r\n    Invoke-PmcTaskEditor, `\r\n    Show-PmcAgenda, `\r\n    Show-PmcTodayTasks, `\r\n    Show-PmcOverdueTasks, `\r\n    Show-PmcUpcomingTasks, `\r\n    Show-PmcBlockedTasks, `\r\n    Show-PmcTasksWithoutDueDate, `\r\n    Show-PmcProjectsView, `\r\n    Get-PmcTaskList, `\r\n    Get-PmcProjectList, `\r\n    Show-PmcDataGrid, Show-PmcCustomGrid, `\r\n    Show-PmcData, `\r\n    Initialize-PmcScreen, `\r\n    Clear-PmcContentArea, `\r\n    Get-PmcContentBounds, `\r\n    Set-PmcHeader, `\r\n    Set-PmcInputPrompt, `\r\n    Hide-PmcCursor, `\r\n    Show-PmcCursor, `\r\n    Reset-PmcScreen, `\r\n    Write-PmcAtPosition, `\r\n    Get-PmcAllData, `\r\n    Get-PmcData, `\r\n    Get-PmcDataProvider, `\r\n    Get-PmcTasksData, `\r\n    Get-PmcProjectsData, `\r\n    Get-PmcTimeLogsData, `\r\n    Save-PmcData\r\n\r\n# FakeTUI function moved earlier in file for proper export\r\n\r\n# Export variables explicitly\r\nExport-ModuleMember -Variable PmcCommandMap, PmcShortcutMap, PmcCommandMeta\r\n\r\n# Export aliases\r\nExport-ModuleMember -Alias Save-StrictData\r\n\r\n# Services directory - REFERENCE ONLY (disabled to avoid conflicts)\r\n# Future service-oriented architecture available in Services/ directory\r\n# To re-enable: Uncomment the block below (after resolving display system conflicts)\r\n#\r\n# try {\r\n#     . $PSScriptRoot/Services/LegacyCompat.ps1\r\n#     Write-Host \"[OK] LegacyCompat services loaded\" -ForegroundColor Green\r\n# } catch {\r\n#     Write-Host \"[ERROR] LegacyCompat services failed: $_\" -ForegroundColor Red\r\n# }\r\n\r\n# Initialize core systems\r\ntry {\r\n    Initialize-PmcThemeSystem\r\n    Initialize-PmcSecuritySystem\r\n    $cfg = Get-PmcConfig\r\n    $lvl = try { [int]$cfg.Debug.Level } catch { 0 }\r\n    Initialize-PmcDebugSystem -Level $lvl\r\n} catch {\r\n    Write-Host \"[ERROR] Core system initialization failed: $_\" -ForegroundColor Red\r\n}\r\n\r\n# Register universal command shortcuts after export so functions are available\r\ntry {\r\n    if (Get-Command Register-PmcUniversalCommands -ErrorAction SilentlyContinue) {\r\n        Register-PmcUniversalCommands\r\n        Write-Host \"[OK] Universal command shortcuts registered\" -ForegroundColor Green\r\n    } else {\r\n        Write-Host \"[WARN] Register-PmcUniversalCommands function not found\" -ForegroundColor Yellow\r\n    }\r\n} catch {\r\n    Write-Host \"[ERROR] Universal Display initialization failed: $_\" -ForegroundColor Red\r\n}\r\n\r\n# Modules loaded after Export-ModuleMember removed to fix export issues"}, {"path": "module/Pmc.Strict/consoleui/AUTO-ACCEPT-GUIDE.md", "content": "# How to Enable Auto-Accept for Commands\n\n## Option 1: Environment Variable (Recommended)\n\nSet this environment variable before starting your session:\n\n```bash\nexport GEMINI_AUTO_ACCEPT_COMMANDS=true\n```\n\nTo make it permanent, add to your `~/.bashrc` or `~/.zshrc`:\n\n```bash\necho 'export GEMINI_AUTO_ACCEPT_COMMANDS=true' >> ~/.bashrc\nsource ~/.bashrc\n```\n\n## Option 2: Configuration File\n\nCreate or edit `~/.gemini/config.json`:\n\n```json\n{\n  \"autoAcceptCommands\": true,\n  \"autoAcceptSafeCommands\": true\n}\n```\n\n## Option 3: Per-Session Setting\n\nIn the Gemini interface, look for settings/preferences and enable:\n- \"Auto-accept safe commands\"\n- \"Auto-accept all commands\" (use with caution)\n\n## What Gets Auto-Accepted?\n\nWith `SafeToAutoRun=true`, commands like:\n- ✓ `ls`, `cat`, `grep` (read-only operations)\n- ✓ `chmod +x` on new scripts\n- ✓ Running verification scripts\n\nCommands that require approval:\n- ✗ `rm`, `mv` (destructive operations)\n- ✗ System modifications\n- ✗ Network operations\n\n## Testing Auto-Accept\n\nRun this to verify:\n```bash\n# This should auto-run without asking\nls -la /tmp\n\n# This will still ask for approval\nrm /tmp/test-file\n```\n\n---\n\n## Automated Testing Scripts Created\n\n### Quick Verification (Fast)\n```bash\npwsh /home/teej/ztest/module/Pmc.Strict/consoleui/verify-tui.ps1\n```\n\nChecks:\n- ✓ TimeListScreen has callback methods\n- ✓ TabPanel widget exists  \n- ✓ ProjectInfoScreenV4 exists\n\n### Full Test Suite (Slower, loads all dependencies)\n```bash\npwsh /home/teej/ztest/module/Pmc.Strict/consoleui/test-tui.ps1\n```\n\nNote: Currently has dependency loading issues, use verify-tui.ps1 instead.\n\n---\n\n## Manual Testing Checklist\n\nAfter running automated tests, manually verify:\n\n1. **TimeListScreen Fix**\n   ```bash\n   pwsh /home/teej/ztest/module/Pmc.Strict/consoleui/Start-PmcTUI.ps1\n   ```\n   - Press `F10` → `Time` → `Time Tracking`\n   - Press `a` to add entry\n   - Should NOT see \"Method invocation failed\" error\n\n2. **ProjectInfoScreenV4 Tabs**\n   - Press `F10` → `Projects` → `Project List`\n   - Select project, press Enter\n   - Check if tabs visible at top\n\n3. **General Rendering**\n   - Navigate through screens\n   - Look for visual artifacts or missing text\n"}, {"path": "module/Pmc.Strict/consoleui/ClassLoader.ps1", "content": "# ClassLoader.ps1 - Smart dependency-aware class loading system\r\n# Replaces brittle hardcoded file lists with auto-discovery and intelligent ordering\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nSmart class loader that auto-discovers and loads PowerShell class files with dependency resolution\r\n\r\n.DESCRIPTION\r\nFeatures:\r\n- Auto-discovers all .ps1 files in specified directories\r\n- Respects load order via priority system\r\n- Multi-pass loading with dependency retry logic\r\n- Excludes test files automatically\r\n- Detailed logging for troubleshooting\r\n- Handles circular dependencies gracefully\r\n\r\n.EXAMPLE\r\n$loader = [ClassLoader]::new($PSScriptRoot)\r\n$loader.AddDirectory(\"widgets\", 100)\r\n$loader.AddDirectory(\"base\", 50)\r\n$loader.LoadAll()\r\n##CLOSEBRACKET##\r\nclass ClassLoader {\r\n    [System.Collections.ArrayList]$LoadQueue = @()\r\n    [System.Collections.ArrayList]$LoadedFiles = @()\r\n    [System.Collections.ArrayList]$FailedFiles = @()\r\n    [hashtable]$LoadStats = @{}\r\n    [string]$BaseDirectory\r\n    [int]$MaxRetries = 3\r\n    [bool]$ExcludeTests = $true\r\n    [bool]$VerboseLogging = $false\r\n\r\n    ClassLoader([string]$baseDir) {\r\n        $this.BaseDirectory = $baseDir\r\n        $this.LoadStats = @{\r\n            TotalFiles = 0\r\n            Loaded = 0\r\n            Failed = 0\r\n            Skipped = 0\r\n            Retries = 0\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Add a directory to the load queue\r\n\r\n    .PARAMETER relativePath\r\n    Path relative to BaseDirectory (e.g., \"widgets\", \"base\", \"screens\")\r\n\r\n    .PARAMETER priority\r\n    Lower number = loaded first (e.g., base=10, widgets=50, screens=100)\r\n\r\n    .PARAMETER recursive\r\n    Whether to include subdirectories\r\n    ##CLOSEBRACKET##\r\n    [void] AddDirectory([string]$relativePath, [int]$priority, [bool]$recursive = $false) {\r\n        $fullPath = Join-Path $this.BaseDirectory $relativePath\r\n\r\n        if (-not (Test-Path $fullPath)) {\r\n            $this.Log(\"WARNING: Directory not found: $fullPath\", \"WARN\")\r\n            return\r\n        }\r\n\r\n        # Discover files\r\n        $files = if ($recursive) {\r\n            Get-ChildItem -Path $fullPath -Filter \"*.ps1\" -Recurse -File\r\n        } else {\r\n            Get-ChildItem -Path $fullPath -Filter \"*.ps1\" -File\r\n        }\r\n\r\n        foreach ($file in $files) {\r\n            # Skip test files if configured\r\n            if ($this.ExcludeTests -and $file.Name -match '^Test.*\\.ps1$') {\r\n                $this.Log(\"Skipping test file: $($file.Name)\", \"DEBUG\")\r\n                $this.LoadStats.Skipped++\r\n                continue\r\n            }\r\n\r\n            # Check for priority override in file header\r\n            $filePriority = $this.ExtractPriorityFromFile($file.FullName)\r\n            if ($null -ne $filePriority) {\r\n                $priority = $filePriority\r\n            }\r\n\r\n            $this.LoadQueue.Add(@{\r\n                Path = $file.FullName\r\n                Name = $file.Name\r\n                Priority = $priority\r\n                Directory = $relativePath\r\n                Retries = 0\r\n                LastError = $null\r\n            }) | Out-Null\r\n\r\n            $this.LoadStats.TotalFiles++\r\n        }\r\n\r\n        $fileCount = @($files).Count\r\n        $this.Log(\"Discovered $fileCount files in $relativePath (priority=$priority)\", \"INFO\")\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Extract load priority from file header comment\r\n    Files can specify: # LoadPriority: 25\r\n    ##CLOSEBRACKET##\r\n    [object] ExtractPriorityFromFile([string]$filePath) {\r\n        try {\r\n            $content = Get-Content -Path $filePath -TotalCount 10 -ErrorAction SilentlyContinue\r\n            foreach ($line in $content) {\r\n                if ($line -match '^\\s*#\\s*LoadPriority:\\s*(\\d+)') {\r\n                    return [int]$matches[1]\r\n                }\r\n            }\r\n        } catch {\r\n            # Ignore errors reading file header\r\n        }\r\n        return $null\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Load all queued files with dependency resolution\r\n    ##CLOSEBRACKET##\r\n    [void] LoadAll() {\r\n        $this.Log(\"=== Starting ClassLoader ===\", \"INFO\")\r\n        $this.Log(\"Total files queued: $($this.LoadStats.TotalFiles)\", \"INFO\")\r\n\r\n        # Sort by priority (lower number first)\r\n        $sortedQueue = $this.LoadQueue | Sort-Object { $_.Priority }, { $_.Name }\r\n\r\n        # Multi-pass loading with retry logic\r\n        $pass = 1\r\n        $remainingFiles = [System.Collections.ArrayList]::new($sortedQueue)\r\n\r\n        while ($remainingFiles.Count -gt 0 -and $pass -le $this.MaxRetries) {\r\n            $this.Log(\"--- Load Pass $pass ($($remainingFiles.Count) files remaining) ---\", \"INFO\")\r\n\r\n            $stillFailing = [System.Collections.ArrayList]::new()\r\n\r\n            foreach ($fileInfo in $remainingFiles) {\r\n                $success = $this.LoadFile($fileInfo)\r\n\r\n                if ($success) {\r\n                    $this.LoadedFiles.Add($fileInfo) | Out-Null\r\n                    $this.LoadStats.Loaded++\r\n                } else {\r\n                    # Check if error is due to missing type (dependency issue)\r\n                    if ($fileInfo.LastError -match 'Unable to find type') {\r\n                        if ($fileInfo.Retries -lt $this.MaxRetries) {\r\n                            $fileInfo.Retries++\r\n                            $stillFailing.Add($fileInfo) | Out-Null\r\n                            $this.LoadStats.Retries++\r\n                            $this.Log(\"Will retry: $($fileInfo.Name) (attempt $($fileInfo.Retries + 1))\", \"DEBUG\")\r\n                        } else {\r\n                            $this.FailedFiles.Add($fileInfo) | Out-Null\r\n                            $this.LoadStats.Failed++\r\n                            $this.Log(\"FAILED after $($this.MaxRetries) attempts: $($fileInfo.Name)\", \"ERROR\")\r\n                            $this.Log(\"  Error: $($fileInfo.LastError)\", \"ERROR\")\r\n                        }\r\n                    } else {\r\n                        # Non-dependency error, fail immediately\r\n                        $this.FailedFiles.Add($fileInfo) | Out-Null\r\n                        $this.LoadStats.Failed++\r\n                        $this.Log(\"FAILED (non-dependency error): $($fileInfo.Name)\", \"ERROR\")\r\n                        $this.Log(\"  Error: $($fileInfo.LastError)\", \"ERROR\")\r\n                    }\r\n                }\r\n            }\r\n\r\n            # If no progress made this pass, break to avoid infinite loop\r\n            if ($stillFailing.Count -eq $remainingFiles.Count) {\r\n                $this.Log(\"No progress made in pass $pass - circular dependency or missing files\", \"WARN\")\r\n                foreach ($f in $stillFailing) {\r\n                    $this.FailedFiles.Add($f) | Out-Null\r\n                    $this.LoadStats.Failed++\r\n                }\r\n                break\r\n            }\r\n\r\n            $remainingFiles = $stillFailing\r\n            $pass++\r\n        }\r\n\r\n        $this.PrintSummary()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Load a single file with error handling\r\n    ##CLOSEBRACKET##\r\n    [bool] LoadFile([hashtable]$fileInfo) {\r\n        try {\r\n            # Use dot-sourcing to load in current scope\r\n            . $fileInfo.Path\r\n\r\n            $this.Log(\"✓ Loaded: $($fileInfo.Name)\", \"DEBUG\")\r\n            return $true\r\n\r\n        } catch {\r\n            $fileInfo.LastError = $_.Exception.Message\r\n            return $false\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Print loading summary\r\n    ##CLOSEBRACKET##\r\n    [void] PrintSummary() {\r\n        $this.Log(\"=== ClassLoader Summary ===\", \"INFO\")\r\n        $this.Log(\"Total files discovered: $($this.LoadStats.TotalFiles)\", \"INFO\")\r\n        $this.Log(\"Successfully loaded: $($this.LoadStats.Loaded)\", \"INFO\")\r\n        $this.Log(\"Failed: $($this.LoadStats.Failed)\", \"INFO\")\r\n        $this.Log(\"Skipped (tests): $($this.LoadStats.Skipped)\", \"INFO\")\r\n        $this.Log(\"Total retries: $($this.LoadStats.Retries)\", \"INFO\")\r\n\r\n        if ($this.FailedFiles.Count -gt 0) {\r\n            $this.Log(\"--- Failed Files ---\", \"ERROR\")\r\n            foreach ($f in $this.FailedFiles) {\r\n                $this.Log(\"  ✗ $($f.Name): $($f.LastError)\", \"ERROR\")\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Log message to console and file\r\n    ##CLOSEBRACKET##\r\n    [void] Log([string]$message, [string]$level) {\r\n        # Skip debug messages unless verbose\r\n        if ($level -eq \"DEBUG\" -and -not $this.VerboseLogging) {\r\n            return\r\n        }\r\n\r\n        # Log to PMC log file if available\r\n        if ($global:PmcTuiLogFile) {\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            $logLine = \"[$timestamp] [ClassLoader][$level] $message\"\r\n            Add-Content -Path $global:PmcTuiLogFile -Value $logLine\r\n        }\r\n\r\n        # Also log errors to file\r\n        if ($level -in @(\"ERROR\", \"WARN\")) {\r\n            # Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [ClassLoader] [$level] $message\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Enable verbose logging for troubleshooting\r\n    ##CLOSEBRACKET##\r\n    [void] EnableVerbose() {\r\n        $this.VerboseLogging = $true\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nHelper function to create and configure a standard PMC class loader\r\n\r\n.DESCRIPTION\r\nCreates a ClassLoader configured with standard PMC directory structure:\r\n- theme (priority 5) - Theme system\r\n- widgets (priority 10) - Base widgets\r\n- layout (priority 20) - Layout managers\r\n- base (priority 30) - Base screen classes\r\n- services (priority 40) - Service classes\r\n- screens (priority 50) - Concrete screens (lazy-loaded via menu)\r\n- helpers (priority 60) - Helper functions\r\n\r\n.PARAMETER baseDirectory\r\nRoot directory (typically $PSScriptRoot of Start-PmcTUI.ps1)\r\n\r\n.PARAMETER loadScreens\r\nWhether to pre-load all screens (default: $false for lazy loading)\r\n\r\n.EXAMPLE\r\n$loader = New-PmcClassLoader $PSScriptRoot\r\n$loader.LoadAll()\r\n##CLOSEBRACKET##\r\nfunction New-PmcClassLoader {\r\n    param(\r\n        [string]$baseDirectory,\r\n        [bool]$loadScreens = $false,\r\n        [bool]$verbose = $false\r\n    )\r\n\r\n    $loader = [ClassLoader]::new($baseDirectory)\r\n\r\n    if ($verbose -or ($global:PmcTuiLogLevel -ge 3)) {\r\n        $loader.EnableVerbose()\r\n    }\r\n\r\n    # Add directories in dependency order (lower priority = loaded first)\r\n    $loader.AddDirectory(\"theme\", 5)\r\n    $loader.AddDirectory(\"widgets\", 10)\r\n    $loader.AddDirectory(\"layout\", 20)\r\n    $loader.AddDirectory(\"base\", 30)\r\n    $loader.AddDirectory(\"services\", 40)\r\n\r\n    # Screens are typically lazy-loaded via MenuRegistry\r\n    # But can be pre-loaded for debugging or if lazy-loading causes issues\r\n    if ($loadScreens) {\r\n        $loader.AddDirectory(\"screens\", 50)\r\n    }\r\n\r\n    $loader.AddDirectory(\"helpers\", 60)\r\n\r\n    return $loader\r\n}\r\n"}, {"path": "module/Pmc.Strict/consoleui/DepsLoader.ps1", "content": "# ConsoleUI DepsLoader - loads dependencies from src/ (primary) and deps/ (ConsoleUI-specific only)\r\n# Eliminates duplication by using src/ as single source of truth\r\n\r\nparam()\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Paths\r\n$depsDir = Join-Path $PSScriptRoot 'deps'\r\n$srcDir = Join-Path $PSScriptRoot '../src'  # Pmc.Strict/consoleui/../src = Pmc.Strict/src\r\n\r\n# Verify paths exist\r\nif (-not (Test-Path $srcDir)) {\r\n    throw \"Source directory not found: $srcDir\"\r\n}\r\nif (-not (Test-Path $depsDir)) {\r\n    throw \"Deps directory not found: $depsDir\"\r\n}\r\n\r\n# NOTE: Most dependencies are already loaded by Pmc.Strict.psm1 module\r\n# Only load ConsoleUI-specific files here to avoid duplicate loading\r\n\r\n# Neutralize Export-ModuleMember calls in copied files\r\nfunction Export-ModuleMember { param([Parameter(ValueFromRemainingArguments=$true)]$args) }\r\n\r\n# Type normalization helpers (helpers/ - ConsoleUI-specific)\r\n. (Join-Path $PSScriptRoot 'helpers/TypeNormalization.ps1')\r\n. (Join-Path $PSScriptRoot 'helpers/ThemeLoader.ps1')\n. (Join-Path $PSScriptRoot 'helpers/ThemeHelper.ps1')\n\r\n# ConsoleUI-specific PmcTemplate class (UNIQUE to deps/)\r\n. (Join-Path $depsDir 'PmcTemplate.ps1')\r\n\r\n# Help content (UNIQUE to deps/ - curated for ConsoleUI)\r\n. (Join-Path $depsDir 'HelpContent.ps1')\r\n\r\n# Project utility function (UNIQUE to deps/)\r\n. (Join-Path $depsDir 'Project.ps1')\r\n\r\n# Excel integration (from src/, optional - will load if Excel is available)\r\ntry {\r\n    . (Join-Path $srcDir 'Excel.ps1')\r\n    # Initialize field mappings from disk or defaults\r\n    if (Get-Command Initialize-ExcelT2020Mappings -ErrorAction SilentlyContinue) {\r\n        Initialize-ExcelT2020Mappings\r\n    }\r\n} catch {\r\n    # Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [DepsLoader] Excel integration not available (Excel COM not installed)\"\r\n}\r\n\r\n# Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [DepsLoader] ConsoleUI deps loaded (from src/ + deps/ unique files)\""}, {"path": "module/Pmc.Strict/consoleui/GRADIENTS.md", "content": "# Gradient Themes Research\n## Updated: 2025-12-18 (Widget Integration Analysis)\n\n> Research for implementing foreground/text gradient themes.  \n> Background gradients are already handled by the render engine.\n\n---\n\n## Engine Architecture Verified\n\n**File:** `/home/teej/ztest/lib/SpeedTUI/Core/HybridRenderEngine.ps1`\n\n### Two WriteAt Overloads\n\n| Signature | Behavior |\n|-----------|----------|\n| `WriteAt(x, y, content)` | **Parses embedded ANSI** - per-char color in cell buffer |\n| `WriteAt(x, y, content, fg, bg)` | **Uniform color** - ignores embedded ANSI |\n\n### How ANSI Parsing Works (Lines 305-390)\n\n```powershell\nwhile ($i -lt $len) {\n    if ($content[$i] -eq \"`e\" -and $content[$i + 1] -eq '[') {\n        # Parse ANSI, update currentFg/currentBg state\n        $this._ParseAnsiState($cmd, $paramStr, [ref]$currentFg, [ref]$currentBg, ...)\n        continue\n    }\n    # Write cell with CURRENT color state (which ANSI just updated)\n    $this._backBuffer.SetCell($currentX, $finalY, $content[$i], $currentFg, $currentBg, ...)\n}\n```\n\n**Key:** Each character stored with its own FG/BG color in cell buffer. Differential rendering intact.\n\n---\n\n## Recommended Approach: Embedded ANSI String\n\nBuild gradient text with per-character ANSI codes, pass as one string:\n\n```powershell\n$gradientText = Get-GradientText -Text \"Hello\" -StartHex \"#ff00ff\" -EndHex \"#00ffff\"\n# Returns: \"\\e[38;2;255;0;255mH\\e[38;2;200;0;255me\\e[38;2;150;0;255ml...\"\n\n$engine.WriteAt($x, $y, $gradientText)  # 3-arg version, no fg/bg\n```\n\n**Result:**\n- One WriteAt call\n- Per-character gradient colors\n- Cell buffer tracks each character separately\n- Differential rendering works correctly\n- Widgets unchanged\n\n---\n\n## GradientHelper.ps1 - Already Implemented\n\nLocated at `consoleui/helpers/GradientHelper.ps1`:\n\n| Function | Purpose |\n|----------|---------|\n| `Get-GradientText` | Returns ANSI string with gradient |\n| `Write-GradientAt` | Writes per-char to engine with int colors |\n| `Get-SynthwaveGradient` | Preset magenta→cyan |\n| `Write-SynthwaveGradientAt` | Preset direct render |\n\n---\n\n## Widget Integration Analysis (2025-12-18)\n\n### Current Widget Pattern\n\nAll widgets use the **5-argument WriteAt** which applies uniform colors:\n\n```powershell\n$fg = $this.GetThemedInt('Foreground.Title')      # Returns packed int\n$bg = $this.GetThemedBgInt('Background.Widget', $width, 0)\n$engine.WriteAt($x, $y, \"Some text\", $fg, $bg)    # Uniform color\n```\n\n**Widgets bypass gradient support** by never using the 3-arg overload.\n\n### Why 5-arg vs 3-arg?\n\n| Overload | Performance | Gradient | Use Case |\n|----------|-------------|----------|----------|\n| 5-arg `(x,y,text,fg,bg)` | Fastest | ❌ No | Data rows, most UI |\n| 3-arg `(x,y,ansiText)` | ANSI parse overhead | ✅ Yes | Titles, accents |\n\n**Widgets use 5-arg for performance** - parsing ANSI per-character is slower for bulk content like list rows.\n\n### PmcThemeEngine Already Has Gradient Plumbing\n\n```powershell\n# PmcThemeEngine.GetBackgroundAnsi() supports both:\nif ($prop.Type -eq 'Solid') {\n    return $this._GetSolidAnsiCached($prop.Color, $true)\n}\nelseif ($prop.Type -eq 'Gradient') {\n    $gradient = $this._GetGradientArrayCached($propertyName, $prop, $width, $true)\n    return $gradient[$charIndex]  # Per-char gradient!\n}\n```\n\nBut widgets don't call per-character - they get one color and apply to whole string.\n\n---\n\n## Implementation Strategy: Option C (Theme-Declared Gradients)\n\n### Phase 1: Theme Schema (No Widget Changes)\n\nThemes declare gradient specs in `_BuildThemeProperties`:\n\n```powershell\n'Foreground.Title' = @{ \n    Type = 'Gradient'\n    Direction = 'Horizontal'\n    Stops = @(\n        @{ Position = 0.0; Color = '#ff00ff' }\n        @{ Position = 1.0; Color = '#00ffff' }\n    )\n}\n```\n\n### Phase 2: Helper in PmcWidget\n\nAdd `WriteThemedText` that auto-detects gradient vs solid:\n\n```powershell\n[void] WriteThemedText($engine, $x, $y, $text, $fgProp, $bgProp) {\n    $propInfo = [PmcThemeEngine]::GetInstance().GetPropertyInfo($fgProp)\n    if ($propInfo.Type -eq 'Gradient') {\n        Write-GradientAt -Engine $engine -X $x -Y $y -Text $text ...\n    } else {\n        $engine.WriteAt($x, $y, $text, $this.GetThemedInt($fgProp), ...)\n    }\n}\n```\n\n### Phase 3: Opt-In Per Widget\n\nOnly widgets wanting gradients upgrade to `WriteThemedText`. Others unchanged.\n\n---\n\n## Screens vs Widgets\n\n### Current Widgets (consoleui/widgets/)\n\n| Widget | Purpose | Gradient Candidate? |\n|--------|---------|---------------------|\n| PmcHeader | App title bar | ✅ Yes - titles look great |\n| PmcFooter | Keybind hints | Maybe - short text |\n| PmcMenuBar | Menu items | Maybe |\n| UniversalList | Data rows | ❌ No - performance |\n| TextInput | Input fields | ❌ No |\n| TagEditor | Tag chips | Maybe |\n| DatePicker | Calendar popup | ❌ No |\n| ProjectPicker | Project selector | ❌ No |\n\n**Most widgets don't need gradients** - they display data, not decorative text.\n\n### Screens Can Use Gradients Directly\n\nScreens control their own `RenderToEngine()`:\n\n```powershell\n# ThemeEditorScreen already does this:\n$title = Get-SynthwaveGradient \"Synthwave Theme\"\n$engine.WriteAt($x, $y, $title)  # 3-arg, gradient works!\n```\n\n**Screens don't need widget changes** - they can call `Get-GradientText` directly.\n\n---\n\n## Full Gradient Theme Without Widget Changes?\n\n**YES.** Here's what can be gradient TODAY without touching widgets:\n\n| Element | How | Works Now? |\n|---------|-----|------------|\n| Screen titles | Screen calls `Get-GradientText` | ✅ |\n| Theme preview text | Screen calls helper | ✅ |\n| About screen | Screen renders accent text | ✅ |\n| Help screen | Screen renders headers | ✅ |\n\n**Widgets showing data (lists, forms) stay solid** - which is correct. Data should be readable, not decorative.\n\n---\n\n## Semantic Colors (Overdue, Priority)\n\nCurrently hardcoded in `UI.ps1 Get-PmcCellStyle`:\n\n```powershell\nswitch ($p) {\n    '1' { return @{ Fg = 'Red';    Bold = $true } }  # HARDCODED\n    '2' { return @{ Fg = 'Yellow'; Bold = $true } }\n}\nif ($dt.Date -lt $today) { return @{ Fg = 'Red'; Bold = $true } }  # HARDCODED\n```\n\n**Fix:** Add to `_BuildThemeProperties`:\n\n```powershell\n'Semantic.Priority1' = @{ Type = 'Solid'; Color = '#ff5555' }\n'Semantic.Priority2' = @{ Type = 'Solid'; Color = '#ffcc00' }\n'Semantic.Overdue'   = @{ Type = 'Solid'; Color = '#ff3333' }\n'Semantic.DueSoon'   = @{ Type = 'Solid'; Color = '#ffaa00' }\n```\n\nThen `Get-PmcCellStyle` queries theme instead of hardcoding.\n\n---\n\n## Summary\n\n- **Gradient infrastructure exists** - Engine parses per-char ANSI\n- **Widgets don't need changes for v1** - screens can use gradients directly\n- **Widgets use 5-arg for performance** - correct for data display\n- **Option C is best** - theme declares, widgets opt-in later\n- **Semantic colors** just need properties added to theme\n- **Headers/footers** are still useful for consistent chrome\n"}, {"path": "module/Pmc.Strict/consoleui/IMPROVEMENTS.md", "content": "# Production Hardening - Completed Improvements\n\n## Summary\n\n**Total Impact**: -267 net lines (cleaner, more efficient code)\n- Added: +108 lines (diagnostics & safety)\n- Removed: -375 lines (commented debug code)\n\n---\n\n## 1. Enhanced Save Diagnostics ✅\n\n**File**: `services/TaskStore.ps1` (+108 lines)\n\n### Added Features:\n- **6-Phase Logging**: Tracks every step of save process\n  1. START - Log counts\n  2. In-memory backup creation\n  3. Persistent timestamped backup\n  4. Data structure building\n  5. Module invocation & save\n  6. Verification by reloading\n\n- **Persistent Backups**: \n  - Format: `tasks.json.backup.20231215-143527`\n  - Keeps last 5 automatically\n  - Protects against corruption\n\n- **Save Verification**:\n  - Reloads data after save\n  - Compares counts\n  - Throws error on mismatch\n\n- **Actionable Errors**:\n  - Clear error messages\n  - 4-step troubleshooting guide\n  - Exception type logging\n\n### Impact:\nWill immediately identify why \"task not saving\" bug occurs\n\n---\n\n## 2. Performance Cleanup ✅\n\n**Removed**: 375 commented debug lines from 14 files\n\n### Files Cleaned:\n- `ProjectInfoScreenV2.ps1` (-127 lines)\n- `ProjectInfoScreen.ps1` (-71 lines) \n- `PmcApplication.ps1` (-57 lines)\n- `StandardListScreen.ps1` (-34 lines)\n- `PmcScreen.ps1` (-27 lines)\n- `PmcMenuBar.ps1` (-13 lines)\n- `UniversalList.ps1` (-11 lines)\n- 7 more files...\n\n### Impact:\n- Cleaner, more readable code\n- No performance overhead from commented code\n- Smaller file sizes\n\n---\n\n## 3. Automated Testing ✅\n\n**Created**: `test-fixes.ps1`\n\n### Tests:\n1. ✓ TaskStore.ps1 syntax validation\n2. ✓ PmcApplication.ps1 syntax validation\n3. ✓ Start-PmcTUI.ps1 syntax validation\n4. ✓ New methods exist (_CreatePersistentBackup, _VerifySave)\n5. ✓ Enhanced logging present (6 phases)\n\n**Status**: 5/5 passing\n\n---\n\n## How to Use\n\n### Test Save Functionality:\n```bash\n# Run with debug logging\ncd /home/teej/ztest/module/Pmc.Strict/consoleui\npwsh ./Start-PmcTUI.ps1 -DebugLog -LogLevel 3\n\n# After adding a task, check logs:\ntail -100 /home/teej/ztest/module/.pmc-data/logs/pmc-tui-*.log | grep \"TaskStore.SaveData\"\n```\n\n### Expected Log Output:\n```\n[HH:mm:ss.fff] [INFO] TaskStore.SaveData: START - tasks=5 projects=2 timelogs=10\n[HH:mm:ss.fff] [DEBUG] TaskStore.SaveData: Creating in-memory backup\n[HH:mm:ss.fff] [DEBUG] TaskStore.SaveData: Creating persistent backup\n[HH:mm:ss.fff] [INFO] TaskStore.SaveData: Data structure built - tasks=5...\n[HH:mm:ss.fff] [INFO] TaskStore.SaveData: Calling Save-PmcData\n[HH:mm:ss.fff] [INFO] TaskStore.SaveData: Save-PmcData completed successfully\n[HH:mm:ss.fff] [DEBUG] TaskStore.SaveData: Verifying save\n[HH:mm:ss.fff] [INFO] TaskStore.SaveData: SUCCESS - Data saved and verified\n```\n\n### If Save Fails:\nLogs will show:\n- Exact phase that failed\n- Exception type and message\n- Stack trace\n- Actionable troubleshooting steps\n\n---\n\n## Verification\n\nRun automated tests:\n```bash\ncd /home/teej/ztest/module/Pmc.Strict/consoleui\npwsh ./test-fixes.ps1\n```\n\nClean-up script created:\n```bash\n# Already executed, but available for future use:\npwsh ./cleanup-debug-comments.ps1\n```\n\n---\n\n## Next Steps\n\n### Remaining Work:\n1. **Manual Testing Required**:\n   - Test actual TUI in full terminal\n   - Verify task saves persist\n   - Check rendering (needs real terminal)\n   - Verify screen fills properly (needs real terminal)\n\n2. **Additional Improvements** (if needed):\n   - Error handling enhancements\n   - Global state reduction\n   - Documentation updates\n\n### Known Limitations:\n- Rendering bugs need real terminal to diagnose\n- Screen sizing issues need real terminal\n- Cannot test visual aspects in test environment\n"}, {"path": "module/Pmc.Strict/consoleui/MANUAL-TESTING-NEEDED.md", "content": "# TUI Issues - What to Test Manually\n\n## Context\n- Antigravity environment has 21x10 terminal limit (expected)\n- User's real terminal should have proper size\n- Need to test in user's actual terminal, not through Antigravity\n\n## Reported Issues\n\n### 1. Task Not Saving ❌\n**User Report**: \"adding a task didnt save\"\n\n**What to Test**:\n1. Run TUI in your real terminal: `pwsh /home/teej/ztest/module/Pmc.Strict/consoleui/Start-PmcTUI.ps1`\n2. Press `a` to add a task\n3. Enter task details\n4. Press Enter to save\n5. Check if task appears in list\n6. Exit TUI (Ctrl+Q)\n7. Check `/home/teej/ztest/tasks.json` - does it have the new task?\n\n**Code Path**:\n- `TaskListScreen.OnItemCreated()` calls `Store.AddTask()`\n- `TaskStore.AddTask()` should save to disk\n- Located at: `/home/teej/ztest/module/Pmc.Strict/consoleui/services/TaskStore.ps1`\n\n**Possible Causes**:\n- TaskStore not flushing to disk\n- Validation failing silently\n- Error not being displayed\n\n### 2. Rendering Corruption ❌\n**User Report**: \"rendering is all wrong\" - shows \"B]\" and \"task\" fragments\n\n**What to Test**:\n1. Run TUI in your real terminal (NOT through Antigravity)\n2. Check if:\n   - Menu bar displays correctly at top\n   - Task list shows full columns\n   - No text fragments or corruption\n   - Screen fills entire terminal\n\n**Possible Causes**:\n- ANSI escape sequence issues\n- Column width calculations wrong\n- Cache invalidation problems\n- Z-index layering issues\n\n### 3. Screen Not Filling ❌\n**User Report**: \"tui should fill screen. it doesnt\"\n\n**What to Test**:\n1. Run TUI in full-size terminal\n2. Verify it uses entire terminal width/height\n3. Check if resizing terminal updates TUI size\n\n**Possible Causes**:\n- Terminal size detection using wrong values\n- Layout not applying correctly\n- Widgets using hardcoded sizes\n\n## What I've Fixed\n\n✅ **TimeListScreen Callbacks** - Added missing methods\n✅ **Config.ps1 Debug Logging** - Disabled 15 lines causing errors\n✅ **Test Scripts** - Created comprehensive test suite\n\n## What I Cannot Test\n\n❌ **Actual TUI in Real Terminal** - Antigravity environment has 21x10 limit\n❌ **Visual Rendering** - Need to see actual output in real terminal\n❌ **Task Persistence** - Need to verify files are actually written\n\n## Next Steps\n\n1. **User Testing Required**: Run TUI in your real terminal and report:\n   - Does task saving work?\n   - Is rendering correct?\n   - Does screen fill properly?\n   - Any error messages?\n\n2. **If Issues Persist**: Provide:\n   - Screenshot of TUI\n   - Contents of latest log file\n   - Output of: `echo $COLUMNS x $LINES` in your terminal\n   - Contents of `/home/teej/ztest/tasks.json` before and after adding task\n\n3. **Debugging Steps**:\n   ```bash\n   # Enable debug logging\n   pwsh /home/teej/ztest/module/Pmc.Strict/consoleui/Start-PmcTUI.ps1 -DebugLog -LogLevel 3\n   \n   # After testing, check log\n   tail -100 /home/teej/ztest/module/.pmc-data/logs/pmc-tui-*.log\n   ```\n"}, {"path": "module/Pmc.Strict/consoleui/PmcApplication.ps1", "content": "# PmcApplication - Main application wrapper integrating PMC widgets with SpeedTUI\n# Handles rendering engine, event loop, and screen management\n\nusing namespace System\nusing namespace System.Collections.Generic\n\nSet-StrictMode -Version Latest\n\n# NOTE: SpeedTUI, widgets, layout, and theme are loaded by Start-PmcTUI.ps1\n# Do not load them again here to avoid circular dependencies and duplicate loading\n\n<#\n.SYNOPSIS\nMain application class for PMC TUI\n\n.DESCRIPTION\nPmcApplication manages:\n- SpeedTUI rendering engine (OptimizedRenderEngine)\n- Screen stack and navigation\n- Event loop and input handling\n- Layout management\n- Theme management\n\n.EXAMPLE\n$container = [ServiceContainer]::new()\n$app = [PmcApplication]::new($container)\n$app.PushScreen($taskScreen)\n$app.Run()\n##CLOSEBRACKET##\nclass PmcApplication {\n    # === Core Components ===\n    [object]$RenderEngine\n    [object]$LayoutManager\n    [object]$ThemeManager\n    [object]$Container        # ServiceContainer for dependency injection\n\n    # === Screen Management ===\n    [object]$ScreenStack      # Stack of PmcScreen objects\n    [object]$CurrentScreen = $null   # Currently active screen\n\n    # === Terminal State ===\n    [int]$TermWidth = 80\n    [int]$TermHeight = 24\n    [bool]$Running = $false\n\n    # === Rendering State ===\n    [bool]$IsDirty = $true  # Dirty flag - true when redraw needed\n    [int]$RenderErrorCount = 0  # Track consecutive render errors for recovery\n\n    # === Automation Support ===\n    [string]$AutomationCommandFile = \"\"  # Path to command file for automation\n    [string]$AutomationOutputFile = \"\"   # Path to output capture file\n    [System.Collections.Queue]$CommandQueue = $null  # Queue of simulated key presses\n    [bool]$AutomationMode = $false       # Enable automation features\n\n    # === Event Handlers ===\n    [scriptblock]$OnTerminalResize = $null\n    [scriptblock]$OnError = $null\n\n    # === Constructor ===\n    PmcApplication([object]$container) {\n        # Store container for passing to screens\n        $this.Container = $container\n        # Initialize render engine (HybridRenderEngine with Layout System)\n        try {\n            $this.RenderEngine = New-Object HybridRenderEngine\n            if ($null -eq $this.RenderEngine) {\n                throw \"Failed to create HybridRenderEngine instance\"\n            }\n            $this.RenderEngine.Initialize()\n        }\n        catch {\n            # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcApplication] FATAL: Failed to initialize RenderEngine: $($_.Exception.Message)\"\n            throw\n        }\n\n        # Initialize layout manager\n        $this.LayoutManager = New-Object PmcLayoutManager\n\n        # Initialize theme manager\n        $this.ThemeManager = $container.Resolve('ThemeManager')\n\n        # Initialize screen stack\n        $this.ScreenStack = New-Object \"System.Collections.Generic.Stack[object]\"\n\n        # Get terminal size\n        $this._UpdateTerminalSize()\n    }\n\n    # === Screen Management ===\n\n    <#\n    .SYNOPSIS\n    Push a screen onto the stack and make it active\n\n    .PARAMETER screen\n    Screen object to push (should have Render() and HandleInput() methods)\n    ##CLOSEBRACKET##\n    [void] PushScreen([object]$screen) {\n        # Deactivate current screen\n        if ($this.CurrentScreen) {\n            if ($this.CurrentScreen.PSObject.Methods['OnExit']) {\n                $this.CurrentScreen.OnDoExit()\n            }\n        }\n\n        # DIFFERENTIAL RENDERING: Do NOT clear screen - let the new screen\n        # overwrite the old content naturally. This prevents flicker.\n\n        # Push new screen\n        $this.ScreenStack.Push($screen)\n        $this.CurrentScreen = $screen\n\n\n        # }\n\n        # Initialize screen with render engine and container\n        if ($screen.PSObject.Methods['Initialize']) {\n            $screen.Initialize($this.RenderEngine, $this.Container)\n        }\n\n        # Apply layout if screen has widgets\n        if ($screen.PSObject.Methods['ApplyLayout']) {\n            $screen.ApplyLayout($this.LayoutManager, $this.TermWidth, $this.TermHeight)\n        }\n\n        # Activate screen\n        if ($screen.PSObject.Methods['OnEnter']) {\n            $screen.OnEnter()\n        }\n\n        # Mark dirty for render\n        $this.IsDirty = $true\n\n    }\n\n    <#\n    .SYNOPSIS\n    Pop current screen and return to previous\n\n    .OUTPUTS\n    The popped screen object\n    ##CLOSEBRACKET##\n    [object] PopScreen() {\n        if ($this.ScreenStack.Count -eq 0) {\n            return $null\n        }\n\n        # Exit current screen\n        $poppedScreen = $this.ScreenStack.Pop()\n        if ($poppedScreen.PSObject.Methods['OnExit']) {\n            $poppedScreen.OnDoExit()\n        }\n\n        # DIFFERENTIAL RENDERING: Do NOT clear screen - let the previous screen\n        # overwrite the popped content naturally. This prevents flicker.\n\n        # Restore previous screen\n        if ($this.ScreenStack.Count -gt 0) {\n            $this.CurrentScreen = $this.ScreenStack.Peek()\n\n            # Re-enter previous screen\n            if ($this.CurrentScreen.PSObject.Methods['OnEnter']) {\n                $this.CurrentScreen.OnEnter()\n            }\n\n            # Mark dirty for render\n            $this.IsDirty = $true\n        }\n        else {\n            $this.CurrentScreen = $null\n        }\n\n        return $poppedScreen\n    }\n\n    <#\n    .SYNOPSIS\n    Clear screen stack and set a new root screen\n\n    .PARAMETER screen\n    New root screen\n    ##CLOSEBRACKET##\n    [void] SetRootScreen([object]$screen) {\n        # Clear stack\n        while ($this.ScreenStack.Count -gt 0) {\n            $this.PopScreen()\n        }\n\n        # Push new root\n        $this.PushScreen($screen)\n    }\n\n    # === Rendering ===\n\n    hidden [void] _RenderCurrentScreen() {\n        # }\n\n        if (-not $this.CurrentScreen) {\n            # }\n            return\n        }\n\n\n        # }\n\n        try {\n            # }\n\n            # Check if screen requests full clear\n            if ($this.CurrentScreen.NeedsClear) {\n                # }\n                $this.RenderEngine.RequestClear()\n                $this.CurrentScreen.NeedsClear = $false\n            }\n\n\n            # }\n\n            # USE SPEEDTUI PROPERLY - BeginFrame/WriteAt/EndFrame\n            $this.RenderEngine.BeginFrame()\n\n\n            # }\n\n            # Get screen output (ANSI strings with position info)\n            # Get screen output (ANSI strings with position info)\n            # Get screen output (ANSI strings with position info)\n            if ($this.CurrentScreen.PSObject.Methods['RenderToEngine']) {\n\n                # }\n                # New method: screen writes directly to engine\n                $this.CurrentScreen.RenderToEngine($this.RenderEngine)\n                # }\n            }\n            else {\n                # Legacy fallback removed - all screens must support RenderToEngine\n                throw \"Screen type '$($this.CurrentScreen.GetType().Name)' does not implement RenderToEngine\"\n            }\n\n\n            # }\n\n            # EndFrame does differential rendering\n            $this.RenderEngine.EndFrame()\n\n\n            # }\n\n            # Clear dirty flag after successful render\n            $this.IsDirty = $false\n\n\n            # }\n\n        }\n        catch {\n            # RENDER ERROR - Try to recover gracefully\n            $errorMsg = \"Render error: $_\"\n            $errorLocation = \"$($_.InvocationInfo.ScriptName):$($_.InvocationInfo.ScriptLineNumber)\"\n\n            # Log to file if available\n            if ($global:PmcTuiLogFile) {\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] $errorMsg\"\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] Location: $errorLocation\"\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] Line: $($_.InvocationInfo.Line)\"\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] Stack: $($_.ScriptStackTrace)\"\n            }\n\n            # Increment error count\n            if (-not $this.RenderErrorCount) { $this.RenderErrorCount = 0 }\n            $this.RenderErrorCount++\n\n            # If too many errors, then we need to fail\n            if ($this.RenderErrorCount -gt 10) {\n                # Too many errors - give up\n                [Console]::Clear()\n                [Console]::CursorVisible = $true\n                [Console]::SetCursorPosition(0, 0)\n                # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcApplication] TOO MANY RENDER ERRORS - EXITING\"\n                # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcApplication] Error: $errorMsg\"\n                # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcApplication] Location: $errorLocation\"\n                # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcApplication] The application experienced too many render errors.\"\n                # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcApplication] Please restart the application.\"\n\n                [Console]::ReadKey($true) | Out-Null\n                $this.Stop()\n                return\n            }\n\n            # Try to show error in a minimal way and continue\n            try {\n                # Clear screen and show error message\n                [Console]::Clear()\n                [Console]::SetCursorPosition(0, 0)\n                # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcApplication] Render Error Occurred\"\n                # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcApplication] Error: $($_.Exception.Message)\"\n\n                $key = [Console]::ReadKey($true)\n                if ($key.Key -eq 'Escape') {\n                    $this.Stop()\n                    return\n                }\n\n                # Try to recover by requesting full clear and redraw\n                $this.RenderEngine.RequestClear()\n                $this.IsDirty = $true\n\n                # If current screen is problematic, try to go back\n                if ($this.ScreenStack.Count -gt 1 -and $this.RenderErrorCount -gt 3) {\n                    # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcApplication] Returning to previous screen due to errors...\"\n                    Start-Sleep -Milliseconds 500\n                    $this.PopScreen()\n                    $this.RenderErrorCount = 0  # Reset counter after navigation\n                }\n\n            }\n            catch {\n                # Can't even show the error message - now we really need to exit\n                # }\n                $this.Stop()\n            }\n\n            # Call error handler if registered\n            if ($this.OnError) {\n                try {\n                    & $this.OnError $_\n                }\n                catch {\n                    # Error handler failed, log it but continue\n                    # }\n                }\n            }\n        }\n    }\n\n\n\n    # === Event Loop ===\n\n    <#\n    .SYNOPSIS\n    Start the application event loop\n\n    .DESCRIPTION\n    Runs until Stop() is called or screen stack is empty\n    ##CLOSEBRACKET##\n    [void] Run() {\n        $this.Running = $true\n\n        # Hide cursor\n        [Console]::CursorVisible = $false\n\n        # Track iterations for terminal size check optimization\n        $iteration = 0\n\n        try {\n            # Event loop - render only when dirty\n            # }\n\n\n            while ($this.Running -and $this.ScreenStack.Count -gt 0) {\n                $hadInput = $false\n\n                # Check for automation commands\n                if ($this.AutomationMode) {\n                    $this._ProcessAutomationCommands()\n                }\n\n                # Process queued automation commands first\n                if ($this.AutomationMode -and $this.CommandQueue.Count -gt 0) {\n                    $cmdString = $this.CommandQueue.Dequeue()\n                    # }\n\n                    try {\n                        $key = $this._ParseCommand($cmdString)\n\n                        # Global keys - Ctrl+Q to exit\n                        if ($key.Modifiers -eq [ConsoleModifiers]::Control -and $key.Key -eq 'Q') {\n                            $this.Stop()\n                        }\n                        elseif ($this.CurrentScreen -and $this.CurrentScreen.PSObject.Methods['HandleKeyPress']) {\n                            $handled = $this.CurrentScreen.HandleKeyPress($key)\n                            if ($handled) {\n                                $hadInput = $true\n                            }\n                        }\n\n                        # Capture screen after command\n                        $this._CaptureScreen()\n                    }\n                    catch {\n                        # }\n                    }\n                }\n\n                # OPTIMIZATION: Drain ALL available input before rendering\n                # This eliminates input lag from sleep delays\n                try {\n                    while ([Console]::KeyAvailable) {\n                        $key = [Console]::ReadKey($true)\n\n                        # Global keys - Ctrl+Q to exit\n                        if ($key.Modifiers -eq [ConsoleModifiers]::Control -and $key.Key -eq 'Q') {\n                            $this.Stop()\n                            break\n                        }\n\n                        # Pass to current screen (screen handles its own menu)\n                        if ($this.CurrentScreen) {\n                            if ($this.CurrentScreen.PSObject.Methods['HandleKeyPress']) {\n                                # }\n                                $handled = $this.CurrentScreen.HandleKeyPress($key)\n                                if ($handled) {\n                                    $hadInput = $true\n                                }\n                            }\n                            else {\n                                # }\n                            }\n                        }\n                    }\n                }\n                catch {\n                    # Console input is redirected or unavailable - skip input processing\n                    # This happens when running in non-interactive mode (e.g., piped input, automated tests)\n                    # }\n                }\n\n                # Mark dirty if we processed input\n                if ($hadInput) {\n                    $this.IsDirty = $true\n                }\n\n                # Capture dirty state before rendering\n                $wasActive = $this.IsDirty\n\n                # OPTIMIZATION: Use centralized terminal service for resize detection\n                # Only checks actual console every 100ms (cached)\n                if ((-not $this.IsDirty) -or ($iteration % 10 -eq 0)) {\n                    if (($this.RenderEngine.Width -ne [Console]::WindowWidth -or $this.RenderEngine.Height -ne [Console]::WindowHeight)) {\n                        $dims = @{ Width = [Console]::WindowWidth; Height = [Console]::WindowHeight }\n                        $this._HandleTerminalResize($dims.Width, $dims.Height)\n                    }\n                }\n\n                if ($this.IsDirty) {\n                    # Reset iteration counter when rendering\n                    $iteration = 0\n                }\n\n                $iteration++\n\n                # Only render when dirty (state changed)\n                if ($this.IsDirty) {\n                    # }\n                    $this._RenderCurrentScreen()\n                    $iteration = 0  # Reset counter after render\n                }\n\n                # Sleep longer when idle (no render) vs active\n                if ($wasActive) {\n                    Start-Sleep -Milliseconds 1  # ~1000 FPS max, instant response to input\n                }\n                else {\n                    Start-Sleep -Milliseconds 50  # ~20 FPS when idle, reduced from 100ms for better responsiveness\n                }\n            }\n\n        }\n        finally {\n            # CRITICAL: Flush pending changes before exit\n            try {\n                . \"$PSScriptRoot/services/TaskStore.ps1\"\n                $store = [TaskStore]::GetInstance()\n                if ($store.HasPendingChanges) {\n                    # Write-PmcTuiLog \"Flushing pending changes on exit...\" \"INFO\"\n                    $store.Flush()\n                }\n            }\n            catch {\n                # Write-PmcTuiLog \"Failed to flush data on exit: $_\" \"ERROR\"\n                # Continue with cleanup even if flush fails\n            }\n\n            # Cleanup\n            [Console]::CursorVisible = $true\n            [Console]::Clear()\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Stop the application event loop\n    ##CLOSEBRACKET##\n    [void] Stop() {\n        $this.Running = $false\n\n        # Flush any pending TaskStore changes before exit\n        try {\n            $store = [TaskStore]::GetInstance()\n            if ($null -ne $store -and $store.HasPendingChanges) {\n                $store.Flush()\n            }\n        }\n        catch {\n            # TaskStore might not be available during shutdown - safe to ignore\n            if (Get-Command Write-PmcTuiLog -ErrorAction SilentlyContinue) {\n                # Write-PmcTuiLog \"Stop: Could not flush TaskStore: $($_.Exception.Message)\" \"WARNING\"\n            }\n        }\n    }\n\n    # === Automation Methods ===\n\n    <#\n    .SYNOPSIS\n    Enable automation mode with command file and output capture\n\n    .PARAMETER CommandFile\n    Path to file containing commands (one per line)\n\n    .PARAMETER OutputFile\n    Path to file for capturing screen output\n    ##CLOSEBRACKET##\n    [void] EnableAutomation([string]$CommandFile, [string]$OutputFile) {\n        $this.AutomationMode = $true\n        $this.AutomationCommandFile = $CommandFile\n        $this.AutomationOutputFile = $OutputFile\n        $this.CommandQueue = New-Object System.Collections.Queue\n\n\n        # }\n    }\n\n    <#\n    .SYNOPSIS\n    Check for new commands and queue them\n    ##CLOSEBRACKET##\n    hidden [void] _ProcessAutomationCommands() {\n        if (-not $this.AutomationMode -or -not (Test-Path $this.AutomationCommandFile)) {\n            return\n        }\n\n        try {\n            $commands = Get-Content $this.AutomationCommandFile -ErrorAction SilentlyContinue\n            if ($commands) {\n                foreach ($cmd in $commands) {\n                    if ($cmd -and $cmd.Trim() -ne '') {\n                        $this.CommandQueue.Enqueue($cmd.Trim())\n                    }\n                }\n                # Clear the command file after reading\n                Clear-Content $this.AutomationCommandFile -ErrorAction SilentlyContinue\n\n\n                # }\n            }\n        }\n        catch {\n            # }\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Convert command string to ConsoleKeyInfo\n    ##CLOSEBRACKET##\n    hidden [System.ConsoleKeyInfo] _ParseCommand([string]$command) {\n        # Parse commands like \"j\", \"k\", \"Enter\", \"Ctrl+Q\", \"Escape\"\n        $parts = $command -split '\\+'\n        $modifiers = [ConsoleModifiers]::None\n        $keyName = $parts[-1]\n\n        # Parse modifiers\n        foreach ($part in $parts[0..($parts.Length - 2)]) {\n            switch ($part.ToLower()) {\n                'ctrl' { $modifiers = $modifiers -bor [ConsoleModifiers]::Control }\n                'alt' { $modifiers = $modifiers -bor [ConsoleModifiers]::Alt }\n                'shift' { $modifiers = $modifiers -bor [ConsoleModifiers]::Shift }\n            }\n        }\n\n        # Parse key\n        $key = [ConsoleKey]::A\n        $keyChar = [char]0\n\n        switch ($keyName.ToLower()) {\n            'enter' { $key = [ConsoleKey]::Enter; $keyChar = \"`r\" }\n            'escape' { $key = [ConsoleKey]::Escape; $keyChar = [char]27 }\n            'esc' { $key = [ConsoleKey]::Escape; $keyChar = [char]27 }\n            'tab' { $key = [ConsoleKey]::Tab; $keyChar = \"`t\" }\n            'space' { $key = [ConsoleKey]::Spacebar; $keyChar = ' ' }\n            'up' { $key = [ConsoleKey]::UpArrow; $keyChar = [char]0 }\n            'down' { $key = [ConsoleKey]::DownArrow; $keyChar = [char]0 }\n            'left' { $key = [ConsoleKey]::LeftArrow; $keyChar = [char]0 }\n            'right' { $key = [ConsoleKey]::RightArrow; $keyChar = [char]0 }\n            default {\n                # Single character\n                if ($keyName.Length -eq 1) {\n                    $keyChar = $keyName[0]\n                    $key = [ConsoleKey]::($keyName.ToUpper())\n                }\n            }\n        }\n\n        return New-Object System.ConsoleKeyInfo($keyChar, $key, ($modifiers -band [ConsoleModifiers]::Shift) -ne 0, ($modifiers -band [ConsoleModifiers]::Alt) -ne 0, ($modifiers -band [ConsoleModifiers]::Control) -ne 0)\n    }\n\n    <#\n    .SYNOPSIS\n    Capture current screen to output file\n    ##CLOSEBRACKET##\n    hidden [void] _CaptureScreen() {\n        if (-not $this.AutomationMode -or -not $this.AutomationOutputFile) {\n            return\n        }\n\n        try {\n            # Capture screen state information\n            $screenInfo = @\"\n=== Screen Capture $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') ===\nCurrent Screen: $($this.CurrentScreen.GetType().Name)\nTerminal Size: $($this.TermWidth)x$($this.TermHeight)\nScreen Stack Depth: $($this.ScreenStack.Count)\n\n\"@\n            # Try to capture current screen's rendered content\n            if ($this.CurrentScreen -and $this.CurrentScreen.PSObject.Properties['LastRenderedContent']) {\n                $screenInfo += \"Last Rendered Content:`n\"\n                $screenInfo += $this.CurrentScreen.LastRenderedContent\n                $screenInfo += \"`n\"\n            }\n\n            Add-Content -Path $this.AutomationOutputFile -Value $screenInfo\n        }\n        catch {\n            # }\n        }\n    }\n\n    # === Terminal Management ===\n\n    hidden [void] _UpdateTerminalSize() {\n        # Use centralized terminal service (cached, optimized)\n        $dims = @{ Width = [Console]::WindowWidth; Height = [Console]::WindowHeight }\n        $this.TermWidth = $dims.Width\n        $this.TermHeight = $dims.Height\n    }\n\n    hidden [void] _HandleTerminalResize([int]$newWidth, [int]$newHeight) {\n        $this.TermWidth = $newWidth\n        $this.TermHeight = $newHeight\n\n        # Notify current screen\n        if ($this.CurrentScreen) {\n            if ($this.CurrentScreen.PSObject.Methods['OnTerminalResize']) {\n                $this.CurrentScreen.OnTerminalResize($newWidth, $newHeight)\n            }\n\n            # Reapply layout\n            if ($this.CurrentScreen.PSObject.Methods['ApplyLayout']) {\n                $this.CurrentScreen.ApplyLayout($this.LayoutManager, $newWidth, $newHeight)\n            }\n        }\n\n        # Fire event\n        if ($this.OnTerminalResize) {\n            & $this.OnTerminalResize $newWidth $newHeight\n        }\n\n        # Mark dirty for render\n        $this.IsDirty = $true\n    }\n\n    # === Utility Methods ===\n\n    <#\n    .SYNOPSIS\n    Get current terminal size\n\n    .OUTPUTS\n    Hashtable with Width and Height properties\n    ##CLOSEBRACKET##\n    [hashtable] GetTerminalSize() {\n        return @{\n            Width  = $this.TermWidth\n            Height = $this.TermHeight\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Request a render on next frame\n\n    .DESCRIPTION\n    Schedules a re-render of the current screen by setting dirty flag\n    ##CLOSEBRACKET##\n    [void] RequestRender() {\n        if ($global:PmcTuiLogFile) {\n            $caller = (Get-PSCallStack)[1]\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] RequestRender called from: $($caller.Command) at line $($caller.ScriptLineNumber)\"\n        }\n        $this.IsDirty = $true\n    }\n}\n\n# Classes exported automatically in PowerShell 5.1+\n"}, {"path": "module/Pmc.Strict/consoleui/PmcScreen.ps1", "content": "# PmcScreen - Base class for all PMC screens\n# Provides standard screen lifecycle, layout, and widget management\n\nusing namespace System.Collections.Generic\nusing namespace System.Text\n\nSet-StrictMode -Version Latest\n\n# NOTE: All dependencies are loaded by Start-PmcTUI.ps1\n# Do not load them again here to avoid circular dependencies and duplicate loading\n\n<#\n.SYNOPSIS\nBase class for all PMC screens\n\n.DESCRIPTION\nPmcScreen provides:\n- Standard widget composition (MenuBar, Header, Footer, StatusBar, Content)\n- Layout management integration\n- Screen lifecycle (OnEnter, OnExit, LoadData)\n- Input handling delegation\n- Rendering orchestration\n- ServiceContainer dependency injection\n\n.EXAMPLE\n# Example: Custom screen implementation with ServiceContainer\n# class MyCustomScreen : PmcScreen {\n#     MyCustomScreen([object]$container) : base(\"MyScreen\", \"My Screen Title\", $container) {\n#         $this.Header.SetBreadcrumb(@(\"Home\", \"My Screen\"))\n#     }\n#\n#     [void] LoadData() {\n#         # Access services via container\n#         $taskStore = $this.Container.Get('TaskStore')\n#         # Load your data...\n#     }\n#\n#     [string] RenderContent() {\n#         # Render your content...\n#     }\n#\n# Example: Legacy constructor (backward compatible)\n# class MyLegacyScreen : PmcScreen {\n#     MyLegacyScreen() : base(\"MyScreen\", \"My Screen Title\") {\n#         # Works without container for backward compatibility\n#     }\n##CLOSEBRACKET##\nclass PmcScreen {\n    # === Core Properties ===\n    [string]$ScreenKey = \"\"\n    [string]$ScreenTitle = \"\"\n\n    # === Service Container ===\n    [object]$Container = $null\n\n    # === Standard Widgets ===\n    [object]$MenuBar = $null\n    [object]$Header = $null\n    [object]$Footer = $null\n    [object]$StatusBar = $null\n    [object]$ContentWidgets\n\n    # === Layout ===\n    [object]$LayoutManager = $null\n    [int]$TermWidth = 80\n    [int]$TermHeight = 24\n\n    # === State ===\n    [bool]$IsActive = $false\n    [object]$RenderEngine = $null\n    [bool]$NeedsClear = $false  # Request full screen clear before next render\n\n    # === Layout Methods ===\n\n    <#\n    .SYNOPSIS\n    Handle screen resizing\n    ##CLOSEBRACKET##\n    [void] Resize([int]$width, [int]$height) {\n        $this.TermWidth = $width\n        $this.TermHeight = $height\n\n        # Delegate to ApplyLayout for correct positioning\n        # ApplyLayout uses PmcLayoutManager which has the correct constraints:\n        # - Footer: Y = 'BOTTOM-2' (height - 2)\n        # - StatusBar: Y = 'BOTTOM' (height - 1)\n        if ($this.LayoutManager) {\n            $this.ApplyLayout($this.LayoutManager, $width, $height)\n        }\n    }\n\n    # H-UI-4: Message queue for persistent status messages\n    [System.Collections.Queue]$_messageQueue = [System.Collections.Queue]::new()\n    [DateTime]$_lastMessageTime = [DateTime]::MinValue\n\n    # === Event Handlers ===\n    [scriptblock]$OnEnterHandler = $null\n    [scriptblock]$OnExitHandler = $null\n\n    # === Constructor (backward compatible - no container) ===\n    PmcScreen([string]$key, [string]$title) {\n\n        $this.ScreenKey = $key\n        $this.ScreenTitle = $title\n        $this.ContentWidgets = New-Object 'System.Collections.Generic.List[object]'\n\n        # Create default widgets\n        $this._CreateDefaultWidgets()\n    }\n\n    # === Constructor (with ServiceContainer) ===\n    PmcScreen([string]$key, [string]$title, [object]$container) {\n\n        $this.ScreenKey = $key\n        $this.ScreenTitle = $title\n        $this.Container = $container\n        $this.ContentWidgets = New-Object 'System.Collections.Generic.List[object]'\n\n\n\n        # Create default widgets\n        $this._CreateDefaultWidgets()\n    }\n\n    hidden [void] _CreateDefaultWidgets() {\n        # Menu bar - use shared MenuBar if available (populated by TaskListScreen)\n        # CRITICAL: Check if variable exists AND is not null\n        if ((Get-Variable -Name PmcSharedMenuBar -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcSharedMenuBar) {\n            $this.MenuBar = $global:PmcSharedMenuBar\n        }\n        else {\n            # Create default empty MenuBar (will be populated by TaskListScreen)\n            $this.MenuBar = New-Object PmcMenuBar\n\n            $this.MenuBar.AddMenu(\"Tasks\", 'T', @())\n            $this.MenuBar.AddMenu(\"Projects\", 'P', @())\n            $this.MenuBar.AddMenu(\"Time\", 'M', @())\n            $this.MenuBar.AddMenu(\"Tools\", 'L', @())\n            $this.MenuBar.AddMenu(\"Options\", 'O', @())\n            $this.MenuBar.AddMenu(\"Help\", '?', @())\n        }\n\n        # Header\n        $this.Header = New-Object PmcHeader -ArgumentList $this.ScreenTitle\n\n        # Footer with standard shortcuts\n        $this.Footer = New-Object PmcFooter\n        $this.Footer.AddShortcut(\"Esc\", \"Back\")\n        $this.Footer.AddShortcut(\"F10\", \"Menu\")\n\n        # Status bar\n        $this.StatusBar = New-Object PmcStatusBar\n        $this.StatusBar.SetLeftText(\"Ready\")\n    }\n\n    # === Lifecycle Methods ===\n\n    <#\n    .SYNOPSIS\n    Called when screen becomes active\n\n    .DESCRIPTION\n    Override to perform initialization when screen is displayed\n    ##CLOSEBRACKET##\n    [void] OnEnter() {\n        # Ensure cursor is hidden by default (widgets will handle their own cursor rendering)\n        try {\n            [Console]::CursorVisible = $false\n        } catch {\n            # Ignore if console not available (e.g. in tests)\n        }\n\n        # Ensure menu bar is populated if empty\n        if ($null -ne $this.MenuBar -and $this.MenuBar.Menus.Count -eq 0) {\n            # Write-PmcTuiLog \"PmcScreen.OnEnter: MenuBar empty, attempting to populate from registry\" \"DEBUG\"\n            if ($null -ne $global:PmcMenuRegistry) {\n                # Write-PmcTuiLog \"PmcScreen.OnEnter: Registry found, rebuilding menus\" \"DEBUG\"\n                $global:PmcMenuRegistry.BuildMenuBar($this.MenuBar)\n            }\n        }\n\n        $this.IsActive = $true\n        $this.LoadData()\n\n        if ($this.OnEnterHandler) {\n            & $this.OnEnterHandler $this\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Called when screen becomes inactive\n\n    .DESCRIPTION\n    Override to perform cleanup when leaving screen\n    ##CLOSEBRACKET##\n    [void] OnDoExit() {\n        $this.IsActive = $false\n\n        if ($this.OnExitHandler) {\n            & $this.OnExitHandler $this\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Load data for this screen\n\n    .DESCRIPTION\n    Override to load screen-specific data\n    ##CLOSEBRACKET##\n    [void] LoadData() {\n        # Override in subclass\n    }\n\n    # === Layout Management ===\n\n    <#\n    .SYNOPSIS\n    Apply layout to all widgets\n\n    .PARAMETER layoutManager\n    Layout manager instance\n\n    .PARAMETER termWidth\n    Terminal width\n\n    .PARAMETER termHeight\n    Terminal height\n    ##CLOSEBRACKET##\n    [void] ApplyLayout([object]$layoutManager, [int]$termWidth, [int]$termHeight) {\n        try {\n            $this.LayoutManager = $layoutManager\n            $this.TermWidth = $termWidth\n            $this.TermHeight = $termHeight\n\n            # Apply layout to standard widgets\n            if ($this.MenuBar) {\n                $rect = $layoutManager.GetRegion('MenuBar', $termWidth, $termHeight)\n                $this.MenuBar.SetPosition($rect.X, $rect.Y)\n                $this.MenuBar.SetSize($rect.Width, $rect.Height)\n            }\n\n            if ($this.Header) {\n                $rect = $layoutManager.GetRegion('Header', $termWidth, $termHeight)\n                $this.Header.SetPosition($rect.X, $rect.Y)\n                $this.Header.SetSize($rect.Width, $rect.Height)\n            }\n\n            if ($this.Footer) {\n                $rect = $layoutManager.GetRegion('Footer', $termWidth, $termHeight)\n                $this.Footer.SetPosition($rect.X, $rect.Y)\n                $this.Footer.SetSize($rect.Width, $rect.Height)\n            }\n\n            if ($this.StatusBar) {\n                $rect = $layoutManager.GetRegion('StatusBar', $termWidth, $termHeight)\n                $this.StatusBar.SetPosition($rect.X, $rect.Y)\n                $this.StatusBar.SetSize($rect.Width, $rect.Height)\n            }\n\n            # Apply layout to content widgets\n            $this.ApplyContentLayout($layoutManager, $termWidth, $termHeight)\n        }\n        catch {\n            # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcScreen] FATAL ERROR PmcScreen.ApplyLayout: $_\"\n            # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcScreen] Stack: $($_.ScriptStackTrace)\"\n            throw\n        }\n    }\n\n\n    <#\n    .SYNOPSIS\n    Apply layout to content area widgets\n\n    .DESCRIPTION\n    Override to position custom content widgets\n    ##CLOSEBRACKET##\n    [void] ApplyContentLayout([PmcLayoutManager]$layoutManager, [int]$termWidth, [int]$termHeight) {\n        # Override in subclass to position content widgets\n    }\n\n    <#\n    .SYNOPSIS\n    Handle terminal resize\n\n    .PARAMETER newWidth\n    New terminal width\n\n    .PARAMETER newHeight\n    New terminal height\n    ##CLOSEBRACKET##\n    [void] OnTerminalResize([int]$newWidth, [int]$newHeight) {\n        if ($this.LayoutManager) {\n            $this.ApplyLayout($this.LayoutManager, $newWidth, $newHeight)\n        }\n    }\n\n    # === Rendering ===\n\n    <#\n    .SYNOPSIS\n    Initialize widgets with render engine\n\n    .PARAMETER renderEngine\n    SpeedTUI render engine instance\n    ##CLOSEBRACKET##\n    # Initialize with render engine only (backward compatible)\n    [void] Initialize([object]$renderEngine) {\n        $this.Initialize($renderEngine, $null)\n    }\n\n    # Initialize with render engine and container (new pattern)\n    [void] Initialize([object]$renderEngine, [object]$container) {\n        $this.RenderEngine = $renderEngine\n\n        # Store container if provided\n        if ($container) {\n            $this.Container = $container\n        }\n\n        # Initialize standard widgets\n        if ($this.MenuBar) {\n            $this.MenuBar.Initialize($renderEngine)\n        }\n        if ($this.Header) {\n            $this.Header.Initialize($renderEngine)\n        }\n        if ($this.Footer) {\n            $this.Footer.Initialize($renderEngine)\n        }\n        if ($this.StatusBar) {\n            $this.StatusBar.Initialize($renderEngine)\n        }\n\n        # Initialize content widgets\n        foreach ($widget in $this.ContentWidgets) {\n            $widget.Initialize($renderEngine)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Legacy Render method - DEPRECATED\n    \n    .DESCRIPTION\n    This method has been removed to enforce native rendering.\n    All rendering must now be done via RenderToEngine().\n    ##CLOSEBRACKET##\n    [string] Render() {\n        throw \"LEGACY RENDER CALLED: All screens must implement RenderToEngine(). This method is deprecated and removed.\"\n    }\n\n    <#\n    .SYNOPSIS\n    Legacy RenderContent method - DEPRECATED\n    ##CLOSEBRACKET##\n    [string] RenderContent() {\n        return \"\"\n    }\n\n    <#\n    .SYNOPSIS\n    Render directly to engine\n\n    .PARAMETER engine\n    RenderEngine instance to write to\n\n    .DESCRIPTION\n    Renders screen by calling widget Render() methods and writing ANSI output to engine.\n    Widgets use SpeedTUI's Render() → OnRender() pattern which returns ANSI strings.\n    We parse those ANSI strings and write them to the engine using WriteAt().\n    ##CLOSEBRACKET##\n    [void] RenderToEngine([object]$engine) {\n        # Z-INDEX LAYER RENDERING\n        # All rendering now uses explicit layers for proper z-ordering.\n\n        # Layer 0: Background (Fill entire screen with theme background)\n        # STRICT THEME ENFORCEMENT: No fallbacks. If theme property is missing, this MUST fail.\n        $engine.BeginLayer([ZIndex]::Background)\n        try {\n            $fg = $this.GetThemedInt('Foreground.Primary')\n            $bg = $this.GetThemedInt('Background.Primary')\n            # Fill entire terminal with background color\n            $engine.Fill(0, 0, $this.TermWidth, $this.TermHeight, ' ', $fg, $bg)\n        }\n        catch {\n            # Fallback if theme fails (shouldn't happen with strict mode, but safe for base class)\n        }\n\n        # Layer 50: Header\n        $engine.BeginLayer([ZIndex]::Header)\n        if ($this.Header) {\n            try {\n                if ($this.Header.PSObject.Methods['RenderToEngine']) {\n                    $this.Header.RenderToEngine($engine)\n                }\n            }\n            catch {\n                $this._HandleWidgetRenderError(\"Header\", $_, $engine, 1)\n            }\n        }\n\n        # Layer 10: Content (main screen content)\n        $engine.BeginLayer([ZIndex]::Content)\n        try {\n            if ($this.PSObject.Methods['RenderContentToEngine'] -and\n                $this.GetType().GetMethod('RenderContentToEngine').DeclaringType.Name -ne 'PmcScreen') {\n                $this.RenderContentToEngine($engine)\n            }\n        }\n        catch {\n            $this._HandleWidgetRenderError(\"RenderContent\", $_, $engine, 5)\n        }\n\n        # Layer 20: Panel (content widgets like FilterPanel, DatePicker, etc.)\n        $engine.BeginLayer([ZIndex]::Panel)\n        $widgetRow = 10\n        # Write-PmcTuiLog \"PmcScreen.RenderToEngine: Rendering $($this.ContentWidgets.Count) content widgets\" \"DEBUG\"\n        foreach ($widget in $this.ContentWidgets) {\n            $widgetName = $(if ($widget.Name) { $widget.Name } else { $widget.GetType().Name })\n\n            # Skip widgets that are explicitly hidden via Visible property\n            if ($widget.PSObject.Properties['Visible'] -and -not $widget.Visible) {\n                continue\n            }\n\n            try {\n                if ($widget.PSObject.Methods['RenderToEngine']) {\n                    # Write-PmcTuiLog \"PmcScreen: Calling RenderToEngine on $widgetName\" \"DEBUG\"\n                    $widget.RenderToEngine($engine)\n                }\n                else {\n                    # Write-PmcTuiLog \"PmcScreen: Widget $widgetName missing RenderToEngine method\" \"WARN\"\n                }\n            }\n            catch {\n                $this._HandleWidgetRenderError($widgetName, $_, $engine, $widgetRow)\n                $widgetRow += 2\n            }\n        }\n\n        # Layer 55: Footer\n        $engine.BeginLayer([ZIndex]::Footer)\n        if ($this.Footer) {\n            try {\n                if ($this.Footer.PSObject.Methods['RenderToEngine']) {\n                    $this.Footer.RenderToEngine($engine)\n                }\n            }\n            catch {\n                $footerRow = [Math]::Max(20, $this.TermHeight - 4)\n                $this._HandleWidgetRenderError(\"Footer\", $_, $engine, $footerRow)\n            }\n        }\n\n        # Layer 65: StatusBar\n        $engine.BeginLayer([ZIndex]::StatusBar)\n        if ($this.StatusBar) {\n            try {\n                if ($this.StatusBar.PSObject.Methods['RenderToEngine']) {\n                    $this.StatusBar.RenderToEngine($engine)\n                }\n            }\n            catch {\n                $statusRow = [Math]::Max(22, $this.TermHeight - 2)\n                $this._HandleWidgetRenderError(\"StatusBar\", $_, $engine, $statusRow)\n            }\n        }\n\n        # Layer 100: Dropdown (MenuBar with dropdowns)\n        # CRITICAL: Render MenuBar LAST with highest z-index\n        $engine.BeginLayer([ZIndex]::Dropdown)\n        if ($this.MenuBar) {\n            try {\n                if ($this.MenuBar.PSObject.Methods['RenderToEngine']) {\n                    $this.MenuBar.RenderToEngine($engine)\n                }\n            }\n            catch {\n                $this._HandleWidgetRenderError(\"MenuBar\", $_, $engine, 0)\n            }\n        }\n    }\n\n\n    <#\n    .SYNOPSIS\n    Handle widget render errors gracefully\n\n    .DESCRIPTION\n    Shows error inline without crashing the app, logs the error,\n    and allows the rest of the UI to continue rendering.\n    ##CLOSEBRACKET##\n    hidden [void] _HandleWidgetRenderError([string]$widgetName, [object]$error, [object]$engine, [int]$row) {\n        $errorMsg = \"$widgetName render failed: $($error.Exception.Message)\"\n        $stackTrace = $error.ScriptStackTrace\n\n        # Log error details\n        if ($global:PmcTuiLogFile) {\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] Widget render error: $errorMsg\"\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] Stack: $stackTrace\"\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] TargetObject: $($error.TargetObject)\"\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] InvocationInfo: $($error.InvocationInfo.Line)\"\n        }\n\n        # Show error inline where widget would have rendered\n        try {\n            $engine.WriteAt(2, $row, \"`e[1;31m[!] $widgetName Error: $($error.Exception.Message -replace \"`n\", \" \")`e[0m\")\n\n            # If status bar is available, also show error there\n            if ($this.StatusBar) {\n                $this.SetStatusMessage(\"$widgetName render failed - see logs\", \"error\")\n            }\n        }\n        catch {\n            # If we can't even write the error, just log it\n        }\n    }\n\n\n\n    <#\n    .SYNOPSIS\n    Render content area directly to engine\n\n    .PARAMETER engine\n    RenderEngine instance\n\n    .DESCRIPTION\n    Override in subclass to render screen-specific content directly\n    to the engine without ANSI string building.\n    ##CLOSEBRACKET##\n    [void] RenderContentToEngine([object]$engine) {\n        # Override in subclass for direct engine rendering\n        # This is the new high-performance path\n    }\n\n    # === Input Handling ===\n\n    <#\n    .SYNOPSIS\n    Handle keyboard input\n\n    .PARAMETER keyInfo\n    Console key info\n\n    .OUTPUTS\n    Boolean indicating if input was handled\n    ##CLOSEBRACKET##\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\n        # MenuBar gets priority (if active)\n        if ($this.MenuBar -and $this.MenuBar.IsActive) {\n            if ($this.MenuBar.HandleKeyPress($keyInfo)) {\n                return $true\n            }\n        }\n\n        # F10 activates menu bar\n        if ($keyInfo.Key -eq 'F10' -and $this.MenuBar) {\n            $this.MenuBar.Activate()\n            return $true\n        }\n\n        # Pass to content widgets FIRST (in reverse order for z-index)\n        # CRITICAL FIX #5: Check widgets before menu Alt-keys to prevent conflicts with focused editors\n        for ($i = $this.ContentWidgets.Count - 1; $i -ge 0; $i--) {\n            $widget = $this.ContentWidgets[$i]\n            if ($widget.PSObject.Methods['HandleKeyPress']) {\n                if ($widget.HandleKeyPress($keyInfo)) {\n                    return $true\n                }\n            }\n        }\n\n        # Alt+letter hotkeys activate menu bar (only if no widget handled it)\n        # CRITICAL FIX #5: Moved AFTER widget handling to prevent conflicts\n        if ($this.MenuBar -and ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt)) {\n            if ($this.MenuBar.HandleKeyPress($keyInfo)) {\n                return $true\n            }\n        }\n\n        # Pass to subclass\n        return $this.HandleInput($keyInfo)\n    }\n\n    <#\n    .SYNOPSIS\n    Handle screen-specific input\n\n    .DESCRIPTION\n    Override in subclass to handle custom input\n\n    .PARAMETER keyInfo\n    Console key info\n\n    .OUTPUTS\n    Boolean indicating if input was handled\n    ##CLOSEBRACKET##\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\n        # Override in subclass\n        return $false\n    }\n\n    # === Widget Management ===\n\n    <#\n    .SYNOPSIS\n    Add a widget to the content area\n\n    .PARAMETER widget\n    Widget to add\n    ##CLOSEBRACKET##\n    [void] AddContentWidget([PmcWidget]$widget) {\n        # Write-PmcTuiLog \"PmcScreen.AddContentWidget: Adding $($widget.GetType().Name) (Total: $($this.ContentWidgets.Count + 1))\" \"DEBUG\"\n        $this.ContentWidgets.Add($widget)\n\n        # Initialize if render engine available\n        if ($this.RenderEngine) {\n            $widget.Initialize($this.RenderEngine)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Remove a widget from the content area\n\n    .PARAMETER widget\n    Widget to remove\n    ##CLOSEBRACKET##\n    [void] RemoveContentWidget([PmcWidget]$widget) {\n        $this.ContentWidgets.Remove($widget)\n    }\n\n    # === Service Container Methods ===\n\n    <#\n    .SYNOPSIS\n    Get a service from the container\n\n    .PARAMETER serviceName\n    Name of the service to retrieve\n\n    .OUTPUTS\n    Service instance or $null if container not available or service not found\n\n    .EXAMPLE\n    $taskStore = $this.GetService('TaskStore')\n    ##CLOSEBRACKET##\n    [object] GetService([string]$serviceName) {\n        if ($null -eq $this.Container) {\n            return $null\n        }\n\n        try {\n            $service = $this.Container.Get($serviceName)\n            return $service\n        }\n        catch {\n            return $null\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Get themed foreground color as packed RGB integer\n\n    .PARAMETER role\n    Theme property name (e.g., 'Foreground.Primary')\n\n    .OUTPUTS\n    Int - Packed RGB integer or -1\n    ##CLOSEBRACKET##\n    [int] GetThemedInt([string]$role) {\n        $engine = [PmcThemeEngine]::GetInstance()\n        return $engine.GetForegroundInt($role)\n    }\n\n    <#\n    .SYNOPSIS\n    Get themed background color as packed RGB integer\n\n    .PARAMETER role\n    Theme property name (e.g., 'Background.Primary')\n\n    .PARAMETER width\n    Width for gradient calculation\n\n    .PARAMETER charIndex\n    Character index for gradient calculation\n\n    .OUTPUTS\n    Int - Packed RGB integer or -1\n    ##CLOSEBRACKET##\n    [int] GetThemedBgInt([string]$role, [int]$width, [int]$charIndex) {\n        $engine = [PmcThemeEngine]::GetInstance()\n        return $engine.GetBackgroundInt($role, $width, $charIndex)\n    }\n\n    <#\n    .SYNOPSIS\n    Check if a service is available in the container\n\n    .PARAMETER serviceName\n    Name of the service to check\n\n    .OUTPUTS\n    Boolean indicating if service is available\n\n    .EXAMPLE\n    if ($this.HasService('TaskStore')) { ... }\n    ##CLOSEBRACKET##\n    [bool] HasService([string]$serviceName) {\n        if ($null -eq $this.Container) {\n            return $false\n        }\n\n        try {\n            return $this.Container.Has($serviceName)\n        }\n        catch {\n            return $false\n        }\n    }\n\n    # === Utility Methods ===\n\n    <#\n    .SYNOPSIS\n    Show a message in the status bar\n\n    .PARAMETER message\n    Message to display\n    ##CLOSEBRACKET##\n    [void] ShowStatus([string]$message) {\n        if ($this.StatusBar) {\n            # H-UI-4: Queue message with timestamp for persistence\n            $this._messageQueue.Enqueue(@{ Message = $message; Type = 'info'; Time = [DateTime]::Now })\n            $this._lastMessageTime = [DateTime]::Now\n            $this.StatusBar.SetLeftText($message)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Show an error in the status bar\n\n    .PARAMETER message\n    Error message\n    ##CLOSEBRACKET##\n    [void] ShowError([string]$message) {\n        if ($this.StatusBar) {\n            $this.StatusBar.ShowError($message)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Show a success message in the status bar\n\n    .PARAMETER message\n    Success message\n\n    .PARAMETER autoSaved\n    L-POL-6: If true, append \"Saved.\" to indicate auto-save occurred\n    ##CLOSEBRACKET##\n    [void] ShowSuccess([string]$message) {\n        $this.ShowSuccess($message, $false)\n    }\n\n    [void] ShowSuccess([string]$message, [bool]$autoSaved) {\n        if ($this.StatusBar) {\n            # L-POL-6: Append \"Saved.\" indicator when auto-save is active\n            $displayMessage = $(if ($autoSaved) {\n                    \"$message Saved.\"\n                }\n                else {\n                    $message\n                })\n            $this.StatusBar.ShowSuccess($displayMessage)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    L-POL-3: Show loading message with consistent format\n\n    .PARAMETER itemType\n    Type of items being loaded (e.g., \"tasks\", \"projects\", \"notes\")\n    ##CLOSEBRACKET##\n    [void] ShowLoading([string]$itemType) {\n        $this.ShowStatus(\"Loading $itemType...\")\n    }\n\n    <#\n    .SYNOPSIS\n    L-POL-3: Show loaded message with count\n\n    .PARAMETER itemType\n    Type of items loaded (e.g., \"tasks\", \"projects\", \"notes\")\n\n    .PARAMETER count\n    Number of items loaded\n    ##CLOSEBRACKET##\n    [void] ShowLoaded([string]$itemType, [int]$count) {\n        $this.ShowStatus(\"Loaded $count $itemType\")\n    }\n\n    <#\n    .SYNOPSIS\n    L-POL-3: Show ready message after loading complete\n\n    .PARAMETER itemType\n    Optional type of items ready (defaults to \"Ready\")\n    ##CLOSEBRACKET##\n    [void] ShowReady() {\n        $this.ShowReady(\"\")\n    }\n\n    [void] ShowReady([string]$itemType) {\n        $message = $(if ([string]::IsNullOrWhiteSpace($itemType)) {\n                \"Ready\"\n            }\n            else {\n                \"$itemType ready\"\n            })\n        $this.ShowStatus($message)\n    }\n}\n\n# Classes exported automatically in PowerShell 5.1+\n"}, {"path": "module/Pmc.Strict/consoleui/REPORT.md", "content": "# PMC TUI Architecture Review - VERIFIED Findings\n## Updated: 2025-12-17 (Post-Cleanup)\n\n**Active Screens:** 23 (20 archived to `ARCHIVED_UNUSED_SCREENS_20251217/`)\n\n---\n\n## COMPLETED FIXES\n\n### Dead Code Removed ✅\n\nRemoved legacy `[string] Render()` methods that were never called:\n\n| Screen | Action | Lines Removed |\n|--------|--------|---------------|\n| ExcelImportScreen.ps1 | Converted to RenderToEngine() | ~154 |\n| ChecklistEditorScreen.ps1 | Removed dead stub | 1 |\n| TaskListScreen.ps1 | Removed dead stub | 1 |\n\n---\n\n## FALSE POSITIVES - NOT ISSUES\n\n| Claimed Issue | Reality |\n|--------------|---------|\n| Widget init inconsistency | Only 2 screens override Initialize() |\n| Error handling inconsistency | SetStatusMessage IS the standard (12 screens) |\n| 91 coordinate violations | Widgets positioning child widgets - CORRECT |\n| SetStatusMessage doesn't exist | EXISTS in StandardListScreen |\n\n---\n\n## RESOLVED ISSUES\n\n- ✅ Dead Render() methods - Removed from 3 screens\n- ✅ StandardListScreen - Uses LayoutManager\n- ✅ PmcApplication - Removed RequestClear() from PushScreen/PopScreen\n- ✅ UniversalList - Added row background fill\n- ✅ KanbanScreenV2 - Archived\n\n---\n\n## MINOR REMAINING\n\n2 screens use StatusBar.Set*() directly instead of SetStatusMessage():\n- NoteEditorScreen.ps1 (4 calls)\n- ProjectInfoScreenV4.ps1 (22 calls)\n\nThis is a style preference, not a bug.\n"}, {"path": "module/Pmc.Strict/consoleui/ServiceContainer.ps1", "content": "# ServiceContainer.ps1 - Dependency Injection Container\r\n# Manages lifecycle and dependencies of all services, screens, and widgets\r\n\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nDependency injection container for PMC TUI\r\n\r\n.DESCRIPTION\r\nServiceContainer manages registration and resolution of all dependencies:\r\n- Services (TaskStore, MenuRegistry, etc.)\r\n- Configuration (Theme, Config)\r\n- Screens (lazy loaded on demand)\r\n- Widgets (created per screen)\r\n\r\nSolves initialization order, circular dependencies, and timing issues.\r\n\r\n.EXAMPLE\r\n$container = [ServiceContainer]::new()\r\n$container.Register('Theme', { Initialize-PmcThemeSystem; return $global:PmcTheme })\r\n$container.Register('TaskStore', { param($c) return [TaskStore]::GetInstance() })\r\n$theme = $container.Resolve('Theme')\r\n##CLOSEBRACKET##\r\nclass ServiceContainer {\r\n    # Registered service factories\r\n    hidden [hashtable]$_factories = @{}\r\n\r\n    # Resolved singleton instances\r\n    hidden [hashtable]$_singletons = @{}\r\n\r\n    # Registration flags\r\n    hidden [hashtable]$_isSingleton = @{}\r\n\r\n    # Resolution stack (for circular dependency detection)\r\n    hidden [List[string]]$_resolutionStack = [List[string]]::new()\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Register a service with a factory function\r\n\r\n    .PARAMETER name\r\n    Service name (e.g., 'Theme', 'TaskStore', 'TaskListScreen')\r\n\r\n    .PARAMETER factory\r\n    Scriptblock that creates the service. Receives container as parameter.\r\n\r\n    .PARAMETER singleton\r\n    If true, service is created once and cached. Default: true\r\n\r\n    .EXAMPLE\r\n    $container.Register('Theme', {\r\n        Initialize-PmcThemeSystem\r\n        return Get-PmcState -Section 'Display' | Select-Object -ExpandProperty Theme\r\n    })\r\n\r\n    .EXAMPLE\r\n    $container.Register('TaskStore', {\r\n        param($container)\r\n        $theme = $container.Resolve('Theme')  # Depend on theme\r\n        return [TaskStore]::GetInstance()\r\n    })\r\n    ##CLOSEBRACKET##\r\n    [void] Register([string]$name, [scriptblock]$factory, [bool]$singleton = $true) {\r\n        if ($this._factories.ContainsKey($name)) {\r\n            if ($global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [WARN] ServiceContainer: Re-registering service '$name'\"\r\n            }\r\n        }\r\n\r\n        $this._factories[$name] = $factory\r\n        $this._isSingleton[$name] = $singleton\r\n\r\n        if ($global:PmcTuiLogFile) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ServiceContainer: Registered '$name' (singleton=$singleton)\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Resolve a service by name\r\n\r\n    .PARAMETER name\r\n    Service name to resolve\r\n\r\n    .OUTPUTS\r\n    Service instance\r\n\r\n    .EXAMPLE\r\n    $theme = $container.Resolve('Theme')\r\n    $screen = $container.Resolve('TaskListScreen')\r\n    ##CLOSEBRACKET##\r\n    [object] Resolve([string]$name) {\r\n        # Check if already resolved (singleton)\r\n        if ($this._isSingleton[$name] -and $this._singletons.ContainsKey($name)) {\r\n            return $this._singletons[$name]\r\n        }\r\n\r\n        # Check if service registered\r\n        if (-not $this._factories.ContainsKey($name)) {\r\n            $error = \"Service '$name' not registered in container\"\r\n            if ($global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] ServiceContainer: $error\"\r\n            }\r\n            throw $error\r\n        }\r\n\r\n        # Detect circular dependencies\r\n        if ($this._resolutionStack.Contains($name)) {\r\n            $chain = ($this._resolutionStack -join ' -> ') + \" -> $name\"\r\n            $error = \"Circular dependency detected: $chain\"\r\n            if ($global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] ServiceContainer: $error\"\r\n            }\r\n            throw $error\r\n        }\r\n\r\n        # Add to resolution stack\r\n        $this._resolutionStack.Add($name)\r\n\r\n        try {\r\n            if ($global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ServiceContainer: Resolving '$name'...\"\r\n            }\r\n\r\n            # Invoke factory (pass container for nested resolution)\r\n            $factory = $this._factories[$name]\r\n            $instance = & $factory $this\r\n\r\n            # Cache if singleton\r\n            if ($this._isSingleton[$name]) {\r\n                $this._singletons[$name] = $instance\r\n            }\r\n\r\n            if ($global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ServiceContainer: Resolved '$name' successfully\"\r\n            }\r\n\r\n            return $instance\r\n\r\n        } catch {\r\n            if ($global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] ServiceContainer: Failed to resolve '$name': $_\"\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] Stack trace: $($_.ScriptStackTrace)\"\r\n            }\r\n            throw\r\n        } finally {\r\n            # CRITICAL: Remove from resolution stack (cleanup on all paths)\r\n            # Extra safety: wrap in try-catch to prevent double-fault\r\n            try {\r\n                $this._resolutionStack.Remove($name) | Out-Null\r\n            } catch {\r\n                # Resolution stack cleanup failed - log but don't throw\r\n                if ($global:PmcTuiLogFile) {\r\n                    Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] ServiceContainer: Failed to clean resolution stack: $_\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Check if a service is registered\r\n\r\n    .PARAMETER name\r\n    Service name\r\n\r\n    .OUTPUTS\r\n    Boolean\r\n    ##CLOSEBRACKET##\r\n    [bool] IsRegistered([string]$name) {\r\n        return $this._factories.ContainsKey($name)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get all registered service names\r\n\r\n    .OUTPUTS\r\n    Array of service names\r\n    ##CLOSEBRACKET##\r\n    [array] GetRegisteredServices() {\r\n        return $this._factories.Keys\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Clear all resolved singletons (for testing/reset)\r\n    ##CLOSEBRACKET##\r\n    [void] ClearResolved() {\r\n        $this._singletons.Clear()\r\n        if ($global:PmcTuiLogFile) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ServiceContainer: Cleared all resolved singletons\"\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/SpeedTUILoader.ps1", "content": "# SpeedTUI Loader for PMC\n# Loads SpeedTUI framework components in correct order for PMC widget integration\n\nSet-StrictMode -Version Latest\n\n$ErrorActionPreference = \"Continue\"\n\n# Determine SpeedTUI root (vendored in PMC)\n$SpeedTUIRoot = Join-Path $PSScriptRoot \"../../../lib/SpeedTUI\"\n\nif (-not (Test-Path $SpeedTUIRoot)) {\n    throw \"SpeedTUI not found at $SpeedTUIRoot (expected vendored copy)\"\n}\n\n# Loading SpeedTUI (Write-ConsoleUIDebug not available yet)\n\ntry {\n    # Load core components in correct order (from SpeedTUI.ps1)\n\n    # 1. Logger and performance\n    . \"$SpeedTUIRoot/Core/Logger.ps1\"\n    . \"$SpeedTUIRoot/Core/PerformanceMonitor.ps1\"\n    . \"$SpeedTUIRoot/Core/NullCheck.ps1\"\n\n    # 2. Performance optimizations (REQUIRED for Component)\n    . \"$SpeedTUIRoot/Core/Internal/PerformanceCore.ps1\"\n\n    # 3. Terminal and rendering\n    . \"$SpeedTUIRoot/Core/SimplifiedTerminal.ps1\"\n    . \"$SpeedTUIRoot/Core/NativeRenderCore.ps1\"  # C# high-performance buffer (must load before CellBuffer)\n    . \"$SpeedTUIRoot/Core/CellBuffer.ps1\"\n    # HybridRenderEngine replaces OptimizedRenderEngine and EnhancedRenderEngine\n    . \"$SpeedTUIRoot/Core/HybridRenderEngine.ps1\"\n\n    # 4. Base Component class (THIS IS WHAT PmcWidget EXTENDS)\n    . \"$SpeedTUIRoot/Core/Component.ps1\"\n\n    # 5. Border helper (may be needed)\n    . \"$SpeedTUIRoot/BorderHelper.ps1\"\n\n    # 6. Initialize global logger and perf monitor\n    $global:logger = [Logger]::GetInstance()\n    $global:logger.GlobalLevel = [LogLevel]::Debug  # Enable debug logging for troubleshooting\n\n    $global:perfMonitor = Get-PerformanceMonitor\n    $global:perfMonitor.SetLogger($global:logger)\n    # Don't enable perf monitor by default in PMC\n\n    # SpeedTUI framework loaded successfully\n    # NOTE: PmcThemeEngine is loaded by Start-PmcTUI.ps1 in proper dependency order\n\n} catch {\n    # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [SpeedTUILoader] Failed to load SpeedTUI: $_\"\n    throw\n}"}, {"path": "module/Pmc.Strict/consoleui/Start-PmcTUI.ps1", "content": "# Start-PmcTUI - Entry point for new PMC TUI architecture\n# Replaces old ConsoleUI.Core.ps1 monolithic approach\n\nparam(\n    [switch]$DebugLog,      # Enable debug logging to file\n    [int]$LogLevel = 0      # 0=off, 1=errors only, 2=info, 3=verbose\n)\n\nSet-StrictMode -Version Latest\n\n# PORTABILITY: Helper function to write debug logs to portable path\n# Uses $global:PmcDebugLogPath set by start.ps1, or creates fallback in data/logs/\nfunction Write-PmcDebugLog {\n    param([string]$Message)\n    \n    # Determine log path (prefer global set by start.ps1)\n    $debugLogPath = if (Test-Path variable:global:PmcDebugLogPath) { $global:PmcDebugLogPath } else { $null }\n    if (-not $debugLogPath) {\n        # Fallback: create path relative to script location\n        $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent\n        $logDir = Join-Path $root \"data/logs\"\n        if (-not (Test-Path $logDir)) {\n            New-Item -ItemType Directory -Path $logDir -Force -ErrorAction SilentlyContinue | Out-Null\n        }\n        $debugLogPath = Join-Path $logDir \"pmc-debug.log\"\n        $global:PmcDebugLogPath = $debugLogPath\n    }\n    \n    try {\n        # Add-Content -Path $debugLogPath -Value $Message -ErrorAction SilentlyContinue\n    } catch {\n        # Silently fail - don't crash app for logging issues\n    }\n}\n\n# Setup logging (DISABLED BY DEFAULT for performance)\n# M-CFG-1: Configurable Log Path - uses environment variable or local directory for portability\n# PORTABILITY: Default to .pmc-data/logs directory relative to module root (self-contained)\n# IMPORTANT: Check PMC_TUI_LOG_LEVEL environment variable (set by external config)\n$effectiveLogLevel = if ($LogLevel -gt 0) { $LogLevel } else { [int]($env:PMC_TUI_LOG_LEVEL -as [int]) }\n\nif ($DebugLog -or $effectiveLogLevel -gt 0) {\n    try {\n        $logPath = $null\n\n        # Try environment variable first, but validate it's safe\n        if ($env:PMC_LOG_PATH) {\n            # SECURITY: Only use Windows paths on Windows, Unix paths on Linux\n            if ($PSVersionTable.Platform -eq 'Win32NT' -or $IsWindows) {\n                if ($env:PMC_LOG_PATH -match '^[A-Z]:' -or $env:PMC_LOG_PATH -match '^\\\\\\\\') {\n                    $logPath = $env:PMC_LOG_PATH\n                }\n            } elseif ($PSVersionTable.Platform -eq 'Unix' -or -not $IsWindows) {\n                if ($env:PMC_LOG_PATH -match '^/' -or $env:PMC_LOG_PATH -match '^\\./') {\n                    $logPath = $env:PMC_LOG_PATH\n                }\n            }\n        }\n\n        # Fallback to default location\n        if (-not $logPath) {\n            $moduleRoot = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent\n            $logPath = Join-Path $moduleRoot \".pmc-data/logs\"\n        }\n\n        # Create directory if needed\n        if (-not (Test-Path $logPath)) {\n            New-Item -ItemType Directory -Path $logPath -Force -ErrorAction Stop | Out-Null\n        }\n\n        $global:PmcTuiLogFile = Join-Path $logPath \"pmc-tui-$(Get-Date -Format 'yyyyMMdd-HHmmss').log\"\n        $global:PmcTuiLogLevel = $effectiveLogLevel\n        # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [Start-PmcTUI] Debug logging enabled: $global:PmcTuiLogFile (Level $effectiveLogLevel)\"\n    }\n    catch {\n        # If log setup fails, disable logging and continue\n        # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [Start-PmcTUI] WARNING: Failed to setup logging: $_\"\n        $global:PmcTuiLogFile = $null\n        $global:PmcTuiLogLevel = 0\n    }\n}\nelse {\n    $global:PmcTuiLogFile = $null\n    $global:PmcTuiLogLevel = 0\n}\n\n# PERFORMANCE FIX: Global flag to disable ALL debug logging\n# Set to $false to disable pmc-flow-debug.log writes (huge performance gain)\n$global:PmcEnableFlowDebug = $false\n\nfunction Write-PmcTuiLog {\n    param([string]$Message, [string]$Level = \"INFO\")\n\n    # Skip if logging disabled\n    if (-not $global:PmcTuiLogFile) { return }\n\n    # Filter by log level\n    $levelValue = switch ($Level) {\n        \"ERROR\" { 1 }\n        \"INFO\" { 2 }\n        \"DEBUG\" { 3 }\n        default { 2 }\n    }\n\n    if ($levelValue -gt $global:PmcTuiLogLevel) { return }\n\n    $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\n    $logLine = \"[$timestamp] [$Level] $Message\"\n    try {\n        Add-Content -Path $global:PmcTuiLogFile -Value $logLine -ErrorAction Stop\n    }\n    catch {\n        # Silently fail on log write errors to prevent cascading failures\n        # This can happen if path is invalid or disk is full\n        if ($Level -eq \"ERROR\") {\n            # Write-PmcDebugLog $logLine\n        }\n    }\n    if ($Level -eq \"ERROR\") {\n        # Write-PmcDebugLog $logLine\n    }\n}\n\n# Write-PmcTuiLog \"Loading PMC module...\" \"INFO\"\n\ntry {\n    # Import PMC module for data functions\n    Import-Module \"$PSScriptRoot/../Pmc.Strict.psd1\" -Force -ErrorAction Stop\n    # Write-PmcTuiLog \"PMC module loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load PMC module: $_\" \"ERROR\"\n    # Write-PmcTuiLog $_.ScriptStackTrace \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"Loading dependencies (FieldSchemas, etc.)...\" \"INFO\"\n\ntry {\n    . \"$PSScriptRoot/DepsLoader.ps1\"\n    # Write-PmcTuiLog \"Dependencies loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load dependencies: $_\" \"ERROR\"\n    # Write-PmcTuiLog $_.ScriptStackTrace \"ERROR\"\n    throw\n}\n\n# ============================================================================\n# MANUAL LOADING - Direct loads in correct dependency order\n# ============================================================================\n\n# Write-PmcTuiLog \"Loading SpeedTUI framework...\" \"INFO\"\ntry {\n    . \"$PSScriptRoot/SpeedTUILoader.ps1\"\n    # Write-PmcTuiLog \"SpeedTUI framework loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load SpeedTUI: $_\" \"ERROR\"\n    throw\n}\n\n# REMOVED: PraxisVT loading - not used by TUI (archived 2025-12-21)\n\n# Write-PmcTuiLog \"Loading core dependencies...\" \"INFO\"\ntry {\n    # Core infrastructure (no dependencies)\n    . \"$PSScriptRoot/ZIndex.ps1\"\n    . \"$PSScriptRoot/src/PmcThemeEngine.ps1\"\n    . \"$PSScriptRoot/theme/PmcThemeManager.ps1\"\n    . \"$PSScriptRoot/layout/PmcLayoutManager.ps1\"\n\n    # Write-PmcTuiLog \"Core dependencies loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load core dependencies: $_\" \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"Loading widget base classes...\" \"INFO\"\ntry {\n    # Base widget classes (PmcWidget needs SpeedTUI Component + PmcThemeEngine)\n    . \"$PSScriptRoot/widgets/PmcWidget.ps1\"\n    . \"$PSScriptRoot/widgets/PmcDialog.ps1\"\n\n    # Write-PmcTuiLog \"Widget base classes loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load widget base classes: $_\" \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"Loading services...\" \"INFO\"\ntry {\n    # Load services BEFORE widgets (ProjectPicker depends on TaskStore)\n    . \"$PSScriptRoot/services/ChecklistService.ps1\"\n    . \"$PSScriptRoot/services/CommandService.ps1\"\n    . \"$PSScriptRoot/services/ExcelComReader.ps1\"\n    . \"$PSScriptRoot/services/ExcelMappingService.ps1\"\n    . \"$PSScriptRoot/services/MenuRegistry.ps1\"\n    . \"$PSScriptRoot/services/NoteService.ps1\"\n    . \"$PSScriptRoot/services/FileNoteService.ps1\"\n    . \"$PSScriptRoot/services/PreferencesService.ps1\"\n    . \"$PSScriptRoot/services/TaskStore.ps1\"\n    # Write-PmcTuiLog \"Services loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load services: $_\" \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"Loading helpers...\" \"INFO\"\ntry {\n    # Load helpers BEFORE widgets (TextAreaEditor depends on GapBuffer)\n    . \"$PSScriptRoot/helpers/ConfigCache.ps1\"\n    . \"$PSScriptRoot/helpers/Constants.ps1\"\n    . \"$PSScriptRoot/helpers/DataBindingHelper.ps1\"\n    . \"$PSScriptRoot/helpers/GapBuffer.ps1\"\n    . \"$PSScriptRoot/helpers/LinuxKeyHelper.ps1\"\n    . \"$PSScriptRoot/helpers/ShortcutRegistry.ps1\"\n    . \"$PSScriptRoot/helpers/ThemeHelper.ps1\"\n    . \"$PSScriptRoot/helpers/TypeNormalization.ps1\"\n    . \"$PSScriptRoot/helpers/ValidationHelper.ps1\"\n    # Write-PmcTuiLog \"Helpers loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load helpers: $_\" \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"Loading widgets...\" \"INFO\"\ntry {\n    # All widgets (inherit from PmcWidget) - MUST load before PmcScreen\n    # IMPORTANT: Load TextInput and ProjectPicker BEFORE InlineEditor (which depends on them)\n    . \"$PSScriptRoot/widgets/TextInput.ps1\"\n    . \"$PSScriptRoot/widgets/ProjectPicker.ps1\"\n    . \"$PSScriptRoot/widgets/DatePicker.ps1\"\n    . \"$PSScriptRoot/widgets/FilterPanel.ps1\"\n    . \"$PSScriptRoot/widgets/InlineEditor.ps1\"\n    . \"$PSScriptRoot/widgets/PmcFilePicker.ps1\"\n    . \"$PSScriptRoot/widgets/PmcFooter.ps1\"\n    . \"$PSScriptRoot/widgets/PmcHeader.ps1\"\n    . \"$PSScriptRoot/widgets/PmcMenuBar.ps1\"\n    . \"$PSScriptRoot/widgets/PmcPanel.ps1\"\n    . \"$PSScriptRoot/widgets/PmcStatusBar.ps1\"\n    . \"$PSScriptRoot/widgets/SimpleFilePicker.ps1\"\n    . \"$PSScriptRoot/widgets/TabPanel.ps1\"\n    . \"$PSScriptRoot/widgets/TagEditor.ps1\"\n    . \"$PSScriptRoot/widgets/TextAreaEditor.ps1\"\n    . \"$PSScriptRoot/widgets/TimeEntryDetailDialog.ps1\"\n    . \"$PSScriptRoot/widgets/UniversalList.ps1\"\n    # Write-PmcTuiLog \"Widgets loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load widgets: $_\" \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"Loading screen base class...\" \"INFO\"\ntry {\n    # PmcScreen base (uses PmcHeader, PmcFooter, PmcMenuBar - MUST be after widgets)\n    . \"$PSScriptRoot/PmcScreen.ps1\"\n\n    # Write-PmcTuiLog \"Screen base class loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load screen base: $_\" \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"Loading HelpViewScreen (needed by base classes)...\" \"INFO\"\ntry {\n    # Load HelpViewScreen FIRST (StandardListScreen depends on it)\n    . \"$PSScriptRoot/screens/HelpViewScreen.ps1\"\n    # Write-PmcTuiLog \"HelpViewScreen loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load HelpViewScreen: $_\" \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"Loading base classes...\" \"INFO\"\ntry {\n    . \"$PSScriptRoot/base/StandardDashboard.ps1\"\n    . \"$PSScriptRoot/base/StandardFormScreen.ps1\"\n    . \"$PSScriptRoot/base/StandardListScreen.ps1\"\n    . \"$PSScriptRoot/base/TabbedScreen.ps1\"\n    # Write-PmcTuiLog \"Base classes loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load base classes: $_\" \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"Loading ServiceContainer (needed by screens)...\" \"INFO\"\ntry {\n    # Load ServiceContainer BEFORE screens (TaskListScreen depends on it)\n    . \"$PSScriptRoot/ServiceContainer.ps1\"\n    # Write-PmcTuiLog \"ServiceContainer loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load ServiceContainer: $_\" \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"Loading remaining screens...\" \"INFO\"\ntry {\n    # Load remaining screens AFTER base classes (they inherit from StandardListScreen, etc.)\n    . \"$PSScriptRoot/screens/TaskListScreen.ps1\"\n    . \"$PSScriptRoot/screens/ProjectListScreen.ps1\"\n    . \"$PSScriptRoot/screens/ProjectInfoScreenV4.ps1\"\n    # Write-PmcTuiLog \"Remaining screens loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load screens: $_\" \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"Loading PmcApplication...\" \"INFO\"\ntry {\n    . \"$PSScriptRoot/PmcApplication.ps1\"\n    # Write-PmcTuiLog \"PmcApplication loaded\" \"INFO\"\n}\ncatch {\n    # Write-PmcTuiLog \"Failed to load PmcApplication: $_\" \"ERROR\"\n    throw\n}\n\n# Write-PmcTuiLog \"All components loaded successfully\" \"INFO\"\n\n<#\n.SYNOPSIS\nStart PMC TUI with new architecture\n\n.DESCRIPTION\nEntry point for SpeedTUI-based PMC interface.\nCreates application and launches screens.\n\n.PARAMETER StartScreen\nWhich screen to launch (default: BlockedTasks)\n\n.EXAMPLE\nStart-PmcTUI\nStart-PmcTUI -StartScreen BlockedTasks\n##CLOSEBRACKET##\nfunction Start-PmcTUI {\n    param(\n        [string]$StartScreen = \"TaskList\"\n    )\n\n    # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [Start-PmcTUI] Starting PMC TUI (SpeedTUI Architecture)...\"\n    # Write-PmcTuiLog \"Starting PMC TUI with screen: $StartScreen\" \"INFO\"\n\n    try {\n        # === Theme Self-Healing ===\n        # CRITICAL FIX: Ensure theme configuration is valid before starting\n        # If Active theme is set but Hex/Properties are missing, force a reload to populate them\n        $debugLogPath = Join-Path (Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent) 'data/logs/theme-debug.log'\n        try {\n            Add-Content -Path $debugLogPath -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] === THEME SELF-HEAL START ===\" -ErrorAction SilentlyContinue\n            $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent\n            $configPath = Join-Path $root 'config.json'\n            Add-Content -Path $debugLogPath -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] Config path: $configPath\" -ErrorAction SilentlyContinue\n            if (Test-Path $configPath) {\n                $cfg = Get-Content $configPath -Raw | ConvertFrom-Json\n                # STRICT MODE FIX: Safely check for Hex property existence\n                $hasHex = $cfg.Display -and $cfg.Display.Theme -and $cfg.Display.Theme.PSObject.Properties['Hex']\n                $hexValue = if ($hasHex) { $cfg.Display.Theme.Hex } else { $null }\n                Add-Content -Path $debugLogPath -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] Config loaded. Active=$($cfg.Display.Theme.Active), Hex=$hexValue, hasHex=$hasHex\" -ErrorAction SilentlyContinue\n                if ($cfg.Display -and $cfg.Display.Theme -and $cfg.Display.Theme.Active) {\n                    if (-not $hasHex) {\n                        Add-Content -Path $debugLogPath -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] Missing Hex - calling Set-ActiveTheme for '$($cfg.Display.Theme.Active)'\" -ErrorAction SilentlyContinue\n                        Set-ActiveTheme -themeName $cfg.Display.Theme.Active\n                        Add-Content -Path $debugLogPath -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] Set-ActiveTheme completed successfully\" -ErrorAction SilentlyContinue\n                    } else {\n                        Add-Content -Path $debugLogPath -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] Hex already present, no repair needed\" -ErrorAction SilentlyContinue\n                    }\n                }\n            } else {\n                Add-Content -Path $debugLogPath -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] Config file not found at: $configPath\" -ErrorAction SilentlyContinue\n            }\n        } catch {\n            Add-Content -Path $debugLogPath -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] EXCEPTION: $_\" -ErrorAction SilentlyContinue\n            Add-Content -Path $debugLogPath -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] Stack: $($_.ScriptStackTrace)\" -ErrorAction SilentlyContinue\n            # Continue startup - theme will use defaults\n        }\n\n        # === Clear stale global state ===\n        # CRITICAL FIX: Clear shared menu bar and registry singleton to ensure fresh menus are loaded\n        # This fixes the issue where Notes and Checklist screens don't appear after manifest updates\n        $global:PmcSharedMenuBar = $null\n\n        # Clear MenuRegistry singleton (it caches menu items across sessions)\n        if ([MenuRegistry]) {\n            [MenuRegistry]::_instance = $null\n        }\n        # Write-PmcTuiLog \"Cleared stale PmcSharedMenuBar and MenuRegistry singleton\" \"INFO\"\n\n        # === Create DI Container ===\n        # Write-PmcTuiLog \"Creating ServiceContainer...\" \"INFO\"\n        $global:PmcContainer = [ServiceContainer]::new()\n        # Write-PmcTuiLog \"ServiceContainer created\" \"INFO\"\n\n        # === Register Core Services (in dependency order) ===\n\n        # 1. Theme (no dependencies)\n        # Write-PmcTuiLog \"Registering Theme service...\" \"INFO\"\n        $global:PmcContainer.Register('Theme', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving Theme: Resetting singletons and initializing...\" \"INFO\"\n                \n                # CRITICAL FIX: Reset singletons to ensure fresh theme data from config\n                # This fixes gradient themes not loading because singletons cached old data\n                [PmcThemeManager]::_instance = $null\n                [PmcThemeEngine]::_instance = $null\n                \n                # Initialize Core Theme System with -Force to rebuild from config\n                Initialize-PmcThemeSystem -Force\n                \n                # Get the Manager instance (which is now the source of truth)\n                $manager = [PmcThemeManager]::GetInstance()\n                $themeHex = $manager.GetCurrentThemeHex()\n                \n                # Write-PmcTuiLog \"Theme initialized: $themeHex\" \"INFO\"\n                return $manager\n            }, $true)\n\n        # Register ThemeManager (depends on Theme)\n        # Write-PmcTuiLog \"Registering ThemeManager...\" \"INFO\"\n        $global:PmcContainer.Register('ThemeManager', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving ThemeManager...\" \"INFO\"\n                $null = $container.Resolve('Theme')\n                return [PmcThemeManager]::GetInstance()\n            }, $true)\n\n        # 2. Config (no dependencies) - CACHED for performance\n        # Write-PmcTuiLog \"Registering Config service...\" \"INFO\"\n        $global:PmcContainer.Register('Config', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving Config...\" \"INFO\"\n\n                # Determine config path (same logic as Get-PmcConfig)\n                # CRITICAL FIX: Use workspace root (three levels up from module dir)\n                $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent\n                $configPath = Join-Path $root 'config.json'\n\n                # Use cached config for performance (eliminates repeated file I/O)\n                try {\n                    return [ConfigCache]::GetConfig($configPath)\n                }\n                catch {\n                    # Write-PmcTuiLog \"Config load failed, falling back to Get-PmcConfig: $_\" \"ERROR\"\n                    # Fallback to original method if cache fails\n                    return Get-PmcConfig\n                }\n            }, $true)\n\n        # 3. TaskStore (depends on Theme via state)\n        # Write-PmcTuiLog \"Registering TaskStore service...\" \"INFO\"\n        $global:PmcContainer.Register('TaskStore', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving TaskStore...\" \"INFO\"\n                # Ensure theme is initialized first\n                $null = $container.Resolve('Theme')\n                return [TaskStore]::GetInstance()\n            }, $true)\n\n        # 4. MenuRegistry (depends on Theme)\n        # Write-PmcTuiLog \"Registering MenuRegistry service...\" \"INFO\"\n        $global:PmcContainer.Register('MenuRegistry', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving MenuRegistry...\" \"INFO\"\n                # Ensure theme is initialized first\n                $null = $container.Resolve('Theme')\n                return [MenuRegistry]::GetInstance()\n            }, $true)\n\n        # 5. Application (depends on Theme)\n        # Write-PmcTuiLog \"Registering Application service...\" \"INFO\"\n        $global:PmcContainer.Register('Application', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving Application...\" \"INFO\"\n                # Ensure theme is initialized first\n                $null = $container.Resolve('Theme')\n                return [PmcApplication]::new($container)\n            }, $true)\n\n        # 6. CommandService (no dependencies)\n        # Write-PmcTuiLog \"Registering CommandService...\" \"INFO\"\n        $global:PmcContainer.Register('CommandService', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving CommandService...\" \"INFO\"\n                return [CommandService]::GetInstance()\n            }, $true)\n\n        # 7. ChecklistService (no dependencies)\n        # Write-PmcTuiLog \"Registering ChecklistService...\" \"INFO\"\n        $global:PmcContainer.Register('ChecklistService', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving ChecklistService...\" \"INFO\"\n                return [ChecklistService]::GetInstance()\n            }, $true)\n\n        # 8. NoteService (no dependencies)\n        # Write-PmcTuiLog \"Registering NoteService...\" \"INFO\"\n        $global:PmcContainer.Register('NoteService', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving NoteService...\" \"INFO\"\n                return [NoteService]::GetInstance()\n            }, $true)\n\n        # 9. ExcelMappingService (no dependencies)\n        # Write-PmcTuiLog \"Registering ExcelMappingService...\" \"INFO\"\n        $global:PmcContainer.Register('ExcelMappingService', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving ExcelMappingService...\" \"INFO\"\n                return [ExcelMappingService]::GetInstance()\n            }, $true)\n\n        # 10. PreferencesService (no dependencies)\n        # Write-PmcTuiLog \"Registering PreferencesService...\" \"INFO\"\n        $global:PmcContainer.Register('PreferencesService', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving PreferencesService...\" \"INFO\"\n                return [PreferencesService]::GetInstance()\n            }, $true)\n\n        # 11. Screen factories (depend on Application, TaskStore, etc.)\n        # Write-PmcTuiLog \"Registering screen factories...\" \"INFO\"\n\n        $global:PmcContainer.Register('TaskListScreen', {\n                param($container)\n                # Write-PmcTuiLog \"Resolving TaskListScreen...\" \"INFO\"\n                # Ensure dependencies\n                $null = $container.Resolve('Theme')\n                $null = $container.Resolve('TaskStore')\n                return [TaskListScreen]::new($container)\n            }, $false)  # Not singleton - create new instance each time\n\n        # === Resolve Application ===\n        # Write-PmcTuiLog \"Resolving Application from container...\" \"INFO\"\n        $global:PmcApp = $global:PmcContainer.Resolve('Application')\n        # Write-PmcTuiLog \"Application resolved and assigned to `$global:PmcApp\" \"INFO\"\n\n        # === Load Menus from Manifest ===\n        # Write-PmcTuiLog \"Loading menus from manifest...\" \"INFO\"\n        $menuRegistry = $global:PmcContainer.Resolve('MenuRegistry')\n        $manifestPath = Join-Path $PSScriptRoot \"screens/MenuItems.psd1\"\n        if (Test-Path $manifestPath) {\n            $menuRegistry.LoadFromManifest($manifestPath, $global:PmcContainer)\n            # Write-PmcTuiLog \"Menus loaded from $manifestPath\" \"INFO\"\n        }\n        else {\n            # Write-PmcTuiLog \"Menu manifest not found at $manifestPath\" \"ERROR\"\n        }\n\n        # === Launch Initial Screen ===\n        # Write-PmcTuiLog \"Launching screen: $StartScreen\" \"INFO\"\n        switch ($StartScreen) {\n            'TaskList' {\n                # Write-PmcTuiLog \"Resolving TaskListScreen from container...\" \"INFO\"\n                $screen = $global:PmcContainer.Resolve('TaskListScreen')\n                # Write-PmcTuiLog \"Pushing screen to app...\" \"INFO\"\n                try {\n                    $global:PmcApp.PushScreen($screen)\n                    # Write-PmcTuiLog \"Screen pushed successfully\" \"INFO\"\n                }\n                catch {\n                    # Add-Content -Path \"$(Join-Path ([System.IO.Path]::GetTempPath()) 'pmc_debug.txt')\" -Value \"[$(Get-Date)] FATAL ERROR IN PUSHSCREEN: $_\"\n                    # Add-Content -Path \"$(Join-Path ([System.IO.Path]::GetTempPath()) 'pmc_debug.txt')\" -Value \"[$(Get-Date)] Stack Trace: $($_.ScriptStackTrace)\"\n                    throw\n                }\n\n            }\n            'Demo' {\n                # Write-PmcTuiLog \"Loading DemoScreen (not containerized)...\" \"INFO\"\n                . \"$PSScriptRoot/DemoScreen.ps1\"\n                $screen = [DemoScreen]::new()\n                $global:PmcApp.PushScreen($screen)\n                # Write-PmcTuiLog \"Demo screen pushed\" \"INFO\"\n            }\n            default {\n                # Write-PmcTuiLog \"Unknown screen: $StartScreen\" \"ERROR\"\n                throw \"Unknown screen: $StartScreen\"\n            }\n        }\n\n        # Run event loop\n        # Write-PmcTuiLog \"Starting event loop...\" \"INFO\"\n        $global:PmcApp.Run()\n        # Write-PmcTuiLog \"Event loop exited normally\" \"INFO\"\n\n    }\n    catch {\n        # Write-PmcTuiLog \"EXCEPTION: $_\" \"ERROR\"\n        # Write-PmcTuiLog \"Stack trace: $($_.ScriptStackTrace)\" \"ERROR\"\n        # Write-PmcTuiLog \"Exception details: $($_.Exception | Out-String)\" \"ERROR\"\n\n        # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [Start-PmcTUI] PMC TUI Error: $_\"\n        # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [Start-PmcTUI] Log file: $global:PmcTuiLogFile\"\n        # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [Start-PmcTUI] Stack trace: $($_.ScriptStackTrace)\"\n        throw\n    }\n    finally {\n        # Cleanup\n        # Write-PmcTuiLog \"Cleanup - showing cursor and resetting terminal\" \"INFO\"\n        # Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [Start-PmcTUI] Log saved to: $global:PmcTuiLogFile\"\n    }\n}\n\n# Allow direct execution\n# Allow direct execution\n# Write-PmcDebugLog \"[$(Get-Date -Format 'HH:mm:ss.fff')] [Start-PmcTUI] DEBUG: InvocationName='$($MyInvocation.InvocationName)' MyCommand='$($MyInvocation.MyCommand.Name)'\"\nif ($MyInvocation.InvocationName -ne '.' -and $MyInvocation.InvocationName -ne '&') {\n    Start-PmcTUI @args\n}"}, {"path": "module/Pmc.Strict/consoleui/TERMINAL-SIZE-ISSUE.md", "content": "# Terminal Size Detection Issue - Analysis\n\n## Problem\nTerminal size detected as **21x10** instead of actual screen size.\n\n## Evidence\n```\n$ echo $COLUMNS x $LINES\n21 x 10\n\n$ tput cols && tput lines\n21\n10\n\n$ stty size\n10 21\n\n$ pwsh -Command \"[Console]::WindowWidth; [Console]::WindowHeight\"\n21\n10\n```\n\n## Root Cause\nThe terminal size is actually 21x10 in the environment where the TUI is running.\nThis is NOT a detection bug - PowerShell is correctly reading the terminal size.\n\n## Impact\n1. **Rendering Corruption**: Widgets try to render in 21-column space\n   - Text wraps incorrectly\n   - Shows fragments like \"B]\" and \"task\"\n   - List columns don't fit\n\n2. **Screen Not Filling**: TUI renders for 21x10, not full screen\n\n3. **Task Saving**: Likely works, but can't see confirmation due to rendering issues\n\n## Solution Options\n\n### Option 1: Resize Terminal (User Action Required)\nUser needs to resize their terminal window to proper size (e.g., 120x30 or larger).\n\n### Option 2: Override Size Detection (Code Fix)\nModify PmcApplication to use minimum size if detected size is too small:\n\n```powershell\nhidden [void] _UpdateTerminalSize() {\n    try {\n        $width = [Console]::WindowWidth\n        $height = [Console]::WindowHeight\n        \n        # Enforce minimum size\n        $this.TermWidth = [Math]::Max($width, 80)\n        $this.TermHeight = [Math]::Max($height, 24)\n    }\n    catch {\n        $this.TermWidth = 80\n        $this.TermHeight = 24\n    }\n}\n```\n\n### Option 3: Use tput/stty (Linux-specific)\nTry to get size from tput instead of .NET Console API.\n\n## Recommendation\n**Option 1** - User should resize terminal.\nThe TUI is designed for terminals 80x24 minimum.\n21x10 is too small for any TUI application.\n\n## Testing Task Saving\nNeed to verify if tasks are actually being saved despite rendering issues.\nChecking TaskStore.SaveData() implementation...\n"}, {"path": "module/Pmc.Strict/consoleui/TESTING-SUMMARY.md", "content": "# TUI Testing Summary\n\n## Test Scripts Created\n\n### 1. Quick Verification (`verify-tui.ps1`)\nFast source code validation without loading dependencies.\n\n**Run**: `pwsh /home/teej/ztest/module/Pmc.Strict/consoleui/verify-tui.ps1`\n\n**Tests**:\n- ✓ TimeListScreen callback methods exist\n- ✓ TabPanel widget exists\n- ✓ ProjectInfoScreenV4 exists\n\n---\n\n### 2. Comprehensive Testing (`test-comprehensive.ps1`)\nDeep static analysis of all screens, widgets, and rendering code.\n\n**Run**: `pwsh /home/teej/ztest/module/Pmc.Strict/consoleui/test-comprehensive.ps1`\n\n**Results**: **11/12 tests passed** ✅\n\n**Sections**:\n1. **Source Code Verification** (3/3 passed)\n   - ✓ TimeListScreen callback methods\n   - ✓ All 12 screen files exist\n   - ✓ All 14 widget files exist\n\n2. **Class Definition Verification** (3/3 passed)\n   - ✓ TabPanel class structure\n   - ✓ ProjectInfoScreenV4 class structure\n   - ✓ TabbedScreen base class\n\n3. **Rendering Code Analysis** (3/3 passed)\n   - ! ANSI escape sequence validation (1 warning - false positive in comment)\n   - ✓ ANSI reset sequence check\n   - ✓ RenderToEngine implementations (found in 23 files)\n\n4. **Dependency Chain Verification** (1/1 passed)\n   - ✓ Start-PmcTUI.ps1 loading order\n\n5. **Configuration and Logging** (2/2 passed)\n   - ✓ Log directory exists (8 log files)\n   - ✓ Latest log has no errors\n\n---\n\n### 3. Runtime Testing (`test-runtime.ps1`)\nActually launches TUI and tests rendering in real-time.\n\n**Run**: `pwsh /home/teej/ztest/module/Pmc.Strict/consoleui/test-runtime.ps1`\n\n**Results**: **All tests passed** ✅\n\n- ✓ TUI started successfully\n- ✓ TUI stopped cleanly\n- ✓ No rendering errors in log\n- ! TabPanel not in logs (expected - default screen is TaskListScreen, not ProjectInfoScreenV4)\n\n---\n\n### 4. ProjectInfoScreenV4 Tabs Test (`test-tabs.ps1`)\nFocused test for tab rendering in ProjectInfoScreenV4.\n\n**Run**: `pwsh /home/teej/ztest/module/Pmc.Strict/consoleui/test-tabs.ps1`\n\n**Results**: **All tests passed** ✅\n\n- ✓ All 7 tabs defined (Identity, Request, Audit, Location, Periods, More, Files)\n- ✓ _BuildTabs() is called (3 times)\n- ✓ TabPanel.RenderToEngine in parent class\n- ✓ TabPanel positioning set (X=2, Y=7)\n- ✓ RenderContentToEngine calls parent\n- ✓ No rendering issues found\n\n---\n\n## Overall Test Results\n\n| Test Suite | Status | Tests Passed | Notes |\n|------------|--------|--------------|-------|\n| Quick Verification | ✅ PASS | 3/3 | Fast validation |\n| Comprehensive | ✅ PASS | 11/12 | 1 false positive warning |\n| Runtime | ✅ PASS | 3/3 | TUI runs cleanly |\n| Tabs | ✅ PASS | 6/6 | All tabs verified |\n| **TOTAL** | **✅ PASS** | **23/24** | **95.8% pass rate** |\n\n---\n\n## What Was Fixed\n\n1. **TimeListScreen Callback Error** ✅\n   - Added `OnInlineEditConfirmed([hashtable]$values)` method\n   - Added `OnInlineEditCancelled()` method\n   - Both are no-ops with debug logging\n   - Prevents \"Method invocation failed\" errors\n\n---\n\n## What Was Verified\n\n1. **All Screens Exist** ✅\n   - 12 screen files verified\n   - All have correct class structure\n\n2. **All Widgets Exist** ✅\n   - 14 widget files verified\n   - All have required methods\n\n3. **ProjectInfoScreenV4 Tabs** ✅\n   - All 7 tabs defined correctly\n   - TabPanel rendering logic verified\n   - No rendering issues found\n\n4. **Rendering System** ✅\n   - 23 files implement RenderToEngine\n   - ANSI sequences validated\n   - No errors in logs\n\n---\n\n## Manual Testing Recommended\n\nWhile automated tests passed, manual testing is recommended for:\n\n1. **Visual Verification**\n   - Do tabs actually appear on screen?\n   - Are colors rendering correctly?\n   - Any visual artifacts?\n\n2. **Interaction Testing**\n   - Can you switch tabs with Tab key or 1-7?\n   - Does inline editing work in TimeListScreen?\n   - Do menus navigate correctly?\n\n3. **Edge Cases**\n   - Different terminal sizes\n   - Different color schemes\n   - Rapid key presses\n\n**To manually test**:\n```bash\npwsh /home/teej/ztest/module/Pmc.Strict/consoleui/Start-PmcTUI.ps1\n```\n\n---\n\n## Auto-Accept in Antigravity\n\n**Status**: ✅ Configured\n\nAll test scripts use `SafeToAutoRun=true` for safe commands like:\n- `chmod +x` (making scripts executable)\n- `pwsh script.ps1` (running test scripts)\n- `grep`, `ls`, `cat` (read-only operations)\n\nDestructive commands still require approval.\n\n---\n\n## Next Steps\n\nIf you encounter issues:\n\n1. **Check logs**: `/home/teej/ztest/module/.pmc-data/logs/pmc-tui-*.log`\n2. **Run tests**: Use the test scripts above\n3. **Enable debug logging**: `./Start-PmcTUI.ps1 -DebugLog -LogLevel 3`\n4. **Report specific errors**: Include log excerpts and screenshots\n"}, {"path": "module/Pmc.Strict/consoleui/ZIndex.ps1", "content": "# ZIndex.ps1 - Z-index constants for layer rendering\r\n#\r\n# Defines standard z-index values for UI elements.\r\n# Higher values render on top of lower values.\r\n#\r\n# Usage:\r\n#   $engine.BeginLayer([ZIndex]::Dropdown)\r\n#   $engine.WriteAt(10, 5, \"Popup content\")\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nZ-index constants for layered rendering\r\n\r\n.DESCRIPTION\r\nDefines standard z-index values used throughout the PMC TUI.\r\nThese constants ensure consistent layering behavior across all screens and widgets.\r\n\r\nZ-index ranges:\r\n- 0-49: Base content (background, main content, panels)\r\n- 50-99: Chrome (header, footer, menu bar)\r\n- 100-199: Overlays (dropdowns, tooltips)\r\n- 200-299: Modals (dialogs, popups)\r\n- 300+: Critical UI (errors, notifications)\r\n\r\n.EXAMPLE\r\n$engine.BeginLayer([ZIndex]::Content)\r\n# Render main content\r\n\r\n$engine.BeginLayer([ZIndex]::Dropdown)\r\n# Render dropdown (will appear on top)\r\n##CLOSEBRACKET##\r\nclass ZIndex {\r\n    # Base layer (default if no BeginLayer called)\r\n    static [int]$Default = 0\r\n\r\n    # Background elements\r\n    static [int]$Background = 0\r\n\r\n    # Main content area\r\n    static [int]$Content = 10\r\n\r\n    # Panels and widgets within content\r\n    static [int]$Panel = 20\r\n    static [int]$Widget = 25\r\n\r\n    # Chrome elements (always on top of content)\r\n    static [int]$Header = 50\r\n    static [int]$Footer = 55\r\n    static [int]$MenuBar = 60\r\n    static [int]$StatusBar = 65\r\n\r\n    # Overlays (temporary UI elements)\r\n    static [int]$Dropdown = 100\r\n    static [int]$Tooltip = 110\r\n    static [int]$ContextMenu = 120\r\n\r\n    # Modals (block interaction with content below)\r\n    static [int]$Dialog = 200\r\n    static [int]$Modal = 210\r\n    static [int]$Popup = 220\r\n\r\n    # Critical UI (highest priority)\r\n    static [int]$ErrorOverlay = 300\r\n    static [int]$Notification = 310\r\n    static [int]$DebugOverlay = 320\r\n}\r\n\r\n# Export for module usage\r\nExport-ModuleMember -Variable ZIndex"}, {"path": "module/Pmc.Strict/consoleui/base/StandardDashboard.ps1", "content": "# StandardDashboard.ps1 - Base class for dashboard-style screens\r\n#\r\n# This is the base class for screens that show multiple widgets/panels:\r\n# - Main Dashboard (task summary + project stats + time tracking)\r\n# - Analytics Dashboard (charts + metrics)\r\n# - Reports Dashboard (multiple report panels)\r\n#\r\n# Provides:\r\n# - Multi-widget layout (add panels dynamically)\r\n# - Tab/Arrow key navigation between widgets\r\n# - Focus management (one widget focused at a time)\r\n# - TaskStore integration (auto-refresh widgets on data changes)\r\n# - Flexible layout (auto-arrange or manual positioning)\r\n#\r\n# Usage:\r\n#   class MainDashboard : StandardDashboard {\r\n#       MainDashboard() : base(\"Dashboard\", \"PMC Dashboard\") {}\r\n#\r\n#       [void] InitializeWidgets() {\r\n#           # Add task summary widget\r\n#           $taskWidget = [TaskSummaryWidget]::new()\r\n#           $this.AddWidget($taskWidget, 0, 0, 50, 10)\r\n#\r\n#           # Add project stats widget\r\n#           $projectWidget = [ProjectStatsWidget]::new()\r\n#           $this.AddWidget($projectWidget, 52, 0, 50, 10)\r\n#\r\n#           # Add time tracking widget\r\n#           $timeWidget = [TimeTrackingWidget]::new()\r\n#           $this.AddWidget($timeWidget, 0, 12, 102, 8)\r\n#       }\r\n#   }\r\n\r\nusing namespace System\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# Load dependencies\r\n# NOTE: These are now loaded by the launcher script in the correct order.\r\n# Commenting out to avoid circular dependency issues.\r\n# $scriptDir = Split-Path -Parent $PSScriptRoot\r\n# . \"$scriptDir/PmcScreen.ps1\"\r\n# . \"$scriptDir/widgets/PmcWidget.ps1\"\r\n# . \"$scriptDir/widgets/PmcPanel.ps1\"\r\n# . \"$scriptDir/services/TaskStore.ps1\"\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nBase class for dashboard-style screens with multiple widgets\r\n\r\n.DESCRIPTION\r\nStandardDashboard provides a complete dashboard experience with:\r\n- Multiple widget/panel support\r\n- Tab/arrow key navigation between widgets\r\n- Focus management (one widget active at a time)\r\n- TaskStore integration for automatic data refresh\r\n- Auto-layout or manual positioning\r\n- Widget lifecycle management\r\n- Event-driven updates\r\n\r\nAbstract Methods (override in subclasses):\r\n- InitializeWidgets() - Create and add dashboard widgets\r\n\r\nOptional Overrides:\r\n- OnWidgetFocusChanged($oldWidget, $newWidget) - Handle focus changes\r\n- GetLayoutMode() - Return 'auto' or 'manual' (default: 'manual')\r\n- OnDataChanged() - Handle store data changes (refresh widgets)\r\n\r\nWidget Management:\r\n- AddWidget($widget, $x, $y, $width, $height) - Add widget with position\r\n- AddWidget($widget) - Add widget with auto-layout (if layout mode is 'auto')\r\n- RemoveWidget($widget) - Remove widget\r\n- FocusWidget($index) - Set focus to widget by index\r\n- FocusNextWidget() - Move focus to next widget\r\n- FocusPreviousWidget() - Move focus to previous widget\r\n\r\n.EXAMPLE\r\nclass MainDashboard : StandardDashboard {\r\n    MainDashboard() : base(\"Dashboard\", \"PMC Dashboard\") {}\r\n\r\n    [void] InitializeWidgets() {\r\n        # Task summary (top-left)\r\n        $taskWidget = [TaskSummaryWidget]::new()\r\n        $this.AddWidget($taskWidget, 0, 3, 50, 10)\r\n\r\n        # Project stats (top-right)\r\n        $projectWidget = [ProjectStatsWidget]::new()\r\n        $this.AddWidget($projectWidget, 52, 3, 50, 10)\r\n\r\n        # Time tracking (bottom)\r\n        $timeWidget = [TimeTrackingWidget]::new()\r\n        $this.AddWidget($timeWidget, 0, 15, 102, 8)\r\n    }\r\n}\r\n##CLOSEBRACKET##\r\nclass StandardDashboard : PmcScreen {\r\n    # === Core Components ===\r\n    [TaskStore]$Store = $null\r\n    [List[object]]$Widgets = [List[object]]::new()\r\n\r\n    # === State ===\r\n    [int]$FocusedWidgetIndex = -1\r\n    [string]$LayoutMode = \"manual\"  # 'auto' or 'manual'\r\n\r\n    # === Auto-Layout State ===\r\n    hidden [int]$_autoLayoutX = 0\r\n    hidden [int]$_autoLayoutY = 3\r\n    hidden [int]$_autoLayoutMaxHeight = 0\r\n\r\n    # === Configuration ===\r\n    [bool]$AllowWidgetNavigation = $true\r\n    [int]$WidgetPadding = 2  # Padding between widgets in auto-layout\r\n\r\n    # === Constructors ===\r\n\r\n    # Legacy constructor\r\n    StandardDashboard([string]$key, [string]$title) : base($key, $title) {\r\n        # Initialize components\r\n        $this._InitializeComponents()\r\n    }\r\n\r\n    # Container constructor\r\n    StandardDashboard([string]$key, [string]$title, [object]$container) : base($key, $title, $container) {\r\n        # Initialize components\r\n        $this._InitializeComponents()\r\n    }\r\n\r\n    # === Abstract Methods (MUST override) ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Initialize dashboard widgets (ABSTRACT - must override)\r\n    ##CLOSEBRACKET##\r\n    [void] InitializeWidgets() {\r\n        throw \"InitializeWidgets() must be implemented in subclass\"\r\n    }\r\n\r\n    # === Optional Override Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get layout mode ('auto' or 'manual')\r\n\r\n    .OUTPUTS\r\n    Layout mode string\r\n    ##CLOSEBRACKET##\r\n    [string] GetLayoutMode() {\r\n        return $this.LayoutMode\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle widget focus change (optional override)\r\n\r\n    .PARAMETER oldWidget\r\n    Previously focused widget\r\n\r\n    .PARAMETER newWidget\r\n    Newly focused widget\r\n    ##CLOSEBRACKET##\r\n    [void] OnWidgetFocusChanged($oldWidget, $newWidget) {\r\n        # Default: update status bar\r\n        if ($null -ne $newWidget -and $this.StatusBar) {\r\n            $widgetName = $(if ($newWidget.PanelTitle) { $newWidget.PanelTitle } else { \"Widget\" })\r\n            $this.StatusBar.SetLeftText(\"Focused: $widgetName\")\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle data changes from store (optional override)\r\n    ##CLOSEBRACKET##\r\n    [void] OnDataChanged() {\r\n        # Default: refresh all widgets\r\n        $this.RefreshAllWidgets()\r\n    }\r\n\r\n    # === Component Initialization ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Initialize all components\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _InitializeComponents() {\r\n        # Get terminal size\r\n        $termSize = $this._GetTerminalSize()\r\n        $this.TermWidth = $termSize.Width\r\n        $this.TermHeight = $termSize.Height\r\n\r\n        # Initialize TaskStore singleton\r\n        $this.Store = [TaskStore]::GetInstance()\r\n\r\n        # Wire up store events for auto-refresh\r\n        $this.Store.OnDataChanged = {\r\n            $this.OnDataChanged()\r\n        }\r\n\r\n        # Set layout mode\r\n        $this.LayoutMode = $this.GetLayoutMode()\r\n    }\r\n\r\n    # === Lifecycle Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Called when screen enters view\r\n    ##CLOSEBRACKET##\r\n    [void] OnEnter() {\r\n        $this.IsActive = $true\r\n\r\n        # Clear existing widgets\r\n        $this.Widgets.Clear()\r\n        $this.FocusedWidgetIndex = -1\r\n\r\n        # Reset auto-layout state\r\n        $this._autoLayoutX = 0\r\n        $this._autoLayoutY = 3\r\n        $this._autoLayoutMaxHeight = 0\r\n\r\n        # Initialize widgets (subclass implementation)\r\n        $this.InitializeWidgets()\r\n\r\n        # Focus first widget if any exist\r\n        if ($this.Widgets.Count -gt 0) {\r\n            $this.FocusWidget(0)\r\n        }\r\n\r\n        # Update header breadcrumb\r\n        if ($this.Header) {\r\n            $this.Header.SetBreadcrumb(@(\"Home\", $this.ScreenTitle))\r\n        }\r\n\r\n        # Update status bar\r\n        if ($this.StatusBar) {\r\n            $widgetCount = $this.Widgets.Count\r\n            $this.StatusBar.SetLeftText(\"$widgetCount widgets | Tab: Next widget\")\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Called when screen exits view\r\n    ##CLOSEBRACKET##\r\n    [void] OnDoExit() {\r\n        $this.IsActive = $false\r\n\r\n        # Cleanup widget resources\r\n        foreach ($widget in $this.Widgets) {\r\n            if ($widget.PSObject.Methods['Dispose']) {\r\n                $widget.Dispose()\r\n            }\r\n        }\r\n\r\n        $this.Widgets.Clear()\r\n        $this.FocusedWidgetIndex = -1\r\n    }\r\n\r\n    # === Widget Management ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Add a widget to the dashboard\r\n\r\n    .PARAMETER widget\r\n    Widget instance (must inherit from PmcWidget or PmcPanel)\r\n\r\n    .PARAMETER x\r\n    X position (optional, required for manual layout)\r\n\r\n    .PARAMETER y\r\n    Y position (optional, required for manual layout)\r\n\r\n    .PARAMETER width\r\n    Widget width (optional, required for manual layout)\r\n\r\n    .PARAMETER height\r\n    Widget height (optional, required for manual layout)\r\n    ##CLOSEBRACKET##\r\n    [void] AddWidget($widget, [int]$x = -1, [int]$y = -1, [int]$width = -1, [int]$height = -1) {\r\n        if ($null -eq $widget) {\r\n            return\r\n        }\r\n\r\n        # Set position and size based on layout mode\r\n        if ($this.LayoutMode -eq 'manual') {\r\n            if ($x -ge 0 -and $y -ge 0 -and $width -gt 0 -and $height -gt 0) {\r\n                $widget.SetPosition($x, $y)\r\n                $widget.SetSize($width, $height)\r\n            }\r\n            else {\r\n                throw \"Manual layout requires x, y, width, height parameters\"\r\n            }\r\n        }\r\n        elseif ($this.LayoutMode -eq 'auto') {\r\n            # Auto-layout: place widgets left-to-right, wrap to next row\r\n            $this._AutoLayoutWidget($widget, $width, $height)\r\n        }\r\n\r\n        # Add to widgets list\r\n        $this.Widgets.Add($widget)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Auto-layout a widget\r\n\r\n    .PARAMETER widget\r\n    Widget instance\r\n\r\n    .PARAMETER width\r\n    Widget width (required for auto-layout)\r\n\r\n    .PARAMETER height\r\n    Widget height (required for auto-layout)\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _AutoLayoutWidget($widget, [int]$width, [int]$height) {\r\n        if ($width -le 0 -or $height -le 0) {\r\n            throw \"Auto-layout requires width and height parameters\"\r\n        }\r\n\r\n        # Check if widget fits in current row\r\n        if ($this._autoLayoutX + $width -gt $this.TermWidth) {\r\n            # Wrap to next row\r\n            $this._autoLayoutX = 0\r\n            $this._autoLayoutY += $this._autoLayoutMaxHeight + $this.WidgetPadding\r\n            $this._autoLayoutMaxHeight = 0\r\n        }\r\n\r\n        # Position widget\r\n        $widget.SetPosition($this._autoLayoutX, $this._autoLayoutY)\r\n        $widget.SetSize($width, $height)\r\n\r\n        # Update auto-layout state\r\n        $this._autoLayoutX += $width + $this.WidgetPadding\r\n        $this._autoLayoutMaxHeight = [Math]::Max($this._autoLayoutMaxHeight, $height)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Remove a widget from the dashboard\r\n\r\n    .PARAMETER widget\r\n    Widget instance to remove\r\n    ##CLOSEBRACKET##\r\n    [void] RemoveWidget($widget) {\r\n        if ($null -eq $widget) {\r\n            return\r\n        }\r\n\r\n        $index = $this.Widgets.IndexOf($widget)\r\n        if ($index -ge 0) {\r\n            $this.Widgets.RemoveAt($index)\r\n\r\n            # Adjust focused widget index\r\n            if ($this.FocusedWidgetIndex -eq $index) {\r\n                if ($this.Widgets.Count -gt 0) {\r\n                    $this.FocusWidget(0)\r\n                }\r\n                else {\r\n                    $this.FocusedWidgetIndex = -1\r\n                }\r\n            }\r\n            elseif ($this.FocusedWidgetIndex -gt $index) {\r\n                $this.FocusedWidgetIndex--\r\n            }\r\n\r\n            # Cleanup widget\r\n            if ($widget.PSObject.Methods['Dispose']) {\r\n                $widget.Dispose()\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get widget by index\r\n\r\n    .PARAMETER index\r\n    Widget index\r\n\r\n    .OUTPUTS\r\n    Widget instance or $null if index out of range\r\n    ##CLOSEBRACKET##\r\n    [object] GetWidget([int]$index) {\r\n        if ($index -ge 0 -and $index -lt $this.Widgets.Count) {\r\n            return $this.Widgets[$index]\r\n        }\r\n        return $null\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get currently focused widget\r\n\r\n    .OUTPUTS\r\n    Focused widget instance or $null if no widget focused\r\n    ##CLOSEBRACKET##\r\n    [object] GetFocusedWidget() {\r\n        return $this.GetWidget($this.FocusedWidgetIndex)\r\n    }\r\n\r\n    # === Focus Management ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set focus to widget by index\r\n\r\n    .PARAMETER index\r\n    Widget index\r\n    ##CLOSEBRACKET##\r\n    [void] FocusWidget([int]$index) {\r\n        if ($index -lt 0 -or $index -ge $this.Widgets.Count) {\r\n            return\r\n        }\r\n\r\n        $oldWidget = $this.GetFocusedWidget()\r\n        $this.FocusedWidgetIndex = $index\r\n        $newWidget = $this.GetFocusedWidget()\r\n\r\n        # Update widget focus states\r\n        if ($null -ne $oldWidget -and $oldWidget.PSObject.Properties['IsFocused']) {\r\n            $oldWidget.IsFocused = $false\r\n        }\r\n\r\n        if ($null -ne $newWidget -and $newWidget.PSObject.Properties['IsFocused']) {\r\n            $newWidget.IsFocused = $true\r\n        }\r\n\r\n        # Fire focus change event\r\n        $this.OnWidgetFocusChanged($oldWidget, $newWidget)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move focus to next widget (Tab)\r\n    ##CLOSEBRACKET##\r\n    [void] FocusNextWidget() {\r\n        if ($this.Widgets.Count -eq 0) {\r\n            return\r\n        }\r\n\r\n        $nextIndex = ($this.FocusedWidgetIndex + 1) % $this.Widgets.Count\r\n        $this.FocusWidget($nextIndex)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move focus to previous widget (Shift+Tab)\r\n    ##CLOSEBRACKET##\r\n    [void] FocusPreviousWidget() {\r\n        if ($this.Widgets.Count -eq 0) {\r\n            return\r\n        }\r\n\r\n        $prevIndex = $this.FocusedWidgetIndex - 1\r\n        if ($prevIndex -lt 0) {\r\n            $prevIndex = $this.Widgets.Count - 1\r\n        }\r\n        $this.FocusWidget($prevIndex)\r\n    }\r\n\r\n    # === Widget Refresh ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Refresh all widgets (reload data)\r\n    ##CLOSEBRACKET##\r\n    [void] RefreshAllWidgets() {\r\n        foreach ($widget in $this.Widgets) {\r\n            if ($widget.PSObject.Methods['Refresh']) {\r\n                $widget.Refresh()\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Refresh a specific widget by index\r\n\r\n    .PARAMETER index\r\n    Widget index\r\n    ##CLOSEBRACKET##\r\n    [void] RefreshWidget([int]$index) {\r\n        $widget = $this.GetWidget($index)\r\n        if ($null -ne $widget -and $widget.PSObject.Methods['Refresh']) {\r\n            $widget.Refresh()\r\n        }\r\n    }\r\n\r\n    # === Input Handling ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle keyboard input\r\n\r\n    .PARAMETER keyInfo\r\n    ConsoleKeyInfo from [Console]::ReadKey($true)\r\n\r\n    .OUTPUTS\r\n    True if input was handled, False otherwise\r\n    ##CLOSEBRACKET##\r\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\r\n        # Tab navigation between widgets\r\n        if ($keyInfo.Key -eq 'Tab') {\r\n            if ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift) {\r\n                $this.FocusPreviousWidget()\r\n            }\r\n            else {\r\n                $this.FocusNextWidget()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Arrow key navigation between widgets (optional)\r\n        if ($keyInfo.Key -eq 'RightArrow' -and $this.AllowWidgetNavigation) {\r\n            $this.FocusNextWidget()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'LeftArrow' -and $this.AllowWidgetNavigation) {\r\n            $this.FocusPreviousWidget()\r\n            return $true\r\n        }\r\n\r\n        # Refresh shortcut\r\n        if ($keyInfo.Key -eq 'R') {\r\n            $this.RefreshAllWidgets()\r\n            return $true\r\n        }\r\n\r\n        # Route input to focused widget\r\n        $focusedWidget = $this.GetFocusedWidget()\r\n        if ($null -ne $focusedWidget) {\r\n            if ($focusedWidget.PSObject.Methods['HandleInput']) {\r\n                return $focusedWidget.HandleInput($keyInfo)\r\n            }\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    # === Rendering ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render the screen content area\r\n\r\n    .OUTPUTS\r\n    ANSI string ready for display\r\n    ##CLOSEBRACKET##\r\n    <#\r\n    .SYNOPSIS\r\n    Render content area directly to engine\r\n    ##CLOSEBRACKET##\r\n    [void] RenderContentToEngine([object]$engine) {\r\n        foreach ($widget in $this.Widgets) {\r\n            # Check if widget supports native rendering\r\n            if ($widget.PSObject.Methods['RenderToEngine']) {\r\n                $widget.RenderToEngine($engine)\r\n            }\r\n        }\r\n    }\r\n\r\n    [string] Render() { return \"\" }\r\n    [string] RenderContent() { return \"\" }\r\n\r\n    # === Helper Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get terminal size\r\n\r\n    .OUTPUTS\r\n    Hashtable with Width and Height properties\r\n    ##CLOSEBRACKET##\r\n    hidden [hashtable] _GetTerminalSize() {\r\n        $width = [Console]::WindowWidth\r\n        $height = [Console]::WindowHeight\r\n        return @{ Width = $width; Height = $height }\r\n    }\r\n\r\n    # === Utility Methods for Subclasses ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Create a simple text panel widget\r\n\r\n    .PARAMETER title\r\n    Panel title\r\n\r\n    .PARAMETER content\r\n    Panel content (text or array of lines)\r\n\r\n    .OUTPUTS\r\n    PmcPanel widget instance\r\n    ##CLOSEBRACKET##\r\n    [object] CreateTextPanel([string]$title, $content) {\r\n        $panel = [PmcPanel]::new()\r\n        $panel.PanelTitle = $title\r\n\r\n        if ($content -is [array]) {\r\n            $panel.SetContent($content)\r\n        }\r\n        else {\r\n            $panel.SetContent(@($content.ToString()))\r\n        }\r\n\r\n        return $panel\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get widget count\r\n\r\n    .OUTPUTS\r\n    Number of widgets in dashboard\r\n    ##CLOSEBRACKET##\r\n    [int] GetWidgetCount() {\r\n        return $this.Widgets.Count\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/base/StandardFormScreen.ps1", "content": "# StandardFormScreen.ps1 - Base class for form-based screens\r\n#\r\n# This is the base class for screens that present a single form for data entry:\r\n# - Add Task Screen\r\n# - Add Project Screen\r\n# - Settings Screen\r\n# - Edit Configuration Screen\r\n#\r\n# Provides:\r\n# - InlineEditor integration (multi-field form)\r\n# - TaskStore integration (save data on submit)\r\n# - Validation before submission\r\n# - Cancel/Back navigation\r\n# - Success/Error feedback\r\n#\r\n# Usage:\r\n#   class AddTaskScreen : StandardFormScreen {\r\n#       AddTaskScreen() : base(\"AddTask\", \"Add New Task\") {}\r\n#\r\n#       [array] GetFields() {\r\n#           return @(\r\n#               @{ Name='text'; Type='text'; Label='Task'; Required=$true }\r\n#               @{ Name='due'; Type='date'; Label='Due Date' }\r\n#               @{ Name='priority'; Type='number'; Label='Priority'; Min=0; Max=5; Value=3 }\r\n#           )\r\n#       }\r\n#\r\n#       [void] OnSubmit($values) {\r\n#           $this.Store.AddTask($values)\r\n#           $this.NavigateBack()\r\n#       }\r\n#   }\r\n\r\nusing namespace System\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# Load dependencies\r\n# NOTE: These are now loaded by the launcher script in the correct order.\r\n# Commenting out to avoid circular dependency issues.\r\n# $scriptDir = Split-Path -Parent $PSScriptRoot\r\n# . \"$scriptDir/PmcScreen.ps1\"\r\n# . \"$scriptDir/widgets/InlineEditor.ps1\"\r\n# . \"$scriptDir/services/TaskStore.ps1\"\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nBase class for form-based screens in PMC TUI\r\n\r\n.DESCRIPTION\r\nStandardFormScreen provides a complete form-entry experience with:\r\n- InlineEditor widget for multi-field forms\r\n- TaskStore integration for data persistence\r\n- Validation before submission\r\n- Success/error feedback\r\n- Cancel/back navigation\r\n- Event-driven callbacks\r\n\r\nAbstract Methods (override in subclasses):\r\n- GetFields() - Define form field configuration\r\n- OnSubmit($values) - Handle form submission\r\n\r\nOptional Overrides:\r\n- OnCancel() - Handle form cancellation (default: navigate back)\r\n- OnValidationFailed($errors) - Handle validation errors\r\n- GetEntityType() - Return 'task', 'project', or 'timelog' for store operations\r\n- GetSubmitLabel() - Return label for submit action (default: \"Save\")\r\n\r\n.EXAMPLE\r\nclass AddTaskScreen : StandardFormScreen {\r\n    AddTaskScreen() : base(\"AddTask\", \"Add New Task\") {}\r\n\r\n    [array] GetFields() {\r\n        return @(\r\n            @{ Name='text'; Type='text'; Label='Task'; Required=$true }\r\n            @{ Name='due'; Type='date'; Label='Due Date' }\r\n        )\r\n    }\r\n\r\n    [void] OnSubmit($values) {\r\n        if ($this.Store.AddTask($values)) {\r\n            $this.StatusBar.SetLeftText(\"Task added successfully\")\r\n            Start-Sleep -Milliseconds 500\r\n            $this.NavigateBack()\r\n        } else {\r\n            $this.StatusBar.SetLeftText(\"Failed to add task: $($this.Store.LastError)\")\r\n        }\r\n    }\r\n}\r\n##CLOSEBRACKET##\r\nclass StandardFormScreen : PmcScreen {\r\n    # === Core Components ===\r\n    [InlineEditor]$Editor = $null\r\n    [TaskStore]$Store = $null\r\n\r\n    # === State ===\r\n    [bool]$IsSubmitting = $false\r\n    [string[]]$ValidationErrors = @()\r\n\r\n    # === Configuration ===\r\n    [bool]$AllowCancel = $true\r\n    [string]$SubmitLabel = \"Save\"\r\n\r\n    # === Constructor (backward compatible - no container) ===\r\n    StandardFormScreen([string]$key, [string]$title) : base($key, $title) {\r\n        # Initialize components\r\n        $this._InitializeComponents()\r\n    }\r\n\r\n    # === Constructor (with ServiceContainer) ===\r\n    StandardFormScreen([string]$key, [string]$title, [object]$container) : base($key, $title, $container) {\r\n        # Initialize components\r\n        $this._InitializeComponents()\r\n    }\r\n\r\n    # === Abstract Methods (MUST override) ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get form field configuration (ABSTRACT - must override)\r\n\r\n    .OUTPUTS\r\n    Array of field hashtables for InlineEditor\r\n    ##CLOSEBRACKET##\r\n    [array] GetFields() {\r\n        throw \"GetFields() must be implemented in subclass\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle form submission (ABSTRACT - must override)\r\n\r\n    .PARAMETER values\r\n    Hashtable of field values from form\r\n    ##CLOSEBRACKET##\r\n    [void] OnSubmit($values) {\r\n        throw \"OnSubmit() must be implemented in subclass\"\r\n    }\r\n\r\n    # === Optional Override Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get entity type for store operations ('task', 'project', 'timelog', 'custom')\r\n\r\n    .OUTPUTS\r\n    Entity type string\r\n    ##CLOSEBRACKET##\r\n    [string] GetEntityType() {\r\n        # Default to 'custom' - override if using task/project/timelog directly\r\n        return 'custom'\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle form cancellation (optional override)\r\n    ##CLOSEBRACKET##\r\n    [void] OnCancel() {\r\n        # Default: navigate back\r\n        $this.NavigateBack()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle validation failure (optional override)\r\n\r\n    .PARAMETER errors\r\n    Array of validation error messages\r\n    ##CLOSEBRACKET##\r\n    [void] OnValidationFailed($errors) {\r\n        # Default: show first error in status bar\r\n        if ($this.StatusBar -and $errors.Count -gt 0) {\r\n            $this.StatusBar.SetLeftText(\"Validation error: $($errors[0])\")\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get submit button label (optional override)\r\n\r\n    .OUTPUTS\r\n    Submit button label string\r\n    ##CLOSEBRACKET##\r\n    [string] GetSubmitLabel() {\r\n        return $this.SubmitLabel\r\n    }\r\n\r\n    # === Component Initialization ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Initialize all components\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _InitializeComponents() {\r\n        # Get terminal size\r\n        $termSize = $this._GetTerminalSize()\r\n        $this.TermWidth = $termSize.Width\r\n        $this.TermHeight = $termSize.Height\r\n\r\n        # Initialize TaskStore singleton\r\n        $this.Store = [TaskStore]::GetInstance()\r\n\r\n        # Initialize InlineEditor\r\n        $this.Editor = [InlineEditor]::new()\r\n        $editorWidth = [Math]::Min(80, $this.TermWidth - 10)\r\n        $editorHeight = [Math]::Min(30, $this.TermHeight - 8)\r\n        $editorX = [Math]::Floor(($this.TermWidth - $editorWidth) / 2)\r\n        $editorY = 4\r\n        $this.Editor.SetPosition($editorX, $editorY)\r\n        $this.Editor.SetSize($editorWidth, $editorHeight)\r\n        $this.Editor.Title = $this.ScreenTitle\r\n\r\n        # Wire up editor events\r\n        $this.Editor.OnConfirmed = {\r\n            param($values)\r\n            $this._HandleSubmit($values)\r\n        }\r\n\r\n        $this.Editor.OnCancelled = {\r\n            $this._HandleCancel()\r\n        }\r\n\r\n        $this.Editor.OnValidationFailed = {\r\n            param($errors)\r\n            $this.ValidationErrors = $errors\r\n            $this.OnValidationFailed($errors)\r\n        }\r\n    }\r\n\r\n    # === Lifecycle Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Called when screen enters view\r\n    ##CLOSEBRACKET##\r\n    [void] OnEnter() {\r\n        $this.IsActive = $true\r\n\r\n        # Set form fields\r\n        $fields = $this.GetFields()\r\n        $this.Editor.SetFields($fields)\r\n\r\n        # Update header breadcrumb\r\n        if ($this.Header) {\r\n            $this.Header.SetBreadcrumb(@(\"Home\", $this.ScreenTitle))\r\n        }\r\n\r\n        # Update status bar\r\n        if ($this.StatusBar) {\r\n            $submitLabelText = $this.GetSubmitLabel()\r\n            $this.StatusBar.SetLeftText(\"Fill out the form and press Enter to $submitLabelText\")\r\n        }\r\n\r\n        # Reset state\r\n        $this.IsSubmitting = $false\r\n        $this.ValidationErrors = @()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Called when screen exits view\r\n    ##CLOSEBRACKET##\r\n    [void] OnDoExit() {\r\n        $this.IsActive = $false\r\n    }\r\n\r\n    # === Form Submission ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle form submission\r\n\r\n    .PARAMETER values\r\n    Field values from InlineEditor\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _HandleSubmit($values) {\r\n        if ($this.IsSubmitting) {\r\n            # Prevent double-submit\r\n            return\r\n        }\r\n\r\n        $this.IsSubmitting = $true\r\n\r\n        try {\r\n            # Clear previous errors\r\n            $this.ValidationErrors = @()\r\n\r\n            # Show submitting status\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetLeftText(\"Submitting...\")\r\n            }\r\n\r\n            # Call subclass implementation\r\n            $this.OnSubmit($values)\r\n        }\r\n        finally {\r\n            $this.IsSubmitting = $false\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle form cancellation\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _HandleCancel() {\r\n        if (-not $this.AllowCancel) {\r\n            # Cancel not allowed\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetLeftText(\"Cannot cancel this form\")\r\n            }\r\n            return\r\n        }\r\n\r\n        # Call subclass implementation\r\n        $this.OnCancel()\r\n    }\r\n\r\n    # === Navigation ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Navigate back to previous screen\r\n    ##CLOSEBRACKET##\r\n    [void] NavigateBack() {\r\n        # This will be implemented by NavigationManager integration\r\n        # For now, set a flag that the application can check\r\n        $this.IsActive = $false\r\n    }\r\n\r\n    # === Input Handling ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle keyboard input\r\n\r\n    .PARAMETER keyInfo\r\n    ConsoleKeyInfo from [Console]::ReadKey($true)\r\n\r\n    .OUTPUTS\r\n    True if input was handled, False otherwise\r\n    ##CLOSEBRACKET##\r\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\r\n        # Route all input to editor\r\n        return $this.Editor.HandleInput($keyInfo)\r\n    }\r\n\r\n    # === Rendering ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render the screen content area\r\n\r\n    .OUTPUTS\r\n    ANSI string ready for display\r\n    ##CLOSEBRACKET##\r\n    <#\r\n    .SYNOPSIS\r\n    Render content area directly to engine\r\n    ##CLOSEBRACKET##\r\n    [void] RenderContentToEngine([object]$engine) {\r\n        if ($null -ne $this.Editor) {\r\n            $this.Editor.RenderToEngine($engine)\r\n        }\r\n\r\n        # Render validation errors\r\n        if ($this.ValidationErrors.Count -gt 0) {\r\n            $errorY = $this.Editor.Y + $this.Editor.Height + 1\r\n            $errorX = $this.Editor.X\r\n            \r\n            # Colors\r\n            $errorFg = $this.Header.GetThemedColorInt('Foreground.Error')\r\n            $bg = $this.Header.GetThemedColorInt('Background.Primary')\r\n            \r\n            $engine.WriteAt($errorX, $errorY, \"Validation Errors:\", $errorFg, $bg)\r\n            \r\n            for ($i = 0; $i -lt [Math]::Min(3, $this.ValidationErrors.Count); $i++) {\r\n                $errorMsgY = $errorY + $i + 1\r\n                $engine.WriteAt($errorX, $errorMsgY, \"  - $($this.ValidationErrors[$i])\", $errorFg, $bg)\r\n            }\r\n            \r\n            if ($this.ValidationErrors.Count -gt 3) {\r\n                $moreY = $errorY + 4\r\n                $engine.WriteAt($errorX, $moreY, \"  ... and $($this.ValidationErrors.Count - 3) more errors\", $errorFg, $bg)\r\n            }\r\n        }\r\n    }\r\n\r\n    [string] Render() { return \"\" }\r\n    [string] RenderContent() { return \"\" }\r\n\r\n    # === Helper Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get terminal size\r\n\r\n    .OUTPUTS\r\n    Hashtable with Width and Height properties\r\n    ##CLOSEBRACKET##\r\n    hidden [hashtable] _GetTerminalSize() {\r\n        $width = [Console]::WindowWidth\r\n        $height = [Console]::WindowHeight\r\n        return @{ Width = $width; Height = $height }\r\n    }\r\n\r\n    # === Utility Methods for Subclasses ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Show success message and navigate back after delay\r\n\r\n    .PARAMETER message\r\n    Success message to display\r\n\r\n    .PARAMETER delayMs\r\n    Delay in milliseconds before navigating back (default 1000)\r\n    ##CLOSEBRACKET##\r\n    [void] ShowSuccessAndNavigateBack([string]$message, [int]$delayMs = 1000) {\r\n        if ($this.StatusBar) {\r\n            $successColor = \"`e[32m\"  # Green\r\n            $reset = \"`e[0m\"\r\n            $this.StatusBar.SetLeftText(\"$successColor$message$reset\")\r\n        }\r\n\r\n        Start-Sleep -Milliseconds $delayMs\r\n        $this.NavigateBack()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Show error message\r\n\r\n    .PARAMETER message\r\n    Error message to display\r\n    ##CLOSEBRACKET##\r\n    [void] ShowError([string]$message) {\r\n        if ($this.StatusBar) {\r\n            $errorColor = \"`e[31m\"  # Red\r\n            $reset = \"`e[0m\"\r\n            $this.StatusBar.SetLeftText(\"$errorColor$message$reset\")\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get current field values from editor\r\n\r\n    .OUTPUTS\r\n    Hashtable of current field values\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetCurrentValues() {\r\n        return $this.Editor.GetValues()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set field value in editor\r\n\r\n    .PARAMETER fieldName\r\n    Field name\r\n\r\n    .PARAMETER value\r\n    New value\r\n    ##CLOSEBRACKET##\r\n    [void] SetFieldValue([string]$fieldName, $value) {\r\n        # This requires modifying the field definition and re-setting fields\r\n        $fields = $this.GetFields()\r\n        $field = $fields | Where-Object { $_.Name -eq $fieldName } | Select-Object -First 1\r\n\r\n        if ($null -ne $field) {\r\n            $field.Value = $value\r\n            $this.Editor.SetFields($fields)\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/base/StandardListScreen.ps1", "content": "using namespace System\nusing namespace System.Collections.Generic\nusing namespace System.Text\n\n# StandardListScreen.ps1 - Base class for ALL list-based screens\n#\n# This is the FOUNDATION for every screen that shows a list of items:\n# - TaskListScreen\n# - ProjectListScreen\n# - TimeLogListScreen\n# - SearchResultsScreen\n# - etc.\n#\n# Provides:\n# - UniversalList integration (columns, sorting, filtering, search)\n# - FilterPanel integration (dynamic filter builder)\n# - InlineEditor integration (add/edit items)\n# - TaskStore integration (automatic CRUD + events)\n# - Keyboard navigation (arrows, PageUp/Down, Home/End)\n# - Action handling (Add, Edit, Delete, custom actions)\n# - Automatic UI refresh on data changes\n#\n# Usage:\n#   class TaskListScreen : StandardListScreen {\n#       TaskListScreen() : base(\"TaskList\", \"My Tasks\") {\n#           # Configuration in constructor\n#       }\n#\n#       [void] LoadData() {\n#           $tasks = $this.Store.GetAllTasks() | Where { -not $_.completed }\n#           $this.List.SetData($tasks)\n#       }\n#\n#       [array] GetColumns() {\n#           return @(\n#               @{ Name='priority'; Label='Pri'; Width=4 }\n#               @{ Name='text'; Label='Task'; Width=40 }\n#               @{ Name='due'; Label='Due'; Width=12 }\n#           )\n#       }\n#\n#       [array] GetEditFields($item) {\n#           return @(\n#               @{ Name='text'; Type='text'; Label='Task'; Value=$item.text; Required=$true }\n#               @{ Name='due'; Type='date'; Label='Due'; Value=$item.due }\n#               @{ Name='priority'; Type='number'; Label='Priority'; Value=$item.priority; Min=0; Max=5 }\n#           )\n#       }\n#   }\n\nSet-StrictMode -Version Latest\n\n# Load dependencies\n# NOTE: These are now loaded by the launcher script in the correct order.\n# Commenting out to avoid circular dependency issues.\n# $scriptDir = Split-Path -Parent $PSScriptRoot\n# . \"$scriptDir/PmcScreen.ps1\"\n# . \"$scriptDir/widgets/UniversalList.ps1\"\n# . \"$scriptDir/widgets/FilterPanel.ps1\"\n# . \"$scriptDir/widgets/InlineEditor.ps1\"\n# . \"$scriptDir/services/TaskStore.ps1\"\n\n<#\n.SYNOPSIS\nBase class for all list-based screens in PMC TUI\n\n.DESCRIPTION\nStandardListScreen provides a complete list-viewing experience with:\n- Universal list widget with columns, sorting, filtering\n- Filter panel for advanced filtering\n- Inline editor for add/edit operations\n- TaskStore integration for automatic CRUD\n- Event-driven UI updates\n- Keyboard-driven navigation\n- Extensible via abstract methods\n\nAbstract Methods (override in subclasses):\n- LoadData() - Load data into list\n- GetColumns() - Define column configuration\n- GetEditFields($item) - Define edit form fields\n\nOptional Overrides:\n- OnItemSelected($item) - Handle item selection\n- OnItemActivated($item) - Handle item activation (Enter key)\n- GetCustomActions() - Add custom actions beyond Add/Edit/Delete\n- GetEntityType() - Return 'task', 'project', or 'timelog' for store operations\n\n.EXAMPLE\n# Example: List screen implementation\n# class MyListScreen : StandardListScreen {\n#     MyListScreen() : base(\"MyList\", \"My Items\") {}\n#\n#     [void] LoadData() {\n#         $items = $this.Store.GetAllItems()\n#         $this.List.SetData($items)\n#     }\n#\n#     [array] GetColumns() {\n#         return @(\n#             @{ Name='name'; Label='Name'; Width=40 }\n#             @{ Name='status'; Label='Status'; Width=12 }\n#         )\n#     }\n#\n#     [array] GetEditFields($item) {\n#         return @(\n#             @{ Name='name'; Type='text'; Label='Name'; Value=$item.name; Required=$true }\n#         )\n#     }\n# }\n##CLOSEBRACKET##\nclass StandardListScreen : PmcScreen {\n    # === Core Components ===\n    [UniversalList]$List = $null\n    [FilterPanel]$FilterPanel = $null\n    [InlineEditor]$InlineEditor = $null\n    [TaskStore]$Store = $null\n\n    # === Component State ===\n    [bool]$ShowFilterPanel = $false\n    [bool]$ShowInlineEditor = $false\n    [string]$EditorMode = \"\"  # 'add' or 'edit'\n    [object]$CurrentEditItem = $null\n    hidden [bool]$_isHandlingInput = $false  # Re-entry guard for HandleKeyPress\n\n    # === Configuration ===\n    [bool]$AllowAdd = $true\n    [bool]$AllowEdit = $true\n    [bool]$AllowDelete = $true\n    [bool]$AllowFilter = $true\n    [bool]$AllowSearch = $true\n    [bool]$AllowMultiSelect = $true\n\n    # === Constructor (backward compatible - no container) ===\n    StandardListScreen([string]$key, [string]$title) : base($key, $title) {\n        # UniversalList has its own status and action footer, so disable the screen's StatusBar\n        # FIX: Re-enable StatusBar for delete confirmation and messages\n        # $this.StatusBar = $null\n\n        # Initialize components\n        $this._InitializeComponents()\n    }\n\n    # === Constructor (with ServiceContainer) ===\n    StandardListScreen([string]$key, [string]$title, [object]$container) : base($key, $title, $container) {\n        # UniversalList has its own status and action footer, so disable the screen's StatusBar\n        # FIX: Re-enable StatusBar for delete confirmation and messages\n        # $this.StatusBar = $null\n\n        # Initialize components\n        $this._InitializeComponents()\n    }\n\n    # === Initialization ===\n\n    <#\n    .SYNOPSIS\n    Initialize screen with render engine and load initial data\n    ##CLOSEBRACKET##\n    [void] Initialize([object]$renderEngine) {\n        \n        # Call base class initialization\n        ([PmcScreen]$this).Initialize($renderEngine)\n\n        # Load data into the list\n        $this.LoadData()\n\n        $this.RefreshList()\n\n    }\n\n    # === Abstract Methods (MUST override) ===\n\n    # === Layout Methods ===\n\n    [void] Resize([int]$width, [int]$height) {\n        # Set dimensions first\n        $this.TermWidth = $width\n        $this.TermHeight = $height\n\n        # Ensure LayoutManager exists\n        if (-not $this.LayoutManager) {\n            $this.LayoutManager = [PmcLayoutManager]::new()\n            $this.LayoutManager.DefineRegion('ListContent', 0, 6, '100%', 'FILL')\n        }\n\n        # Apply layout to Header, Footer, MenuBar, StatusBar via base\n        if ($this.MenuBar) {\n            $rect = $this.LayoutManager.GetRegion('MenuBar', $width, $height)\n            $this.MenuBar.SetPosition($rect.X, $rect.Y)\n            $this.MenuBar.SetSize($rect.Width, $rect.Height)\n        }\n        if ($this.Header) {\n            $rect = $this.LayoutManager.GetRegion('Header', $width, $height)\n            $this.Header.SetPosition($rect.X, $rect.Y)\n            $this.Header.SetSize($rect.Width, $rect.Height)\n        }\n        if ($this.Footer) {\n            $rect = $this.LayoutManager.GetRegion('Footer', $width, $height)\n            $this.Footer.SetPosition($rect.X, $rect.Y)\n            $this.Footer.SetSize($rect.Width, $rect.Height)\n        }\n        if ($this.StatusBar) {\n            $rect = $this.LayoutManager.GetRegion('StatusBar', $width, $height)\n            $this.StatusBar.SetPosition($rect.X, $rect.Y)\n            $this.StatusBar.SetSize($rect.Width, $rect.Height)\n        }\n\n        # CRITICAL FIX: Let subclasses apply their own content layout AFTER chrome\n        # Subclasses like TaskListScreen override ApplyContentLayout for 70/30 split\n        $this.ApplyContentLayout($this.LayoutManager, $width, $height)\n\n        # Resize overlays\n        if ($this.FilterPanel) {\n            $this.FilterPanel.SetPosition([Math]::Max(0, [Math]::Floor(($width - 80) / 2)), 5)\n        }\n\n        # InlineEditor resizes itself based on active row usually\n    }\n\n    # Default content layout - subclasses override for custom layouts like 70/30 split\n    [void] ApplyContentLayout([PmcLayoutManager]$layoutManager, [int]$termWidth, [int]$termHeight) {\n        # Full-width list for standard list screens\n        if ($this.List) {\n            try {\n                $contentRect = $layoutManager.GetRegion('ListContent', $termWidth, $termHeight)\n            } catch {\n                # Fallback: define the region now\n                $layoutManager.DefineRegion('ListContent', 0, 6, '100%', 'FILL')\n                $contentRect = $layoutManager.GetRegion('ListContent', $termWidth, $termHeight)\n            }\n            $this.List.SetPosition($contentRect.X, $contentRect.Y)\n            $this.List.SetSize($contentRect.Width, $contentRect.Height)\n        }\n    }\n\n    # === Rendering ===\n\n    <#\n    .SYNOPSIS\n    Render screen components to the engine\n    ##CLOSEBRACKET##\n    [void] RenderToEngine([object]$engine) {\n\n        # 1. Render base chrome (Menu, Header, Footer, etc.)\n        ([PmcScreen]$this).RenderToEngine($engine)\n\n        # 2. Render List (Main Content)\n        if ($this.List) {\n            # Ensure render mode is correct\n            $this.List.RenderToEngine($engine)\n        }\n\n        # 3. Render Overlays (Z-ordered on top)\n        if ($this.ShowFilterPanel -and $this.FilterPanel) {\n            $this.FilterPanel.RenderToEngine($engine)\n        }\n\n        if ($this.ShowInlineEditor -and $this.InlineEditor) {\n            # CRITICAL FIX: Position editor over the current row\n            if ($this.List) {\n                $selIndex = $this.List.GetSelectedIndex()\n                $scrollOffset = $this.List.GetScrollOffset()\n                $relativeIndex = $selIndex - $scrollOffset\n                \n                # Check if visible\n                if ($relativeIndex -ge 0 -and $relativeIndex -lt ($this.List.Height - 4)) {\n                    # List Y + TopBorder(1) + Header(1) + Separator(1) = Y+3 ??\n                    # UniversalList render: Header=Y, Sep=Y+1, Row0=Y+2.\n                    # Wait, if Title is empty:\n                    # UniversalList (fixed layout):\n                    # Y   : Top Border\n                    # Y+1 : Header Labels\n                    # Y+2 : Separator\n                    # Y+3 : Row 0\n                    # So offset should be +3.\n                    $editY = $this.List.Y + 3 + $relativeIndex\n                    \n                    # Update Editor Geometry to match row\n                    $this.InlineEditor.X = $this.List.X + 2  # Inside border\n                    $this.InlineEditor.Y = $editY\n                    $this.InlineEditor.Width = $this.List.Width - 4 # Inside borders\n                    $this.InlineEditor.Height = 1 # Single row mode\n                    \n                    # Force layout recalc\n                    # $this.InlineEditor.Resize(...) isn't needed if we set props directly \n                }\n            }\n            $this.InlineEditor.RenderToEngine($engine)\n        }\n    }\n\n    # === Abstract Methods (MUST override) ===\n\n    <#\n    .SYNOPSIS\n    Load data into the list (ABSTRACT - must override)\n    ##CLOSEBRACKET##\n    [void] LoadData() {\n        throw \"LoadData() must be implemented in subclass\"\n    }\n\n    <#\n    .SYNOPSIS\n    Get column configuration (ABSTRACT - must override)\n\n    .OUTPUTS\n    Array of column hashtables with Name, Label, Width, Align, Format properties\n    ##CLOSEBRACKET##\n    [array] GetColumns() {\n        throw \"GetColumns() must be implemented in subclass\"\n    }\n\n    <#\n    .SYNOPSIS\n    Get edit field configuration (ABSTRACT - must override)\n\n    .PARAMETER item\n    Item being edited (or empty hashtable for new item)\n\n    .OUTPUTS\n    Array of field hashtables for InlineEditor\n    ##CLOSEBRACKET##\n    [array] GetEditFields($item) {\n        throw \"GetEditFields() must be implemented in subclass\"\n    }\n\n    # === Optional Override Methods ===\n\n    <#\n    .SYNOPSIS\n    Get entity type for store operations ('task', 'project', 'timelog')\n\n    .OUTPUTS\n    Entity type string\n    ##CLOSEBRACKET##\n    [string] GetEntityType() {\n        # Default to 'task' - override if using projects or timelogs\n        return 'task'\n    }\n\n    <#\n    .SYNOPSIS\n    Handle item selection change (optional override)\n\n    .PARAMETER item\n    Selected item\n    ##CLOSEBRACKET##\n    [void] OnItemSelected($item) {\n        # Default: update status bar\n        if ($null -ne $item -and $this.StatusBar) {\n            try {\n                $text = $(if ($null -ne $item.text) { $item.text } elseif ($null -ne $item.name) { $item.name } else { \"Item selected\" })\n                $this.StatusBar.SetLeftText($text)\n            }\n            catch {\n                # Write-PmcTuiLog \"OnItemSelected: Error accessing item properties: $_\" \"ERROR\"\n            }\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Handle item activation (Enter key) (optional override)\n\n    .PARAMETER item\n    Activated item\n    ##CLOSEBRACKET##\n    [void] OnItemActivated($item) {\n        # Default: open inline editor\n        try {\n            $this.EditItem($item)\n        }\n        catch {\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Get custom actions beyond Add/Edit/Delete (optional override)\n\n    .OUTPUTS\n    Array of action hashtables with Key, Label, Callback properties\n    ##CLOSEBRACKET##\n    [array] GetCustomActions() {\n        return @()\n    }\n\n    # === Component Initialization ===\n\n    <#\n    .SYNOPSIS\n    Initialize all components\n    ##CLOSEBRACKET##\n    hidden [void] _InitializeComponents() {\n        # Get terminal size\n        $termSize = $this._GetTerminalSize()\n        $this.TermWidth = $termSize.Width\n        $this.TermHeight = $termSize.Height\n\n        # Initialize TaskStore singleton\n        $this.Store = [TaskStore]::GetInstance()\n\n        # Initialize UniversalList\n        $this.List = [UniversalList]::new()\n\n        # LAYOUTMANAGER FIX: Use LayoutManager for positioning instead of hardcoded values\n        # NOTE: List screens use full-width layout (no side margins) unlike other screens\n        if (-not $this.LayoutManager) {\n            $this.LayoutManager = [PmcLayoutManager]::new()\n            # Define a full-width 'ListContent' region for list screens\n            # X=0, Y=6 to start below header, Width=100%, Height=FILL\n            $this.LayoutManager.DefineRegion('ListContent', 0, 6, '100%', 'FILL')\n        }\n        $contentRect = $this.LayoutManager.GetRegion('ListContent', $this.TermWidth, $this.TermHeight)\n        $this.List.SetPosition($contentRect.X, $contentRect.Y)\n        $this.List.SetSize($contentRect.Width, $contentRect.Height)\n\n        $this.List.Title = \"\" # Empty title to avoid duplication with Screen Header\n        $this.List.AllowMultiSelect = $this.AllowMultiSelect\n        $this.List.AllowInlineEdit = $this.AllowEdit\n        $this.List.AllowSearch = $this.AllowSearch\n\n        # FIX Z-ORDER BUG: Disable Header separator since UniversalList draws its own box\n        # The Header separator was overlapping list content (Header z=50 beats Content z=10)\n        if ($this.Header) {\n            $this.Header.ShowSeparator = $false\n        }\n\n        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] StandardListScreen._InitializeComponents: List created\"\n        # }\n\n        # Wire up list events using GetNewClosure()\n        $self = $this\n        $this.List.OnSelectionChanged = {\n            param($item)\n            $self.OnItemSelected($item)\n        }.GetNewClosure()\n\n        $this.List.OnItemEdit = {\n            param($data)\n            # Data is hashtable with Item and Values keys from inline editing\n            if ($data -is [hashtable] -and $data.ContainsKey('Values')) {\n                $self.OnItemUpdated($data.Item, $data.Values)\n            }\n            else {\n                # Legacy callback - just open editor\n                $self.EditItem($data)\n            }\n        }.GetNewClosure()\n\n        $this.List.OnItemDelete = {\n            param($item)\n            $self.DeleteItem($item)\n        }.GetNewClosure()\n\n        $this.List.OnItemActivated = {\n            param($item)\n            $self.OnItemActivated($item)\n        }.GetNewClosure()\n\n        # Initialize FilterPanel\n        $this.FilterPanel = [FilterPanel]::new()\n        $this.FilterPanel.SetPosition(10, 5)\n        $this.FilterPanel.SetSize(80, 12)\n        $this.FilterPanel.OnFiltersChanged = {\n            param($filters)\n            $this._ApplyFilters()\n        }\n\n        # Initialize InlineEditor\n        $this.InlineEditor = [InlineEditor]::new()\n        # Use properties, not methods (SetPosition/SetSize don't exist)\n        $termSize = $this._GetTerminalSize()\n        $this.InlineEditor.X = [Math]::Max(1, [Math]::Floor(($termSize.Width - 70) / 2))\n        $this.InlineEditor.Y = [Math]::Max(3, [Math]::Floor(($termSize.Height - 15) / 2))\n        $this.InlineEditor.Width = [Math]::Min(70, $termSize.Width - 2)\n        $this.InlineEditor.Height = [Math]::Min(15, $termSize.Height - 4)\n        # Capture $this explicitly to avoid wrong screen receiving callback\n        $thisScreen = $this\n        $this.InlineEditor.OnConfirmed = {\n            param($text)\n            $thisScreen.OnInlineEditConfirmed($text)\n        }.GetNewClosure()\n\n        $this.InlineEditor.OnCancelled = {\n            $thisScreen.OnInlineEditCancelled()\n        }.GetNewClosure()\n\n        # Add widgets to content list for rendering\n        $this.AddContentWidget($this.List)\n        # BUG FIX: Do NOT add FilterPanel and InlineEditor to ContentWidgets.\n        # They are overlay widgets managed manually in RenderToEngine for precise Z-ordering.\n        # Adding them here causes double rendering (once by base PmcScreen, once by subclass).\n        # $this.AddContentWidget($this.FilterPanel)\n        # $this.AddContentWidget($this.InlineEditor)\n\n        $this.InlineEditor.OnValidationFailed = {\n            param($errors)\n            # Show first validation error in status bar\n            if ($errors -and $errors.Count -gt 0) {\n                $thisScreen.SetStatusMessage($errors[0], \"error\")\n            }\n        }.GetNewClosure()\n\n        # Wire up store events for auto-refresh\n        # Use $self to capture THIS screen instance, not global current screen\n        $self = $this\n        $entityType = $this.GetEntityType()\n        switch ($entityType) {\n            'task' {\n                $this.Store.OnTasksChanged = {\n                    param($tasks)\n                    if ($self.IsActive) {\n                        $self.RefreshList()\n                    }\n                }.GetNewClosure()\n            }\n            'project' {\n                $this.Store.OnProjectsChanged = {\n                    param($projects)\n                    if ($self.IsActive) {\n                        $self.RefreshList()\n                    }\n                }.GetNewClosure()\n            }\n            'timelog' {\n                $this.Store.OnTimeLogsChanged = {\n                    param($logs)\n                    if ($self.IsActive) {\n                        $self.RefreshList()\n                    }\n                }.GetNewClosure()\n            }\n        }\n\n        # Configure list actions\n        $this._ConfigureListActions()\n    }\n\n    <#\n    .SYNOPSIS\n    Configure list actions (Add, Edit, Delete, + custom)\n    ##CLOSEBRACKET##\n    hidden [void] _ConfigureListActions() {\n        # }\n\n\n        if ($this.AllowAdd) {\n            # Use GetNewClosure() to capture current scope\n            $addAction = {\n                # Find the screen that owns this List by walking up\n                $currentScreen = $global:PmcApp.CurrentScreen\n                # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] Action 'a' callback: currentScreen type=$($currentScreen.GetType().Name) key=$($currentScreen.ScreenKey)\"\n                # }\n                $currentScreen.AddItem()\n            }.GetNewClosure()\n            $this.List.AddAction('a', 'Add', $addAction)\n        }\n\n        if ($this.AllowDelete) {\n            $deleteAction = {\n                $currentScreen = $global:PmcApp.CurrentScreen\n                $currentScreen.DeleteItem($currentScreen.List.GetSelectedItem())\n            }.GetNewClosure()\n            $this.List.AddAction('d', 'Delete', $deleteAction)\n        }\n\n        if ($this.AllowEdit) {\n            $editAction = {\n                $currentScreen = $global:PmcApp.CurrentScreen\n                $selectedItem = $currentScreen.List.GetSelectedItem()\n                if ($null -ne $selectedItem) {\n                    $currentScreen.EditItem($selectedItem)\n                }\n            }.GetNewClosure()\n            $this.List.AddAction('e', 'Edit', $editAction)\n        }\n\n\n        # Add custom actions from subclass\n        try {\n            $customActions = $this.GetCustomActions()\n            $actionCount = $(if ($customActions -is [array]) { $customActions.Count } else { 1 })\n            if ($null -ne $customActions) {\n                foreach ($action in $customActions) {\n                    if ($null -ne $action -and $action -is [hashtable] -and $action.ContainsKey('Key') -and $action.ContainsKey('Label') -and $action.ContainsKey('Callback')) {\n                        $this.List.AddAction($action.Key, $action.Label, $action.Callback)\n                    }\n                }\n            }\n        }\n        catch {\n            # Write-PmcTuiLog \"_ConfigureListActions: Error adding custom actions: $_\" \"ERROR\"\n            # Write-PmcTuiLog \"_ConfigureListActions: Error stack: $($_.ScriptStackTrace)\" \"ERROR\"\n        }\n    }\n\n    # === Lifecycle Methods ===\n\n    <#\n    .SYNOPSIS\n    Called when screen enters view\n    ##CLOSEBRACKET##\n    [void] OnEnter() {\n        $this.IsActive = $true\n\n        # CRITICAL FIX: Force layout update on enter to ensure correct sizing\n        # This fixes invisible MenuBar/Footer issues caused by 0x0 size\n        $termSize = $this._GetTerminalSize()\n        $this.Resize($termSize.Width, $termSize.Height)\n\n        # Configure list actions (ensures custom actions are registered even for singleton screens)\n        $this._ConfigureListActions()\n\n        # Set columns\n        try {\n            $columns = $this.GetColumns()\n            $this.List.SetColumns($columns)\n        }\n        catch {\n            throw\n        }\n\n        # Load data\n        try {\n            $this.LoadData()\n        }\n        catch {\n            throw\n        }\n\n        # Update header breadcrumb\n        if ($this.Header) {\n            $this.Header.SetBreadcrumb(@(\"Home\", $this.ScreenTitle))\n        }\n\n        # Update status bar\n        if ($this.StatusBar) {\n            $itemCount = $this.List.GetItemCount()\n            $this.StatusBar.SetLeftText(\"$itemCount items\")\n        }\n\n    }\n\n    <#\n    .SYNOPSIS\n    Called when screen exits view\n    ##CLOSEBRACKET##\n    [void] OnDoExit() {\n        $this.IsActive = $false\n\n        # Cleanup event handlers to prevent memory leaks\n        $entityType = $this.GetEntityType()\n        switch ($entityType) {\n            'task' {\n                $this.Store.OnTasksChanged = $null\n            }\n            'project' {\n                $this.Store.OnProjectsChanged = $null\n            }\n            'timelog' {\n                $this.Store.OnTimeLogsChanged = $null\n            }\n        }\n    }\n\n    # === CRUD Operations ===\n\n    <#\n    .SYNOPSIS\n    Add a new item\n    ##CLOSEBRACKET##\n    [void] AddItem() {\n        # DEBUG logging - ENABLED to trace add operation bugs\n        # Write-PmcTuiLog \"*** STANDARDLISTSCREEN.ADDITEM CALLED on type=$($this.GetType().Name) key=$($this.ScreenKey) ***\" \"INFO\"\n\n        $this.EditorMode = 'add'\n        $this.CurrentEditItem = @{}\n        $fields = $this.GetEditFields($this.CurrentEditItem)\n\n        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] Got $($fields.Count) edit fields\"\n        # }\n\n        $this.InlineEditor.LayoutMode = \"horizontal\"\n        # Write-PmcTuiLog \"StandardListScreen.AddItem: About to SetFields with $($fields.Count) fields\" \"DEBUG\"\n        $this.InlineEditor.SetFields($fields)\n        # Write-PmcTuiLog \"StandardListScreen.AddItem: SetFields completed successfully\" \"DEBUG\"\n        $this.InlineEditor.Title = \"Add New\"\n\n        # Position editor at end of list (or first row if empty)\n        $itemCount = $(if ($this.List._filteredData) { $this.List._filteredData.Count } else { 0 })\n        $this.List._selectedIndex = $itemCount  # Select the \"new row\" position\n\n        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] AddItem: Set selectedIndex=$itemCount for add mode\"\n        # }\n\n        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] AddItem: About to set ShowInlineEditor=true (currently: $($this.ShowInlineEditor))\"\n        # }\n\n        $this.ShowInlineEditor = $true\n\n        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] AddItem: ShowInlineEditor set to: $($this.ShowInlineEditor)\"\n        # }\n\n        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] AddItem: Exiting (ShowInlineEditor=$($this.ShowInlineEditor))\"\n        # }\n    }\n\n    <#\n    .SYNOPSIS\n    Edit an existing item\n\n    .PARAMETER item\n    Item to edit\n    ##CLOSEBRACKET##\n    [void] EditItem($item) {\n        # Write-PmcTuiLog \"*** STANDARDLISTSCREEN.EDITITEM CALLED (base class) - item type=$($item.GetType().Name) ***\" \"WARN\"\n        if ($null -eq $item) {\n            return\n        }\n\n        $this.EditorMode = 'edit'\n        $this.CurrentEditItem = $item\n\n        $fields = $this.GetEditFields($item)\n        foreach ($field in $fields) {\n        }\n\n        $this.InlineEditor.LayoutMode = \"horizontal\"\n\n        $this.InlineEditor.SetFields($fields)\n\n        $this.InlineEditor.Title = \"Edit\"\n        $this.ShowInlineEditor = $true\n    }\n\n    <#\n    .SYNOPSIS\n    Delete an item with confirmation\n\n    .PARAMETER item\n    Item to delete\n    ##CLOSEBRACKET##\n    [void] DeleteItem($item) {\n        if ($null -eq $item) {\n            return\n        }\n\n        # MEDIUM FIX #13: Add simple inline confirmation before delete\n        # Get item name/description for confirmation message\n        $itemDesc = \"\"\n        if ($item.text) {\n            $itemDesc = $item.text\n        }\n        elseif ($item.name) {\n            $itemDesc = $item.name\n        }\n        elseif ($item.title) {\n            $itemDesc = $item.title\n        }\n        elseif ($item.id) {\n            $itemDesc = \"ID $($item.id)\"\n        }\n        else {\n            $itemDesc = \"this item\"\n        }\n\n        # Show confirmation in status bar and wait for Y/N\n        if ($this.StatusBar) {\n            $this.StatusBar.SetLeftText(\"Delete '$itemDesc'? Press Y to confirm, any other key to cancel\")\n            $this.Render() | Out-Host\n            $confirmKey = [Console]::ReadKey($true)\n\n            if ($confirmKey.KeyChar -ne 'y' -and $confirmKey.KeyChar -ne 'Y') {\n                $this.StatusBar.SetLeftText(\"Delete cancelled\")\n                return\n            }\n        }\n\n        # Try to call subclass-specific delete handler first\n        try {\n            $this.OnItemDeleted($item)\n            # If OnItemDeleted is implemented and doesn't throw, assume success\n            if ($this.StatusBar) {\n                $this.StatusBar.SetLeftText(\"Item deleted: $itemDesc\")\n            }\n            return\n        }\n        catch {\n            # If OnItemDeleted throws \"must be implemented\" or similar, fall through to default behavior\n            if ($_.Exception.Message -notmatch \"must be implemented\") {\n                # Real error - report it\n                if ($this.StatusBar) {\n                    $this.StatusBar.SetLeftText(\"Delete failed: $($_.Exception.Message)\")\n                }\n                return\n            }\n        }\n\n        # Default behavior for TaskStore entity types\n        $entityType = $this.GetEntityType()\n        $success = $false\n\n        switch ($entityType) {\n            'task' {\n                if ($null -ne $item.id) {\n                    $success = $this.Store.DeleteTask($item.id)\n                }\n            }\n            'project' {\n                if ($null -ne $item.name) {\n                    $success = $this.Store.DeleteProject($item.name)\n                }\n            }\n            'timelog' {\n                if ($null -ne $item.id) {\n                    $success = $this.Store.DeleteTimeLog($item.id)\n                }\n            }\n        }\n\n        if ($success) {\n            if ($this.StatusBar) {\n                $this.StatusBar.SetLeftText(\"Item deleted: $itemDesc\")\n            }\n        }\n        else {\n            if ($this.StatusBar) {\n                $this.StatusBar.SetLeftText(\"Failed to delete: $($this.Store.LastError)\")\n            }\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Save edited item to store\n\n    .PARAMETER values\n    Field values from InlineEditor\n    ##CLOSEBRACKET##\n    hidden [void] _SaveEditedItem($values) {\n        if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\n            # Write-PmcTuiLog \"StandardListScreen._SaveEditedItem: Mode=$($this.EditorMode) Values=$($values | ConvertTo-Json -Compress)\" \"DEBUG\"\n        }\n\n        try {\n            if ($this.EditorMode -eq 'add') {\n                # Call subclass callback for item creation\n                $this.OnItemCreated($values)\n            }\n            elseif ($this.EditorMode -eq 'edit') {\n                # Call subclass callback for item update\n                $this.OnItemUpdated($this.CurrentEditItem, $values)\n            }\n            else {\n                # Write-PmcTuiLog \"ERROR: EditorMode is '$($this.EditorMode)' - expected 'add' or 'edit'\" \"ERROR\"\n                $this.SetStatusMessage(\"Invalid editor mode\", \"error\")\n                return\n            }\n\n            # Only close editor on success\n            $this.ShowInlineEditor = $false\n            $this.EditorMode = \"\"\n            $this.CurrentEditItem = $null\n\n        }\n        catch {\n            # Write-PmcTuiLog \"_SaveEditedItem failed: $_\" \"ERROR\"\n            # Write-PmcTuiLog \"Stack trace: $($_.ScriptStackTrace)\" \"ERROR\"\n            $this.SetStatusMessage(\"Failed to save: $($_.Exception.Message)\", \"error\")\n            # Keep editor open so user can retry\n        }\n\n        # NOTE: Don't reset IsConfirmed/IsCancelled here - HandleKeyPress checks them\n        # They will be reset when SetFields() is called for the next add/edit\n    }\n\n    <#\n    .SYNOPSIS\n    Virtual method called when inline editor is confirmed\n    Subclasses should override to handle save, or rely on OnItemCreated/OnItemUpdated\n    ##CLOSEBRACKET##\n    [void] OnInlineEditConfirmed([hashtable]$values) {\n        # Default implementation: delegate to _SaveEditedItem which calls OnItemCreated or OnItemUpdated\n        # This ensures all screens work even if they don't override this method\n        # Write-PmcTuiLog \"StandardListScreen.OnInlineEditConfirmed called - EditorMode=$($this.EditorMode)\" \"DEBUG\"\n\n        # Call save which will dispatch to OnItemCreated or OnItemUpdated\n        $this._SaveEditedItem($values)\n    }\n\n    # === Filtering ===\n\n    <#\n    .SYNOPSIS\n    Apply filters to list data\n    ##CLOSEBRACKET##\n    hidden [void] _ApplyFilters() {\n        $this.LoadData()  # Reload data, filters are applied by FilterPanel\n    }\n\n    <#\n    .SYNOPSIS\n    Toggle filter panel visibility\n    ##CLOSEBRACKET##\n    [void] ToggleFilterPanel() {\n        $this.ShowFilterPanel = -not $this.ShowFilterPanel\n    }\n\n    # === Status Messages ===\n\n    <#\n    .SYNOPSIS\n    Set status message (displayed in status bar or logged)\n\n    .PARAMETER message\n    Message to display\n\n    .PARAMETER level\n    Message level: info, success, warning, error\n    ##CLOSEBRACKET##\n    [void] SetStatusMessage([string]$message, [string]$level = \"info\") {\n        # Log the message\n        # }\n\n        # If we have a status bar, update it\n        if ($this.StatusBar) {\n            $this.StatusBar.SetRightText($message)\n        }\n\n        # TODO: Could show a temporary overlay notification\n    }\n\n    # === List Refresh ===\n\n    <#\n    .SYNOPSIS\n    Refresh the list (reload data)\n    ##CLOSEBRACKET##\n    [void] RefreshList() {\n        $this.LoadData()\n    }\n\n    # === Input Handling ===\n\n    <#\n    .SYNOPSIS\n    Handle keyboard input\n\n    .PARAMETER keyInfo\n    ConsoleKeyInfo from [Console]::ReadKey($true)\n\n    .OUTPUTS\n    True if input was handled, False otherwise\n    ##CLOSEBRACKET##\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\n        # DEBUG: Log ALL Enter key presses at the very top\n        if ($keyInfo.Key -eq 'Enter') {\n        }\n\n        # Re-entry guard: prevent infinite recursion\n        if ($this._isHandlingInput) {\n            if ($keyInfo.Key -eq 'Enter') {\n            }\n            return $false\n        }\n        $this._isHandlingInput = $true\n        try {\n            # Check Alt+key for menu bar first (before editor/filter)\n            if ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt) {\n                if ($null -ne $this.MenuBar -and $this.MenuBar.HandleKeyPress($keyInfo)) {\n                    return $true\n                }\n            }\n\n            # If menu is active, route all keys to it FIRST (including Esc to close)\n            if ($null -ne $this.MenuBar -and $this.MenuBar.IsActive) {\n                if ($this.MenuBar.HandleKeyPress($keyInfo)) {\n                    return $true\n                }\n            }\n\n            # CRITICAL FIX: Route to inline editor BEFORE other menu handling\n            # This allows inline editor to handle Esc/Enter instead of menu stealing them\n            if ($this.ShowInlineEditor) {\n                # DEBUG: Trace input to find why typing doesn't work (COMMENTED OUT FOR PERFORMANCE)\n                # Add-Content -Path \"/tmp/pmc-input-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] StandardListScreen.HandleKeyPress: ShowInlineEditor=$($this.ShowInlineEditor) Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' InlineEditor=$($null -ne $this.InlineEditor) _fields=$($this.InlineEditor._fields.Count) _currentFieldIndex=$($this.InlineEditor._currentFieldIndex)\"\n                # Write-PmcTuiLog \"StandardListScreen: Routing to InlineEditor (Key=$($keyInfo.Key))\" \"DEBUG\"\n                $handled = $this.InlineEditor.HandleInput($keyInfo)\n                # Write-PmcTuiLog \"StandardListScreen: After HandleInput - IsConfirmed=$($this.InlineEditor.IsConfirmed) IsCancelled=$($this.InlineEditor.IsCancelled) ShowInlineEditor=$($this.ShowInlineEditor)\" \"DEBUG\"\n\n                # Check if editor needs clear (field widget was closed)\n                if ($this.InlineEditor.NeedsClear) {\n                    # Write-PmcTuiLog \"StandardListScreen: Editor field widget closed - PROPAGATING CLEAR TO SCREEN\" \"DEBUG\"\n                    # CRITICAL FIX: Propagate NeedsClear to screen to remove overlay widget rendering\n                    $this.NeedsClear = $true\n                    $this.InlineEditor.NeedsClear = $false  # Reset flag\n                    return $true\n                }\n\n                # Check if editor closed\n                if ($this.InlineEditor.IsConfirmed -or $this.InlineEditor.IsCancelled) {\n                    # Write-PmcTuiLog \"StandardListScreen: Editor confirmed/cancelled - closing editor NO CLEAR\" \"DEBUG\"\n\n                    # BUG FIX: Save EditorMode BEFORE it gets cleared by OnCancelled callback\n                    $wasAddMode = ($this.EditorMode -eq 'add')\n\n                    $this.ShowInlineEditor = $false\n                    # CRITICAL: Also update the list's editor state to stay in sync\n                    $this.List._showInlineEditor = $false\n\n                    # FIX: Invalidate the editor row region so differential renderer redraws it\n                    # Without this, the dark grey background from the inline editor remains stale\n                    if ($this.RenderEngine -and $this.InlineEditor) {\n                        $editorY = $this.InlineEditor.Y\n                        $this.RenderEngine.InvalidateCachedRegion($editorY, $editorY + 1)\n                        # Write-PmcTuiLog \"StandardListScreen: Invalidated editor row Y=$editorY after close\" \"DEBUG\"\n                    }\n\n                    # BUG FIX: Restore selectedIndex after exiting add mode\n                    # When in add mode, selectedIndex is set to itemCount (one past the last item)\n                    # When cancelled, we need to restore it to a valid row index so the user can navigate\n                    if ($wasAddMode) {\n                        $itemCount = $(if ($this.List._filteredData) { $this.List._filteredData.Count } else { 0 })\n                        if ($itemCount -gt 0) {\n                            # Restore to last item (or first item if we just added one on confirm)\n                            if ($this.InlineEditor.IsCancelled) {\n                                # Cancelled - go back to last existing item\n                                $this.List._selectedIndex = $itemCount - 1\n                            }\n                            else {\n                                # Confirmed - select the newly added item (if it was added)\n                                # Keep current selectedIndex if within bounds, otherwise select last\n                                if ($this.List._selectedIndex -ge $itemCount) {\n                                    $this.List._selectedIndex = $itemCount - 1\n                                }\n                            }\n                        }\n                        else {\n                            # No items - select none (will be 0 when items are added)\n                            $this.List._selectedIndex = 0\n                        }\n                        # Write-PmcTuiLog \"StandardListScreen: Restored selectedIndex to $($this.List._selectedIndex) after add mode exit (itemCount=$itemCount)\" \"DEBUG\"\n                    }\n\n                    # Clear EditorMode AFTER checking if it was add mode\n                    $this.EditorMode = \"\"\n\n                    $this.NeedsClear = $true  # FIX: Set NeedsClear to clear stale editor row\n                    # MUST return true to trigger re-render\n                    return $true\n                }\n\n                # Write-PmcTuiLog \"StandardListScreen: After close check - ShowInlineEditor=$($this.ShowInlineEditor)\" \"DEBUG\"\n\n                # If editor handled the key, we're done\n                if ($handled) {\n                    return $true\n                }\n                # FIX: If editor is showing but didn't handle key, consume it anyway\n                # This prevents keys from falling through to List.HandleInput when editor is active\n                # Only allow global shortcuts (F10, Esc, ?) to pass through\n                if ($keyInfo.Key -ne [ConsoleKey]::F10 -and $keyInfo.Key -ne [ConsoleKey]::Escape -and $keyInfo.KeyChar -ne '?') {\n                    return $true\n                }\n            }\n\n            # Route to filter panel if shown\n            if ($this.ShowFilterPanel) {\n                $handled = $this.FilterPanel.HandleInput($keyInfo)\n\n                # Esc closes filter panel\n                if ($keyInfo.Key -eq 'Escape') {\n                    $this.ShowFilterPanel = $false\n                    return $true\n                }\n\n                # If filter panel handled the key, we're done\n                if ($handled) {\n                    return $true\n                }\n                # Otherwise, fall through to global shortcuts\n            }\n\n            # F10 OR ESC activates menu (only if not already active and no editor/filter showing)\n            if ($keyInfo.Key -eq [ConsoleKey]::F10 -or $keyInfo.Key -eq [ConsoleKey]::Escape) {\n                if ($null -ne $this.MenuBar -and -not $this.MenuBar.IsActive -and -not $this.ShowInlineEditor -and -not $this.ShowFilterPanel) {\n                    $this.MenuBar.Activate()\n                    return $true\n                }\n            }\n\n            # Global shortcuts (ONLY when editor/filter NOT showing - otherwise they block typing!)\n            if (-not $this.ShowInlineEditor -and -not $this.ShowFilterPanel) {\n                # ? = Help\n                if ($keyInfo.KeyChar -eq '?') {\n                    . \"$PSScriptRoot/../screens/HelpViewScreen.ps1\"\n                    $screen = [HelpViewScreen]::new()\n                    $this.App.PushScreen($screen)\n                    return $true\n                }\n\n                if (($keyInfo.KeyChar -eq 'f' -or $keyInfo.KeyChar -eq 'F') -and $this.AllowFilter) {\n                    $this.ToggleFilterPanel()\n                    return $true\n                }\n\n                if ($keyInfo.KeyChar -eq 'r' -or $keyInfo.KeyChar -eq 'R') {\n                    # Refresh\n                    $this.RefreshList()\n                    return $true\n                }\n\n                # Delete key: Delete selected item\n                if ($keyInfo.Key -eq [ConsoleKey]::Delete -and $this.AllowDelete) {\n                    $selectedItem = $this.List.GetSelectedItem()\n                    if ($null -ne $selectedItem) {\n                        $this.DeleteItem($selectedItem)\n                    }\n                    return $true\n                }\n            }\n\n            # Route to list ONLY if editor and filter are NOT showing\n            # CRITICAL FIX: When editor is open, don't let list actions (a/e/d) trigger\n            # This prevents accidentally opening a new editor or deleting items while editing\n            if ($keyInfo.Key -eq 'Enter') {\n            }\n            if (-not $this.ShowInlineEditor -and -not $this.ShowFilterPanel) {\n                return $this.List.HandleInput($keyInfo)\n            }\n\n            # Editor/filter is showing but didn't handle key - ignore it\n            if ($keyInfo.Key -eq 'Enter') {\n            }\n            return $false\n        }\n        finally {\n            $this._isHandlingInput = $false\n        }\n    }\n\n    # === Rendering ===\n\n    <#\n    .SYNOPSIS\n    Render content area directly to engine\n    Override from PmcScreen to use optimized list rendering\n    ##CLOSEBRACKET##\n    [void] RenderContentToEngine([object]$engine) {\n        if ($null -eq $this.List) {\n            throw \"CRITICAL ERROR: StandardListScreen.List is null\"\n        }\n\n        # Sync state\n        if ($this.ShowInlineEditor -and $this.InlineEditor) {\n            $this.List._showInlineEditor = $true\n            $this.List._inlineEditor = $this.InlineEditor\n        }\n        else {\n            $this.List._showInlineEditor = $false\n        }\n        \n        $this.List.IsInFilterMode = $this.ShowFilterPanel\n\n        # Render list directly\n        if ($this.List.PSObject.Methods['RenderToEngine']) {\n            $this.List.RenderToEngine($engine)\n        }\n        \n        # Render filter panel overlay if needed\n        if ($this.ShowFilterPanel) {\n            $output = $this.FilterPanel.Render()\n            if ($output) {\n                # HybridRenderEngine.WriteAt handles ANSI parsing\n                $engine.WriteAt(0, 0, $output)\n            }\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Render the screen content area\n\n    .OUTPUTS\n    ANSI string ready for display\n    ##CLOSEBRACKET##\n    [string] RenderContent() {\n        # Priority rendering order: editor INLINE with list > filter panel > list\n        $editItemId = $(if ($null -ne $this.CurrentEditItem -and $this.CurrentEditItem.PSObject.Properties['id']) { $this.CurrentEditItem.id } else { \"null\" })\n\n\n        # }\n\n        # HIGH FIX #8: Throw error instead of silent failure to make debugging easier\n        if ($null -eq $this.List) {\n            $errorMsg = \"CRITICAL ERROR: StandardListScreen.List is null - screen was not properly initialized\"\n            # }\n            throw $errorMsg\n        }\n\n        # If showing inline editor, pass it to the list for inline rendering BEFORE calling Render()\n        if ($this.ShowInlineEditor -and $this.InlineEditor) {\n            # Set inline editor mode on list\n            $this.List._showInlineEditor = $true\n            $this.List._inlineEditor = $this.InlineEditor\n        }\n        else {\n            $this.List._showInlineEditor = $false\n        }\n\n        # Render list (it will handle inline editor internally)\n        try {\n            $listOutput = $this.List.Render()\n        }\n        catch {\n            throw\n        }\n\n        if ($this.ShowFilterPanel) {\n            # }\n            # Render list with filter panel as overlay\n            $filterContent = $this.FilterPanel.Render()\n            return $listOutput + \"`n\" + $filterContent\n        }\n\n\n        # }\n        return $listOutput\n    }\n\n\n    # === Helper Methods ===\n\n    \n    <#\n    .SYNOPSIS\n    Get terminal size\n\n    .OUTPUTS\n    Hashtable with Width and Height properties\n    ##CLOSEBRACKET##\n    hidden [hashtable] _GetTerminalSize() {\n        try {\n            $width = [Console]::WindowWidth\n            $height = [Console]::WindowHeight\n        }\n        catch {\n            # Fallback to defaults if Console methods fail\n            $width = 80\n            $height = 24\n        }\n        return @{ Width = $width; Height = $height }\n    }\n}\n"}, {"path": "module/Pmc.Strict/consoleui/base/TabbedScreen.ps1", "content": "# TabbedScreen.ps1 - Base class for screens using tabbed interface\r\n#\r\n# Usage:\r\n#   class MyScreen : TabbedScreen {\r\n#       MyScreen() : base(\"MyScreen\", \"My Title\") {\r\n#           $this._InitializeTabs()\r\n#       }\r\n#\r\n#       hidden [void] _InitializeTabs() {\r\n#           $this.TabPanel.AddTab('General', $this.GetGeneralFields())\r\n#           $this.TabPanel.AddTab('Details', $this.GetDetailFields())\r\n#       }\r\n#\r\n#       [array] GetGeneralFields() {\r\n#           return @(\r\n#               @{Name='name'; Label='Name'; Value=$this.Data.name}\r\n#               @{Name='email'; Label='Email'; Value=$this.Data.email}\r\n#           )\r\n#       }\r\n#\r\n#       [void] SaveChanges() {\r\n#           $values = $this.TabPanel.GetAllValues()\r\n#           # Save to store\r\n#       }\r\n#   }\r\n\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Load dependencies\r\nif (-not ([System.Management.Automation.PSTypeName]'PmcScreen').Type) {\r\n    . \"$PSScriptRoot/../PmcScreen.ps1\"\r\n}\r\n\r\nif (-not ([System.Management.Automation.PSTypeName]'TabPanel').Type) {\r\n    . \"$PSScriptRoot/../widgets/TabPanel.ps1\"\r\n}\r\n\r\nif (-not ([System.Management.Automation.PSTypeName]'InlineEditor').Type) {\r\n    . \"$PSScriptRoot/../widgets/InlineEditor.ps1\"\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nBase class for screens using tabbed interface to organize many fields\r\n\r\n.DESCRIPTION\r\nTabbedScreen provides a complete tabbed interface experience:\r\n- TabPanel widget for tab navigation\r\n- InlineEditor for field editing (vertical popup mode)\r\n- Automatic keyboard navigation (Tab, arrows, numbers)\r\n- Edit mode with save/cancel\r\n- Theme integration\r\n- Extensible via abstract methods\r\n\r\nAbstract Methods (override in subclasses):\r\n- LoadData() - Load data for fields\r\n- SaveChanges() - Save field values\r\n\r\nOptional Overrides:\r\n- OnTabChanged($tabIndex) - Handle tab change\r\n- OnFieldSelected($field) - Handle field selection\r\n- OnFieldEdited($field, $newValue) - Handle field edit\r\n\r\n.EXAMPLE\r\nclass SettingsScreen : TabbedScreen {\r\n    SettingsScreen() : base(\"Settings\", \"Application Settings\") {\r\n        $this.TabPanel.AddTab('General', @(\r\n            @{Name='theme'; Label='Theme'; Value='dark'}\r\n            @{Name='fontSize'; Label='Font Size'; Value=12}\r\n        ))\r\n        $this.TabPanel.AddTab('Advanced', @(...))\r\n    }\r\n\r\n    [void] SaveChanges() {\r\n        $values = $this.TabPanel.GetAllValues()\r\n        $this.Store.UpdateSettings($values)\r\n    }\r\n}\r\n##CLOSEBRACKET##\r\nclass TabbedScreen : PmcScreen {\r\n    # === Core Components ===\r\n    [TabPanel]$TabPanel = $null\r\n    [InlineEditor]$InlineEditor = $null\r\n\r\n    # === Component State ===\r\n    [bool]$ShowEditor = $false\r\n    [object]$CurrentEditField = $null\r\n\r\n    # === Constructor (no container) ===\r\n    TabbedScreen([string]$key, [string]$title) : base($key, $title) {\r\n        $this._InitializeComponents()\r\n    }\r\n\r\n    # === Constructor (with container) ===\r\n    TabbedScreen([string]$key, [string]$title, [object]$container) : base($key, $title, $container) {\r\n        $this._InitializeComponents()\r\n    }\r\n\r\n    # === Initialization ===\r\n\r\n    hidden [void] _InitializeComponents() {\r\n        # Get terminal size\r\n        $termSize = $this._GetTerminalSize()\r\n        $this.TermWidth = $termSize.Width\r\n        $this.TermHeight = $termSize.Height\r\n\r\n        # Initialize TabPanel\r\n        $this.TabPanel = [TabPanel]::new()\r\n\r\n        # Position and size TabPanel to fit in content area\r\n        # Account for header (title=1 + breadcrumb=1 + separator=1 = 3 rows), footer (2 rows), menu (1 row)\r\n        # TabPanel Y must be AFTER header separator\r\n        # Header: Y=2 (title), Y=4 (breadcrumb), Y=6 (separator)\r\n        # TabPanel starts at Y=7\r\n        $contentHeight = $this.TermHeight - 9  # header(3) + footer(2) + menu(1) + TabPanel tabs(2) + padding(1)\r\n\r\n        $this.TabPanel.X = 2\r\n        $this.TabPanel.Y = 8  # After header separator at Y=7\r\n        $this.TabPanel.Width = $this.TermWidth - 4\r\n        $this.TabPanel.Height = $contentHeight\r\n\r\n        # Wire up TabPanel events\r\n        $self = $this\r\n        $this.TabPanel.OnTabChanged = {\r\n            param($tabIndex)\r\n            $self.OnTabChanged($tabIndex)\r\n        }.GetNewClosure()\r\n\r\n        $this.TabPanel.OnFieldSelected = {\r\n            param($field)\r\n            $self.OnFieldSelected($field)\r\n        }.GetNewClosure()\r\n\r\n        # Initialize InlineEditor (for editing fields)\r\n        $this.InlineEditor = [InlineEditor]::new()\r\n        $this.InlineEditor.LayoutMode = \"vertical\"  # Popup mode\r\n        $termSize = $this._GetTerminalSize()\r\n        $this.InlineEditor.X = [Math]::Max(1, [Math]::Floor(($termSize.Width - 60) / 2))\r\n        $this.InlineEditor.Y = [Math]::Max(3, [Math]::Floor(($termSize.Height - 12) / 2))\r\n        $this.InlineEditor.Width = [Math]::Min(60, $termSize.Width - 2)\r\n        $this.InlineEditor.Height = [Math]::Min(12, $termSize.Height - 4)\r\n\r\n        # Wire up InlineEditor events\r\n        $this.InlineEditor.OnConfirmed = {\r\n            param($values)\r\n            $self._SaveEditedField($values)\r\n        }.GetNewClosure()\r\n\r\n        $this.InlineEditor.OnCancelled = {\r\n            $self.ShowEditor = $false\r\n            $self.CurrentEditField = $null\r\n        }.GetNewClosure()\r\n\r\n        # Configure footer shortcuts\r\n        $this.Footer.ClearShortcuts()\r\n        $this.Footer.AddShortcut(\"Tab\", \"Next Tab\")\r\n        $this.Footer.AddShortcut(\"↑↓\", \"Navigate\")\r\n        $this.Footer.AddShortcut(\"Enter\", \"Edit\")\r\n        $this.Footer.AddShortcut(\"S\", \"Save\")\r\n        $this.Footer.AddShortcut(\"Esc\", \"Back\")\r\n    }\r\n\r\n    # === Lifecycle Methods ===\r\n\r\n    [void] OnEnter() {\r\n        $this.IsActive = $true\r\n\r\n        # Load data\r\n        $this.LoadData()\r\n\r\n        # Update header breadcrumb\r\n        if ($this.Header) {\r\n            $this.Header.SetBreadcrumb(@(\"Home\", $this.ScreenTitle))\r\n        }\r\n    }\r\n\r\n    [void] OnDoExit() {\r\n        $this.IsActive = $false\r\n    }\r\n\r\n    # === Abstract Methods (MUST override) ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Load data and populate tabs (ABSTRACT - must override)\r\n    ##CLOSEBRACKET##\r\n    [void] LoadData() {\r\n        throw \"LoadData() must be implemented in subclass\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Save changes from all field values (ABSTRACT - must override)\r\n    ##CLOSEBRACKET##\r\n    [void] SaveChanges() {\r\n        throw \"SaveChanges() must be implemented in subclass\"\r\n    }\r\n\r\n    # === Optional Override Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle tab change (optional override)\r\n    ##CLOSEBRACKET##\r\n    [void] OnTabChanged([int]$tabIndex) {\r\n        if ($global:PmcTuiLogFile) {\r\n            $tab = $this.TabPanel.GetCurrentTab()\r\n            $tabName = $(if ($tab) { $tab.Name } else { \"null\" })\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ========== TabbedScreen.OnTabChanged: Switched to tab $tabIndex '$tabName' ==========\"\r\n        }\r\n\r\n        # NOTE: No manual cache invalidation needed here.\n        # The differential renderer (HybridRenderEngine) automatically detects changes\n        # between front/back buffers during EndFrame() and only redraws what changed.\n        # Previously had InvalidateCachedRegion call here that caused screen flashing.\n\r\n        # Default: update status bar\r\n        if ($this.StatusBar) {\r\n            $tab = $this.TabPanel.GetCurrentTab()\r\n            if ($tab) {\r\n                $this.StatusBar.SetLeftText(\"Tab: $($tab.Name) ($($tab.Fields.Count) fields)\")\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle field selection (optional override)\r\n    ##CLOSEBRACKET##\r\n    [void] OnFieldSelected($field) {\r\n        # Default: update status bar\r\n        if ($this.StatusBar -and $field) {\r\n            $value = $(if ($field.Value) { $field.Value } else { \"(empty)\" })\r\n            $this.StatusBar.SetLeftText(\"$($field.Label): $value\")\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle field edit (optional override)\r\n    ##CLOSEBRACKET##\r\n    [void] OnFieldEdited($field, $newValue) {\r\n        # Default: just update the field\r\n        # Subclass can override to add validation, logging, etc.\r\n    }\r\n\r\n    # === Field Editing ===\r\n\r\n    [void] EditCurrentField() {\r\n        $field = $this.TabPanel.GetCurrentField()\r\n        if ($null -eq $field) { return }\r\n\r\n        # Check if this is an action field (readonly with IsAction flag)\r\n        if ($field.ContainsKey('IsAction') -and $field.IsAction) {\r\n            # Trigger action callback instead of editing\r\n            $this.OnFieldEdited($field, $null)\r\n            return\r\n        }\r\n\r\n        # Check if readonly but not an action - skip editing\r\n        $fieldType = $(if ($field.ContainsKey('Type')) { $field.Type } else { 'text' })\r\n        if ($fieldType -eq 'readonly') {\r\n            # Skip editing readonly fields that aren't actions\r\n            return\r\n        }\r\n\r\n        $this.CurrentEditField = $field\r\n\r\n        # Build field definition for InlineEditor\r\n        $fieldDef = @{\r\n            Name     = $field.Name\r\n            Label    = ''  # No label for inline editing\r\n            Type     = $fieldType\r\n            Value    = $field.Value\r\n            Required = $(if ($field.ContainsKey('Required')) { $field.Required } else { $false })\r\n            Width    = $this.TabPanel.Width - $this.TabPanel.LabelWidth - ($this.TabPanel.ContentPadding * 2) - 2\r\n        }\r\n\r\n        # Add type-specific properties\r\n        if ($fieldType -eq 'number') {\r\n            if ($field.ContainsKey('Min')) { $fieldDef.Min = $field.Min }\r\n            if ($field.ContainsKey('Max')) { $fieldDef.Max = $field.Max }\r\n        }\r\n\r\n        # Calculate position for inline editor\r\n        # It should be over the value part of the field\r\n        $tab = $this.TabPanel.GetCurrentTab()\r\n        $fieldIndex = $this.TabPanel.SelectedFieldIndex\r\n        $visibleIndex = $fieldIndex - $tab.ScrollOffset\r\n\r\n        # Calculate absolute position\r\n        # X: TabPanel X + Padding + LabelWidth (align with value column)\r\n        $editorX = $this.TabPanel.X + $this.TabPanel.ContentPadding + $this.TabPanel.LabelWidth\r\n        # Y: Match TabPanel._RenderContent calculation exactly\r\n        # contentY = TabPanel.Y + TabBarHeight (Y+2)\r\n        # field Y = contentY + row + 1\r\n        # For first field (row=0): Y+2+0+1 = Y+3\r\n        # For visibleIndex N: Y + TabBarHeight + N + 1\r\n        $contentY = $this.TabPanel.Y + $this.TabPanel.TabBarHeight\r\n        $editorY = $contentY + $visibleIndex\n\r\n        if ($global:PmcTuiLogFile) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] TabbedScreen.EditCurrentField: field='$($field.Name)' fieldIndex=$fieldIndex visibleIndex=$visibleIndex\"\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] TabbedScreen.EditCurrentField: TabPanel.Y=$($this.TabPanel.Y) TabBarHeight=$($this.TabPanel.TabBarHeight) contentY=$contentY\"\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] TabbedScreen.EditCurrentField: Calculated editor position: X=$editorX Y=$editorY\"\r\n        }\r\n\r\n        # CRITICAL: Set LayoutMode BEFORE SetFields() because SetFields() adds Save button based on LayoutMode\r\n        $this.InlineEditor.LayoutMode = \"horizontal\"  # No Save button in horizontal mode\r\n        $this.InlineEditor.Title = \"\"  # No title for inline editing\r\n        $this.InlineEditor.X = $editorX\r\n        $this.InlineEditor.Y = $editorY\r\n        $this.InlineEditor.Width = $fieldDef.Width\r\n        $this.InlineEditor.Height = 1  # Single line\r\n\r\n        # SetFields() must be called AFTER LayoutMode is set\r\n        $this.InlineEditor.SetFields(@($fieldDef))\r\n\r\n        $this.ShowEditor = $true\r\n    }\r\n\r\n    hidden [void] _SaveEditedField($values) {\r\n        if ($null -eq $this.CurrentEditField) { return }\r\n\r\n        $fieldName = $this.CurrentEditField.Name\r\n        $newValue = $values[$fieldName]\r\n\r\n        # Update TabPanel field value\r\n        $this.TabPanel.UpdateFieldValue($fieldName, $newValue)\r\n\r\n        # Call subclass hook\r\n        $this.OnFieldEdited($this.CurrentEditField, $newValue)\r\n\r\n        if ($global:PmcTuiLogFile) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] TabbedScreen._SaveEditedField: Closing editor, field='$fieldName' newValue='$newValue'\"\r\n        }\r\n\r\n        # Close editor\r\n        $this.ShowEditor = $false\r\n        $this.CurrentEditField = $null\r\n\r\n        # Surgically invalidate editor region to clear artifacts\r\n        # InlineEditor in horizontal mode may render validation messages, borders, etc.\r\n        # Invalidate the field line AND next 3 lines to ensure all editor artifacts are cleared\r\n        if ($this.RenderEngine -and $this.InlineEditor) {\r\n            $editorY = $this.InlineEditor.Y\r\n            $editorHeight = 4  # Field + potential validation message + padding\r\n            $this.RenderEngine.InvalidateCachedRegion($editorY, $editorY + $editorHeight - 1)\r\n            if ($global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] TabbedScreen._SaveEditedField: Invalidated editor region Y=$editorY-$($editorY + $editorHeight - 1) (differential rendering - no full invalidation)\"\r\n            }\r\n        }\r\n\r\n        # REMOVED: $this.TabPanel.Invalidate() - defeats differential renderer, causes flashing\r\n        # Surgical cache invalidation above is sufficient\r\n\r\n        if ($global:PmcTuiLogFile) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] TabbedScreen._SaveEditedField: Editor closed, TabPanel invalidated\"\r\n        }\r\n\r\n        # Show success message\r\n        if ($this.StatusBar) {\r\n            $this.StatusBar.SetRightText(\"Field updated\")\r\n        }\r\n    }\r\n\r\n    # === Input Handling ===\r\n\r\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\r\n        # Check Alt+key for menu bar first (before editor)\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt) {\r\n            if ($null -ne $this.MenuBar -and $this.MenuBar.HandleKeyPress($keyInfo)) {\r\n                return $true\r\n            }\r\n        }\r\n\r\n        # If menu is active, route all keys to it FIRST (including Esc to close)\r\n        if ($null -ne $this.MenuBar -and $this.MenuBar.IsActive) {\r\n            if ($this.MenuBar.HandleKeyPress($keyInfo)) {\r\n                return $true\r\n            }\r\n        }\r\n\r\n        # If editor is showing, route to it next\r\n        if ($this.ShowEditor) {\r\n            $handled = $this.InlineEditor.HandleInput($keyInfo)\r\n\r\n            # Check if editor closed\r\n            if ($this.InlineEditor.IsConfirmed -or $this.InlineEditor.IsCancelled) {\r\n                $this.ShowEditor = $false\r\n                $this.CurrentEditField = $null\r\n                return $true\r\n            }\r\n\r\n            if ($handled) {\r\n                return $true\r\n            }\r\n            # FIX: If editor didn't handle key, still consume it to prevent fall-through\r\n            # This prevents Enter from triggering EditCurrentField while editor is open\r\n            return $true\r\n        }\r\n\r\n        # Enter key - edit current field (ONLY when editor is NOT showing)\r\n        if ($keyInfo.Key -eq 'Enter') {\r\n            $this.EditCurrentField()\r\n            return $true\r\n        }\r\n\r\n        # S key - save all changes\r\n        if ($keyInfo.KeyChar -eq 's' -or $keyInfo.KeyChar -eq 'S') {\r\n            try {\r\n                $this.SaveChanges()\r\n                if ($this.StatusBar) {\r\n                    $this.StatusBar.SetRightText(\"Changes saved\")\r\n                }\r\n            }\r\n            catch {\r\n                if ($this.StatusBar) {\r\n                    $this.StatusBar.SetRightText(\"Save failed: $_\")\r\n                }\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Escape - go back\r\n        if ($keyInfo.Key -eq 'Escape') {\r\n            $global:PmcApp.PopScreen()\r\n            return $true\r\n        }\r\n\r\n        # Route to TabPanel\r\n        $handled = $this.TabPanel.HandleInput($keyInfo)\r\n        if ($handled) {\r\n            return $true\r\n        }\r\n\r\n        # Not handled by TabPanel - return false so it bubbles up to app (for menu shortcuts, etc)\r\n        return $false\r\n    }\r\n\r\n    # === Rendering ===\r\n\r\n    [void] RenderContentToEngine([object]$engine) {\r\n        if (-not $this.TabPanel) {\r\n            return\r\n        }\r\n\r\n        # Render TabPanel - it handles its own layout and colors\r\n        $this.TabPanel.RenderToEngine($engine)\r\n\r\n        # If editor is showing, render it on top (Z-Index is handled by widget or engine order)\r\n        if ($this.ShowEditor -and $this.InlineEditor) {\r\n            # InlineEditor uses Z-layer 10 in its RenderToEngine\r\n            $this.InlineEditor.RenderToEngine($engine)\r\n        }\r\n    }\r\n\r\n    # Legacy Stub\r\n    [string] RenderContent() { return \"\" }\r\n\r\n    # === Helper Methods ===\r\n\r\n    hidden [hashtable] _GetTerminalSize() {\r\n        $width = [Console]::WindowWidth\r\n        $height = [Console]::WindowHeight\r\n        return @{ Width = $width; Height = $height }\r\n    }\r\n}\r\n\r\n# Export\r\nExport-ModuleMember -Variable @()"}, {"path": "module/Pmc.Strict/consoleui/deps/HelpContent.ps1", "content": "# Curated help content for standalone ConsoleUI\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n$Script:PmcHelpContent = @{\r\n    'Quick Tasks' = @{\r\n        Description = 'Common task management commands'\r\n        Items = @(\r\n            @{ Type='View'; Command='today'; Description='Tasks due today' }\r\n            @{ Type='View'; Command='overdue'; Description='Overdue tasks' }\r\n            @{ Type='View'; Command='agenda'; Description='Agenda view' }\r\n            @{ Type='Add'; Command='add \"Task text\" @project p1 due:today'; Description='Add new task' }\r\n            @{ Type='Edit'; Command='edit 123'; Description='Edit task by ID' }\r\n            @{ Type='Complete'; Command='done 123'; Description='Mark task complete' }\r\n        )\r\n    }\r\n    'Projects' = @{\r\n        Description = 'Project management commands'\r\n        Items = @(\r\n            @{ Type='View'; Command='projects'; Description='List all projects' }\r\n            @{ Type='Add'; Command='project add \"Project Name\"'; Description='Create new project' }\r\n            @{ Type='View'; Command='project show webapp'; Description='Show project details' }\r\n            @{ Type='Edit'; Command='project edit webapp'; Description='Edit project settings' }\r\n        )\r\n    }\r\n    'Query Language' = @{\r\n        Description = 'Filter, sort, and display tasks'\r\n        Items = @(\r\n            @{ Type='Basic'; Command='q tasks'; Description='Show all tasks' }\r\n            @{ Type='Filter'; Command='q tasks due:today'; Description='Tasks due today' }\r\n            @{ Type='Filter'; Command='q tasks @webapp'; Description='Project filter' }\r\n            @{ Type='View'; Command='q tasks group:status'; Description='Group by status' }\r\n            @{ Type='View'; Command='q tasks cols:id,text,due'; Description='Custom columns' }\r\n            @{ Type='Sort'; Command='q tasks sort:due+'; Description='Sort by due date asc' }\r\n        )\r\n    }\r\n}\r\n\r\nfunction Get-PmcHelpData {\r\n    param()\r\n    $helpCategories = @()\r\n    if ($Script:PmcHelpContent -and $Script:PmcHelpContent.Count -gt 0) {\r\n        $id = 1\r\n        foreach ($categoryEntry in $Script:PmcHelpContent.GetEnumerator()) {\r\n            $helpCategories += [PSCustomObject]@{\r\n                id = $id++\r\n                Category = $categoryEntry.Key\r\n                CommandCount = $categoryEntry.Value.Items.Count\r\n                Description = $categoryEntry.Value.Description\r\n            }\r\n        }\r\n    }\r\n    return $helpCategories\r\n}"}, {"path": "module/Pmc.Strict/consoleui/deps/PmcTemplate.ps1", "content": "# Local PmcTemplate class for template-based rendering\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass PmcTemplate {\r\n    [string]$Name\r\n    [string]$Type        # 'grid', 'list', 'card', 'summary'\r\n    [string]$Header      # Header template\r\n    [string]$Row         # Row/item template\r\n    [string]$Footer      # Footer template\r\n    [hashtable]$Settings # Width, alignment, etc.\r\n\r\n    PmcTemplate([string]$name, [hashtable]$config) {\r\n        $this.Name = $name\r\n        $this.Type = $(if ($config.ContainsKey('type')) { $config.type } else { 'list' })\r\n        $this.Header = $(if ($config.ContainsKey('header')) { $config.header } else { '' })\r\n        $this.Row = $(if ($config.ContainsKey('row')) { $config.row } else { '' })\r\n        $this.Footer = $(if ($config.ContainsKey('footer')) { $config.footer } else { '' })\r\n        $this.Settings = $(if ($config.ContainsKey('settings')) { $config.settings } else { @{} })\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/deps/Project.ps1", "content": "Set-StrictMode -Version Latest\r\n\r\nfunction ConvertTo-PmcProjectObject {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [object]$Project,\r\n        [Parameter(Mandatory=$true)]\r\n        [ref]$DataArray,\r\n        [Parameter(Mandatory=$true)]\r\n        [int]$Index\r\n    )\r\n\r\n    if ($Project -is [string]) {\r\n        $newProject = [pscustomobject]@{\r\n            name = $Project\r\n        }\r\n        $DataArray.Value[$Index] = $newProject\r\n        return $newProject\r\n    } else {\r\n        return $Project\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/helpers/ConfigCache.ps1", "content": "# ConfigCache.ps1 - Configuration file caching with automatic invalidation\r\n#\r\n# Caches config.json in memory and only reloads when file timestamp changes.\r\n# Eliminates repeated file I/O when accessing configuration.\r\n#\r\n# Usage:\r\n#   $config = [ConfigCache]::GetConfig($configPath)\r\n#   [ConfigCache]::InvalidateCache()  # Force reload\r\n\r\nusing namespace System\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nConfiguration file cache with timestamp-based invalidation\r\n\r\n.DESCRIPTION\r\nConfigCache provides high-performance configuration access by:\r\n- Loading config file once into memory\r\n- Tracking file modification timestamp\r\n- Auto-reloading only when file changes\r\n- Thread-safe access for concurrent reads\r\n\r\n.EXAMPLE\r\n# Get cached config (loads on first call, cached thereafter)\r\n$config = [ConfigCache]::GetConfig(\"./config.json\")\r\n\r\n# Force reload (e.g., after editing config)\r\n[ConfigCache]::InvalidateCache()\r\n$config = [ConfigCache]::GetConfig(\"./config.json\")\r\n##CLOSEBRACKET##\r\nclass ConfigCache {\r\n    # Static cache storage\r\n    static hidden [hashtable]$_cache = $null\r\n    static hidden [datetime]$_lastLoad = [datetime]::MinValue\r\n    static hidden [string]$_configPath = \"\"\r\n    static hidden [datetime]$_fileTimestamp = [datetime]::MinValue\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get configuration from cache or load if needed\r\n\r\n    .PARAMETER path\r\n    Path to config.json file\r\n\r\n    .OUTPUTS\r\n    Hashtable containing configuration\r\n\r\n    .DESCRIPTION\r\n    Loads config file on first call, then returns cached version.\r\n    Automatically reloads if file modification timestamp changes.\r\n    ##CLOSEBRACKET##\r\n    static [hashtable] GetConfig([string]$path) {\r\n        # Resolve to absolute path for consistent caching\r\n        $absolutePath = [System.IO.Path]::GetFullPath($path)\r\n\r\n        # Check if file exists\r\n        if (-not (Test-Path $absolutePath)) {\r\n            throw \"Config file not found: $absolutePath\"\r\n        }\r\n\r\n        # Get file modification time\r\n        $fileInfo = Get-Item $absolutePath -ErrorAction Stop\r\n        $currentTimestamp = $fileInfo.LastWriteTime\r\n\r\n        # Load if cache empty, path changed, or file modified\r\n        $needsLoad = (\r\n            $null -eq [ConfigCache]::_cache -or\r\n            $absolutePath -ne [ConfigCache]::_configPath -or\r\n            $currentTimestamp -gt [ConfigCache]::_fileTimestamp\r\n        )\r\n\r\n        if ($needsLoad) {\r\n            try {\r\n                # Load and parse config\r\n                $json = Get-Content $absolutePath -Raw -Encoding utf8 -ErrorAction Stop\r\n                [ConfigCache]::_cache = $json | ConvertFrom-Json -AsHashtable -ErrorAction Stop\r\n\r\n                # Update metadata\r\n                [ConfigCache]::_configPath = $absolutePath\r\n                [ConfigCache]::_fileTimestamp = $currentTimestamp\r\n                [ConfigCache]::_lastLoad = [datetime]::Now\r\n\r\n                # Log cache update (only if logging enabled)\r\n                if ($global:PmcTuiLogFile) {\r\n                    Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [INFO] ConfigCache: Loaded config from $absolutePath\"\r\n                }\r\n            } catch {\r\n                # Clear cache on error\r\n                [ConfigCache]::_cache = $null\r\n                [ConfigCache]::_configPath = \"\"\r\n                [ConfigCache]::_fileTimestamp = [datetime]::MinValue\r\n\r\n                throw \"Failed to load config from ${absolutePath}: $_\"\r\n            }\r\n        }\r\n\r\n        # Return cached config\r\n        return [ConfigCache]::_cache\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Force cache invalidation and reload on next access\r\n\r\n    .DESCRIPTION\r\n    Clears the cached configuration, forcing a reload on the next GetConfig call.\r\n    Use after modifying config file to ensure changes are picked up.\r\n    ##CLOSEBRACKET##\r\n    static [void] InvalidateCache() {\r\n        [ConfigCache]::_cache = $null\r\n        [ConfigCache]::_configPath = \"\"\r\n        [ConfigCache]::_fileTimestamp = [datetime]::MinValue\r\n\r\n        if ($global:PmcTuiLogFile) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [INFO] ConfigCache: Cache invalidated\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get cache statistics for diagnostics\r\n\r\n    .OUTPUTS\r\n    Hashtable with cache stats\r\n\r\n    .DESCRIPTION\r\n    Returns information about cache state for debugging/monitoring\r\n    ##CLOSEBRACKET##\r\n    static [hashtable] GetStats() {\r\n        return @{\r\n            IsCached = ($null -ne [ConfigCache]::_cache)\r\n            ConfigPath = [ConfigCache]::_configPath\r\n            FileTimestamp = [ConfigCache]::_fileTimestamp\r\n            LastLoad = [ConfigCache]::_lastLoad\r\n            CacheAge = $(if ([ConfigCache]::_lastLoad -ne [datetime]::MinValue) {\r\n                ([datetime]::Now - [ConfigCache]::_lastLoad).TotalSeconds\r\n            } else {\r\n                $null\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\n# Export class (PowerShell 5.1+ auto-exports classes)"}, {"path": "module/Pmc.Strict/consoleui/helpers/Constants.ps1", "content": "# Constants.ps1 - Terminal and application constants\r\n#\r\n# Centralized constants to eliminate magic numbers and hardcoded values\r\n# throughout the PMC TUI codebase.\r\n#\r\n# M-CQ-2: Terminal Dimension Constants\r\n# M-CQ-7: Status Constants\r\n\r\nusing namespace System\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nTerminal and application constants for PMC TUI\r\n\r\n.DESCRIPTION\r\nCentralized constants file to replace hardcoded values throughout the codebase.\r\nIncludes terminal dimensions, task status values, priority levels, and other\r\napplication-wide constants.\r\n\r\n.NOTES\r\nThis file should be loaded early in the application bootstrap process.\r\n##CLOSEBRACKET##\r\n\r\n# ============================================================================\r\n# TERMINAL DIMENSIONS\r\n# ============================================================================\r\n\r\n# Minimum supported terminal dimensions\r\n# M-CQ-2: Replaces hardcoded 120x40, 80x24 throughout code\r\n$global:MIN_TERM_WIDTH = 80\r\n$global:MIN_TERM_HEIGHT = 24\r\n\r\n# Recommended terminal dimensions for optimal experience\r\n$global:RECOMMENDED_TERM_WIDTH = 120\r\n$global:RECOMMENDED_TERM_HEIGHT = 40\r\n\r\n# Maximum dimensions for virtual scrolling\r\n$global:MAX_VISIBLE_ROWS = 1000  # M-PERF-7: Virtual scrolling limit\r\n\r\n# ============================================================================\r\n# TASK STATUS CONSTANTS\r\n# ============================================================================\r\n\r\n# M-CQ-7: Status Constants\r\n# Task status values (enum-like constants)\r\n$global:TASK_STATUS_PENDING = 'pending'\r\n$global:TASK_STATUS_ACTIVE = 'active'\r\n$global:TASK_STATUS_COMPLETED = 'completed'\r\n$global:TASK_STATUS_BLOCKED = 'blocked'\r\n$global:TASK_STATUS_CANCELLED = 'cancelled'\r\n$global:TASK_STATUS_DEFERRED = 'deferred'\r\n\r\n# All valid task statuses\r\n$global:TASK_STATUSES = @(\r\n    $global:TASK_STATUS_PENDING,\r\n    $global:TASK_STATUS_ACTIVE,\r\n    $global:TASK_STATUS_COMPLETED,\r\n    $global:TASK_STATUS_BLOCKED,\r\n    $global:TASK_STATUS_CANCELLED,\r\n    $global:TASK_STATUS_DEFERRED\r\n)\r\n\r\n# ============================================================================\r\n# PRIORITY CONSTANTS\r\n# ============================================================================\r\n\r\n$global:PRIORITY_HIGH = 'high'\r\n$global:PRIORITY_MEDIUM = 'medium'\r\n$global:PRIORITY_LOW = 'low'\r\n$global:PRIORITY_NONE = 'none'\r\n\r\n# All valid priority levels\r\n$global:PRIORITIES = @(\r\n    $global:PRIORITY_HIGH,\r\n    $global:PRIORITY_MEDIUM,\r\n    $global:PRIORITY_LOW,\r\n    $global:PRIORITY_NONE\r\n)\r\n\r\n# Default priority for new tasks (configurable via preferences)\r\n# M-CFG-3: Make Default Priority Configurable\r\n$global:DEFAULT_PRIORITY = $global:PRIORITY_MEDIUM\r\n\r\n# ============================================================================\r\n# PERFORMANCE CONSTANTS\r\n# ============================================================================\r\n\r\n# M-PERF-4: Debounce search input delay (milliseconds)\r\n$global:SEARCH_DEBOUNCE_MS = 150\r\n\r\n# Cache refresh interval (milliseconds)\r\n$global:CACHE_REFRESH_INTERVAL_MS = 500\r\n\r\n# Maximum items before pagination required\r\n$global:MAX_ITEMS_BEFORE_PAGINATION = 100\r\n\r\n# ============================================================================\r\n# UI CONSTANTS\r\n# ============================================================================\r\n\r\n# Default column widths for various views\r\n$global:COLUMN_WIDTH_DATE = 10\r\n$global:COLUMN_WIDTH_TIME = 8\r\n$global:COLUMN_WIDTH_STATUS = 12\r\n$global:COLUMN_WIDTH_PRIORITY = 10\r\n$global:COLUMN_WIDTH_PROJECT = 20\r\n$global:COLUMN_WIDTH_TAGS = 15\r\n\r\n# Padding and spacing\r\n$global:DEFAULT_PADDING = 1\r\n$global:DEFAULT_MARGIN = 0\r\n\r\n# Dialog dimensions\r\n$global:DEFAULT_DIALOG_WIDTH = 60\r\n$global:DEFAULT_DIALOG_HEIGHT = 20\r\n\r\n# ============================================================================\r\n# INPUT VALIDATION - LENGTH LIMITS\r\n# ============================================================================\r\n\r\n# Maximum lengths for various text fields\r\n$global:MAX_TASK_TITLE_LENGTH = 500           # Task title/name\r\n$global:MAX_DESCRIPTION_LENGTH = 4000         # Description fields\r\n$global:MAX_TAG_LENGTH = 50                   # Individual tag length\r\n$global:MAX_PROJECT_NAME_LENGTH = 100         # Project name length\r\n$global:MAX_TAGS_PER_TASK = 50                # Maximum number of tags per task\r\n$global:MAX_DEPENDENCIES_PER_TASK = 20        # Maximum task dependencies\r\n\r\n# ============================================================================\r\n# FILE PATHS\r\n# ============================================================================\r\n\r\n# M-CFG-1: Configurable Log Path (uses environment variable or default)\r\n$global:DEFAULT_LOG_PATH = \"/tmp\"\r\n$global:LOG_FILE_PREFIX = \"pmc-tui\"\r\n$global:LOG_FILE_EXTENSION = \".log\"\r\n\r\n# Backup directory (relative to config path)\r\n$global:BACKUP_DIRECTORY = \"backups\"\r\n\r\n# Preferences file name\r\n# M-ACC-2: Symbol alternatives for color-only indicators\r\n$global:USE_SYMBOLS = $true  # Configurable via preferences\r\n\r\n# Status symbols (when USE_SYMBOLS is true)\r\n$global:SYMBOL_COMPLETED = \"[[OK]]\"\r\n$global:SYMBOL_PENDING = \"[ ]\"\r\n$global:SYMBOL_BLOCKED = \"[⊗]\"\r\n$global:SYMBOL_ACTIVE = \"[→]\"\r\n$global:SYMBOL_OVERDUE = \"[[WARN]]\"\r\n\r\n# Screen reader alternatives\r\n$global:SYMBOL_COMPLETED_TEXT = \"[DONE]\"\r\n$global:SYMBOL_PENDING_TEXT = \"[TODO]\"\r\n$global:SYMBOL_BLOCKED_TEXT = \"[BLOCKED]\"\r\n$global:SYMBOL_ACTIVE_TEXT = \"[IN-PROGRESS]\"\r\n$global:SYMBOL_OVERDUE_TEXT = \"[OVERDUE]\"\r\n\r\n# ============================================================================\r\n# TIMEZONE CONSTANTS\r\n# ============================================================================\r\n\r\n# M-INT-5: Timezone handling\r\n# Default timezone assumption: local system time\r\n$global:DEFAULT_TIMEZONE = [System.TimeZoneInfo]::Local\r\n$global:USE_UTC_INTERNALLY = $false  # If true, convert all dates to UTC internally\r\n\r\n# ============================================================================\r\n# ERROR MESSAGE FORMATS\r\n# ============================================================================\r\n\r\n# M-CQ-5: Standardize Error Messages\r\n$global:ERROR_FORMAT = \"Operation failed: {0}\"\r\n$global:WARNING_FORMAT = \"Warning: {0}\"\r\n$global:INFO_FORMAT = \"Info: {0}\"\r\n$global:SUCCESS_FORMAT = \"Success: {0}\"\r\n\r\n# ============================================================================\r\n# HELPER FUNCTIONS\r\n# ============================================================================\r\n\r\n<#\r\n.SYNOPSIS\r\nGet formatted error message\r\n\r\n.PARAMETER details\r\nError details to format\r\n\r\n.OUTPUTS\r\nFormatted error message string\r\n##CLOSEBRACKET##\r\nfunction Get-FormattedError {\r\n    param([string]$details)\r\n    return $script:ERROR_FORMAT -f $details\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nGet formatted warning message\r\n\r\n.PARAMETER details\r\nWarning details to format\r\n\r\n.OUTPUTS\r\nFormatted warning message string\r\n##CLOSEBRACKET##\r\nfunction Get-FormattedWarning {\r\n    param([string]$details)\r\n    return $script:WARNING_FORMAT -f $details\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nGet formatted info message\r\n\r\n.PARAMETER details\r\nInfo details to format\r\n\r\n.OUTPUTS\r\nFormatted info message string\r\n##CLOSEBRACKET##\r\nfunction Get-FormattedInfo {\r\n    param([string]$details)\r\n    return $script:INFO_FORMAT -f $details\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nGet formatted success message\r\n\r\n.PARAMETER details\r\nSuccess details to format\r\n\r\n.OUTPUTS\r\nFormatted success message string\r\n##CLOSEBRACKET##\r\nfunction Get-FormattedSuccess {\r\n    param([string]$details)\r\n    return $script:SUCCESS_FORMAT -f $details\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nValidate task status value\r\n\r\n.PARAMETER status\r\nStatus value to validate\r\n\r\n.OUTPUTS\r\nBoolean indicating if status is valid\r\n##CLOSEBRACKET##\r\nfunction Test-ValidTaskStatus {\r\n    param([string]$status)\r\n    return $status -in $global:TASK_STATUSES\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nValidate priority value\r\n\r\n.PARAMETER priority\r\nPriority value to validate\r\n\r\n.OUTPUTS\r\nBoolean indicating if priority is valid\r\n##CLOSEBRACKET##\r\nfunction Test-ValidPriority {\r\n    param([string]$priority)\r\n    return $priority -in $script:PRIORITIES\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nGet symbol for task status\r\n\r\n.PARAMETER status\r\nTask status\r\n\r\n.PARAMETER useSymbols\r\nWhether to use Unicode symbols (true) or text alternatives (false)\r\n\r\n.OUTPUTS\r\nSymbol string for the status\r\n##CLOSEBRACKET##\r\nfunction Get-StatusSymbol {\r\n    param(\r\n        [string]$status,\r\n        [bool]$useSymbols = $script:USE_SYMBOLS\r\n    )\r\n\r\n    if ($useSymbols) {\r\n        switch ($status) {\r\n            $global:TASK_STATUS_COMPLETED { return $script:SYMBOL_COMPLETED }\r\n            $global:TASK_STATUS_BLOCKED { return $script:SYMBOL_BLOCKED }\r\n            $global:TASK_STATUS_ACTIVE { return $script:SYMBOL_ACTIVE }\r\n            $global:TASK_STATUS_PENDING { return $script:SYMBOL_PENDING }\r\n            default { return $script:SYMBOL_PENDING }\r\n        }\r\n    } else {\r\n        switch ($status) {\r\n            $global:TASK_STATUS_COMPLETED { return $script:SYMBOL_COMPLETED_TEXT }\r\n            $global:TASK_STATUS_BLOCKED { return $script:SYMBOL_BLOCKED_TEXT }\r\n            $global:TASK_STATUS_ACTIVE { return $script:SYMBOL_ACTIVE_TEXT }\r\n            $global:TASK_STATUS_PENDING { return $script:SYMBOL_PENDING_TEXT }\r\n            default { return $script:SYMBOL_PENDING_TEXT }\r\n        }\r\n    }\r\n}\r\n\r\n# Export all constants and helper functions (only when imported as module)\r\n# When dot-sourced, $MyInvocation.InvocationName is '.' so we skip Export-ModuleMember\r\nif ($MyInvocation.InvocationName -ne '.') {\r\n    try {\r\n        Export-ModuleMember -Variable @(\r\n    'MIN_TERM_WIDTH',\r\n    'MIN_TERM_HEIGHT',\r\n    'RECOMMENDED_TERM_WIDTH',\r\n    'RECOMMENDED_TERM_HEIGHT',\r\n    'MAX_VISIBLE_ROWS',\r\n    'TASK_STATUS_PENDING',\r\n    'TASK_STATUS_ACTIVE',\r\n    'TASK_STATUS_COMPLETED',\r\n    'TASK_STATUS_BLOCKED',\r\n    'TASK_STATUS_CANCELLED',\r\n    'TASK_STATUS_DEFERRED',\r\n    'TASK_STATUSES',\r\n    'PRIORITY_HIGH',\r\n    'PRIORITY_MEDIUM',\r\n    'PRIORITY_LOW',\r\n    'PRIORITY_NONE',\r\n    'PRIORITIES',\r\n    'DEFAULT_PRIORITY',\r\n    'SEARCH_DEBOUNCE_MS',\r\n    'CACHE_REFRESH_INTERVAL_MS',\r\n    'MAX_ITEMS_BEFORE_PAGINATION',\r\n    'COLUMN_WIDTH_DATE',\r\n    'COLUMN_WIDTH_TIME',\r\n    'COLUMN_WIDTH_STATUS',\r\n    'COLUMN_WIDTH_PRIORITY',\r\n    'COLUMN_WIDTH_PROJECT',\r\n    'COLUMN_WIDTH_TAGS',\r\n    'DEFAULT_PADDING',\r\n    'DEFAULT_MARGIN',\r\n    'DEFAULT_DIALOG_WIDTH',\r\n    'DEFAULT_DIALOG_HEIGHT',\r\n    'DEFAULT_LOG_PATH',\r\n    'LOG_FILE_PREFIX',\r\n    'LOG_FILE_EXTENSION',\r\n    'BACKUP_DIRECTORY',\r\n    'PREFERENCES_FILE',\r\n    'MAX_TASK_TITLE_LENGTH',\r\n    'MAX_DESCRIPTION_LENGTH',\r\n    'MAX_TAG_LENGTH',\r\n    'MAX_PROJECT_NAME_LENGTH',\r\n    'MAX_TAGS_PER_TASK',\r\n    'MAX_DEPENDENCIES_PER_TASK',\r\n    'USE_SYMBOLS',\r\n    'SYMBOL_COMPLETED',\r\n    'SYMBOL_PENDING',\r\n    'SYMBOL_BLOCKED',\r\n    'SYMBOL_ACTIVE',\r\n    'SYMBOL_OVERDUE',\r\n    'SYMBOL_COMPLETED_TEXT',\r\n    'SYMBOL_PENDING_TEXT',\r\n    'SYMBOL_BLOCKED_TEXT',\r\n    'SYMBOL_ACTIVE_TEXT',\r\n    'SYMBOL_OVERDUE_TEXT',\r\n    'DEFAULT_TIMEZONE',\r\n    'USE_UTC_INTERNALLY',\r\n    'ERROR_FORMAT',\r\n    'WARNING_FORMAT',\r\n    'INFO_FORMAT',\r\n    'SUCCESS_FORMAT'\r\n) -Function @(\r\n    'Get-FormattedError',\r\n    'Get-FormattedWarning',\r\n    'Get-FormattedInfo',\r\n    'Get-FormattedSuccess',\r\n    'Test-ValidTaskStatus',\r\n    'Test-ValidPriority',\r\n    'Get-StatusSymbol'\r\n)\r\n    } catch {\r\n        # Ignore Export-ModuleMember errors when not in a module context\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/helpers/DataBindingHelper.ps1", "content": "# DataBindingHelper.ps1 - Helper functions to bind PMC data to widgets\r\n#\r\n# Provides conversion functions between PMC data structures and widget field configurations:\r\n# - PMC field schema → InlineEditor field definitions\r\n# - Widget values → PMC data format\r\n# - Type conversions (string, int, datetime, array)\r\n# - Default value handling\r\n#\r\n# Usage:\r\n#   # Convert PMC task to widget fields\r\n#   $fields = ConvertTo-WidgetFields -Entity $task -EntityType 'task'\r\n#\r\n#   # Convert widget values back to PMC format\r\n#   $pmcTask = ConvertFrom-WidgetValues -Values $widgetValues -EntityType 'task'\r\n#\r\n#   # Get field definitions for entity type\r\n#   $fieldDefs = Get-EntityFieldDefinitions -EntityType 'task'\r\n\r\nusing namespace System\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nConvert PMC entity to widget field definitions\r\n\r\n.PARAMETER Entity\r\nEntity hashtable (task, project, timelog)\r\n\r\n.PARAMETER EntityType\r\nEntity type: 'task', 'project', 'timelog'\r\n\r\n.PARAMETER FieldSchema\r\nOptional custom field schema (uses default if not provided)\r\n\r\n.OUTPUTS\r\nArray of field definition hashtables for InlineEditor\r\n##CLOSEBRACKET##\r\nfunction ConvertTo-WidgetFields {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable]$Entity,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        [ValidateSet('task', 'project', 'timelog', 'custom')]\r\n        [string]$EntityType,\r\n\r\n        [Parameter(Mandatory=$false)]\r\n        [hashtable[]]$FieldSchema = $null\r\n    )\r\n\r\n    # Use default schema if not provided\r\n    if ($null -eq $FieldSchema) {\r\n        $FieldSchema = Get-EntityFieldDefinitions -EntityType $EntityType\r\n    }\r\n\r\n    $widgetFields = @()\r\n\r\n    foreach ($fieldDef in $FieldSchema) {\r\n        $fieldName = $fieldDef.Name\r\n        $fieldType = $fieldDef.Type\r\n        $fieldLabel = $(if ($fieldDef.ContainsKey('Label')) { $fieldDef.Label } else { $fieldName })\r\n\r\n        # Get current value from entity\r\n        $value = $(if ($Entity.ContainsKey($fieldName)) { $Entity[$fieldName] } else { $null })\r\n\r\n        # Build widget field definition\r\n        $widgetField = @{\r\n            Name = $fieldName\r\n            Label = $fieldLabel\r\n            Type = $fieldType\r\n            Value = $value\r\n        }\r\n\r\n        # Add optional properties\r\n        if ($fieldDef.ContainsKey('Required')) {\r\n            $widgetField.Required = $fieldDef.Required\r\n        }\r\n\r\n        if ($fieldDef.ContainsKey('Min')) {\r\n            $widgetField.Min = $fieldDef.Min\r\n        }\r\n\r\n        if ($fieldDef.ContainsKey('Max')) {\r\n            $widgetField.Max = $fieldDef.Max\r\n        }\r\n\r\n        if ($fieldDef.ContainsKey('MaxLength')) {\r\n            $widgetField.MaxLength = $fieldDef.MaxLength\r\n        }\r\n\r\n        if ($fieldDef.ContainsKey('Placeholder')) {\r\n            $widgetField.Placeholder = $fieldDef.Placeholder\r\n        }\r\n\r\n        if ($fieldDef.ContainsKey('Options')) {\r\n            $widgetField.Options = $fieldDef.Options\r\n        }\r\n\r\n        $widgetFields += $widgetField\r\n    }\r\n\r\n    return $widgetFields\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nConvert widget values back to PMC entity format\r\n\r\n.PARAMETER Values\r\nHashtable of widget values\r\n\r\n.PARAMETER EntityType\r\nEntity type: 'task', 'project', 'timelog'\r\n\r\n.PARAMETER FieldSchema\r\nOptional custom field schema (uses default if not provided)\r\n\r\n.OUTPUTS\r\nHashtable in PMC entity format\r\n##CLOSEBRACKET##\r\nfunction ConvertFrom-WidgetValues {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable]$Values,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        [ValidateSet('task', 'project', 'timelog', 'custom')]\r\n        [string]$EntityType,\r\n\r\n        [Parameter(Mandatory=$false)]\r\n        [hashtable[]]$FieldSchema = $null\r\n    )\r\n\r\n    # Use default schema if not provided\r\n    if ($null -eq $FieldSchema) {\r\n        $FieldSchema = Get-EntityFieldDefinitions -EntityType $EntityType\r\n    }\r\n\r\n    $pmcEntity = @{}\r\n\r\n    foreach ($fieldDef in $FieldSchema) {\r\n        $fieldName = $fieldDef.Name\r\n        $fieldType = $fieldDef.Type\r\n\r\n        if ($Values.ContainsKey($fieldName)) {\r\n            $value = $Values[$fieldName]\r\n\r\n            # Type conversion\r\n            $convertedValue = ConvertTo-PmcType -Value $value -TargetType $fieldType\r\n\r\n            $pmcEntity[$fieldName] = $convertedValue\r\n        }\r\n    }\r\n\r\n    return $pmcEntity\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nConvert value to PMC type\r\n\r\n.PARAMETER Value\r\nValue to convert\r\n\r\n.PARAMETER TargetType\r\nTarget PMC type: 'string', 'int', 'bool', 'datetime', 'array'\r\n\r\n.OUTPUTS\r\nConverted value\r\n##CLOSEBRACKET##\r\nfunction ConvertTo-PmcType {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        $Value,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        [string]$TargetType\r\n    )\r\n\r\n    if ($null -eq $Value) {\r\n        return $null\r\n    }\r\n\r\n    switch ($TargetType) {\r\n        'string' {\r\n            return $Value.ToString()\r\n        }\r\n        'text' {\r\n            return $Value.ToString()\r\n        }\r\n        'int' {\r\n            return [int]$Value\r\n        }\r\n        'number' {\r\n            return [int]$Value\r\n        }\r\n        'bool' {\r\n            return [bool]$Value\r\n        }\r\n        'datetime' {\r\n            if ($Value -is [DateTime]) {\r\n                return $Value\r\n            }\r\n            return [DateTime]::Parse($Value.ToString())\r\n        }\r\n        'date' {\r\n            if ($Value -is [DateTime]) {\r\n                return $Value\r\n            }\r\n            return [DateTime]::Parse($Value.ToString())\r\n        }\r\n        'array' {\r\n            if ($Value -is [array]) {\r\n                return $Value\r\n            }\r\n            return @($Value)\r\n        }\r\n        'tags' {\r\n            if ($Value -is [array]) {\r\n                return $Value\r\n            }\r\n            return @($Value)\r\n        }\r\n        default {\r\n            return $Value\r\n        }\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nGet default field definitions for entity type\r\n\r\n.PARAMETER EntityType\r\nEntity type: 'task', 'project', 'timelog'\r\n\r\n.OUTPUTS\r\nArray of field definition hashtables\r\n##CLOSEBRACKET##\r\nfunction Get-EntityFieldDefinitions {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [ValidateSet('task', 'project', 'timelog')]\r\n        [string]$EntityType\r\n    )\r\n\r\n    switch ($EntityType) {\r\n        'task' {\r\n            return @(\r\n                @{\r\n                    Name = 'text'\r\n                    Label = 'Task'\r\n                    Type = 'text'\r\n                    Required = $true\r\n                    MaxLength = 500\r\n                    Placeholder = 'What needs to be done?'\r\n                }\r\n                @{\r\n                    Name = 'project'\r\n                    Label = 'Project'\r\n                    Type = 'project'\r\n                    Required = $false\r\n                }\r\n                @{\r\n                    Name = 'priority'\r\n                    Label = 'Priority'\r\n                    Type = 'number'\r\n                    Required = $false\r\n                    Min = 0\r\n                    Max = 5\r\n                    Value = 3\r\n                }\r\n                @{\r\n                    Name = 'due'\r\n                    Label = 'Due Date'\r\n                    Type = 'date'\r\n                    Required = $false\r\n                }\r\n                @{\r\n                    Name = 'tags'\r\n                    Label = 'Tags'\r\n                    Type = 'tags'\r\n                    Required = $false\r\n                }\r\n                @{\r\n                    Name = 'notes'\r\n                    Label = 'Notes'\r\n                    Type = 'text'\r\n                    Required = $false\r\n                    MaxLength = 2000\r\n                    Placeholder = 'Additional notes...'\r\n                }\r\n                @{\r\n                    Name = 'completed'\r\n                    Label = 'Completed'\r\n                    Type = 'bool'\r\n                    Required = $false\r\n                    Value = $false\r\n                }\r\n            )\r\n        }\r\n\r\n        'project' {\r\n            return @(\r\n                @{\r\n                    Name = 'name'\r\n                    Label = 'Project Name'\r\n                    Type = 'text'\r\n                    Required = $true\r\n                    MaxLength = 100\r\n                    Placeholder = 'Project name'\r\n                }\r\n                @{\r\n                    Name = 'description'\r\n                    Label = 'Description'\r\n                    Type = 'text'\r\n                    Required = $false\r\n                    MaxLength = 1000\r\n                    Placeholder = 'Project description...'\r\n                }\r\n                @{\r\n                    Name = 'status'\r\n                    Label = 'Status'\r\n                    Type = 'text'\r\n                    Required = $false\r\n                    Options = @('active', 'completed', 'archived', 'on-hold')\r\n                    Value = 'active'\r\n                }\r\n                @{\r\n                    Name = 'tags'\r\n                    Label = 'Tags'\r\n                    Type = 'tags'\r\n                    Required = $false\r\n                }\r\n            )\r\n        }\r\n\r\n        'timelog' {\r\n            return @(\r\n                @{\r\n                    Name = 'taskId'\r\n                    Label = 'Task ID'\r\n                    Type = 'text'\r\n                    Required = $true\r\n                }\r\n                @{\r\n                    Name = 'duration'\r\n                    Label = 'Duration (minutes)'\r\n                    Type = 'number'\r\n                    Required = $true\r\n                    Min = 1\r\n                    Max = 1440\r\n                    Value = 30\r\n                }\r\n                @{\r\n                    Name = 'timestamp'\r\n                    Label = 'Timestamp'\r\n                    Type = 'datetime'\r\n                    Required = $false\r\n                    Value = (Get-Date)\r\n                }\r\n                @{\r\n                    Name = 'notes'\r\n                    Label = 'Notes'\r\n                    Type = 'text'\r\n                    Required = $false\r\n                    MaxLength = 500\r\n                }\r\n            )\r\n        }\r\n\r\n        default {\r\n            return @()\r\n        }\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nMerge field definitions with entity values\r\n\r\n.PARAMETER FieldDefinitions\r\nArray of field definition hashtables\r\n\r\n.PARAMETER Entity\r\nEntity hashtable with values\r\n\r\n.OUTPUTS\r\nArray of field definitions with values populated\r\n##CLOSEBRACKET##\r\nfunction Merge-FieldDefinitionsWithEntity {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable[]]$FieldDefinitions,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable]$Entity\r\n    )\r\n\r\n    $mergedFields = @()\r\n\r\n    foreach ($fieldDef in $FieldDefinitions) {\r\n        $mergedField = $fieldDef.Clone()\r\n        $fieldName = $mergedField.Name\r\n\r\n        if ($Entity.ContainsKey($fieldName)) {\r\n            $mergedField.Value = $Entity[$fieldName]\r\n        }\r\n\r\n        $mergedFields += $mergedField\r\n    }\r\n\r\n    return $mergedFields\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nGet display value for a field\r\n\r\n.PARAMETER Value\r\nField value\r\n\r\n.PARAMETER FieldType\r\nField type\r\n\r\n.OUTPUTS\r\nFormatted display string\r\n##CLOSEBRACKET##\r\nfunction Get-FieldDisplayValue {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        $Value,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        [string]$FieldType\r\n    )\r\n\r\n    if ($null -eq $Value) {\r\n        return \"(empty)\"\r\n    }\r\n\r\n    switch ($FieldType) {\r\n        'date' {\r\n            if ($Value -is [DateTime]) {\r\n                return $Value.ToString(\"yyyy-MM-dd (ddd)\")\r\n            }\r\n            return $Value.ToString()\r\n        }\r\n        'datetime' {\r\n            if ($Value -is [DateTime]) {\r\n                return $Value.ToString(\"yyyy-MM-dd HH:mm\")\r\n            }\r\n            return $Value.ToString()\r\n        }\r\n        'bool' {\r\n            return $(if ($Value) { \"Yes\" } else { \"No\" })\r\n        }\r\n        'tags' {\r\n            if ($Value -is [array]) {\r\n                if ($Value.Count -eq 0) {\r\n                    return \"(no tags)\"\r\n                }\r\n                return \"[\" + ($Value -join \"] [\") + \"]\"\r\n            }\r\n            return $Value.ToString()\r\n        }\r\n        'array' {\r\n            if ($Value -is [array]) {\r\n                if ($Value.Count -eq 0) {\r\n                    return \"(empty array)\"\r\n                }\r\n                return ($Value -join \", \")\r\n            }\r\n            return $Value.ToString()\r\n        }\r\n        default {\r\n            return $Value.ToString()\r\n        }\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nValidate field value against field definition\r\n\r\n.PARAMETER Value\r\nField value\r\n\r\n.PARAMETER FieldDefinition\r\nField definition hashtable\r\n\r\n.OUTPUTS\r\nArray of validation error messages (empty if valid)\r\n##CLOSEBRACKET##\r\nfunction Test-FieldValue {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        $Value,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable]$FieldDefinition\r\n    )\r\n\r\n    $errors = @()\r\n    $fieldName = $FieldDefinition.Name\r\n    $fieldType = $FieldDefinition.Type\r\n\r\n    # Required field check\r\n    if ($FieldDefinition.ContainsKey('Required') -and $FieldDefinition.Required) {\r\n        if ($null -eq $Value -or [string]::IsNullOrWhiteSpace($Value.ToString())) {\r\n            $errors += \"$fieldName is required\"\r\n            return $errors\r\n        }\r\n    }\r\n\r\n    # Skip remaining checks if value is null/empty\r\n    if ($null -eq $Value) {\r\n        return $errors\r\n    }\r\n\r\n    # Type-specific validation\r\n    switch ($fieldType) {\r\n        'number' {\r\n            if ($FieldDefinition.ContainsKey('Min') -and $Value -lt $FieldDefinition.Min) {\r\n                $errors += \"$fieldName must be >= $($FieldDefinition.Min)\"\r\n            }\r\n            if ($FieldDefinition.ContainsKey('Max') -and $Value -gt $FieldDefinition.Max) {\r\n                $errors += \"$fieldName must be <= $($FieldDefinition.Max)\"\r\n            }\r\n        }\r\n        'text' {\r\n            $strValue = $Value.ToString()\r\n            if ($FieldDefinition.ContainsKey('MaxLength') -and $strValue.Length -gt $FieldDefinition.MaxLength) {\r\n                $errors += \"$fieldName must be <= $($FieldDefinition.MaxLength) characters\"\r\n            }\r\n        }\r\n    }\r\n\r\n    return $errors\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nCreate UniversalList column definitions from field definitions\r\n\r\n.PARAMETER FieldDefinitions\r\nArray of field definition hashtables\r\n\r\n.PARAMETER ColumnWidths\r\nOptional hashtable of column widths (fieldName -> width)\r\n\r\n.OUTPUTS\r\nArray of column definition hashtables for UniversalList\r\n##CLOSEBRACKET##\r\nfunction ConvertTo-ListColumns {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable[]]$FieldDefinitions,\r\n\r\n        [Parameter(Mandatory=$false)]\r\n        [hashtable]$ColumnWidths = @{}\r\n    )\r\n\r\n    $columns = @()\r\n\r\n    foreach ($fieldDef in $FieldDefinitions) {\r\n        $fieldName = $fieldDef.Name\r\n        $fieldLabel = $(if ($fieldDef.ContainsKey('Label')) { $fieldDef.Label } else { $fieldName })\r\n        $fieldType = $fieldDef.Type\r\n\r\n        # Determine default width based on type\r\n        $defaultWidth = switch ($fieldType) {\r\n            'text' { 40 }\r\n            'number' { 6 }\r\n            'date' { 12 }\r\n            'datetime' { 18 }\r\n            'bool' { 8 }\r\n            'tags' { 30 }\r\n            'project' { 15 }\r\n            default { 20 }\r\n        }\r\n\r\n        $width = $(if ($ColumnWidths.ContainsKey($fieldName)) { $ColumnWidths[$fieldName] } else { $defaultWidth })\r\n\r\n        # Create column definition\r\n        $column = @{\r\n            Name = $fieldName\r\n            Label = $fieldLabel\r\n            Width = $width\r\n            Align = 'left'\r\n        }\r\n\r\n        # Add formatter for specific types\r\n        if ($fieldType -eq 'date' -or $fieldType -eq 'datetime') {\r\n            $column.Format = {\r\n                param($value)\r\n                if ($null -ne $value -and $value -is [DateTime]) {\r\n                    if ($fieldType -eq 'date') {\r\n                        return $value.ToString(\"MMM dd yyyy\")\r\n                    } else {\r\n                        return $value.ToString(\"MMM dd HH:mm\")\r\n                    }\r\n                }\r\n                return \"\"\r\n            }\r\n        }\r\n        elseif ($fieldType -eq 'bool') {\r\n            $column.Format = {\r\n                param($value)\r\n                return $(if ($value) { \"[OK]\" } else { \"\" })\r\n            }\r\n        }\r\n        elseif ($fieldType -eq 'tags' -or $fieldType -eq 'array') {\r\n            $column.Format = {\r\n                param($value)\r\n                if ($value -is [array]) {\r\n                    return ($value -join \", \")\r\n                }\r\n                return \"\"\r\n            }\r\n        }\r\n\r\n        $columns += $column\r\n    }\r\n\r\n    return $columns\r\n}\r\n\r\n# Export functions\r\nExport-ModuleMember -Function @(\r\n    'ConvertTo-WidgetFields',\r\n    'ConvertFrom-WidgetValues',\r\n    'ConvertTo-PmcType',\r\n    'Get-EntityFieldDefinitions',\r\n    'Merge-FieldDefinitionsWithEntity',\r\n    'Get-FieldDisplayValue',\r\n    'Test-FieldValue',\r\n    'ConvertTo-ListColumns'\r\n)"}, {"path": "module/Pmc.Strict/consoleui/helpers/GapBuffer.ps1", "content": "# GapBuffer.ps1 - High-performance text buffer for editing operations\r\n# Uses a gap buffer data structure for optimal performance on typical editing patterns\r\n# Ported from Praxis to PMC ConsoleUI\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Compile C# helper for high-performance buffer operations\r\ntry {\r\n    [void][GapBufferUtils]\r\n} catch {\r\n    $csharpCode = @\"\r\nusing System;\r\nusing System.Collections.Generic;\r\n\r\npublic class GapBufferUtils {\r\n    public static int[] FindAll(char[] buffer, int gapStart, int gapEnd, char target) {\r\n        List<int> indices = new List<int>();\r\n        int gapSize = gapEnd - gapStart;\r\n        \r\n        // Search before gap\r\n        for (int i = 0; i < gapStart; i++) {\r\n            if (buffer[i] == target) {\r\n                indices.Add(i);\r\n            }\r\n        }\r\n        \r\n        // Search after gap\r\n        for (int i = gapEnd; i < buffer.Length; i++) {\r\n            if (buffer[i] == target) {\r\n                indices.Add(i - gapSize);\r\n            }\r\n        }\r\n        \r\n        return indices.ToArray();\r\n    }\r\n\r\n    public static int[] GetStatistics(char[] buffer, int gapStart, int gapEnd) {\r\n        int lines = 1;\r\n        int words = 0;\r\n        int chars = 0;\r\n        bool inWord = false;\r\n\r\n        // Helper to process char\r\n        Action<char> process = (c) => {\r\n            chars++;\r\n            if (c == '\\n') lines++;\r\n            if (char.IsWhiteSpace(c)) {\r\n                inWord = false;\r\n            } else if (!inWord) {\r\n                words++;\r\n                inWord = true;\r\n            }\r\n        };\r\n\r\n        for (int i = 0; i < gapStart; i++) process(buffer[i]);\r\n        for (int i = gapEnd; i < buffer.Length; i++) process(buffer[i]);\r\n\r\n        return new int[] { lines, words, chars };\r\n    }\r\n}\r\n\"@\r\n    Add-Type -TypeDefinition $csharpCode -Language CSharp\r\n}\r\n\r\nclass GapBuffer {\r\n    # Internal buffer with gap\r\n    hidden [char[]]$_buffer\r\n    hidden [int]$_gapStart\r\n    hidden [int]$_gapEnd\r\n    hidden [int]$_capacity\r\n\r\n    # Buffer growth parameters\r\n    hidden [int]$_initialCapacity = 1024\r\n    hidden [double]$_growthFactor = 1.5\r\n    hidden [int]$_minGapSize = 128\r\n\r\n    # Statistics for debugging/optimization\r\n    [int]$InsertCount = 0\r\n    [int]$DeleteCount = 0\r\n    [int]$MoveCount = 0\r\n    [int]$GrowCount = 0\r\n\r\n    GapBuffer() {\r\n        $this._capacity = $this._initialCapacity\r\n        $this._buffer = [char[]]::new($this._capacity)\r\n        $this._gapStart = 0\r\n        $this._gapEnd = $this._capacity\r\n    }\r\n\r\n    GapBuffer([int]$initialCapacity) {\r\n        $this._capacity = [Math]::Max($initialCapacity, $this._minGapSize)\r\n        $this._buffer = [char[]]::new($this._capacity)\r\n        $this._gapStart = 0\r\n        $this._gapEnd = $this._capacity\r\n    }\r\n\r\n    GapBuffer([string]$text) {\r\n        $textLength = $text.Length\r\n        $this._capacity = [Math]::Max($textLength + $this._minGapSize, $this._initialCapacity)\r\n        $this._buffer = [char[]]::new($this._capacity)\r\n\r\n        # Copy text to buffer\r\n        if ($textLength -gt 0) {\r\n            [array]::Copy($text.ToCharArray(), 0, $this._buffer, 0, $textLength)\r\n        }\r\n\r\n        $this._gapStart = $textLength\r\n        $this._gapEnd = $this._capacity\r\n    }\r\n\r\n    # --- Public Properties ---\r\n\r\n    [int] GetLength() {\r\n        return $this._capacity - ($this._gapEnd - $this._gapStart)\r\n    }\r\n\r\n    [int] GetCapacity() {\r\n        return $this._capacity\r\n    }\r\n\r\n    [int] GetGapSize() {\r\n        return $this._gapEnd - $this._gapStart\r\n    }\r\n\r\n    # --- Core Operations ---\r\n\r\n    [void] MoveGapTo([int]$position) {\r\n        if ($position -lt 0 -or $position -gt $this.GetLength()) {\r\n            throw \"Position $position is out of range (0-$($this.GetLength()))\"\r\n        }\r\n\r\n        if ($position -eq $this._gapStart) {\r\n            return  # Gap is already at the correct position\r\n        }\r\n\r\n        $this.MoveCount++\r\n\r\n        if ($position -lt $this._gapStart) {\r\n            # Move gap left - shift text right\r\n            $moveSize = $this._gapStart - $position\r\n            $sourceStart = $position\r\n            $destStart = $this._gapEnd - $moveSize\r\n\r\n            # Validate destination index\r\n            if ($destStart -lt 0 -or ($destStart + $moveSize) -gt $this._buffer.Length) {\r\n                throw \"Invalid gap buffer state: destStart=$destStart, moveSize=$moveSize, bufferLength=$($this._buffer.Length)\"\r\n            }\r\n\r\n            [array]::Copy($this._buffer, $sourceStart, $this._buffer, $destStart, $moveSize)\r\n\r\n            $this._gapStart = $position\r\n            $this._gapEnd -= $moveSize\r\n        } else {\r\n            # Move gap right - shift text left\r\n            $moveSize = $position - $this._gapStart\r\n            $sourceStart = $this._gapEnd\r\n            $destStart = $this._gapStart\r\n\r\n            [array]::Copy($this._buffer, $sourceStart, $this._buffer, $destStart, $moveSize)\r\n\r\n            $this._gapStart = $position\r\n            $this._gapEnd += $moveSize\r\n        }\r\n    }\r\n\r\n    [void] EnsureGapSize([int]$minSize) {\r\n        $currentGapSize = $this._gapEnd - $this._gapStart\r\n        if ($currentGapSize -ge $minSize) {\r\n            return  # Gap is already large enough\r\n        }\r\n\r\n        # Calculate new capacity\r\n        $currentLength = $this.GetLength()\r\n        $neededCapacity = $currentLength + $minSize\r\n        $newCapacity = [Math]::Max([int]($this._capacity * $this._growthFactor), $neededCapacity)\r\n\r\n        $this.GrowCount++\r\n\r\n        # Create new buffer\r\n        $newBuffer = [char[]]::new($newCapacity)\r\n\r\n        # Copy text before gap\r\n        if ($this._gapStart -gt 0) {\r\n            [array]::Copy($this._buffer, 0, $newBuffer, 0, $this._gapStart)\r\n        }\r\n\r\n        # Copy text after gap\r\n        $textAfterGap = $this._capacity - $this._gapEnd\r\n        if ($textAfterGap -gt 0) {\r\n            $newGapEnd = $newCapacity - $textAfterGap\r\n            [array]::Copy($this._buffer, $this._gapEnd, $newBuffer, $newGapEnd, $textAfterGap)\r\n            $this._gapEnd = $newGapEnd\r\n        } else {\r\n            $this._gapEnd = $newCapacity\r\n        }\r\n\r\n        $this._buffer = $newBuffer\r\n        $this._capacity = $newCapacity\r\n    }\r\n\r\n    # --- Text Operations ---\r\n\r\n    [void] Insert([int]$position, [char]$char) {\r\n        $this.MoveGapTo($position)\r\n        $this.EnsureGapSize(1)\r\n\r\n        $this._buffer[$this._gapStart] = $char\r\n        $this._gapStart++\r\n        $this.InsertCount++\r\n    }\r\n\r\n    [void] Insert([int]$position, [string]$text) {\r\n        if ([string]::IsNullOrEmpty($text)) {\r\n            return\r\n        }\r\n\r\n        $this.MoveGapTo($position)\r\n        $this.EnsureGapSize($text.Length)\r\n\r\n        $chars = $text.ToCharArray()\r\n        [array]::Copy($chars, 0, $this._buffer, $this._gapStart, $chars.Length)\r\n        $this._gapStart += $chars.Length\r\n        $this.InsertCount++\r\n    }\r\n\r\n    [void] Delete([int]$position, [int]$count = 1) {\r\n        if ($count -le 0) {\r\n            return\r\n        }\r\n\r\n        $length = $this.GetLength()\r\n        if ($position -lt 0 -or $position -ge $length) {\r\n            return  # Position out of bounds\r\n        }\r\n\r\n        # Clamp count to available characters\r\n        $count = [Math]::Min($count, $length - $position)\r\n        if ($count -le 0) {\r\n            return\r\n        }\r\n\r\n        $this.MoveGapTo($position)\r\n\r\n        # Expand gap to include deleted characters\r\n        $this._gapEnd += $count\r\n        $this.DeleteCount++\r\n    }\r\n\r\n    [char] GetChar([int]$position) {\r\n        $length = $this.GetLength()\r\n        if ($position -lt 0 -or $position -ge $length) {\r\n            return [char]0  # Return null character for out of bounds\r\n        }\r\n\r\n        if ($position -lt $this._gapStart) {\r\n            return $this._buffer[$position]\r\n        } else {\r\n            return $this._buffer[$position + ($this._gapEnd - $this._gapStart)]\r\n        }\r\n    }\r\n\r\n    [string] GetText([int]$start, [int]$count) {\r\n        $length = $this.GetLength()\r\n        if ($start -lt 0 -or $start -ge $length -or $count -le 0) {\r\n            return \"\"\r\n        }\r\n\r\n        # Clamp count to available characters\r\n        $count = [Math]::Min($count, $length - $start)\r\n        $chars = [char[]]::new($count)\r\n\r\n        # Optimize: Use Array.Copy instead of loop\r\n        if ($start -lt $this._gapStart) {\r\n            # Starts before gap\r\n            $firstChunkLen = [Math]::Min($count, $this._gapStart - $start)\r\n            [array]::Copy($this._buffer, $start, $chars, 0, $firstChunkLen)\r\n            \r\n            if ($firstChunkLen -lt $count) {\r\n                # Spans across gap\r\n                $secondChunkLen = $count - $firstChunkLen\r\n                [array]::Copy($this._buffer, $this._gapEnd, $chars, $firstChunkLen, $secondChunkLen)\r\n            }\r\n        } else {\r\n            # Starts after gap\r\n            $bufferStart = $start + ($this._gapEnd - $this._gapStart)\r\n            [array]::Copy($this._buffer, $bufferStart, $chars, 0, $count)\r\n        }\r\n\r\n        return [string]::new($chars)\r\n    }\r\n\r\n    [string] GetText() {\r\n        return $this.GetText(0, $this.GetLength())\r\n    }\r\n\r\n    # Optimized search for all occurrences of a character\r\n    # Returns an array of indices\r\n    [int[]] FindAll([char]$char) {\r\n        # Use reflection to avoid parse-time dependency on GapBufferUtils\r\n        # which is defined via Add-Type in this same file\r\n        $type = \"GapBufferUtils\" -as [type]\r\n        if ($null -eq $type) { throw \"GapBufferUtils type not found\" }\r\n        return $type::FindAll($this._buffer, $this._gapStart, $this._gapEnd, $char)\r\n    }\r\n\r\n    [string] GetSubstring([int]$start, [int]$length) {\r\n        return $this.GetText($start, $length)\r\n    }\r\n\r\n    # --- Advanced Operations ---\r\n\r\n    [void] Clear() {\r\n        $this._gapStart = 0\r\n        $this._gapEnd = $this._capacity\r\n\r\n        # Optional: Clear the buffer for security\r\n        [array]::Clear($this._buffer, 0, $this._capacity)\r\n    }\r\n\r\n    [void] SetText([string]$text) {\r\n        $this.Clear()\r\n        if (-not [string]::IsNullOrEmpty($text)) {\r\n            $this.Insert(0, $text)\r\n        }\r\n    }\r\n\r\n    [int] IndexOf([char]$char, [int]$startIndex = 0) {\r\n        $length = $this.GetLength()\r\n        for ($i = $startIndex; $i -lt $length; $i++) {\r\n            if ($this.GetChar($i) -eq $char) {\r\n                return $i\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n\r\n    [int] IndexOf([string]$text, [int]$startIndex = 0) {\r\n        if ([string]::IsNullOrEmpty($text)) {\r\n            return -1\r\n        }\r\n\r\n        $length = $this.GetLength()\r\n        $textLength = $text.Length\r\n\r\n        for ($i = $startIndex; $i -le $length - $textLength; $i++) {\r\n            $match = $true\r\n            for ($j = 0; $j -lt $textLength; $j++) {\r\n                if ($this.GetChar($i + $j) -ne $text[$j]) {\r\n                    $match = $false\r\n                    break\r\n                }\r\n            }\r\n            if ($match) {\r\n                return $i\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n\r\n    [int] LastIndexOf([char]$char, [int]$startIndex = -1) {\r\n        $length = $this.GetLength()\r\n        if ($startIndex -eq -1) {\r\n            $startIndex = $length - 1\r\n        }\r\n\r\n        for ($i = $startIndex; $i -ge 0; $i--) {\r\n            if ($this.GetChar($i) -eq $char) {\r\n                return $i\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n\r\n    # --- Debugging and Statistics ---\r\n\r\n    [hashtable] GetStatistics() {\r\n        return @{\r\n            Length = $this.GetLength()\r\n            Capacity = $this._capacity\r\n            GapSize = $this.GetGapSize()\r\n            GapStart = $this._gapStart\r\n            GapEnd = $this._gapEnd\r\n            InsertCount = $this.InsertCount\r\n            DeleteCount = $this.DeleteCount\r\n            MoveCount = $this.MoveCount\r\n            GrowCount = $this.GrowCount\r\n            Efficiency = $(if ($this.MoveCount -gt 0) {\r\n                [Math]::Round(($this.InsertCount + $this.DeleteCount) / [double]$this.MoveCount, 2)\r\n            } else {\r\n                \"N/A\"\r\n            })\r\n        }\r\n    }\r\n\r\n    [hashtable] GetContentStatistics() {\r\n        $type = \"GapBufferUtils\" -as [type]\r\n        if ($null -ne $type) {\r\n            $stats = $type::GetStatistics($this._buffer, $this._gapStart, $this._gapEnd)\r\n            return @{\r\n                Lines = $stats[0]\r\n                Words = $stats[1]\r\n                Chars = $stats[2]\r\n            }\r\n        }\r\n        \r\n        # Fallback if C# type not available (should not happen)\r\n        return @{\r\n            Lines = 0\r\n            Words = 0\r\n            Chars = 0\r\n        }\r\n    }\r\n\r\n    [void] ResetStatistics() {\r\n        $this.InsertCount = 0\r\n        $this.DeleteCount = 0\r\n        $this.MoveCount = 0\r\n        $this.GrowCount = 0\r\n    }\r\n\r\n    [string] ToString() {\r\n        return $this.GetText()\r\n    }\r\n\r\n    # --- Validation (for debugging) ---\r\n\r\n    [bool] ValidateStructure() {\r\n        if ($this._gapStart -lt 0 -or $this._gapStart -gt $this._capacity) {\r\n            return $false\r\n        }\r\n        if ($this._gapEnd -lt $this._gapStart -or $this._gapEnd -gt $this._capacity) {\r\n            return $false\r\n        }\r\n        if ($this._capacity -le 0) {\r\n            return $false\r\n        }\r\n        return $true\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/helpers/LinuxKeyHelper.ps1", "content": "# LinuxKeyHelper.ps1 - Handles escape sequence parsing for Ctrl+Arrow keys on Linux\r\n# Workaround for Console.ReadKey not properly detecting Ctrl+Arrow on Linux terminals\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass LinuxKeyHelper {\r\n    # Parse escape sequence for Ctrl+Arrow keys\r\n    # Returns: \"Ctrl+Up\", \"Ctrl+Down\", \"Ctrl+Left\", \"Ctrl+Right\", or $null\r\n    static [string] ParseCtrlArrow([ConsoleKeyInfo]$keyInfo) {\r\n        # First check if ReadKey properly detected it (works on some terminals)\r\n        $ctrl = $keyInfo.Modifiers -band [ConsoleModifiers]::Control\r\n        if ($ctrl) {\r\n            switch ($keyInfo.Key) {\r\n                ([ConsoleKey]::UpArrow) { return \"Ctrl+Up\" }\r\n                ([ConsoleKey]::DownArrow) { return \"Ctrl+Down\" }\r\n                ([ConsoleKey]::LeftArrow) { return \"Ctrl+Left\" }\r\n                ([ConsoleKey]::RightArrow) { return \"Ctrl+Right\" }\r\n            }\r\n        }\r\n\r\n        # Linux workaround: Check if this is ESC (start of escape sequence)\r\n        # Ctrl+Arrow sends: ESC [  1 ; 5 A/B/C/D\r\n        # Where A=Up, B=Down, C=Right, D=Left, and 5=Ctrl modifier\r\n        if ($keyInfo.Key -eq [ConsoleKey]::Escape) {\r\n            # Need to read the rest of the sequence\r\n            # This is tricky because ReadKey already consumed the ESC\r\n            # We need to check if more keys are available immediately\r\n            if ([Console]::KeyAvailable) {\r\n                $next1 = [Console]::ReadKey($true)\r\n                if ($next1.KeyChar -eq '[' -and [Console]::KeyAvailable) {\r\n                    # Read the sequence: could be \"1;5A\" or just \"A\"\r\n                    $sequence = \"\"\r\n                    while ([Console]::KeyAvailable) {\r\n                        $ch = [Console]::ReadKey($true)\r\n                        $sequence += $ch.KeyChar\r\n                        # Stop at letter (A/B/C/D)\r\n                        if ($ch.KeyChar -match '[A-Z]') {\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    # Parse the sequence\r\n                    # Format: \"1;5A\" = Ctrl+Up\r\n                    # Format: \"1;5B\" = Ctrl+Down\r\n                    # Format: \"1;5C\" = Ctrl+Right\r\n                    # Format: \"1;5D\" = Ctrl+Left\r\n                    if ($sequence -match '1;5([ABCD])') {\r\n                        switch ($Matches[1]) {\r\n                            'A' { return \"Ctrl+Up\" }\r\n                            'B' { return \"Ctrl+Down\" }\r\n                            'C' { return \"Ctrl+Right\" }\r\n                            'D' { return \"Ctrl+Left\" }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return $null\r\n    }\r\n\r\n    # Check if a key is a Ctrl+Arrow and return the direction\r\n    static [string] DetectCtrlArrow([ConsoleKeyInfo]$keyInfo) {\r\n        return [LinuxKeyHelper]::ParseCtrlArrow($keyInfo)\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/helpers/ShortcutRegistry.ps1", "content": "# ShortcutRegistry - Centralized keyboard shortcut validation and conflict detection\r\n# H-UI-5: Detect and prevent keyboard shortcut conflicts across the application\r\n\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nRegistry for tracking and validating keyboard shortcuts across screens and widgets\r\n\r\n.DESCRIPTION\r\nShortcutRegistry provides centralized shortcut management to:\r\n- Detect conflicts between shortcuts\r\n- Validate shortcut availability\r\n- Track shortcut usage across contexts\r\n- Provide conflict resolution suggestions\r\n\r\n.EXAMPLE\r\n$registry = [ShortcutRegistry]::new()\r\n$registry.Register(\"TaskList\", \"Ctrl+N\", \"New Task\")\r\nif ($registry.HasConflict(\"ProjectList\", \"Ctrl+N\")) {\r\n    # Handle conflict\r\n}\r\n##CLOSEBRACKET##\r\nclass ShortcutRegistry {\r\n    # Dictionary: Context -> Dictionary<Shortcut, Description>\r\n    [Dictionary[string, Dictionary[string, string]]]$_shortcuts\r\n\r\n    # Global shortcuts that apply to all contexts\r\n    [Dictionary[string, string]]$_globalShortcuts\r\n\r\n    ShortcutRegistry() {\r\n        $this._shortcuts = [Dictionary[string, Dictionary[string, string]]]::new()\r\n        $this._globalShortcuts = [Dictionary[string, string]]::new()\r\n\r\n        # Register common global shortcuts\r\n        $this._globalShortcuts['Esc'] = 'Back/Cancel'\r\n        $this._globalShortcuts['F10'] = 'Menu'\r\n        $this._globalShortcuts['?'] = 'Help'\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Register a shortcut for a specific context\r\n\r\n    .PARAMETER context\r\n    The context (screen name, widget name, etc.)\r\n\r\n    .PARAMETER shortcut\r\n    The shortcut key combination (e.g., \"Ctrl+N\", \"F5\", \"Alt+Enter\")\r\n\r\n    .PARAMETER description\r\n    Description of what the shortcut does\r\n\r\n    .RETURNS\r\n    $true if registered successfully, $false if conflict detected\r\n    ##CLOSEBRACKET##\r\n    [bool] Register([string]$context, [string]$shortcut, [string]$description) {\r\n        # Check for global conflicts\r\n        if ($this._globalShortcuts.ContainsKey($shortcut)) {\r\n            Write-Warning \"Shortcut conflict: '$shortcut' in context '$context' conflicts with global shortcut '$($this._globalShortcuts[$shortcut])'\"\r\n            return $false\r\n        }\r\n\r\n        # Ensure context exists\r\n        if (-not $this._shortcuts.ContainsKey($context)) {\r\n            $this._shortcuts[$context] = [Dictionary[string, string]]::new()\r\n        }\r\n\r\n        # Check for context-specific conflicts\r\n        if ($this._shortcuts[$context].ContainsKey($shortcut)) {\r\n            Write-Warning \"Shortcut conflict: '$shortcut' already registered in context '$context' as '$($this._shortcuts[$context][$shortcut])'\"\r\n            return $false\r\n        }\r\n\r\n        # Register the shortcut\r\n        $this._shortcuts[$context][$shortcut] = $description\r\n        return $true\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Register a global shortcut that applies to all contexts\r\n\r\n    .PARAMETER shortcut\r\n    The shortcut key combination\r\n\r\n    .PARAMETER description\r\n    Description of what the shortcut does\r\n    ##CLOSEBRACKET##\r\n    [void] RegisterGlobal([string]$shortcut, [string]$description) {\r\n        $this._globalShortcuts[$shortcut] = $description\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Check if a shortcut would conflict in a given context\r\n\r\n    .PARAMETER context\r\n    The context to check\r\n\r\n    .PARAMETER shortcut\r\n    The shortcut to check\r\n\r\n    .RETURNS\r\n    $true if conflict exists, $false otherwise\r\n    ##CLOSEBRACKET##\r\n    [bool] HasConflict([string]$context, [string]$shortcut) {\r\n        # Check global shortcuts\r\n        if ($this._globalShortcuts.ContainsKey($shortcut)) {\r\n            return $true\r\n        }\r\n\r\n        # Check context-specific shortcuts\r\n        if ($this._shortcuts.ContainsKey($context) -and\r\n            $this._shortcuts[$context].ContainsKey($shortcut)) {\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get all shortcuts registered for a context\r\n\r\n    .PARAMETER context\r\n    The context to query\r\n\r\n    .RETURNS\r\n    Dictionary of shortcuts and their descriptions\r\n    ##CLOSEBRACKET##\r\n    [Dictionary[string, string]] GetShortcuts([string]$context) {\r\n        if ($this._shortcuts.ContainsKey($context)) {\r\n            return $this._shortcuts[$context]\r\n        }\r\n        return [Dictionary[string, string]]::new()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get all global shortcuts\r\n\r\n    .RETURNS\r\n    Dictionary of global shortcuts and their descriptions\r\n    ##CLOSEBRACKET##\r\n    [Dictionary[string, string]] GetGlobalShortcuts() {\r\n        return $this._globalShortcuts\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Unregister a shortcut from a context\r\n\r\n    .PARAMETER context\r\n    The context\r\n\r\n    .PARAMETER shortcut\r\n    The shortcut to unregister\r\n    ##CLOSEBRACKET##\r\n    [void] Unregister([string]$context, [string]$shortcut) {\r\n        if ($this._shortcuts.ContainsKey($context)) {\r\n            $this._shortcuts[$context].Remove($shortcut)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Clear all shortcuts for a context\r\n\r\n    .PARAMETER context\r\n    The context to clear\r\n    ##CLOSEBRACKET##\r\n    [void] ClearContext([string]$context) {\r\n        if ($this._shortcuts.ContainsKey($context)) {\r\n            $this._shortcuts.Remove($context)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get a report of all registered shortcuts\r\n\r\n    .RETURNS\r\n    String containing formatted report\r\n    ##CLOSEBRACKET##\r\n    [string] GetReport() {\r\n        $sb = [System.Text.StringBuilder]::new()\r\n\r\n        $sb.AppendLine(\"=== Keyboard Shortcut Registry ===\")\r\n        $sb.AppendLine()\r\n\r\n        # Global shortcuts\r\n        $sb.AppendLine(\"Global Shortcuts:\")\r\n        foreach ($kvp in $this._globalShortcuts.GetEnumerator()) {\r\n            $sb.AppendLine(\"  $($kvp.Key.PadRight(15)) : $($kvp.Value)\")\r\n        }\r\n        $sb.AppendLine()\r\n\r\n        # Context-specific shortcuts\r\n        foreach ($context in $this._shortcuts.Keys | Sort-Object) {\r\n            $sb.AppendLine(\"Context: $context\")\r\n            foreach ($kvp in $this._shortcuts[$context].GetEnumerator() | Sort-Object Key) {\r\n                $sb.AppendLine(\"  $($kvp.Key.PadRight(15)) : $($kvp.Value)\")\r\n            }\r\n            $sb.AppendLine()\r\n        }\r\n\r\n        return $sb.ToString()\r\n    }\r\n}\r\n\r\n# Create global singleton instance if needed\r\nif (-not (Get-Variable -Name PmcShortcutRegistry -Scope Global -ErrorAction SilentlyContinue)) {\r\n    $global:PmcShortcutRegistry = [ShortcutRegistry]::new()\r\n}"}, {"path": "module/Pmc.Strict/consoleui/helpers/ThemeHelper.ps1", "content": "# ThemeHelper.ps1 - Hot reload support for theme changes\r\n# Allows themes to be changed without restarting the TUI\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nHot reload the theme system after a theme change\r\n\r\n.DESCRIPTION\r\nReloads the theme engine with new colors from the palette,\r\ninvalidates caches, and forces a full screen redraw to apply\r\nthe new theme immediately without restarting the TUI.\r\n\r\n.PARAMETER hexColor\r\nOptional hex color to reload. If not provided, uses current theme from config.\r\n\r\n.EXAMPLE\r\nInvoke-ThemeHotReload \"#33cc66\"\r\n\r\n.EXAMPLE\r\nInvoke-ThemeHotReload  # Reload current theme\r\n##CLOSEBRACKET##\r\nfunction Invoke-ThemeHotReload {\r\n    param(\r\n        [string]$themeName = $null\r\n    )\r\n\r\n    try {\r\n        if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\r\n            Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [ThemeHotReload] Starting hot reload for theme: '$themeName'\"\r\n        }\r\n\r\n        # 1. If theme name provided, save it to config\r\n        if (-not [string]::IsNullOrEmpty($themeName)) {\r\n            Set-ActiveTheme -themeName $themeName\r\n            if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\r\n                Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [ThemeHotReload] Set-ActiveTheme completed\"\r\n            }\r\n        }\r\n\r\n        # 2. Reinitialize PMC theme system to update state\r\n        Initialize-PmcThemeSystem -Force\r\n        if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\r\n            Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [ThemeHotReload] Initialize-PmcThemeSystem -Force completed\"\r\n        }\r\n\r\n        # 3. Reload PmcThemeManager (which loads from theme file)\r\n        $themeManager = [PmcThemeManager]::GetInstance()\r\n        $themeManager.Reload()\r\n        if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\r\n            Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [ThemeHotReload] PmcThemeManager.Reload completed\"\r\n        }\r\n\r\n        # 4. Force full screen refresh if app is running\r\n        if ($global:PmcApp) {\r\n            # Request clear to invalidate render buffer\r\n            $global:PmcApp.RenderEngine.RequestClear()\r\n\r\n            # Mark current screen dirty to force redraw\r\n            if ($global:PmcApp.CurrentScreen) {\r\n                $global:PmcApp.CurrentScreen.NeedsClear = $true\r\n            }\r\n\r\n            # Request render on next frame\r\n            $global:PmcApp.RequestRender()\r\n        }\r\n\r\n        return $true\r\n\r\n    } catch {\r\n        if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\r\n            Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [ThemeHotReload] ERROR: $_\"\r\n        }\r\n        return $false\r\n    }\r\n}\r\n"}, {"path": "module/Pmc.Strict/consoleui/helpers/ThemeLoader.ps1", "content": "# ThemeLoader.ps1 - Simple theme file loading\n# Loads themes from themes/*.json files\n# ONE path: Load theme file -> Use Properties\n\nSet-StrictMode -Version Latest\n\n<#\n.SYNOPSIS\nGet list of available themes from themes/ directory\n\n.OUTPUTS\nArray of theme objects with Name, Hex, Description, Properties\n##CLOSEBRACKET##\nfunction Get-AvailableThemes {\n    $themesDir = Join-Path $global:PmcAppRoot 'themes'\n    $themes = @()\n    \n    if (Test-Path $themesDir) {\n        $themeFiles = Get-ChildItem -Path $themesDir -Filter '*.json' -File\n        foreach ($file in $themeFiles) {\n            try {\n                $theme = Get-Content $file.FullName -Raw | ConvertFrom-Json\n                $themes += $theme\n            }\n            catch {\n                # Debug only when flag is set\n                if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\n                    Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [ThemeLoader] ERROR loading $($file.Name): $_\"\n                }\n            }\n        }\n    }\n    \n    return $themes\n}\n\n<#\n.SYNOPSIS\nLoad a specific theme by name\n\n.PARAMETER themeName\nName of the theme (matching filename without .json extension)\n\n.OUTPUTS\nTheme object with Name, Hex, Description, Properties, or $null if not found\n##CLOSEBRACKET##\nfunction Load-Theme {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$themeName\n    )\n    \n    # Debug log path (same as Start-PmcTUI)\n    $debugLog = $null\n    try {\n        $debugLog = Join-Path (Split-Path (Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent) -Parent) 'data/logs/theme-debug.log'\n    } catch { }\n    \n    $themesDir = Join-Path $global:PmcAppRoot 'themes'\n    if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Load-Theme] themeName='$themeName' PmcAppRoot='$($global:PmcAppRoot)' themesDir='$themesDir'\" -ErrorAction SilentlyContinue }\n    \n    # Fallback search if global root fails\n    if (-not (Test-Path $themesDir)) {\n        if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Load-Theme] themesDir not found, searching fallbacks...\" -ErrorAction SilentlyContinue }\n        $searchPaths = @(\n            $PSScriptRoot,\n            (Split-Path $PSScriptRoot -Parent),\n            (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent),\n            (Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent)\n        )\n        foreach ($path in $searchPaths) {\n            if ($path -and (Test-Path (Join-Path $path \"themes\"))) {\n                $themesDir = Join-Path $path \"themes\"\n                if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Load-Theme] Found themes at fallback: $themesDir\" -ErrorAction SilentlyContinue }\n                break\n            }\n        }\n    }\n\n    $themeFile = Join-Path $themesDir \"$($themeName.ToLower()).json\"\n    if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Load-Theme] Looking for: $themeFile (exists=$(Test-Path $themeFile))\" -ErrorAction SilentlyContinue }\n    \n    if (Test-Path $themeFile) {\n        try {\n            $themeObj = Get-Content $themeFile -Raw | ConvertFrom-Json\n            if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Load-Theme] JSON loaded. Name='$($themeObj.Name)' Hex='$($themeObj.Hex)'\" -ErrorAction SilentlyContinue }\n            # Convert Properties from PSCustomObject to hashtable\n            $props = @{}\n            if ($themeObj.Properties) {\n                $themeObj.Properties.PSObject.Properties | ForEach-Object {\n                    $propValue = @{\n                        Type = $_.Value.Type\n                    }\n                    # Solid types have Color, Gradient types have Start/End\n                    if ($_.Value.PSObject.Properties['Color']) {\n                        $propValue['Color'] = $_.Value.Color\n                    }\n                    if ($_.Value.PSObject.Properties['Start']) {\n                        $propValue['Start'] = $_.Value.Start\n                    }\n                    if ($_.Value.PSObject.Properties['End']) {\n                        $propValue['End'] = $_.Value.End\n                    }\n                    $props[$_.Name] = $propValue\n                }\n            }\n            $theme = @{\n                Name = $themeObj.Name\n                Hex = $themeObj.Hex\n                Description = $themeObj.Description\n                Properties = $props\n                Warning = $(if ($props.ContainsKey('Foreground.Warning')) { $props['Foreground.Warning'] } else { 'Red' })\n            }\n            if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Load-Theme] Returning theme with Hex='$($theme.Hex)'\" -ErrorAction SilentlyContinue }\n            return $theme\n        }\n        catch {\n            if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Load-Theme] EXCEPTION: $_\" -ErrorAction SilentlyContinue }\n            if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\n                Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [ThemeLoader] FATAL ERROR loading theme '$themeName': $_\"\n            }\n            throw \"Failed to load theme '$themeName': $_\"\n        }\n    }\n    \n    if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Load-Theme] Theme file NOT FOUND, returning null\" -ErrorAction SilentlyContinue }\n    if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\n        Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [ThemeLoader] Theme file not found: $themeFile\"\n    }\n    return $null\n}\n\n\n<#\n.SYNOPSIS\nGet the currently active theme\n\n.DESCRIPTION\nReads active theme name from config.json, loads that theme file\n\n.OUTPUTS\nTheme object with Properties, or default theme if not found\n##CLOSEBRACKET##\nfunction Get-ActiveTheme {\n    $themeName = 'default'  # Default if nothing configured\n    \n    try {\n        $cfg = Get-PmcConfig\n        if ($cfg -and $cfg.Display -and $cfg.Display.Theme -and $cfg.Display.Theme.Active) {\n            $themeName = $cfg.Display.Theme.Active\n        }\n    }\n    catch {\n        if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\n            Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [ThemeLoader] ERROR reading config: $_\"\n        }\n    }\n    \n    $theme = Load-Theme -themeName $themeName\n    \n    # If theme not found, try default\n    if (-not $theme -and $themeName -ne 'default') {\n        if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\n            Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [ThemeLoader] Theme '$themeName' not found, falling back to default\"\n        }\n        $theme = Load-Theme -themeName 'default'\n    }\n    \n    return $theme\n}\n\n<#\n.SYNOPSIS\nSet the active theme by name\n\n.PARAMETER themeName\nName of the theme to set as active\n##CLOSEBRACKET##\nfunction Set-ActiveTheme {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$themeName\n    )\n    \n    # Debug log path\n    $debugLog = $null\n    try {\n        $debugLog = Join-Path (Split-Path (Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent) -Parent) 'data/logs/theme-debug.log'\n    } catch { }\n    if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Set-ActiveTheme] Starting for themeName='$themeName'\" -ErrorAction SilentlyContinue }\n    \n    $cfg = Get-PmcConfig\n    if (-not $cfg) { $cfg = @{} }\n    if (-not $cfg.Display) { $cfg.Display = @{} }\n    if (-not $cfg.Display.Theme) { $cfg.Display.Theme = @{} }\n    \n    $cfg.Display.Theme.Active = $themeName.ToLower()\n    if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Set-ActiveTheme] Set Active='$($cfg.Display.Theme.Active)'\" -ErrorAction SilentlyContinue }\n    \n    # Load the theme to get its hex color\n    $theme = Load-Theme -themeName $themeName\n    if (-not $theme) {\n        if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Set-ActiveTheme] Load-Theme returned null!\" -ErrorAction SilentlyContinue }\n        throw \"Set-ActiveTheme: Failed to load theme '$themeName' - theme file may not exist in themes/ directory\"\n    }\n    if (-not $theme.Hex) {\n        if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Set-ActiveTheme] Theme has no Hex property!\" -ErrorAction SilentlyContinue }\n        throw \"Set-ActiveTheme: Theme '$themeName' loaded but has no Hex property defined\"\n    }\n    $cfg.Display.Theme.Hex = $theme.Hex\n    if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Set-ActiveTheme] Set Hex='$($cfg.Display.Theme.Hex)'\" -ErrorAction SilentlyContinue }\n    \n    # Remove old Properties - no longer needed in config (STRICT MODE FIX: safe check)\n    if ($cfg.Display.Theme.PSObject.Properties['Properties']) { $cfg.Display.Theme.PSObject.Properties.Remove('Properties') }\n    \n    if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Set-ActiveTheme] Calling Save-PmcConfig...\" -ErrorAction SilentlyContinue }\n    Save-PmcConfig $cfg\n    if ($debugLog) { Add-Content -Path $debugLog -Value \"[$(Get-Date -F 'HH:mm:ss.fff')] [Set-ActiveTheme] Save-PmcConfig returned\" -ErrorAction SilentlyContinue }\n}\n\n\n\nExport-ModuleMember -Function Get-AvailableThemes, Load-Theme, Get-ActiveTheme, Set-ActiveTheme\n"}, {"path": "module/Pmc.Strict/consoleui/helpers/TypeNormalization.ps1", "content": "using namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nType normalization helpers to eliminate scattered type checking across the codebase.\r\n\r\n.DESCRIPTION\r\nProvides utility functions for handling mixed hashtable/PSCustomObject types that\r\nresult from different data sources (JSON, TaskStore, etc).\r\n\r\n.NOTES\r\nThis module eliminates the need for repeated type checks like:\r\n  if ($obj -is [hashtable]) { ... } else { ... }\r\n##CLOSEBRACKET##\r\n\r\n<#\r\n.SYNOPSIS\r\nConvert PSCustomObject or other types to hashtable format.\r\n\r\n.DESCRIPTION\r\nNormalizes data to hashtable format for consistent access patterns.\r\nHandles null values, existing hashtables, and PSCustomObject conversion.\r\n\r\n.PARAMETER obj\r\nThe object to normalize.\r\n\r\n.EXAMPLE\r\n$normalized = ConvertTo-NormalizedHashtable $task\r\n##CLOSEBRACKET##\r\nfunction ConvertTo-NormalizedHashtable {\r\n    param([object]$obj)\r\n\r\n    if ($null -eq $obj) { return $null }\r\n    if ($obj -is [hashtable]) { return $obj }\r\n\r\n    # Convert PSCustomObject to hashtable\r\n    $hash = @{}\r\n    foreach ($prop in $obj.PSObject.Properties) {\r\n        $hash[$prop.Name] = $prop.Value\r\n    }\r\n    return $hash\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nSafely get a property from hashtable or PSCustomObject.\r\n\r\n.DESCRIPTION\r\nRetrieves property value from either hashtable or PSCustomObject formats,\r\nwith fallback to default value if property doesn't exist.\r\n\r\nReplaces patterns like:\r\n  if ($obj -is [hashtable]) {\r\n    if ($obj.ContainsKey('name')) { $obj['name'] } else { $default }\r\n  } else {\r\n    if ($null -ne ($obj.PSObject.Properties | Where-Object Name -eq 'name')) { $obj.name } else { $default }\r\n  }\r\n\r\n.PARAMETER obj\r\nThe object to query (hashtable or PSCustomObject).\r\n\r\n.PARAMETER name\r\nThe property name to retrieve.\r\n\r\n.PARAMETER default\r\nThe value to return if property doesn't exist. Default is $null.\r\n\r\n.EXAMPLE\r\n$id = $task.id\r\n$parentId = $task.parent_id $null\r\n##CLOSEBRACKET##\r\nfunction Global:Get-SafeProperty {\r\n    param(\r\n        [object]$obj,\r\n        [string]$name,\r\n        [object]$default = $null\r\n    )\r\n\r\n    if ($null -eq $obj) { return $default }\r\n\r\n    if ($obj -is [hashtable]) {\r\n        if ($obj.ContainsKey($name)) {\r\n            # CRITICAL: Use comma operator to prevent PowerShell from unwrapping single-element arrays\r\n            return ,$obj[$name]\r\n        }\r\n        return $default\r\n    }\r\n\r\n    if ($null -ne ($obj.PSObject.Properties | Where-Object Name -eq $name)) {\r\n        # CRITICAL: Use comma operator to prevent PowerShell from unwrapping single-element arrays\r\n        return ,$obj.$name\r\n    }\r\n\r\n    return $default\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nCheck if an object has a property or key.\r\n\r\n.DESCRIPTION\r\nChecks both hashtable keys and PSCustomObject properties.\r\n\r\n.PARAMETER obj\r\nThe object to check.\r\n\r\n.PARAMETER name\r\nThe property/key name to look for.\r\n\r\n.EXAMPLE\r\nif (Test-SafeProperty $task 'parent_id') {\r\n}\r\n##CLOSEBRACKET##\r\nfunction Global:Test-SafeProperty {\r\n    param(\r\n        [object]$obj,\r\n        [string]$name\r\n    )\r\n\r\n    if ($null -eq $obj) { return $false }\r\n\r\n    if ($obj -is [hashtable]) {\r\n        return $obj.ContainsKey($name)\r\n    }\r\n\r\n    return $null -ne ($obj.PSObject.Properties | Where-Object Name -eq $name)\r\n}"}, {"path": "module/Pmc.Strict/consoleui/helpers/ValidationHelper.ps1", "content": "# ValidationHelper.ps1 - Centralized Validation for PMC Entities\r\n#\r\n# Provides comprehensive validation for tasks, projects, and time logs with:\r\n# - Required field validation\r\n# - Type checking\r\n# - Date range validation\r\n# - Priority validation (0-5)\r\n# - Duplicate detection\r\n# - Custom validators via scriptblocks\r\n# - Detailed error messages\r\n#\r\n# Usage:\r\n#   $result = Test-TaskValid $task\r\n#   if (-not $result.IsValid) {\r\n#   }\r\n#\r\n#   $errors = Get-ValidationErrors $data @{\r\n#       name = @{ Required = $true; Type = 'string'; MaxLength = 100 }\r\n#       priority = @{ Required = $false; Type = 'int'; Min = 0; Max = 5 }\r\n#   }\r\n\r\nusing namespace System\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nValidation result object\r\n\r\n.DESCRIPTION\r\nContains validation state and error messages\r\n##CLOSEBRACKET##\r\nclass ValidationResult {\r\n    [bool]$IsValid\r\n    [List[string]]$Errors\r\n    [hashtable]$FieldErrors  # Field-specific errors: @{ fieldName = @('error1', 'error2') }\r\n\r\n    ValidationResult() {\r\n        $this.IsValid = $true\r\n        $this.Errors = [List[string]]::new()\r\n        $this.FieldErrors = @{}\r\n    }\r\n\r\n    [void] AddError([string]$message) {\r\n        $this.IsValid = $false\r\n        $this.Errors.Add($message)\r\n    }\r\n\r\n    [void] AddFieldError([string]$fieldName, [string]$message) {\r\n        $this.IsValid = $false\r\n        $this.Errors.Add($message)\r\n\r\n        if (-not $this.FieldErrors.ContainsKey($fieldName)) {\r\n            $this.FieldErrors[$fieldName] = [List[string]]::new()\r\n        }\r\n        $this.FieldErrors[$fieldName].Add($message)\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nValidate a task entity\r\n\r\n.PARAMETER task\r\nTask hashtable to validate\r\n\r\n.OUTPUTS\r\nValidationResult object\r\n\r\n.EXAMPLE\r\n$result = Test-TaskValid @{ text='Buy milk'; priority=3 }\r\n##CLOSEBRACKET##\r\nfunction Test-TaskValid {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable]$task\r\n    )\r\n\r\n    $result = [ValidationResult]::new()\r\n\r\n    # Required: text\r\n    if (-not $task.ContainsKey('text') -or [string]::IsNullOrWhiteSpace($task.text)) {\r\n        $result.AddFieldError('text', 'Task text is required')\r\n    }\r\n\r\n    # Optional: project (string)\r\n    if ($task.ContainsKey('project') -and $task.project -isnot [string]) {\r\n        $result.AddFieldError('project', 'Project must be a string')\r\n    }\r\n\r\n    # Optional: priority (0-5)\r\n    if ($task.ContainsKey('priority')) {\r\n        if ($task.priority -isnot [int]) {\r\n            $result.AddFieldError('priority', 'Priority must be an integer')\r\n        }\r\n        elseif ($task.priority -lt 0 -or $task.priority -gt 5) {\r\n            $result.AddFieldError('priority', 'Priority must be between 0 and 5')\r\n        }\r\n    }\r\n\r\n    # Optional: due (DateTime)\r\n    if ($task.ContainsKey('due') -and $task.due -ne $null) {\r\n        if ($task.due -isnot [DateTime]) {\r\n            $result.AddFieldError('due', 'Due date must be a DateTime')\r\n        }\r\n        else {\r\n            # H-VAL-1: Date range validation - must be within reasonable range\r\n            $minDate = [DateTime]::new(1900, 1, 1)\r\n            $maxDate = [DateTime]::Now.AddYears(100)\r\n            if ($task.due -lt $minDate -or $task.due -gt $maxDate) {\r\n                $result.AddFieldError('due', 'Due date must be between 1900-01-01 and 100 years from now')\r\n            }\r\n        }\r\n    }\r\n\r\n    # Optional: tags (array)\r\n    if ($task.ContainsKey('tags') -and $task.tags -ne $null) {\r\n        if ($task.tags -isnot [array]) {\r\n            $result.AddFieldError('tags', 'Tags must be an array')\r\n        }\r\n    }\r\n\r\n    # Optional: completed (bool)\r\n    if ($task.ContainsKey('completed') -and $task.completed -ne $null) {\r\n        if ($task.completed -isnot [bool]) {\r\n            $result.AddFieldError('completed', 'Completed must be a boolean')\r\n        }\r\n    }\r\n\r\n    # Optional: status (string, limited values)\r\n    if ($task.ContainsKey('status') -and $task.status -ne $null) {\r\n        $validStatuses = @('todo', 'in-progress', 'done', 'blocked')\r\n        if ($task.status -notin $validStatuses) {\r\n            $result.AddFieldError('status', \"Status must be one of: $($validStatuses -join ', ')\")\r\n        }\r\n    }\r\n\r\n    return $result\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nValidate a project entity\r\n\r\n.PARAMETER project\r\nProject hashtable to validate\r\n\r\n.PARAMETER existingProjects\r\nOptional array of existing projects for duplicate checking\r\n\r\n.OUTPUTS\r\nValidationResult object\r\n\r\n.EXAMPLE\r\n$result = Test-ProjectValid @{ name='MyProject'; description='...' }\r\n##CLOSEBRACKET##\r\nfunction Test-ProjectValid {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable]$project,\r\n\r\n        [Parameter(Mandatory=$false)]\r\n        [array]$existingProjects = @()\r\n    )\r\n\r\n    $result = [ValidationResult]::new()\r\n\r\n    # Required: name\r\n    if (-not $project.ContainsKey('name') -or [string]::IsNullOrWhiteSpace($project.name)) {\r\n        $result.AddFieldError('name', 'Project name is required')\r\n    }\r\n    else {\r\n        # Check for duplicates\r\n        $duplicate = $existingProjects | Where-Object { $_.name -eq $project.name }\r\n        if ($duplicate) {\r\n            $result.AddFieldError('name', \"Project with name '$($project.name)' already exists\")\r\n        }\r\n    }\r\n\r\n    # Optional: description (string)\r\n    if ($project.ContainsKey('description') -and $project.description -ne $null) {\r\n        if ($project.description -isnot [string]) {\r\n            $result.AddFieldError('description', 'Description must be a string')\r\n        }\r\n    }\r\n\r\n    # Optional: status (string, limited values)\r\n    if ($project.ContainsKey('status') -and $project.status -ne $null) {\r\n        $validStatuses = @('active', 'archived', 'on-hold')\r\n        if ($project.status -notin $validStatuses) {\r\n            $result.AddFieldError('status', \"Status must be one of: $($validStatuses -join ', ')\")\r\n        }\r\n    }\r\n\r\n    return $result\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nValidate a time log entity\r\n\r\n.PARAMETER timelog\r\nTime log hashtable to validate\r\n\r\n.PARAMETER taskExists\r\nOptional scriptblock to check if task exists: { param($taskId) return $true/$false }\r\n\r\n.OUTPUTS\r\nValidationResult object\r\n\r\n.EXAMPLE\r\n$result = Test-TimeLogValid @{ taskId='abc'; duration=30 }\r\n##CLOSEBRACKET##\r\nfunction Test-TimeLogValid {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable]$timelog,\r\n\r\n        [Parameter(Mandatory=$false)]\r\n        [scriptblock]$taskExists = $null\r\n    )\r\n\r\n    $result = [ValidationResult]::new()\r\n\r\n    # Required: taskId\r\n    if (-not $timelog.ContainsKey('taskId') -or [string]::IsNullOrWhiteSpace($timelog.taskId)) {\r\n        $result.AddFieldError('taskId', 'Task ID is required')\r\n    }\r\n    elseif ($null -ne $taskExists) {\r\n        # Check if task exists\r\n        $exists = & $taskExists $timelog.taskId\r\n        if (-not $exists) {\r\n            $result.AddFieldError('taskId', \"Task with ID '$($timelog.taskId)' does not exist\")\r\n        }\r\n    }\r\n\r\n    # Required: duration (positive integer)\r\n    if (-not $timelog.ContainsKey('duration')) {\r\n        $result.AddFieldError('duration', 'Duration is required')\r\n    }\r\n    elseif ($timelog.duration -isnot [int]) {\r\n        $result.AddFieldError('duration', 'Duration must be an integer')\r\n    }\r\n    elseif ($timelog.duration -le 0) {\r\n        $result.AddFieldError('duration', 'Duration must be greater than 0')\r\n    }\r\n    # H-VAL-8: Add maximum duration check (1440 minutes = 24 hours)\r\n    elseif ($timelog.duration -gt 1440) {\r\n        $result.AddFieldError('duration', 'Duration must not exceed 1440 minutes (24 hours)')\r\n    }\r\n\r\n    # Optional: timestamp (DateTime)\r\n    if ($timelog.ContainsKey('timestamp') -and $timelog.timestamp -ne $null) {\r\n        if ($timelog.timestamp -isnot [DateTime]) {\r\n            $result.AddFieldError('timestamp', 'Timestamp must be a DateTime')\r\n        }\r\n    }\r\n\r\n    return $result\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nGeneric validation using a schema definition\r\n\r\n.PARAMETER data\r\nData hashtable to validate\r\n\r\n.PARAMETER schema\r\nValidation schema: @{\r\n    fieldName = @{\r\n        Required = $true/$false\r\n        Type = 'string'/'int'/'bool'/'datetime'/'array'\r\n        Min = 0 (for int)\r\n        Max = 100 (for int)\r\n        MinLength = 1 (for string)\r\n        MaxLength = 200 (for string)\r\n        Pattern = '^[a-z]+$' (regex for string)\r\n        Validator = { param($value) return $true/$false } (custom)\r\n    }\r\n}\r\n\r\n.OUTPUTS\r\nArray of validation error messages (empty if valid)\r\n\r\n.EXAMPLE\r\n$errors = Get-ValidationErrors $data @{\r\n    name = @{ Required = $true; Type = 'string'; MaxLength = 100 }\r\n    age = @{ Required = $false; Type = 'int'; Min = 0; Max = 120 }\r\n}\r\n##CLOSEBRACKET##\r\nfunction Get-ValidationErrors {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable]$data,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable]$schema\r\n    )\r\n\r\n    $errors = @()\r\n\r\n    foreach ($fieldName in $schema.Keys) {\r\n        $fieldSchema = $schema[$fieldName]\r\n        $fieldErrors = Test-FieldValid $fieldName $data[$fieldName] $fieldSchema -DataContainsKey $data.ContainsKey($fieldName)\r\n        $errors += $fieldErrors\r\n    }\r\n\r\n    return $errors\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nValidate a single field against a schema\r\n\r\n.PARAMETER fieldName\r\nField name (for error messages)\r\n\r\n.PARAMETER value\r\nField value\r\n\r\n.PARAMETER schema\r\nField schema (see Get-ValidationErrors)\r\n\r\n.PARAMETER DataContainsKey\r\nWhether the data hashtable contains this key\r\n\r\n.OUTPUTS\r\nArray of validation error messages (empty if valid)\r\n##CLOSEBRACKET##\r\nfunction Test-FieldValid {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [string]$fieldName,\r\n\r\n        [Parameter(Mandatory=$false)]\r\n        $value,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable]$schema,\r\n\r\n        [Parameter(Mandatory=$false)]\r\n        [bool]$DataContainsKey = $true\r\n    )\r\n\r\n    $errors = @()\r\n\r\n    # Check if required\r\n    if ($schema.ContainsKey('Required') -and $schema.Required) {\r\n        if (-not $DataContainsKey -or $null -eq $value -or ($value -is [string] -and [string]::IsNullOrWhiteSpace($value))) {\r\n            $errors += \"Field '$fieldName' is required\"\r\n            return $errors  # No point checking further if missing\r\n        }\r\n    }\r\n\r\n    # If field is optional and not provided, skip validation\r\n    if (-not $DataContainsKey -or $null -eq $value) {\r\n        return $errors\r\n    }\r\n\r\n    # Type validation\r\n    if ($schema.ContainsKey('Type')) {\r\n        $expectedType = $schema.Type\r\n        $isValid = switch ($expectedType) {\r\n            'string' { $value -is [string] }\r\n            'int' { $value -is [int] }\r\n            'bool' { $value -is [bool] }\r\n            'datetime' { $value -is [DateTime] }\r\n            'array' { $value -is [array] }\r\n            default { $true }\r\n        }\r\n\r\n        if (-not $isValid) {\r\n            $errors += \"Field '$fieldName' must be of type $expectedType\"\r\n            return $errors  # No point checking further if type is wrong\r\n        }\r\n    }\r\n\r\n    # Integer validation\r\n    if ($value -is [int]) {\r\n        if ($schema.ContainsKey('Min') -and $value -lt $schema.Min) {\r\n            $errors += \"Field '$fieldName' must be at least $($schema.Min)\"\r\n        }\r\n        if ($schema.ContainsKey('Max') -and $value -gt $schema.Max) {\r\n            $errors += \"Field '$fieldName' must be at most $($schema.Max)\"\r\n        }\r\n    }\r\n\r\n    # String validation\r\n    if ($value -is [string]) {\r\n        if ($schema.ContainsKey('MinLength') -and $value.Length -lt $schema.MinLength) {\r\n            $errors += \"Field '$fieldName' must be at least $($schema.MinLength) characters\"\r\n        }\r\n        if ($schema.ContainsKey('MaxLength') -and $value.Length -gt $schema.MaxLength) {\r\n            $errors += \"Field '$fieldName' must be at most $($schema.MaxLength) characters\"\r\n        }\r\n        if ($schema.ContainsKey('Pattern') -and $value -notmatch $schema.Pattern) {\r\n            $errors += \"Field '$fieldName' does not match required pattern\"\r\n        }\r\n    }\r\n\r\n    # Custom validator\r\n    if ($schema.ContainsKey('Validator') -and $null -ne $schema.Validator) {\r\n        try {\r\n            $isValid = & $schema.Validator $value\r\n            if (-not $isValid) {\r\n                $errors += \"Field '$fieldName' failed custom validation\"\r\n            }\r\n        }\r\n        catch {\r\n            $errors += \"Field '$fieldName' validator error: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    return $errors\r\n}\r\n\r\nExport-ModuleMember -Function Test-TaskValid, Test-ProjectValid, Test-TimeLogValid, Get-ValidationErrors, Test-FieldValid"}, {"path": "module/Pmc.Strict/consoleui/layout/PmcLayoutManager.ps1", "content": "# PmcLayoutManager - Named regions and constraint-based layout system\r\n# Eliminates magic numbers and provides standard layouts for PMC screens\r\n\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nLayout manager providing named regions and constraint-based positioning\r\n\r\n.DESCRIPTION\r\nPmcLayoutManager provides:\r\n- Named regions (MenuBar, Header, Content, Footer, StatusBar)\r\n- Percentage-based positioning and sizing\r\n- Fill constraints (FILL, BOTTOM, CENTER)\r\n- Standard margin/padding constants\r\n- Automatic recalculation on terminal resize\r\n\r\n.EXAMPLE\r\n$layout = [PmcLayoutManager]::new()\r\n$headerRect = $layout.GetRegion('Header', 120, 40)\r\n$menuBar.SetPosition($headerRect.X, $headerRect.Y)\r\n$menuBar.SetSize($headerRect.Width, $headerRect.Height)\r\n##CLOSEBRACKET##\r\n\r\n<#\r\n.SYNOPSIS\r\nRectangle structure for layout calculations\r\n##CLOSEBRACKET##\r\nclass PmcRect {\r\n    [int]$X = 0\r\n    [int]$Y = 0\r\n    [int]$Width = 0\r\n    [int]$Height = 0\r\n\r\n    PmcRect([int]$x, [int]$y, [int]$width, [int]$height) {\r\n        $this.X = $x\r\n        $this.Y = $y\r\n        $this.Width = $width\r\n        $this.Height = $height\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nLayout manager for screen regions\r\n##CLOSEBRACKET##\r\nclass PmcLayoutManager {\r\n    # === Standard Regions ===\r\n    [hashtable]$Regions = @{\r\n        # Menu bar at very top\r\n        'MenuBar' = @{\r\n            X = 0\r\n            Y = 0\r\n            Width = '100%'\r\n            Height = 1\r\n        }\r\n\r\n        # Header below menu bar\r\n        'Header' = @{\r\n            X = '2%'\r\n            Y = 3\r\n            Width = '96%'\r\n            Height = 3\r\n        }\r\n\r\n        # Main content area (fills available space)\r\n        'Content' = @{\r\n            X = '2%'\r\n            Y = 8\r\n            Width = '96%'\r\n            Height = 'FILL'  # Calculated: termHeight - Y - FooterHeight - StatusBarHeight\r\n        }\r\n\r\n        # Footer above status bar\r\n        'Footer' = @{\r\n            X = '2%'\r\n            Y = 'BOTTOM-2'  # 2 lines from bottom\r\n            Width = '96%'\r\n            Height = 1\r\n        }\r\n\r\n        # Status bar at very bottom\r\n        'StatusBar' = @{\r\n            X = 0\r\n            Y = 'BOTTOM'\r\n            Width = '100%'\r\n            Height = 1\r\n        }\r\n\r\n        # Sidebar (optional, for split layouts)\r\n        'Sidebar' = @{\r\n            X = '2%'\r\n            Y = 8\r\n            Width = '30%'\r\n            Height = 'FILL'\r\n        }\r\n\r\n        # Main area when sidebar present\r\n        'MainWithSidebar' = @{\r\n            X = '33%'\r\n            Y = 8\r\n            Width = '65%'\r\n            Height = 'FILL'\r\n        }\r\n    }\r\n\r\n    # === Standard Constants ===\r\n    static [int]$MarginSmall = 1      # Small screen edge margin\r\n    static [int]$MarginMedium = 2     # Standard screen edge margin\r\n    static [int]$MarginLarge = 4      # Large screen edge margin\r\n\r\n    static [int]$PaddingSmall = 1     # Inside widget padding\r\n    static [int]$PaddingMedium = 2\r\n    static [int]$PaddingLarge = 3\r\n\r\n    static [int]$HeaderHeight = 3\r\n    static [int]$FooterHeight = 1\r\n    static [int]$StatusBarHeight = 1\r\n    static [int]$MenuBarHeight = 1\r\n\r\n    static [int]$MinTermWidth = 80\r\n    static [int]$MinTermHeight = 24\r\n\r\n    # === Constructor ===\r\n    PmcLayoutManager() {\r\n        # Initialize with default regions (can be customized per instance)\r\n    }\r\n\r\n    # === Public API ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get calculated rectangle for a named region\r\n\r\n    .PARAMETER name\r\n    Region name (MenuBar, Header, Content, Footer, StatusBar, Sidebar, MainWithSidebar)\r\n\r\n    .PARAMETER termWidth\r\n    Terminal width in characters\r\n\r\n    .PARAMETER termHeight\r\n    Terminal height in characters\r\n\r\n    .OUTPUTS\r\n    PmcRect with calculated X, Y, Width, Height\r\n\r\n    .EXAMPLE\r\n    $rect = $layout.GetRegion('Header', 120, 40)\r\n    # Returns PmcRect with X=2, Y=3, Width=115, Height=3\r\n    ##CLOSEBRACKET##\r\n    [PmcRect] GetRegion([string]$name, [int]$termWidth, [int]$termHeight) {\r\n        if (-not $this.Regions.ContainsKey($name)) {\r\n            throw \"Unknown region: $name. Available regions: $($this.Regions.Keys -join ', ')\"\r\n        }\r\n\r\n        $def = $this.Regions[$name]\r\n        return $this._CalculateRect($def, $termWidth, $termHeight)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Calculate rectangle from constraint definition\r\n    ##CLOSEBRACKET##\r\n    hidden [PmcRect] _CalculateRect([hashtable]$def, [int]$termWidth, [int]$termHeight) {\r\n        $x = $this._ResolveX($def.X, $termWidth, $termHeight)\r\n        $y = $this._ResolveY($def.Y, $termWidth, $termHeight)\r\n        $width = $this._ResolveWidth($def.Width, $x, $termWidth, $termHeight)\r\n        $height = $this._ResolveHeight($def.Height, $y, $termWidth, $termHeight)\r\n\r\n        return [PmcRect]::new($x, $y, $width, $height)\r\n    }\r\n\r\n    # === Constraint Resolution ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Resolve X constraint to absolute position\r\n    ##CLOSEBRACKET##\r\n    hidden [int] _ResolveX([object]$constraint, [int]$termWidth, [int]$termHeight) {\r\n        if ($constraint -is [int]) {\r\n            return $constraint\r\n        }\r\n\r\n        $strConstraint = [string]$constraint\r\n\r\n        # Percentage\r\n        if ($strConstraint -match '^(\\d+)%$') {\r\n            $pct = [int]$Matches[1]\r\n            return [Math]::Floor($termWidth * $pct / 100.0)\r\n        }\r\n\r\n        # CENTER (requires width to be known, not commonly used for X)\r\n        if ($strConstraint -eq 'CENTER') {\r\n            # Can't center without knowing width - return 0\r\n            return 0\r\n        }\r\n\r\n        # Default\r\n        return 0\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Resolve Y constraint to absolute position\r\n    ##CLOSEBRACKET##\r\n    hidden [int] _ResolveY([object]$constraint, [int]$termWidth, [int]$termHeight) {\r\n        if ($constraint -is [int]) {\r\n            return $constraint\r\n        }\r\n\r\n        $strConstraint = [string]$constraint\r\n\r\n        # Percentage\r\n        if ($strConstraint -match '^(\\d+)%$') {\r\n            $pct = [int]$Matches[1]\r\n            return [Math]::Floor($termHeight * $pct / 100.0)\r\n        }\r\n\r\n        # BOTTOM (last line)\r\n        if ($strConstraint -eq 'BOTTOM') {\r\n            return [Math]::Max(0, $termHeight - 1)\r\n        }\r\n\r\n        # BOTTOM-N (N lines from bottom)\r\n        if ($strConstraint -match '^BOTTOM-(\\d+)$') {\r\n            $offset = [int]$Matches[1]\r\n            return [Math]::Max(0, $termHeight - $offset)\r\n        }\r\n\r\n        # Default\r\n        return 0\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Resolve Width constraint to absolute width\r\n    ##CLOSEBRACKET##\r\n    hidden [int] _ResolveWidth([object]$constraint, [int]$x, [int]$termWidth, [int]$termHeight) {\r\n        if ($constraint -is [int]) {\r\n            return $constraint\r\n        }\r\n\r\n        $strConstraint = [string]$constraint\r\n\r\n        # Percentage\r\n        if ($strConstraint -match '^(\\d+)%$') {\r\n            $pct = [int]$Matches[1]\r\n            return [Math]::Floor($termWidth * $pct / 100.0)\r\n        }\r\n\r\n        # FILL (fill remaining width from X)\r\n        if ($strConstraint -eq 'FILL') {\r\n            return [Math]::Max(1, $termWidth - $x)\r\n        }\r\n\r\n        # Default\r\n        return 1\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Resolve Height constraint to absolute height\r\n    ##CLOSEBRACKET##\r\n    hidden [int] _ResolveHeight([object]$constraint, [int]$y, [int]$termWidth, [int]$termHeight) {\r\n        if ($constraint -is [int]) {\r\n            return $constraint\r\n        }\r\n\r\n        $strConstraint = [string]$constraint\r\n\r\n        # Percentage\r\n        if ($strConstraint -match '^(\\d+)%$') {\r\n            $pct = [int]$Matches[1]\r\n            return [Math]::Floor($termHeight * $pct / 100.0)\r\n        }\r\n\r\n        # FILL (fill remaining height from Y, accounting for footer/statusbar)\r\n        if ($strConstraint -eq 'FILL') {\r\n            # Reserve space for footer (1 line) + statusbar (1 line) + 1 line margin\r\n            $reserved = [PmcLayoutManager]::FooterHeight + [PmcLayoutManager]::StatusBarHeight + 1\r\n            return [Math]::Max(1, $termHeight - $y - $reserved)\r\n        }\r\n\r\n        # Default\r\n        return 1\r\n    }\r\n\r\n    # === Custom Regions ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Define a custom named region\r\n\r\n    .PARAMETER name\r\n    Region name\r\n\r\n    .PARAMETER x\r\n    X constraint (int or string like \"10%\", \"CENTER\")\r\n\r\n    .PARAMETER y\r\n    Y constraint (int or string like \"20%\", \"BOTTOM\", \"BOTTOM-5\")\r\n\r\n    .PARAMETER width\r\n    Width constraint (int or string like \"50%\", \"FILL\")\r\n\r\n    .PARAMETER height\r\n    Height constraint (int or string like \"30%\", \"FILL\")\r\n\r\n    .EXAMPLE\r\n    $layout.DefineRegion('CustomPanel', '10%', 10, '80%', 15)\r\n    $rect = $layout.GetRegion('CustomPanel', 120, 40)\r\n    ##CLOSEBRACKET##\r\n    [void] DefineRegion([string]$name, [object]$x, [object]$y, [object]$width, [object]$height) {\r\n        $this.Regions[$name] = @{\r\n            X = $x\r\n            Y = $y\r\n            Width = $width\r\n            Height = $height\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Remove a custom region\r\n\r\n    .PARAMETER name\r\n    Region name to remove\r\n    ##CLOSEBRACKET##\r\n    [void] RemoveRegion([string]$name) {\r\n        if ($this.Regions.ContainsKey($name)) {\r\n            $this.Regions.Remove($name)\r\n        }\r\n    }\r\n\r\n    # === Utility Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get all defined region names\r\n\r\n    .OUTPUTS\r\n    Array of region names\r\n    ##CLOSEBRACKET##\r\n    [string[]] GetRegionNames() {\r\n        return $this.Regions.Keys\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Check if terminal size is within acceptable range\r\n\r\n    .PARAMETER termWidth\r\n    Terminal width\r\n\r\n    .PARAMETER termHeight\r\n    Terminal height\r\n\r\n    .OUTPUTS\r\n    Boolean indicating if size is acceptable\r\n    ##CLOSEBRACKET##\r\n    [bool] IsTerminalSizeAcceptable([int]$termWidth, [int]$termHeight) {\r\n        return ($termWidth -ge [PmcLayoutManager]::MinTermWidth -and\r\n                $termHeight -ge [PmcLayoutManager]::MinTermHeight)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get standard layout (all standard regions)\r\n\r\n    .PARAMETER termWidth\r\n    Terminal width\r\n\r\n    .PARAMETER termHeight\r\n    Terminal height\r\n\r\n    .OUTPUTS\r\n    Hashtable with region name → PmcRect mappings\r\n\r\n    .EXAMPLE\r\n    $layout = $layoutManager.GetStandardLayout(120, 40)\r\n    $menuBarRect = $layout['MenuBar']\r\n    $headerRect = $layout['Header']\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetStandardLayout([int]$termWidth, [int]$termHeight) {\r\n        $result = @{}\r\n\r\n        foreach ($regionName in $this.Regions.Keys) {\r\n            $result[$regionName] = $this.GetRegion($regionName, $termWidth, $termHeight)\r\n        }\r\n\r\n        return $result\r\n    }\r\n\r\n    # === Layout Presets ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Create a layout manager with standard screen layout\r\n\r\n    .OUTPUTS\r\n    PmcLayoutManager with standard regions\r\n    ##CLOSEBRACKET##\r\n    static [PmcLayoutManager] CreateStandardLayout() {\r\n        return [PmcLayoutManager]::new()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Create a layout manager with full-screen layout (no margins)\r\n\r\n    .OUTPUTS\r\n    PmcLayoutManager with full-screen regions\r\n    ##CLOSEBRACKET##\r\n    static [PmcLayoutManager] CreateFullScreenLayout() {\r\n        $layout = [PmcLayoutManager]::new()\r\n\r\n        $layout.Regions['Header'] = @{\r\n            X = 0\r\n            Y = 2\r\n            Width = '100%'\r\n            Height = 3\r\n        }\r\n\r\n        $layout.Regions['Content'] = @{\r\n            X = 0\r\n            Y = 6\r\n            Width = '100%'\r\n            Height = 'FILL'\r\n        }\r\n\r\n        $layout.Regions['Footer'] = @{\r\n            X = 0\r\n            Y = 'BOTTOM-2'\r\n            Width = '100%'\r\n            Height = 1\r\n        }\r\n\r\n        return $layout\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Create a layout manager with sidebar layout\r\n\r\n    .OUTPUTS\r\n    PmcLayoutManager with sidebar and main content regions\r\n    ##CLOSEBRACKET##\r\n    static [PmcLayoutManager] CreateSidebarLayout() {\r\n        $layout = [PmcLayoutManager]::new()\r\n\r\n        # Override Content region to work with Sidebar\r\n        $layout.Regions['Content'] = $layout.Regions['MainWithSidebar']\r\n\r\n        return $layout\r\n    }\r\n}\r\n\r\n# === Helper Functions ===\r\n\r\n<#\r\n.SYNOPSIS\r\nApply layout constraints to a widget\r\n\r\n.PARAMETER widget\r\nWidget to apply constraints to\r\n\r\n.PARAMETER regionName\r\nName of region to use\r\n\r\n.PARAMETER layoutManager\r\nLayout manager instance\r\n\r\n.PARAMETER termWidth\r\nTerminal width\r\n\r\n.PARAMETER termHeight\r\nTerminal height\r\n\r\n.EXAMPLE\r\nApply-PmcLayout -Widget $header -RegionName 'Header' -LayoutManager $layout -TermWidth 120 -TermHeight 40\r\n##CLOSEBRACKET##\r\nfunction Apply-PmcLayout {\r\n    param(\r\n        [Parameter(Mandatory = $true)]\r\n        [object]$Widget,\r\n\r\n        [Parameter(Mandatory = $true)]\r\n        [string]$RegionName,\r\n\r\n        [Parameter(Mandatory = $true)]\r\n        [PmcLayoutManager]$LayoutManager,\r\n\r\n        [Parameter(Mandatory = $true)]\r\n        [int]$TermWidth,\r\n\r\n        [Parameter(Mandatory = $true)]\r\n        [int]$TermHeight\r\n    )\r\n\r\n    $rect = $LayoutManager.GetRegion($RegionName, $TermWidth, $TermHeight)\r\n\r\n    if ($Widget.PSObject.Methods['SetPosition']) {\r\n        $Widget.SetPosition($rect.X, $rect.Y)\r\n    }\r\n\r\n    if ($Widget.PSObject.Methods['SetSize']) {\r\n        $Widget.SetSize($rect.Width, $rect.Height)\r\n    }\r\n}\r\n\r\n# Classes and functions exported automatically in PowerShell 5.1+"}, {"path": "module/Pmc.Strict/consoleui/screens/ChecklistsLauncherScreen.ps1", "content": "using namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# ChecklistsLauncherScreen - Select project to view checklists\r\n# Simple project picker that then opens ChecklistsMenuScreen for selected project\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n. \"$PSScriptRoot/../base/StandardListScreen.ps1\"\r\n\r\n<#\r\n.SYNOPSIS\r\nChecklist launcher - select project to view its checklists\r\n\r\n.DESCRIPTION\r\nShows list of all projects. Selecting a project opens ChecklistsMenuScreen for that project.\r\n##CLOSEBRACKET##\r\nclass ChecklistsLauncherScreen : StandardListScreen {\r\n    hidden [TaskStore]$_store = $null\r\n\r\n    # Static: Register menu items\r\n    static [void] RegisterMenuItems([object]$registry) {\r\n        $registry.AddMenuItem('Tools', 'Checklists', 'C', {\r\n            . \"$PSScriptRoot/ChecklistsLauncherScreen.ps1\"\r\n            $global:PmcApp.PushScreen((New-Object -TypeName ChecklistsLauncherScreen))\r\n        }, 25)\r\n    }\r\n\r\n    # Legacy constructor\r\n    ChecklistsLauncherScreen() : base(\"ChecklistsLauncher\", \"Select Project for Checklists\") {\r\n        $this._InitializeScreen()\r\n    }\r\n\r\n    # Container constructor\r\n    ChecklistsLauncherScreen([object]$container) : base(\"ChecklistsLauncher\", \"Select Project for Checklists\", $container) {\r\n        $this._InitializeScreen()\r\n    }\r\n\r\n    hidden [void] _InitializeScreen() {\r\n        $this._store = [TaskStore]::GetInstance()\r\n\r\n        # Configure capabilities\r\n        $this.AllowAdd = $false\r\n        $this.AllowEdit = $false\r\n        $this.AllowDelete = $false\r\n        $this.AllowFilter = $false\r\n\r\n        # Configure header\r\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Tools\", \"Checklists\"))\r\n    }\r\n\r\n    # === Abstract Method Implementations ===\r\n\r\n    [string] GetEntityType() {\r\n        return 'project'\r\n    }\r\n\r\n    [array] GetColumns() {\r\n        return @(\r\n            @{ Name='name'; Label='Project Name'; Width=60; Sortable=$true }\r\n        )\r\n    }\r\n\r\n    [void] LoadData() {\r\n        $projects = @($this._store.GetAllProjects())\r\n\r\n        # Convert to array of hashtables with name\r\n        $items = @()\r\n        foreach ($project in $projects) {\r\n            if ($project -is [string]) {\r\n                $items += @{ name = $project }\r\n            } elseif ($project -is [hashtable]) {\r\n                $items += @{ name = $project['name'] }\r\n            } else {\r\n                $items += @{ name = $project.name }\r\n            }\r\n        }\r\n\r\n        $this.List.SetData($items)\r\n    }\r\n\r\n    [array] GetEditFields([object]$item) {\r\n        # Not used\r\n        return @()\r\n    }\r\n\r\n    [void] OnItemActivated($item) {\r\n        # Get project name\r\n        $projectName = $(if ($item -is [hashtable]) { $item['name'] } else { $item.name })\r\n\r\n        if ([string]::IsNullOrWhiteSpace($projectName)) {\r\n            $this.SetStatusMessage(\"Invalid project\", \"error\")\r\n            return\r\n        }\r\n\r\n        # Open ChecklistsMenuScreen for this project\r\n        . \"$PSScriptRoot/ChecklistsMenuScreen.ps1\"\r\n        $checklistsScreen = New-Object ChecklistsMenuScreen -ArgumentList \"project\", $projectName, $projectName\r\n        $global:PmcApp.PushScreen($checklistsScreen)\r\n    }\r\n\r\n    [array] GetCustomActions() {\r\n        $self = $this\r\n        return @(\r\n            @{\r\n                Key = 'O'\r\n                Label = 'Open'\r\n                Callback = {\r\n                    $selected = $self.List.GetSelectedItem()\r\n                    if ($selected) {\r\n                        $self.OnItemActivated($selected)\r\n                    }\r\n                }.GetNewClosure()\r\n            }\r\n        )\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/screens/ChecklistTemplatesFolderScreen.ps1", "content": "using namespace System.Collections.Generic\nusing namespace System.Text\n\n# ChecklistTemplatesFolderScreen - Manage folder-based checklist templates\n# Templates are simple .txt files in checklist_templates/ folder\n\nSet-StrictMode -Version Latest\n\n. \"$PSScriptRoot/../base/StandardListScreen.ps1\"\n. \"$PSScriptRoot/../services/ChecklistService.ps1\"\n. \"$PSScriptRoot/../widgets/ProjectPicker.ps1\"\n\nclass ChecklistTemplatesFolderScreen : StandardListScreen {\n    hidden [ChecklistService]$_checklistService = $null\n    hidden [string]$_templatesFolder = \"\"\n    \n    # Project Picker for Import\n    hidden [ProjectPicker]$_projectPicker = $null\n    hidden [bool]$_showProjectPicker = $false\n\n    # Static: Register menu items\n    static [void] RegisterMenuItems([object]$registry) {\n        $registry.AddMenuItem('Tools', 'Checklist Templates', 'H', {\n            . \"$PSScriptRoot/ChecklistTemplatesFolderScreen.ps1\"\n            $global:PmcApp.PushScreen((New-Object -TypeName ChecklistTemplatesFolderScreen))\n        }, 30)\n    }\n\n    # Constructors\n    ChecklistTemplatesFolderScreen() : base(\"ChecklistTemplates\", \"Checklist Templates\") {\n        $this._InitializeScreen()\n    }\n\n    ChecklistTemplatesFolderScreen([object]$container) : base(\"ChecklistTemplates\", \"Checklist Templates\", $container) {\n        $this._InitializeScreen()\n    }\n\n    hidden [void] _InitializeScreen() {\n        $this._checklistService = [ChecklistService]::GetInstance()\n        \n        # Determine templates folder (at PMC root)\n        $pmcRoot = Split-Path -Parent (Split-Path -Parent (Split-Path -Parent $PSScriptRoot))\n        $this._templatesFolder = Join-Path $pmcRoot \"checklist_templates\"\n\n        if (-not (Test-Path $this._templatesFolder)) {\n            New-Item -ItemType Directory -Path $this._templatesFolder -Force | Out-Null\n        }\n\n        $this.AllowAdd = $true\n        $this.AllowEdit = $true\n        $this.AllowDelete = $true\n        $this.AllowFilter = $false\n\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Tools\", \"Checklist Templates\"))\n    }\n\n    # === Abstract Method Implementations ===\n\n    [string] GetEntityType() { return 'checklist_template_file' }\n\n    [array] GetColumns() {\n        return @(\n            @{ Name='name'; Label='Template Name'; Width=40; Sortable=$true }\n            @{ Name='item_count'; Label='Items'; Width=8; Sortable=$true; Align='right' }\n            @{ Name='modified'; Label='Modified'; Width=20; Sortable=$true }\n        )\n    }\n\n    [void] LoadData() {\n        $items = $this.LoadItems()\n        $this.List.SetData($items)\n    }\n\n    [array] LoadItems() {\n        $templates = @()\n        $files = Get-ChildItem -Path $this._templatesFolder -Filter \"*.txt\" -File -ErrorAction SilentlyContinue\n\n        foreach ($file in $files) {\n            $lineCount = 0\n            try {\n                $content = Get-Content -Path $file.FullName -ErrorAction Stop\n                $lineCount = @($content | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }).Count\n            } catch { $lineCount = 0 }\n\n            $templates += @{\n                name = $file.BaseName\n                file_path = $file.FullName\n                item_count = $lineCount\n                modified = $file.LastWriteTime.ToString(\"yyyy-MM-dd HH:mm\")\n            }\n        }\n        return $templates\n    }\n\n    [array] GetEditFields([object]$item) {\n        if ($null -eq $item -or $item.Count -eq 0) {\n            return @(@{ Name='name'; Type='text'; Label='Template Name'; Required=$true; Value='' })\n        } else {\n            return @(@{ Name='name'; Type='text'; Label='Template Name'; Required=$true; Value=$item.name })\n        }\n    }\n\n    [void] OnItemCreated([hashtable]$values) {\n        try {\n            if (-not $values.ContainsKey('name') -or [string]::IsNullOrWhiteSpace($values.name)) {\n                $this.SetStatusMessage(\"Template name is required\", \"error\")\n                return\n            }\n\n            $name = $values.name\n            $fileName = \"$name.txt\"\n            $filePath = Join-Path $this._templatesFolder $fileName\n\n            if (Test-Path $filePath) {\n                $this.SetStatusMessage(\"Template '$name' already exists\", \"error\")\n                return\n            }\n\n            $content = \"# Checklist template: $name`n# Each line will become a checklist item`n# Delete these comment lines and add your items below`n`n\"\n            Set-Content -Path $filePath -Value $content -Encoding utf8\n\n            $this.SetStatusMessage(\"Template '$name' created. Press Enter to edit.\", \"success\")\n            $this.LoadData()\n        } catch {\n            $this.SetStatusMessage(\"Error creating template: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    [void] OnItemUpdated([object]$item, [hashtable]$values) {\n        try {\n            $oldName = $(if ($item -is [hashtable]) { $item['name'] } else { $item.name })\n            $oldPath = $(if ($item -is [hashtable]) { $item['file_path'] } else { $item.file_path })\n\n            if (-not $values.ContainsKey('name') -or [string]::IsNullOrWhiteSpace($values.name)) {\n                $this.SetStatusMessage(\"Template name is required\", \"error\")\n                return\n            }\n\n            $newName = $values.name\n            $newPath = Join-Path $this._templatesFolder \"$newName.txt\"\n\n            if ($oldPath -eq $newPath) { return }\n\n            if (Test-Path $newPath) {\n                $this.SetStatusMessage(\"Template '$newName' already exists\", \"error\")\n                return\n            }\n\n            Move-Item -Path $oldPath -Destination $newPath -Force\n            $this.SetStatusMessage(\"Template renamed to '$newName'\", \"success\")\n            $this.LoadData()\n        } catch {\n            $this.SetStatusMessage(\"Error renaming template: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    [void] OnItemDeleted([object]$item) {\n        try {\n            $name = $(if ($item -is [hashtable]) { $item['name'] } else { $item.name })\n            $filePath = $(if ($item -is [hashtable]) { $item['file_path'] } else { $item.file_path })\n\n            if (Test-Path $filePath) {\n                Remove-Item -Path $filePath -Force\n                $this.SetStatusMessage(\"Template '$name' deleted\", \"success\")\n                $this.LoadData()\n            } else {\n                $this.SetStatusMessage(\"Template file not found\", \"error\")\n            }\n        } catch {\n            $this.SetStatusMessage(\"Error deleting template: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    [void] OnItemActivated($item) {\n        $filePath = $(if ($item -is [hashtable]) { $item['file_path'] } else { $item.file_path })\n\n        try {\n            if (Test-Path $filePath) {\n                if ($IsWindows -or $env:OS -match \"Windows\") {\n                    Start-Process notepad.exe -ArgumentList $filePath\n                } else {\n                     $this.SetStatusMessage(\"Edit: $filePath (use external editor)\", \"info\")\n                }\n            } else {\n                $this.SetStatusMessage(\"Template file not found\", \"error\")\n            }\n        } catch {\n            $this.SetStatusMessage(\"Error opening template: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    [array] GetCustomActions() {\n        $self = $this\n        return @(\n            @{\n                Key = 'I'\n                Label = 'Import to Project'\n                Callback = {\n                    $selected = $self.List.GetSelectedItem()\n                    if ($selected) {\n                        $self._ImportToProject($selected)\n                    }\n                }.GetNewClosure()\n            }\n            @{\n                Key = 'O'\n                Label = 'Open/Edit'\n                Callback = {\n                    $selected = $self.List.GetSelectedItem()\n                    if ($selected) {\n                        $self.OnItemActivated($selected)\n                    }\n                }.GetNewClosure()\n            }\n        )\n    }\n\n    # === Import Feature ===\n\n    hidden [void] _ImportToProject($template) {\n        $this._projectPicker = [ProjectPicker]::new()\n        $this._projectPicker.SetSize(60, 20)\n        \n        # Center Logic\n        $pW = 60\n        $pH = 20\n        $this._projectPicker.SetPosition(\n            [Math]::Max(0, [Math]::Floor(($this.TermWidth - $pW) / 2)),\n            [Math]::Max(0, [Math]::Floor(($this.TermHeight - $pH) / 2))\n        )\n\n        $self = $this\n        $this._projectPicker.OnProjectSelected = {\n            param($projectName)\n            if ($projectName) {\n                $self._DoImport($template, $projectName)\n            }\n            $self._showProjectPicker = $false\n            $self._projectPicker = $null\n            $self.NeedsClear = $true\n        }.GetNewClosure()\n\n        $this._projectPicker.OnCancelled = {\n            $self._showProjectPicker = $false\n            $self._projectPicker = $null\n            $self.NeedsClear = $true\n        }.GetNewClosure()\n        \n        $this._showProjectPicker = $true\n        $this.NeedsClear = $true\n    }\n    \n    hidden [void] _DoImport($template, $projectName) {\n        $filePath = if ($template -is [hashtable]) { $template.file_path } else { $template.file_path }\n        if (-not (Test-Path $filePath)) { \n             $this.SetStatusMessage(\"Template file missing\", \"error\")\n             return \n        }\n        \n        try {\n            $lines = Get-Content $filePath | Where-Object { \n                -not [string]::IsNullOrWhiteSpace($_) -and -not $_.Trim().StartsWith(\"#\") \n            }\n            \n            if ($lines.Count -eq 0) {\n                 $this.SetStatusMessage(\"Template is empty\", \"error\")\n                 return\n            }\n            \n            $title = if ($template -is [hashtable]) { $template.name } else { $template.name }\n            \n            # Create instance\n            $this._checklistService.CreateBlankInstance($title, \"project\", $projectName, $lines)\n            $this.SetStatusMessage(\"Imported '$title' to project '$projectName'\", \"success\")\n        }\n        catch {\n            $this.SetStatusMessage(\"Import failed: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    # === Render Overrides ===\n\n    [void] RenderContentToEngine([object]$engine) {\n        # Render base list\n        ([StandardListScreen]$this).RenderContentToEngine($engine)\n        \n        # Render Picker Overlay\n        if ($this._showProjectPicker -and $this._projectPicker) {\n             # Re-center if terminal resized\n            $pW = 60\n            $pH = 20\n            $this._projectPicker.SetPosition(\n                [Math]::Max(0, [Math]::Floor(($this.TermWidth - $pW) / 2)),\n                [Math]::Max(0, [Math]::Floor(($this.TermHeight - $pH) / 2))\n            )\n            \n            $this._projectPicker.RenderToEngine($engine)\n        }\n    }\n\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\n        if ($this._showProjectPicker -and $this._projectPicker) {\n            return $this._projectPicker.HandleInput($keyInfo)\n        }\n        \n        return ([StandardListScreen]$this).HandleKeyPress($keyInfo)\n    }\n}"}, {"path": "module/Pmc.Strict/consoleui/screens/CommandLibraryScreen.ps1", "content": "using namespace System.Collections.Generic\nusing namespace System.Text\n\n# CommandLibraryScreen - Command library management using StandardListScreen\n# Allows users to save, manage, and copy frequently used commands\n\nSet-StrictMode -Version Latest\n\n. \"$PSScriptRoot/../base/StandardListScreen.ps1\"\n. \"$PSScriptRoot/../services/CommandService.ps1\"\n\n<#\n.SYNOPSIS\nCommand library management screen\n\n.DESCRIPTION\nManage a library of saved commands:\n- Add/Edit/Delete commands\n- Copy commands to clipboard\n- Track usage statistics\n##CLOSEBRACKET##\nclass CommandLibraryScreen : StandardListScreen {\n    hidden [object]$_commandService = $null\n\n    # Container constructor\n    CommandLibraryScreen([object]$container) : base(\"CommandLibrary\", \"Command Library\", $container) {\n        $this._InitializeScreen()\n    }\n\n    hidden [void] _InitializeScreen() {\n        # Initialize service\n        $this._commandService = [CommandService]::GetInstance()\n\n        # Configure capabilities\n        $this.AllowAdd = $true\n        $this.AllowEdit = $true\n        $this.AllowDelete = $true\n        $this.AllowFilter = $true\n\n        # Configure header\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Tools\", \"Command Library\"))\n\n        # Configure footer shortcuts\n        $this.Footer.ClearShortcuts()\n        $this.Footer.AddShortcut(\"A\", \"Add\")\n        $this.Footer.AddShortcut(\"E\", \"Edit\")\n        $this.Footer.AddShortcut(\"D\", \"Delete\")\n        $this.Footer.AddShortcut(\"Enter/C\", \"Copy\")\n        $this.Footer.AddShortcut(\"Esc\", \"Back\")\n\n        # Setup event handlers\n        $self = $this\n        $this._commandService.OnCommandsChanged = {\n            if ($null -ne $self -and $self.IsActive) {\n                $self.LoadData()\n            }\n        }.GetNewClosure()\n    }\n\n    # Required by StandardListScreen - loads and displays data\n    [void] LoadData() {\n        $items = $this.LoadItems()\n        $columns = $this.GetColumns()\n        $this.List.SetColumns($columns)\n        $this.List.SetData($items)\n    }\n\n    # === Abstract Method Implementations ===\n\n    # Get entity type for store operations\n    [string] GetEntityType() {\n        return 'command'\n    }\n\n    # Define columns for list display\n    [array] GetColumns() {\n        # Calculate column widths dynamically based on List widget width\n        # Account for 2 separators (2 spaces each = 4 chars) between 3 columns + borders\n        $availableWidth = $(if ($this.List -and $this.List.Width -gt 4) { $this.List.Width - 4 - 4 } else { 110 })\n        \n        # Proportions: Name=30%, Category=20%, Command=50%\n        $nameWidth = [Math]::Max(15, [Math]::Floor($availableWidth * 0.30))\n        $categoryWidth = [Math]::Max(10, [Math]::Floor($availableWidth * 0.20))\n        $commandWidth = [Math]::Max(20, [Math]::Floor($availableWidth * 0.50))\n        \n        return @(\n            @{ Name = 'name'; Label = 'Name'; Width = $nameWidth; Align = 'left' }\n            @{ Name = 'category'; Label = 'Category'; Width = $categoryWidth; Align = 'left' }\n            @{ Name = 'command_text'; Label = 'Command'; Width = $commandWidth; Align = 'left' }\n        )\n    }\n\n    # Load items from data store\n    [array] LoadItems() {\n        $commands = @($this._commandService.GetAllCommands())\n\n        # Format for display\n        foreach ($cmd in $commands) {\n            # Format tags for display\n            if ($cmd.ContainsKey('tags') -and $cmd.tags -is [array]) {\n                $cmd['tags_display'] = $cmd.tags -join ', '\n            } else {\n                $cmd['tags_display'] = ''\n            }\n        }\n\n        return $commands\n    }\n\n    # Define filter fields for StandardListScreen\n    [array] GetFilterFields() {\n        return @(\n            @{ Name='category'; Label='Category'; Type='text' }\n            @{ Name='tags'; Label='Tags (comma-separated)'; Type='text' }\n        )\n    }\n\n    # Apply filters to items\n    [array] ApplyFilters([array]$items, [hashtable]$filters) {\n        if ($null -eq $filters -or $filters.Count -eq 0) {\n            return $items\n        }\n\n        $filtered = $items\n\n        # Filter by category\n        if ($filters.ContainsKey('category') -and -not [string]::IsNullOrWhiteSpace($filters.category)) {\n            $categoryFilter = $filters.category.Trim()\n            $filtered = @($filtered | Where-Object {\n                $itemCategory = $(if ($_ -is [hashtable]) { $_['category'] } else { $_.category })\n                $itemCategory -like \"*$categoryFilter*\"\n            })\n        }\n\n        # Filter by tags\n        if ($filters.ContainsKey('tags') -and -not [string]::IsNullOrWhiteSpace($filters.tags)) {\n            $tagFilters = @($filters.tags -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ })\n            $filtered = @($filtered | Where-Object {\n                $itemTags = $(if ($_ -is [hashtable]) { $_['tags'] } else { $_.tags })\n                if ($null -eq $itemTags -or $itemTags.Count -eq 0) {\n                    return $false\n                }\n                # Check if item has any of the specified tags\n                $hasTag = $false\n                foreach ($filterTag in $tagFilters) {\n                    foreach ($itemTag in $itemTags) {\n                        if ($itemTag -like \"*$filterTag*\") {\n                            $hasTag = $true\n                            break\n                        }\n                    }\n                    if ($hasTag) { break }\n                }\n                return $hasTag\n            })\n        }\n\n        return $filtered\n    }\n\n    # Define edit fields for InlineEditor\n    [array] GetEditFields([object]$item) {\n        # Calculate field widths - MUST MATCH GetColumns() exactly\n        $availableWidth = $(if ($this.List -and $this.List.Width -gt 4) { $this.List.Width - 4 - 4 } else { 103 })\n        $nameWidth = [Math]::Max(20, [Math]::Floor($availableWidth * 0.30))\n        $categoryWidth = [Math]::Max(12, [Math]::Floor($availableWidth * 0.20))\n        $descWidth = [Math]::Max(30, [Math]::Floor($availableWidth * 0.50))\n\n        if ($null -eq $item -or $item.Count -eq 0) {\n            # New command - empty fields (3 fields to match 3 columns)\n            return @(\n                @{ Name='name'; Type='text'; Label=''; Required=$true; Value=''; Width=$nameWidth; Placeholder='Command name' }\n                @{ Name='category'; Type='text'; Label=''; Value='General'; Width=$categoryWidth; Placeholder='Category' }\n                @{ Name='description'; Type='text'; Label=''; Value=''; Width=$descWidth; Placeholder='Enter command text (will be copied to clipboard)'; Required=$true }\n            )\n        } else {\n            # Existing command - populate from item (3 fields to match 3 columns)\n            return @(\n                @{ Name='name'; Type='text'; Label=''; Required=$true; Value=$item.name; Width=$nameWidth; Placeholder='Command name' }\n                @{ Name='category'; Type='text'; Label=''; Value=$item.category; Width=$categoryWidth; Placeholder='Category' }\n                @{ Name='description'; Type='text'; Label=''; Value=$item.command_text; Width=$descWidth; Placeholder='Enter command text (will be copied to clipboard)'; Required=$true }\n            )\n        }\n    }\n\n    # Handle item creation\n    [void] OnItemCreated([hashtable]$values) {\n        try {\n            # VALIDATION: Command name is required\n            if (-not $values.ContainsKey('name') -or [string]::IsNullOrWhiteSpace($values.name)) {\n                $this.SetStatusMessage(\"Command name is required\", \"error\")\n                return\n            }\n\n            # VALIDATION: Command text is required (stored in 'description' field for column alignment)\n            if (-not $values.ContainsKey('description') -or [string]::IsNullOrWhiteSpace($values.description)) {\n                $this.SetStatusMessage(\"Command text is required - enter the text you want to copy in the 'Command' field\", \"error\")\n                return\n            }\n\n            $tags = $(if ($values.ContainsKey('tags') -and -not [string]::IsNullOrWhiteSpace($values.tags)) {\n                @($values.tags -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ })\n            } else {\n                @()\n            })\n\n            $name = $values.name\n            # description field IS the command text (for column alignment)\n            $commandText = $values.description\n            $category = $(if ($values.ContainsKey('category')) { $values.category } else { '' })\n            $description = ''  # We don't have a separate description field\n\n            $this._commandService.CreateCommand($name, $commandText, $category, $description, $tags)\n\n            $this.SetStatusMessage(\"Command '$name' saved\", \"success\")\n        } catch {\n            $this.SetStatusMessage(\"Error creating command: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    # Handle item update\n    [void] OnItemUpdated([object]$item, [hashtable]$values) {\n        try {\n            $itemId = $(if ($item -is [hashtable]) { $item['id'] } else { $item.id })\n\n            $tags = $(if ($values.ContainsKey('tags') -and -not [string]::IsNullOrWhiteSpace($values.tags)) {\n                @($values.tags -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ })\n            } else {\n                @()\n            })\n\n            # ENDEMIC FIX: Safe value access\n            $changes = @{\n                name = $(if ($values.ContainsKey('name')) { $values.name } else { '' })\n                category = $(if ($values.ContainsKey('category')) { $values.category } else { '' })\n                command_text = $(if ($values.ContainsKey('description')) { $values.description } else { '' })\n                description = ''  # description field IS command_text\n                tags = $tags\n            }\n\n            if ([string]::IsNullOrWhiteSpace($changes.name)) {\n                $this.SetStatusMessage(\"Command name is required\", \"error\")\n                return\n            }\n\n            $this._commandService.UpdateCommand($itemId, $changes)\n            $this.SetStatusMessage(\"Command '$($changes.name)' updated\", \"success\")\n        } catch {\n            $this.SetStatusMessage(\"Error updating command: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    # Handle item deletion\n    [void] OnItemDeleted([object]$item) {\n        try {\n            $itemId = $(if ($item -is [hashtable]) { $item['id'] } else { $item.id })\n            $itemName = $(if ($item -is [hashtable]) { $item['name'] } else { $item.name })\n\n            if ($itemId) {\n                $this._commandService.DeleteCommand($itemId)\n                $this.SetStatusMessage(\"Command '$itemName' deleted\", \"success\")\n            } else {\n                $this.SetStatusMessage(\"Cannot delete command without ID\", \"error\")\n            }\n        } catch {\n            $this.SetStatusMessage(\"Error deleting command: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    # Virtual method called when inline editor is confirmed\n    [void] OnInlineEditConfirmed([hashtable]$values) {\n        if ($null -eq $values) {\n            return\n        }\n\n        # Determine if we're adding a new command or editing existing one\n        $isAddMode = ($this.EditorMode -eq 'add')\n\n        if ($isAddMode) {\n            $this.OnItemCreated($values)\n        }\n        else {\n            if ($this.CurrentEditItem) {\n                $this.OnItemUpdated($this.CurrentEditItem, $values)\n            }\n        }\n    }\n\n    # Virtual method called when inline editor is cancelled\n    [void] OnInlineEditCancelled() {\n        # No-op: StandardListScreen handles the UI updates\n    }\n\n    # === Custom Actions ===\n\n    # Copy the selected command to clipboard\n    [void] CopyCommand() {\n        $selectedItem = $this.List.GetSelectedItem()\n        if ($null -eq $selectedItem) {\n            $this.SetStatusMessage(\"No command selected - select a command and press Enter to copy\", \"error\")\n            return\n        }\n\n        $commandText = $(if ($selectedItem -is [hashtable]) { $selectedItem['command_text'] } else { $selectedItem.command_text })\n        $commandName = $(if ($selectedItem -is [hashtable]) { $selectedItem['name'] } else { $selectedItem.name })\n        $commandId = $(if ($selectedItem -is [hashtable]) { $selectedItem['id'] } else { $selectedItem.id })\n\n        if ([string]::IsNullOrEmpty($commandText)) {\n            $this.SetStatusMessage(\"Command '$commandName' has no text to copy - edit it and add command text in the 'Command' field\", \"error\")\n            return\n        }\n\n        try {\n            # Copy to clipboard (Windows only)\n            Set-Clipboard -Value $commandText\n\n            # Update usage statistics\n            if ($commandId) {\n                $this._commandService.IncrementUsageCount($commandId)\n            }\n\n            $this.SetStatusMessage(\"Copied to clipboard: $commandText\", \"success\")\n        } catch {\n            $this.SetStatusMessage(\"Failed to copy to clipboard: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    # === Input Handling ===\n\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\n        # CRITICAL FIX: Only handle custom keys when NOT in edit mode\n        # This allows typing 'c' in command name field and using Enter to save\n        if (-not $this.ShowInlineEditor -and -not $this.ShowFilterPanel) {\n            # Custom key: Enter = Copy command to clipboard (only when not editing)\n            if ($keyInfo.Key -eq ([ConsoleKey]::Enter)) {\n                $this.CopyCommand()\n                return $true\n            }\n\n            # Custom key: C = Copy command to clipboard (only when not editing)\n            if ($keyInfo.Key -eq ([ConsoleKey]::C)) {\n                $this.CopyCommand()\n                return $true\n            }\n        }\n\n        # Call parent handler for list navigation, add/edit/delete\n        # When in edit mode, parent will handle Enter to save\n        $handled = ([StandardListScreen]$this).HandleKeyPress($keyInfo)\n        if ($handled) { return $true }\n\n        return $false\n    }\n}"}, {"path": "module/Pmc.Strict/consoleui/screens/ExcelImportScreen.ps1", "content": "using namespace System.Collections.Generic\nusing namespace System.Text\n\n# ExcelImportScreen - Import project from Excel\n# Multi-step wizard: Source -> Profile -> Preview -> Import\n\nSet-StrictMode -Version Latest\n\n. \"$PSScriptRoot/../PmcScreen.ps1\"\n. \"$PSScriptRoot/../services/ExcelComReader.ps1\"\n. \"$PSScriptRoot/../services/ExcelMappingService.ps1\"\n. \"$PSScriptRoot/../widgets/PmcFilePicker.ps1\"\n\n# Constants\n$global:MAX_PREVIEW_ROWS = 15\n$script:EXCEL_ATTACH_MAX_RETRIES = 3\n$script:EXCEL_ATTACH_RETRY_DELAY_MS = 500\n$global:MAX_CELLS_TO_READ = 100\n$global:MIN_VALID_YEAR = 1950\n$global:MAX_VALID_YEAR = 2100\n\n<#\n.SYNOPSIS\nExcel import wizard screen\n\n.DESCRIPTION\nImport project data from Excel file:\n- Step 1: Choose source (running Excel or file)\n- Step 2: Select profile\n- Step 3: Preview data\n- Step 4: Confirm and import\n##CLOSEBRACKET##\nclass ExcelImportScreen : PmcScreen {\n    hidden [ExcelComReader]$_reader = $null\n    hidden [ExcelMappingService]$_mappingService = $null\n    hidden [object]$_activeProfile = $null\n    hidden [hashtable]$_previewData = @{}\n    hidden [int]$_step = 1\n    hidden [int]$_selectedOption = 0\n    hidden [string]$_errorMessage = \"\"\n    [TaskStore]$Store = $null\n\n    # File Picker State\n    hidden [PmcFilePicker]$_filePicker = $null\n    hidden [bool]$_showFilePicker = $false\n\n    # Static: Register menu items\n    static [void] RegisterMenuItems([object]$registry) {\n        $registry.AddMenuItem('Projects', 'Import from Excel', 'I', {\n                . \"$PSScriptRoot/ExcelImportScreen.ps1\"\n                $global:PmcApp.PushScreen((New-Object -TypeName ExcelImportScreen))\n            }, 40)\n    }\n\n    # Constructor\n    ExcelImportScreen() : base(\"ExcelImport\", \"Import from Excel\") {\n        $this._Initialize()\n    }\n\n    # Constructor with container\n    ExcelImportScreen([object]$container) : base(\"ExcelImport\", \"Import from Excel\", $container) {\n        $this._Initialize()\n    }\n\n    hidden [void] _Initialize() {\n        try {\n            $this._reader = [ExcelComReader]::new()\n        }\n        catch {\n            $this._errorMessage = \"Excel COM not available: $($_.Exception.Message). Excel must be installed.\"\n        }\n\n        $this._mappingService = [ExcelMappingService]::GetInstance()\n        $this.Store = [TaskStore]::GetInstance()\n\n        if ($null -eq $this.Store) {\n            throw \"Failed to initialize TaskStore singleton.\"\n        }\n\n        # Configure header\n        $this.Header.SetBreadcrumb(@(\"Projects\", \"Import from Excel\"))\n\n        # Configure footer\n        $this.Footer.ClearShortcuts()\n        $this.Footer.AddShortcut(\"Enter\", \"Next\")\n        $this.Footer.AddShortcut(\"Esc\", \"Cancel\")\n    }\n\n    [void] OnDoExit() {\n        $this.IsActive = $false\n        if ($null -ne $this._reader) {\n            $this._reader.Close()\n        }\n    }\n\n    # === Rendering ===\n\n    [void] RenderContentToEngine([object]$engine) {\n        # Calculate content area\n        $contentY = 6\n        $contentWidth = $this.TermWidth\n        $y = $contentY + 2\n\n        # Render based on step\n        switch ($this._step) {\n            1 { $this._RenderStep1Engine($engine, $y, $contentWidth) }\n            2 { $this._RenderStep2Engine($engine, $y, $contentWidth) }\n            3 { $this._RenderStep3Engine($engine, $y, $contentWidth) }\n            4 { $this._RenderStep4Engine($engine, $y, $contentWidth) }\n        }\n\n        # Render error if any\n        if (-not [string]::IsNullOrEmpty($this._errorMessage)) {\n            $errorFg = $this.GetThemedInt('Foreground.Error')\n            $textBg = $this.GetThemedInt('Background.Field')\n            $engine.WriteAt(2, $this.TermHeight - 5, \"Error: $($this._errorMessage)\", $errorFg, $textBg)\n        }\n\n        # Render File Picker Overlay\n        if ($this._showFilePicker -and $this._filePicker) {\n            # Center the picker\n            $pickerWidth = [Math]::Min(70, $this.TermWidth - 4)\n            $pickerHeight = [Math]::Min(20, $this.TermHeight - 4)\n            $pickerX = [Math]::Floor(($this.TermWidth - $pickerWidth) / 2)\n            $pickerY = [Math]::Floor(($this.TermHeight - $pickerHeight) / 2)\n\n            $this._filePicker.X = $pickerX\n            $this._filePicker.Y = $pickerY\n            $this._filePicker.Width = $pickerWidth\n            $this._filePicker.Height = $pickerHeight\n\n            # Ensure z-index is top\n            $engine.BeginLayer(100)\n            $this._filePicker.RenderToEngine($engine)\n        }\n    }\n\n    hidden [void] _RenderStep1Engine([object]$engine, [int]$y, [int]$width) {\n        $titleFg = $this.GetThemedInt('Foreground.Title')\n        $errorFg = $this.GetThemedInt('Foreground.Error')\n        $mutedFg = $this.GetThemedInt('Foreground.Muted')\n        $selFg = $this.GetThemedInt('Foreground.RowSelected')\n        $selBg = $this.GetThemedInt('Background.RowSelected')\n        $textBg = $this.GetThemedInt('Background.Field')\n\n        $engine.WriteAt(2, $y, \"Step 1: Connect to Excel\", $titleFg, $textBg)\n        $y += 2\n\n        if ($null -eq $this._reader) {\n            $engine.WriteAt(4, $y, \"Excel COM is not available on this system.\", $errorFg, $textBg)\n            $y += 2\n            $engine.WriteAt(4, $y, \"This feature requires Microsoft Excel to be installed.\", $mutedFg, $textBg)\n            $y++\n            $engine.WriteAt(4, $y, \"Press Esc to return to the project list.\", $mutedFg, $textBg)\n            return\n        }\n\n        # Option 1\n        $fg1 = $(if ($this._selectedOption -eq 0) { $selFg } else { $mutedFg })\n        $bg1 = $(if ($this._selectedOption -eq 0) { $selBg } else { $textBg })\n        $engine.WriteAt(4, $y, \"1. Attach to running Excel instance\", $fg1, $bg1)\n        $y++\n\n        # Option 2\n        $fg2 = $(if ($this._selectedOption -eq 1) { $selFg } else { $mutedFg })\n        $bg2 = $(if ($this._selectedOption -eq 1) { $selBg } else { $textBg })\n        $engine.WriteAt(4, $y, \"2. Open Excel file...\", $fg2, $bg2)\n        $y += 2\n\n        $hint = $(if ($this._selectedOption -eq 0) { \"(Make sure Excel is running with your workbook open)\" } else { \"(Browse for an Excel file to import)\" })\n        $engine.WriteAt(4, $y, $hint, $mutedFg, $textBg)\n    }\n\n    hidden [void] _RenderStep2Engine([object]$engine, [int]$y, [int]$width) {\n        $titleFg = $this.GetThemedInt('Foreground.Title')\n        $selFg = $this.GetThemedInt('Foreground.RowSelected')\n        $selBg = $this.GetThemedInt('Background.RowSelected')\n        $textFg = $this.GetThemedInt('Foreground.Field')\n        $textBg = $this.GetThemedInt('Background.Field')\n\n        $engine.WriteAt(2, $y, \"Step 2: Select Import Profile\", $titleFg, $textBg)\n        $y += 2\n\n        $profiles = @($this._mappingService.GetAllProfiles())\n        if ($null -eq $profiles -or $profiles.Count -eq 0) {\n            $engine.WriteAt(4, $y, \"No profiles found. Please create a profile first.\", $textFg, $textBg)\n            return\n        }\n\n        $activeProfile = $this._mappingService.GetActiveProfile()\n        $activeId = $null\n        if ($null -ne $activeProfile) {\n            if ($activeProfile -is [hashtable] -and $activeProfile.ContainsKey('id')) { $activeId = $activeProfile['id'] }\n            elseif ($activeProfile.PSObject.Properties['id']) { $activeId = $activeProfile.id }\n        }\n\n        for ($i = 0; $i -lt $profiles.Count; $i++) {\n            $profile = $profiles[$i]\n            if ($null -eq $profile) { continue }\n\n            $profileId = $null\n            $profileName = 'Unnamed'\n            if ($profile -is [hashtable]) {\n                if ($profile.ContainsKey('id')) { $profileId = $profile['id'] }\n                if ($profile.ContainsKey('name')) { $profileName = $profile['name'] }\n            } else {\n                if ($profile.PSObject.Properties['id']) { $profileId = $profile.id }\n                if ($profile.PSObject.Properties['name']) { $profileName = $profile.name }\n            }\n\n            $isActive = $(if ($profileId -eq $activeId) { \" [ACTIVE]\" } else { \"\" })\n            $text = \"$($i + 1). $profileName$isActive\"\n\n            $fg = $(if ($i -eq $this._selectedOption) { $selFg } else { $textFg })\n            $bg = $(if ($i -eq $this._selectedOption) { $selBg } else { $textBg })\n            $engine.WriteAt(4, $y + $i, $text, $fg, $bg)\n        }\n    }\n\n    hidden [void] _RenderStep3Engine([object]$engine, [int]$y, [int]$width) {\n        $titleFg = $this.GetThemedInt('Foreground.Title')\n        $textFg = $this.GetThemedInt('Foreground.Field')\n        $textBg = $this.GetThemedInt('Background.Field')\n\n        $engine.WriteAt(2, $y, \"Step 3: Preview Import Data\", $titleFg, $textBg)\n        $y += 2\n\n        if ($null -eq $this._activeProfile) {\n            $engine.WriteAt(4, $y, \"No profile selected\", $textFg, $textBg)\n            return\n        }\n\n        $profileName = 'Unnamed Profile'\n        if ($this._activeProfile -is [hashtable] -and $this._activeProfile.ContainsKey('name')) {\n            $profileName = $this._activeProfile['name']\n        } elseif ($this._activeProfile.PSObject.Properties['name']) {\n            $profileName = $this._activeProfile.name\n        }\n\n        $engine.WriteAt(4, $y, \"Profile: $profileName\", $textFg, $textBg)\n        $y += 2\n\n        $maxRows = $global:MAX_PREVIEW_ROWS\n        $rowCount = 0\n\n        foreach ($mapping in $this._activeProfile['mappings']) {\n            if ($rowCount -ge $maxRows) { break }\n\n            $fieldName = $mapping['display_name']\n            $value = \"(empty)\"\n            if ($this._previewData.ContainsKey($mapping['excel_cell'])) {\n                $cellValue = $this._previewData[$mapping['excel_cell']]\n                if (-not [string]::IsNullOrWhiteSpace($cellValue)) { $value = $cellValue }\n            }\n\n            $required = $(if ($mapping['required']) { \"*\" } else { \" \" })\n            $engine.WriteAt(4, $y + $rowCount, \"$required$($fieldName): $value\", $textFg, $textBg)\n            $rowCount++\n        }\n    }\n\n    hidden [void] _RenderStep4Engine([object]$engine, [int]$y, [int]$width) {\n        $titleFg = $this.GetThemedInt('Foreground.Title')\n        $textFg = $this.GetThemedInt('Foreground.Field')\n        $textBg = $this.GetThemedInt('Background.Field')\n\n        $engine.WriteAt(2, $y, \"Step 4: Import Complete\", $titleFg, $textBg)\n        $y += 2\n        $engine.WriteAt(4, $y, \"Project imported successfully!\", $textFg, $textBg)\n        $y += 2\n        $engine.WriteAt(4, $y, \"Press Esc to return to project list.\", $textFg, $textBg)\n    }\n\n    # === Input Handling ===\n\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\n        # 1. Handle File Picker (Exclusive)\n        if ($this._showFilePicker -and $this._filePicker) {\n            $handled = $this._filePicker.HandleInput($keyInfo)\n            \n            if ($this._filePicker.IsComplete) {\n                if ($this._filePicker.Result) {\n                    $this._OpenFile($this._filePicker.SelectedPath)\n                }\n                # Close picker\n                $this._showFilePicker = $false\n                $this._filePicker = $null\n                $this.NeedsClear = $true\n            }\n            return $true\n        }\n\n        # 2. Call parent for standard shortcuts (F10, Alt+Keys)\n        $handled = ([PmcScreen]$this).HandleKeyPress($keyInfo)\n        if ($handled) { return $true }\n\n        # 3. Wizard Navigation\n        $this._errorMessage = \"\"\n\n        # Up/Down\n        if ($keyInfo.Key -eq ([ConsoleKey]::UpArrow)) {\n            if ($this._selectedOption -gt 0) {\n                $this._selectedOption--\n            }\n            return $true\n        }\n\n        if ($keyInfo.Key -eq ([ConsoleKey]::DownArrow)) {\n            $maxOptions = $this._GetMaxOptions()\n            if ($maxOptions -gt 0 -and $this._selectedOption -lt $maxOptions - 1) {\n                $this._selectedOption++\n            }\n            return $true\n        }\n\n        # Enter - Next Step / Action\n        if ($keyInfo.Key -eq ([ConsoleKey]::Enter)) {\n            $this._ProcessStep()\n            return $true\n        }\n\n        # Escape - Back / Cancel\n        if ($keyInfo.Key -eq ([ConsoleKey]::Escape)) {\n            if ($this._step -eq 1) {\n                $global:PmcApp.PopScreen()\n            }\n            else {\n                $this._step--\n                $this._selectedOption = 0\n            }\n            return $true\n        }\n\n        return $false\n    }\n\n    hidden [int] _GetMaxOptions() {\n        switch ($this._step) {\n            1 { return 2 }\n            2 { return @($this._mappingService.GetAllProfiles()).Count }\n            3 { return 1 }\n            4 { return 1 }\n            default { return 0 }\n        }\n        return 0\n    }\n\n    hidden [void] _ProcessStep() {\n        # Pre-checks\n        if ($null -eq $this._reader -and $this._step -eq 1) {\n            $this._errorMessage = \"Excel COM not available.\"\n            return\n        }\n\n        try {\n            switch ($this._step) {\n                1 { # Connect\n                    if ($this._selectedOption -eq 0) {\n                        # Attach to running Excel\n                        $this._AttachToExcel()\n                    } else {\n                        # Open File Picker\n                        $this._InitFilePicker()\n                    }\n                }\n                2 { # Select Profile\n                    $this._SelectProfile()\n                }\n                3 { # Validate & Import\n                    $this._ImportProject()\n                    $this._step = 4\n                    $this._selectedOption = 0\n                }\n                4 { # Done\n                    $global:PmcApp.PopScreen()\n                }\n            }\n        }\n        catch {\n            $this._errorMessage = $_.Exception.Message\n        }\n    }\n\n    # === Helper Methods ===\n\n    hidden [void] _InitFilePicker() {\n        $startPath = [Environment]::GetFolderPath('UserProfile')\n        $this._filePicker = [PmcFilePicker]::new($startPath, $false)\n        $this._showFilePicker = $true\n        $this.NeedsClear = $true\n    }\n\n    hidden [void] _OpenFile([string]$path) {\n        if (-not [string]::IsNullOrWhiteSpace($path)) {\n            try {\n                $this._reader.OpenFile($path)\n                $this._CheckWorkbook()\n                $this._step = 2\n                $this._selectedOption = 0\n            } catch {\n                $this._errorMessage = \"Failed to open file: $($_.Exception.Message)\"\n            }\n        }\n    }\n\n    hidden [void] _AttachToExcel() {\n        $maxRetries = $script:EXCEL_ATTACH_MAX_RETRIES\n        $retryDelay = $script:EXCEL_ATTACH_RETRY_DELAY_MS\n        \n        for ($retry = 0; $retry -lt $maxRetries; $retry++) {\n            try {\n                $this._reader.AttachToRunningExcel()\n                $this._CheckWorkbook()\n                \n                # Success\n                $this._step = 2\n                $this._selectedOption = 0\n                return\n            }\n            catch {\n                if ($retry -lt ($maxRetries - 1)) {\n                    Start-Sleep -Milliseconds $retryDelay\n                }\n            }\n        }\n        throw \"Failed to attach to Excel. Make sure it is running with a workbook open.\"\n    }\n\n    hidden [void] _CheckWorkbook() {\n        $wb = $this._reader.GetWorkbook()\n        if ($null -eq $wb -or $null -eq $wb.Sheets -or $wb.Sheets.Count -eq 0) {\n            throw \"Workbook has no accessible sheets\"\n        }\n    }\n\n    hidden [void] _SelectProfile() {\n        $profiles = @($this._mappingService.GetAllProfiles())\n        if ($this._selectedOption -lt $profiles.Count) {\n            $this._activeProfile = $profiles[$this._selectedOption]\n\n            if ($null -eq $this._activeProfile['mappings'] -or $this._activeProfile['mappings'].Count -eq 0) {\n                throw \"Profile has no mappings\"\n            }\n\n            # Read Preview\n            $cellsToRead = @($this._activeProfile['mappings'] | ForEach-Object { $_['excel_cell'] })\n            if ($cellsToRead.Count -gt $global:MAX_CELLS_TO_READ) {\n                $cellsToRead = $cellsToRead | Select-Object -First $global:MAX_CELLS_TO_READ\n            }\n\n            $this._previewData = $this._reader.ReadCells($cellsToRead)\n            if ($null -eq $this._previewData) { $this._previewData = @{} }\n\n            $this._step = 3\n            $this._selectedOption = 0\n        }\n    }\n\n    hidden [void] _ImportProject() {\n        if ($null -eq $this._activeProfile) { throw \"No profile\" }\n\n        $projectData = @{}\n        \n        foreach ($mapping in $this._activeProfile['mappings']) {\n            $cell = $mapping['excel_cell']\n            $val = if ($this._previewData.ContainsKey($cell)) { $this._previewData[$cell] } else { $null }\n\n            # Type Conversion\n            $converted = $val\n            switch ($mapping['data_type']) {\n                'int' { \n                    try { $converted = if ($val) { [long]$val } else { 0 } } catch { throw \"Invalid int: $val\" }\n                }\n                'bool' {\n                    try { $converted = if ($val) { [bool]$val } else { $false } } catch { throw \"Invalid bool: $val\" }\n                }\n                'date' {\n                    try { \n                        if ($val) {\n                            $d = [datetime]$val\n                            if ($d.Year -lt $global:MIN_VALID_YEAR -or $d.Year -gt $global:MAX_VALID_YEAR) {\n                                throw \"Date out of range\"\n                            }\n                            $converted = $d\n                        } else { $converted = $null }\n                    } catch { throw \"Invalid date: $val\" }\n                }\n            }\n            \n            # Required check\n            if ($mapping['required'] -and $null -eq $converted) {\n                throw \"Field '$($mapping['display_name'])' is required\"\n            }\n\n            $projectData[$mapping['project_property']] = $converted\n        }\n\n        if (-not $projectData['name']) { throw \"Project name is required\" }\n\n        $success = $this.Store.AddProject($projectData)\n        if (-not $success) { throw \"Store add failed: $($this.Store.LastError)\" }\n        \n        if (-not $this.Store.Flush()) { throw \"Save to disk failed\" }\n    }\n}"}, {"path": "module/Pmc.Strict/consoleui/screens/ExcelProfileManagerScreen.ps1", "content": "using namespace System.Collections.Generic\nusing namespace System.Text\n\n# ExcelProfileManagerScreen - Manage Excel import profiles\n# List, add, edit, delete mapping profiles\n\nSet-StrictMode -Version Latest\n\n. \"$PSScriptRoot/../base/StandardListScreen.ps1\"\n. \"$PSScriptRoot/../services/ExcelMappingService.ps1\"\n\n<#\n.SYNOPSIS\nExcel profile management screen\n\n.DESCRIPTION\nManage Excel import mapping profiles:\n- Add/Edit/Delete profiles\n- Set active profile\n- Edit field mappings (opens ExcelMappingEditorScreen)\n##CLOSEBRACKET##\nclass ExcelProfileManagerScreen : StandardListScreen {\n    hidden [ExcelMappingService]$_mappingService = $null\n\n    # Static: Register menu items\n    static [void] RegisterMenuItems([object]$registry) {\n        $registry.AddMenuItem('Projects', 'Excel Profiles', 'M', {\n            . \"$PSScriptRoot/ExcelProfileManagerScreen.ps1\"\n            $global:PmcApp.PushScreen((New-Object -TypeName ExcelProfileManagerScreen))\n        }, 50)\n    }\n\n    # Constructor\n    ExcelProfileManagerScreen() : base(\"ExcelProfiles\", \"Excel Import Profiles\") {\n\n        # Initialize service\n        $this._mappingService = [ExcelMappingService]::GetInstance()\n\n        # Configure capabilities\n        $this.AllowAdd = $true\n        $this.AllowEdit = $true\n        $this.AllowDelete = $true\n        $this.AllowFilter = $false\n\n        # Configure header\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Projects\", \"Excel Profiles\"))\n\n        # Setup event handlers\n        $self = $this\n        $this._mappingService.OnProfilesChanged = {\n            if ($null -ne $self -and $self.IsActive) {\n                $self.LoadData()\n            }\n        }.GetNewClosure()\n    }\n\n    # Constructor with container\n    ExcelProfileManagerScreen([object]$container) : base(\"ExcelProfiles\", \"Excel Import Profiles\", $container) {\n\n        # Initialize service\n        $this._mappingService = [ExcelMappingService]::GetInstance()\n\n        # Configure capabilities\n        $this.AllowAdd = $true\n        $this.AllowEdit = $true\n        $this.AllowDelete = $true\n        $this.AllowFilter = $false\n\n        # Configure header\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Projects\", \"Excel Profiles\"))\n\n        # Setup event handlers\n        $self = $this\n        $this._mappingService.OnProfilesChanged = {\n            if ($null -ne $self -and $self.IsActive) {\n                $self.LoadData()\n            }\n        }.GetNewClosure()\n    }\n\n    [void] OnDoExit() {\n        ([StandardListScreen]$this).OnDoExit()\n        $this._mappingService.OnProfilesChanged = $null\n    }\n\n    # === Abstract Method Implementations ===\n\n    [string] GetEntityType() {\n        # Non-standard type, won't wire to TaskStore\n        return 'excel_profile'\n    }\n\n    [array] GetColumns() {\n        return @(\n            @{ Name='name'; Label='Profile Name'; Width=30 }\n            @{ Name='description'; Label='Description'; Width=40 }\n            @{ Name='mapping_count'; Label='Fields'; Width=8 }\n            @{ Name='is_active'; Label='Active'; Width=8 }\n        )\n    }\n\n    [void] LoadData() {\n        try {\n            $items = $this.LoadItems()\n            $this.List.SetData($items)\n        } catch {\n            throw\n        }\n    }\n\n    # Helper method - not part of StandardListScreen contract\n    [array] LoadItems() {\n        $profiles = @($this._mappingService.GetAllProfiles())\n        # Write-PmcTuiLog \"ExcelProfileManagerScreen.LoadItems: Got $($profiles.Count) profiles from service\" \"DEBUG\"\n\n        $activeProfile = $this._mappingService.GetActiveProfile()\n        $activeId = $(if ($activeProfile) { $activeProfile['id'] } else { $null })\n\n        # Format for display\n        foreach ($profile in $profiles) {\n            if ($null -ne $profile) {\n                # Write-PmcTuiLog \"ExcelProfileManagerScreen.LoadItems: Processing profile - type=$($profile.GetType().Name) isHashtable=$($profile -is [hashtable])\" \"DEBUG\"\n                if ($profile -is [hashtable]) {\n                    # Write-PmcTuiLog \"ExcelProfileManagerScreen.LoadItems: Profile keys: $($profile.Keys -join ', ')\" \"DEBUG\"\n                    # Write-PmcTuiLog \"ExcelProfileManagerScreen.LoadItems: Profile name='$($profile['name'])' desc='$($profile['description'])'\" \"DEBUG\"\n                }\n\n                $profile['mapping_count'] = $(if ($profile['mappings']) { $profile['mappings'].Count } else { 0 })\n                $profile['is_active'] = $(if ($profile['id'] -eq $activeId) { \"Yes\" } else { \"No\" })\n\n                # Write-PmcTuiLog \"ExcelProfileManagerScreen.LoadItems: After formatting - mapping_count=$($profile['mapping_count']) is_active=$($profile['is_active'])\" \"DEBUG\"\n            } else {\n                # Write-PmcTuiLog \"ExcelProfileManagerScreen.LoadItems: Null profile in list\" \"DEBUG\"\n            }\n        }\n\n        return $profiles\n    }\n\n    [array] GetEditFields([object]$item) {\n        if ($null -eq $item -or $item.Count -eq 0) {\n            # New profile\n            return @(\n                @{ Name='name'; Type='text'; Label='Profile Name'; Required=$true; Value='' }\n                @{ Name='description'; Type='text'; Label='Description'; Value='' }\n                @{ Name='start_cell'; Type='text'; Label='Start Cell'; Value='A1' }\n            )\n        } else {\n            # Existing profile - use hashtable accessor for consistency\n            $name = $(if ($item -is [hashtable]) { $item['name'] } else { $item.name })\n            $description = $(if ($item -is [hashtable]) { $item['description'] } else { $item.description })\n            $startCell = $(if ($item -is [hashtable]) { $item['start_cell'] } else { $item.start_cell })\n\n            return @(\n                @{ Name='name'; Type='text'; Label='Profile Name'; Required=$true; Value=$name }\n                @{ Name='description'; Type='text'; Label='Description'; Value=$description }\n                @{ Name='start_cell'; Type='text'; Label='Start Cell'; Value=$startCell }\n            )\n        }\n    }\n\n    [void] OnItemCreated([hashtable]$values) {\n        try {\n            # ENDEMIC FIX: Safe value access and validation\n            $name = $(if ($values.ContainsKey('name')) { $values.name } else { '' })\n            $description = $(if ($values.ContainsKey('description')) { $values.description } else { '' })\n            $startCell = $(if ($values.ContainsKey('start_cell')) { $values.start_cell } else { '' })\n\n            if ([string]::IsNullOrWhiteSpace($name)) {\n                $this.SetStatusMessage(\"Profile name is required\", \"error\")\n                return\n            }\n\n            $this._mappingService.CreateProfile($name, $description, $startCell)\n\n            $this.SetStatusMessage(\"Profile '$name' created\", \"success\")\n        } catch {\n            $this.SetStatusMessage(\"Error creating profile: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    [void] OnItemUpdated([object]$item, [hashtable]$values) {\n        try {\n            $itemId = $(if ($item -is [hashtable]) { $item['id'] } else { $item.id })\n\n            # ENDEMIC FIX: Safe value access\n            $changes = @{\n                name = $(if ($values.ContainsKey('name')) { $values.name } else { '' })\n                description = $(if ($values.ContainsKey('description')) { $values.description } else { '' })\n                start_cell = $(if ($values.ContainsKey('start_cell')) { $values.start_cell } else { '' })\n            }\n\n            # Validate required fields\n            if ([string]::IsNullOrWhiteSpace($changes.name)) {\n                $this.SetStatusMessage(\"Profile name is required\", \"error\")\n                return\n            }\n\n            $this._mappingService.UpdateProfile($itemId, $changes)\n            $this.SetStatusMessage(\"Profile '$($changes.name)' updated\", \"success\")\n        } catch {\n            $this.SetStatusMessage(\"Error updating profile: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    [void] OnItemDeleted([object]$item) {\n        try {\n            $itemId = $(if ($item -is [hashtable]) { $item['id'] } else { $item.id })\n            $itemName = $(if ($item -is [hashtable]) { $item['name'] } else { $item.name })\n\n            if ($itemId) {\n                $this._mappingService.DeleteProfile($itemId)\n                $this.SetStatusMessage(\"Profile '$itemName' deleted\", \"success\")\n            } else {\n                $this.SetStatusMessage(\"Cannot delete profile without ID\", \"error\")\n            }\n        } catch {\n            $this.SetStatusMessage(\"Error deleting profile: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    # Override OnItemActivated to open mapping editor\n    [void] OnItemActivated([object]$item) {\n        if ($null -eq $item) {\n            return\n        }\n\n        $itemId = $(if ($item -is [hashtable]) { $item['id'] } else { $item.id })\n        $itemName = $(if ($item -is [hashtable]) { $item['name'] } else { $item.name })\n\n        if ($itemId) {\n            . \"$PSScriptRoot/ExcelMappingEditorScreen.ps1\"\n            $editorScreen = New-Object ExcelMappingEditorScreen -ArgumentList $itemId, $itemName\n            $global:PmcApp.PushScreen($editorScreen)\n        }\n    }\n\n    # Custom action: Set as active profile\n    [void] SetActiveProfile() {\n        $selectedItem = $this.List.GetSelectedItem()\n        if ($null -eq $selectedItem) {\n            $this.SetStatusMessage(\"No profile selected\", \"error\")\n            return\n        }\n\n        $itemId = $(if ($selectedItem -is [hashtable]) { $selectedItem['id'] } else { $selectedItem.id })\n        $itemName = $(if ($selectedItem -is [hashtable]) { $selectedItem['name'] } else { $selectedItem.name })\n\n        try {\n            $this._mappingService.SetActiveProfile($itemId)\n            $this.SetStatusMessage(\"Active profile set to '$itemName'\", \"success\")\n            $this.LoadData()\n        } catch {\n            # Write-PmcTuiLog \"SetActiveProfile: Error setting active profile '$itemName' - $_\" \"ERROR\"\n            $this.SetStatusMessage(\"Error setting active profile: $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    [array] GetCustomActions() {\n        return @(\n            @{\n                Label = \"Set Active (S)\"\n                Key = 's'\n                Callback = {\n                    $this.SetActiveProfile()\n                }.GetNewClosure()\n            }\n        )\n    }\n}\n"}, {"path": "module/Pmc.Strict/consoleui/screens/HelpViewScreen.ps1", "content": "using namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# HelpViewScreen - PMC TUI Help documentation\r\n# Static help screen showing keyboard shortcuts and commands\r\n\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n. \"$PSScriptRoot/../PmcScreen.ps1\"\r\n\r\n<#\r\n.SYNOPSIS\r\nHelp screen showing PMC TUI keyboard shortcuts and commands\r\n\r\n.DESCRIPTION\r\nStatic help documentation screen showing:\r\n- Global keyboard shortcuts\r\n- Task list commands\r\n- Multi-select mode keys\r\n- Quick add syntax\r\n- Feature overview\r\nNo navigation needed, just Esc to exit.\r\n##CLOSEBRACKET##\r\nclass HelpViewScreen : PmcScreen {\r\n    HelpViewScreen() : base('Help', 'Help') {\r\n    }\r\n\r\n\r\n\r\n    # === Layout System ===\r\n\r\n    [void] Resize([int]$width, [int]$height) {\r\n        $this.TermWidth = $width\r\n        $this.TermHeight = $height\r\n        \r\n        # Resize standard components\r\n        if ($this.MenuBar) { $this.MenuBar.SetSize($width, 1) }\r\n        if ($this.Header) { $this.Header.SetSize($width, 3) }\r\n        if ($this.Footer) { \r\n            $this.Footer.SetPosition(0, $height - 1)\r\n            $this.Footer.SetSize($width, 1)\r\n        }\r\n    }\r\n\r\n    [void] RenderContentToEngine([object]$engine) {\r\n        if (-not $this.LayoutManager) { return }\r\n\r\n        # Get content area\r\n        $contentRect = $this.LayoutManager.GetRegion('Content', $this.TermWidth, $this.TermHeight)\r\n        $engine.BeginLayer([ZIndex]::Content)\r\n\r\n        # Colors (Ints)\r\n        $textColor = $this.Header.GetThemedColorInt('Foreground.Field')\r\n        $highlightColor = $this.Header.GetThemedColorInt('Foreground.FieldFocused')\r\n        $mutedColor = $this.Header.GetThemedColorInt('Foreground.Muted')\r\n        $headerColor = $this.Header.GetThemedColorInt('Foreground.FieldFocused')\r\n        $bg = $this.Header.GetThemedColorInt('Background.Primary')\r\n\r\n        $y = $contentRect.Y\r\n        $indent = $contentRect.X + 4\r\n        $subIndent = $contentRect.X + 6\r\n\r\n        # Helper to simplify writing lines\r\n        $writeLine = {\r\n            param($x, $text, $color)\r\n            $engine.WriteAt($x, $y, $text, $color, $bg)\r\n            # Access variable from parent scope using Get-Variable or assume scope inherited in scriptblock\r\n        }\r\n\r\n        # Global Keys\r\n        $engine.WriteAt($indent, $y, \"Global Keys:\", $headerColor, $bg)\r\n        $y++\r\n\r\n        $globalKeys = @(\r\n            \"?         - Show this help screen\"\r\n            \"F10       - Open menu bar\"\r\n            \"Esc       - Back / Close menus / Exit\"\r\n            \"R         - Refresh current view\"\r\n            \"F         - Filter panel (when available)\"\r\n            \"Alt+X     - Quick exit PMC\"\r\n            \"Alt+T     - Open task list\"\r\n            \"Alt+A     - Add new task\"\r\n            \"Alt+P     - Project list\"\r\n        )\r\n        foreach ($line in $globalKeys) {\r\n            $engine.WriteAt($subIndent, $y, $line, $textColor, $bg)\r\n            $y++\r\n        }\r\n        $y++\r\n\r\n        # Task List Keys\r\n        $engine.WriteAt($indent, $y, \"Task List Keys:\", $headerColor, $bg)\r\n        $y++\r\n\r\n        $taskKeys = @(\r\n            \"Up/Down   - Navigate tasks\"\r\n            \"PgUp/PgDn - Scroll page\"\r\n            \"Enter     - View task details\"\r\n            \"A         - Add new task\"\r\n            \"E         - Edit task\"\r\n            \"C         - Complete task\"\r\n            \"D         - Delete task\"\r\n            \"X         - Clone task\"\r\n            \"S         - Add subtask to selected\"\r\n            \"H         - Toggle show completed\"\r\n            \"Tab       - Next field (when editing)\"\r\n            \"/         - Search tasks\"\r\n            \"1-6       - View filters (All, Active, Completed, Overdue, Today, Week)\"\r\n        )\r\n        foreach ($line in $taskKeys) {\r\n            $engine.WriteAt($subIndent, $y, $line, $textColor, $bg)\r\n            $y++\r\n        }\r\n        $y++\r\n\r\n        # Multi-Select Mode\r\n        if ($y -lt $contentRect.Y + $contentRect.Height - 10) {\r\n            $engine.WriteAt($indent, $y, \"Multi-Select Mode:\", $headerColor, $bg)\r\n            $y++\r\n\r\n            $multiKeys = @(\r\n                \"Space     - Toggle task selection\"\r\n                \"A         - Select all visible tasks\"\r\n                \"N         - Clear all selections\"\r\n                \"D         - Complete selected tasks\"\r\n                \"X         - Delete selected tasks\"\r\n            )\r\n            foreach ($line in $multiKeys) {\r\n                $engine.WriteAt($subIndent, $y, $line, $textColor, $bg)\r\n                $y++\r\n            }\r\n            $y++\r\n        }\r\n\r\n        # Project List Keys\r\n        if ($y -lt $contentRect.Y + $contentRect.Height - 12) {\r\n            $engine.WriteAt($indent, $y, \"Project List Keys:\", $headerColor, $bg)\r\n            $y++\r\n\r\n            $projectKeys = @(\r\n                \"A         - Add new project\"\r\n                \"E         - Edit project\"\r\n                \"D         - Delete project\"\r\n                \"R         - Archive/Unarchive project\"\r\n                \"V         - View project details\"\r\n            )\r\n            foreach ($line in $projectKeys) {\r\n                $engine.WriteAt($subIndent, $y, $line, $textColor, $bg)\r\n                $y++\r\n            }\r\n            $y++\r\n        }\r\n\r\n        # Time Tracking Keys\r\n        if ($y -lt $contentRect.Y + $contentRect.Height - 10) {\r\n            $engine.WriteAt($indent, $y, \"Time Tracking Keys:\", $headerColor, $bg)\r\n            $y++\r\n\r\n            $timeKeys = @(\r\n                \"A         - Add time entry\"\r\n                \"E         - Edit time entry\"\r\n                \"D         - Delete time entry\"\r\n                \"Enter     - View entry details\"\r\n                \"W         - Weekly time report\"\r\n                \"G         - Generate time report\"\r\n                \"Arrows    - Navigate weeks (in week view)\"\r\n            )\r\n            foreach ($line in $timeKeys) {\r\n                $engine.WriteAt($subIndent, $y, $line, $textColor, $bg)\r\n                $y++\r\n            }\r\n            $y++\r\n        }\r\n\r\n        # Quick Add Syntax\r\n        if ($y -lt $contentRect.Y + $contentRect.Height - 8) {\r\n            $engine.WriteAt($indent, $y, \"Quick Add Syntax:\", $headerColor, $bg)\r\n            $y++\r\n\r\n            $quickAdd = @(\r\n                \"@project  - Set project (e.g., 'Fix bug @work')\"\r\n                \"#priority - Set priority: #high #medium #low or #h #m #l\"\r\n                \"!due      - Set due date: !today !tomorrow !+7 (days)\"\r\n            )\r\n            foreach ($line in $quickAdd) {\r\n                $engine.WriteAt($subIndent, $y, $line, $mutedColor, $bg)\r\n                $y++\r\n            }\r\n            $y++\r\n        }\r\n    }\r\n    \r\n    [string] RenderContent() { return \"\" }\r\n    \r\n    # Remove old RenderToEngine that used ParseAnsi\r\n\r\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\r\n        # Let MenuBar handle its keys first (F10, menu navigation, etc.)\r\n        if ($null -ne $this.MenuBar -and $this.MenuBar.HandleKeyPress($keyInfo)) {\r\n            return $true\r\n        }\r\n\r\n        # All other keys are ignored on help screen\r\n        return $false\r\n    }\r\n\r\n    hidden [void] _ShowAbout() {\r\n        $this.ShowStatus(\"PMC TUI v1.0 - Project Management Console\")\r\n    }\r\n\r\n    hidden [void] _ShowVersion() {\r\n        $this.ShowStatus(\"Version 1.0.0\")\r\n    }\r\n}\r\n\r\n# Entry point function for compatibility\r\nfunction Show-HelpViewScreen {\r\n    param([object]$App)\r\n\r\n    if (-not $App) {\r\n        throw \"PmcApplication required\"\r\n    }\r\n\r\n    $screen = New-Object HelpViewScreen\r\n    $App.PushScreen($screen)\r\n}"}, {"path": "module/Pmc.Strict/consoleui/screens/KANBAN_V2_README.md", "content": "# Kanban Screen V2 - Complete Implementation\n\n**Status**: ✅ Fully Implemented\n**File**: `consoleui/screens/KanbanScreenV2.ps1`\n**Date**: 2025-11-13\n\n---\n\n## Overview\n\nEnhanced Kanban board with 3 columns, independent scrolling, custom task coloring, and comprehensive task management capabilities.\n\n### Key Features\n\n✅ **Three-column layout**: TODO, IN PROGRESS, DONE\n✅ **Independent scrolling**: Each column scrolls separately\n✅ **Dynamic column width**: Adjusts to terminal size (minimum 120 chars)\n✅ **Ctrl+Arrow movement**: Move tasks between columns and reorder within columns\n✅ **Custom task colors**: Per-task and per-tag color schemes\n✅ **Subtask hierarchy**: Expand/collapse parent tasks, children move with parents\n✅ **Tag editing**: Full tag management using existing TagEditor widget\n✅ **Visual separators**: Column borders and scroll indicators\n\n---\n\n## Controls\n\n### Navigation\n- `↑/↓` - Move selection within active column\n- `←/→` - Switch between columns\n- `Space` - Expand/collapse parent task (show/hide subtasks)\n\n### Task Movement\n- `Ctrl+←` - Move task to previous column (Done → In Progress → TODO)\n- `Ctrl+→` - Move task to next column (TODO → In Progress → Done)\n- `Ctrl+↑` - Move task up within column (swap with task above)\n- `Ctrl+↓` - Move task down within column (swap with task below)\n\n### Task Customization\n- `T` - Edit tags (opens TagEditor widget)\n- `C` - Pick custom color for task\n\n### Other\n- `R` - Refresh/reload data\n- `Esc` - Exit to previous screen\n\n---\n\n## Data Model\n\n### Task Fields Used\n\n```powershell\n@{\n    id = \"uuid\"                       # Unique identifier\n    text = \"Task description\"         # Task text\n    status = \"todo|in-progress|done\"  # Column assignment\n    order = 0                         # Position within column (for manual reordering)\n    color = \"#FF5733\"                 # Custom per-task color (optional)\n    parent_id = \"uuid\"                # Parent task ID (for subtasks)\n    tags = @(\"work\", \"urgent\")        # Tags (optional)\n    priority = 1-5                    # Priority (shown as prefix)\n    completed = $true/$false          # Completion status\n    completedDate = \"2025-11-13\"      # Completion timestamp\n}\n```\n\n### Status Mapping\n\n| Column | Status Values |\n|--------|--------------|\n| TODO | `'todo'`, `'pending'`, or no status |\n| IN PROGRESS | `'in-progress'` |\n| DONE | `'done'` or `completed = true` |\n\n### Order Field\n\nTasks are sorted by `order` field (ascending), then `priority` (descending).\nWhen you use Ctrl+Up/Down to reorder, the `order` values are swapped.\n\n---\n\n## Color System\n\n### Per-Task Colors\n\nSet with `C` key - stores hex color directly on task:\n```powershell\n$task.color = \"#FF0000\"  # Red\n```\n\n### Per-Tag Colors\n\nConfigured in `config.json`:\n```json\n{\n  \"Kanban\": {\n    \"TagColors\": {\n      \"urgent\": \"#FF0000\",\n      \"important\": \"#FFA500\",\n      \"work\": \"#0066CC\",\n      \"personal\": \"#00CC66\",\n      \"blocked\": \"#CC0000\",\n      \"waiting\": \"#CCCC00\"\n    }\n  }\n}\n```\n\n### Color Priority\n\n1. **Per-task color** (if set) - highest priority\n2. **Per-tag color** (first matching tag)\n3. **Default theme color**\n\n---\n\n## Subtask Behavior\n\n### Parent-Child Relationship\n\nTasks are displayed as bordered cards with task text and tags:\n\n```\n┌─ TODO ─────────────────────────┐\n│ ┌────────────────────────────┐ │\n│ │ ▸ Project Alpha            │ │  ← Parent (collapsed)\n│ │ #work #important           │ │\n│ └────────────────────────────┘ │\n│                                 │\n│ ┌────────────────────────────┐ │\n│ │ ▼ Website Redesign         │ │  ← Parent (expanded)\n│ │ #project                   │ │\n│ └────────────────────────────┘ │\n│                                 │\n│ ┌────────────────────────────┐ │\n│ │   ├─ Design mockups        │ │  ← Child (indented)\n│ │ #design                    │ │\n│ └────────────────────────────┘ │\n│                                 │\n> ┌────────────────────────────┐   ← Selected (cursor)\n│ │ Regular task               │ │\n│ │ #urgent                    │ │\n│ └────────────────────────────┘ │\n└─────────────────────────────────┘\n```\n\n### Movement Rules\n\n**When moving parent with Ctrl+Left/Right:**\n- Parent status changes\n- **All children move with parent** (status updated)\n- Children maintain their subtask relationship\n\n**When moving child manually:**\n- Can move child independently of parent\n- Child keeps `parent_id` reference\n- May end up in different column than parent\n\n**Expanding/Collapsing:**\n- Press `Space` on parent task\n- Expanded state persists during session\n- Subtasks show indented with `├─` prefix\n\n---\n\n## Independent Scrolling\n\nEach column maintains its own scroll offset:\n\n```powershell\n[int]$ScrollOffsetTodo = 0\n[int]$ScrollOffsetInProgress = 0\n[int]$ScrollOffsetDone = 0\n```\n\n### Behavior\n\n- Only the **active column** scrolls with arrow keys\n- Other columns stay at their current scroll position\n- Scroll adjusts automatically to keep selection visible\n- Scroll indicators show \"↑ More above\" and \"↓ +N more\"\n\n### Selection Tracking\n\nEach column has independent selection:\n```powershell\n[int]$SelectedIndexTodo = 0\n[int]$SelectedIndexInProgress = 0\n[int]$SelectedIndexDone = 0\n```\n\nSwitching columns with `←/→` preserves each column's selection position.\n\n---\n\n## Dynamic Layout\n\n### Column Width Calculation\n\n```powershell\n# Minimum total width: 120 chars\n$minTotalWidth = 120\n$actualWidth = [Math]::Max($minTotalWidth, $contentRect.Width)\n\n# 3 columns + 6 chars for borders\n$columnWidth = [Math]::Floor(($actualWidth - 6) / 3)\n```\n\n### Responsive Behavior\n\n| Terminal Width | Column Width | Notes |\n|----------------|--------------|-------|\n| 120 chars | 38 chars each | Minimum |\n| 150 chars | 48 chars each | Comfortable |\n| 180+ chars | 58+ chars each | Spacious |\n\nColumns expand equally as terminal width increases.\n\n---\n\n## Tag Editing\n\n### TagEditor Integration\n\nUses the existing `TagEditor.ps1` widget (sophisticated autocomplete-enabled editor):\n\n**Features:**\n- Autocomplete from existing tags\n- Type-ahead filtering\n- Tab/Enter to add tags\n- Backspace to remove tags\n- Comma-separated input\n- Max 10 tags per task\n\n**Workflow:**\n1. Press `T` on selected task\n2. TagEditor opens as modal dialog\n3. Type tags, use autocomplete\n4. Press `Esc` to confirm and save\n5. Tags saved to task immediately\n\n---\n\n## Color Picker\n\n### Simple Color Menu\n\nShows 9 color options:\n- Red (#FF0000)\n- Orange (#FFA500)\n- Yellow (#FFFF00)\n- Green (#00FF00)\n- Blue (#0000FF)\n- Purple (#9966FF)\n- Pink (#FF69B4)\n- Cyan (#00FFFF)\n- Clear (use tag color)\n\n**Workflow:**\n1. Press `C` on selected task\n2. Color picker opens as modal menu\n3. Use `↑↓` to select color\n4. Press `Enter` to apply\n5. Color saved to task immediately\n\n### Visual Preview\n\nEach color shows as colored blocks: `███ > Red`\n\n---\n\n## Implementation Details\n\n### File Structure\n\n```\nconsoleui/screens/KanbanScreenV2.ps1      # Main implementation (980 lines)\nconsoleui/widgets/TagEditor.ps1           # Tag editing widget (reused)\n```\n\n### Key Methods\n\n**Data Loading:**\n- `LoadData()` - Loads tasks from Get-PmcData, filters by status\n\n**Rendering:**\n- `_RenderKanbanBoard()` - Main board layout\n- `_RenderColumn()` - Individual column rendering with bordered task cards\n- `_BuildFlatTaskList()` - Expands parent/child hierarchy\n\n**Card Rendering:**\nEach task is rendered as a 4-line bordered card:\n```\nLine 1: ┌────────┐  (top border)\nLine 2: │ text   │  (task text with indicators)\nLine 3: │ #tags  │  (tags in muted color)\nLine 4: └────────┘  (bottom border)\n```\nCards use box-drawing characters (┌─┐│└┘) with custom colors applied to borders and content.\n\n**Movement:**\n- `_MoveTaskLeft()` / `_MoveTaskRight()` - Inter-column movement\n- `_ReorderTaskUp()` / `_ReorderTaskDown()` - Intra-column reordering\n- `_SwapTaskOrder()` - Swaps order field values\n\n**Hierarchy:**\n- `_HasChildren()` - Checks if task is a parent\n- `_GetChildren()` - Gets child tasks\n- `_ToggleExpand()` - Expand/collapse parent\n\n**Colors:**\n- `_GetTaskColor()` - Resolves color (per-task > per-tag > default)\n- `_HexToAnsi()` - Converts hex to ANSI RGB sequence\n\n**Dialogs:**\n- `_EditTags()` - Opens TagEditor modal\n- `_PickColor()` - Opens color picker modal\n\n---\n\n## Usage Example\n\n### From TUI Menu\n\n1. Launch PMC TUI: `pwsh Start-PmcTUI.ps1`\n2. Open the **Tasks** menu\n3. Press `K` for **Kanban Board**\n\n**Menu Location**: Tasks → Kanban Board (K)\n\n### Programmatic\n\n```powershell\n# Push Kanban screen\n$screen = [KanbanScreenV2]::new()\n$app.PushScreen($screen)\n\n# Or use helper function\nShow-KanbanScreenV2 -App $app\n```\n\n### Menu Configuration\n\nConfigured in `MenuItems.psd1`:\n```powershell\n'KanbanScreenV2' = @{\n    Menu = 'Tasks'\n    Label = 'Kanban Board'\n    Hotkey = 'K'\n    Order = 55\n    ScreenFile = 'KanbanScreenV2.ps1'\n}\n```\n\n---\n\n## Testing Checklist\n\n### Navigation\n- [x] Up/Down moves selection within column\n- [x] Left/Right switches columns\n- [x] Scroll offsets adjust to keep selection visible\n- [x] Each column scrolls independently\n\n### Task Movement\n- [x] Ctrl+Left moves task to previous column\n- [x] Ctrl+Right moves task to next column\n- [x] Ctrl+Up swaps task with one above\n- [x] Ctrl+Down swaps task with one below\n- [x] Status field updates correctly\n- [x] Completed/completedDate updates for DONE column\n\n### Subtasks\n- [x] Space expands/collapses parent tasks\n- [x] Subtasks show indented with tree characters\n- [x] Moving parent moves all children\n- [x] Children can be moved independently\n\n### Colors\n- [x] Per-task colors display correctly\n- [x] Per-tag colors display when no task color\n- [x] Color picker saves colors\n- [x] Clearing color removes task color\n\n### Tags\n- [x] Tag editor opens and closes\n- [x] Tags save to task\n- [x] Autocomplete works\n- [x] Tag colors apply\n\n### Layout\n- [x] Columns adjust to terminal width\n- [x] Minimum 120 char width enforced\n- [x] Column headers show counts\n- [x] Vertical separators render\n- [x] Scroll indicators appear\n\n---\n\n## Differences from Original Kanban Screen\n\n| Feature | Original | V2 |\n|---------|----------|-----|\n| Scrolling | Truncation only | Independent per column |\n| Movement | 'M' key cycles status | Ctrl+Arrows (directional) |\n| Reordering | Not supported | Ctrl+Up/Down swaps |\n| Colors | Priority-based only | Per-task + per-tag custom |\n| Tags | View only | Full editing (T key) |\n| Subtasks | Not shown | Expand/collapse hierarchy |\n| Layout | Fixed width | Dynamic (min 120) |\n| Column width | Hardcoded | Calculated from terminal |\n\n---\n\n## Configuration\n\n### Default Tag Colors\n\nEdit in `config.json`:\n```json\n{\n  \"Kanban\": {\n    \"TagColors\": {\n      \"urgent\": \"#FF0000\",\n      \"work\": \"#0066CC\"\n    }\n  }\n}\n```\n\n### Load Tag Colors\n\nDone automatically in constructor:\n```powershell\nhidden [void] _LoadTagColors() {\n    $cfg = Get-PmcConfig\n    if ($cfg.Kanban -and $cfg.Kanban.TagColors) {\n        $this.TagColors = $cfg.Kanban.TagColors\n    }\n}\n```\n\n---\n\n## Performance Notes\n\n- **Flat list building**: O(n) per column render\n- **Card-based scrolling**: Each card takes 4 lines; typically shows 5-8 tasks per column\n- **Scroll optimization**: Only renders visible task cards\n- **Color caching**: Theme ANSI sequences cached by Header widget\n- **Tag refresh**: TagEditor reloads tags every 10 seconds\n- **Rendering**: Each task card requires 4 cursor movements + 4 string appends\n\n---\n\n## Future Enhancements (Out of Scope)\n\n- [ ] Drag-and-drop with mouse\n- [ ] Keyboard shortcuts customization\n- [ ] Export to CSV/JSON\n- [ ] Filter by tag/priority\n- [ ] Search within columns\n- [ ] Column limits (WIP warnings)\n- [ ] Swimlanes (additional column grouping)\n- [ ] Custom column definitions\n\n---\n\n## Known Limitations\n\n1. **No task creation**: Use TaskListScreen to create tasks (by design)\n2. **No task editing**: Text editing happens in TaskListScreen (by design)\n3. **Max subtask depth**: 1 level (parent → children, no grandchildren)\n4. **Color picker**: Fixed color palette (9 colors)\n5. **Modal dialogs**: Block main screen updates during editing\n\n---\n\n## Troubleshooting\n\n### \"Tasks not appearing\"\n- Check task `status` field matches column filter\n- Ensure tasks aren't filtered out by `completed` status\n\n### \"Colors not showing\"\n- Verify terminal supports 24-bit color (true color)\n- Check `color` field format is `#RRGGBB`\n\n### \"Subtasks not visible\"\n- Press `Space` on parent to expand\n- Ensure `parent_id` matches parent's `id`\n\n### \"Scrolling not working\"\n- Check content area has enough height\n- Verify tasks exceed visible area\n\n---\n\n**Implementation Complete!** ✅\n\nAll requested features implemented and tested.\n"}, {"path": "module/Pmc.Strict/consoleui/screens/MenuItems.psd1", "content": "@{\n    # Menu item definitions for PMC TUI\n    # Format: ScreenName = @{ Menu = 'MenuName'; Label = 'Display Label'; Hotkey = 'X'; Order = 10 }\n\n    # ===== TOOLS MENU =====\n    'CommandLibraryScreen' = @{\n        Menu = 'Tools'\n        Label = 'Command Library'\n        Hotkey = 'L'\n        Order = 10\n        ScreenFile = 'CommandLibraryScreen.ps1'\n    }\n\n    'NotesMenuScreen' = @{\n        Menu = 'Tools'\n        Label = 'Notes'\n        Hotkey = 'N'\n        Order = 20\n        ScreenFile = 'NotesMenuScreen.ps1'\n    }\n\n    'ChecklistsLauncherScreen' = @{\n        Menu = 'Tools'\n        Label = 'Checklists'\n        Hotkey = 'C'\n        Order = 25\n        ScreenFile = 'ChecklistsLauncherScreen.ps1'\n    }\n\n    'ChecklistTemplatesFolderScreen' = @{\n        Menu = 'Tools'\n        Label = 'Checklist Templates'\n        Hotkey = 'H'\n        Order = 30\n        ScreenFile = 'ChecklistTemplatesFolderScreen.ps1'\n    }\n\n    # ===== PROJECTS MENU =====\n    'ProjectListScreen' = @{\n        Menu = 'Projects'\n        Label = 'Project List'\n        Hotkey = 'L'\n        Order = 10\n        ScreenFile = 'ProjectListScreen.ps1'\n    }\n\n    # ProjectInfoScreenV4 removed from menu - accessed via 'V' key in ProjectListScreen\n    # Requires a project to be selected, so should not be directly accessible from menu\n\n    'ExcelImportScreen' = @{\n        Menu = 'Projects'\n        Label = 'Import from Excel'\n        Hotkey = 'I'\n        Order = 40\n        ScreenFile = 'ExcelImportScreen.ps1'\n    }\n\n    'ExcelProfileManagerScreen' = @{\n        Menu = 'Projects'\n        Label = 'Excel Profiles'\n        Hotkey = 'M'\n        Order = 50\n        ScreenFile = 'ExcelProfileManagerScreen.ps1'\n    }\n\n    # ===== TASKS MENU =====\n    'TaskListScreen_Default' = @{\n        Menu = 'Tasks'\n        Label = 'Task List'\n        Hotkey = 'L'\n        Order = 5\n        ScreenFile = 'TaskListScreen.ps1'\n    }\n\n\n\n    # KanbanScreenV2 removed - archived 2025-12-17\n\n    # ===== TIME MENU =====\n    'TimeListScreen' = @{\n        Menu = 'Time'\n        Label = 'Time Tracking'\n        Hotkey = 'T'\n        Order = 5\n        ScreenFile = 'TimeListScreen.ps1'\n    }\n\n    'WeeklyTimeReportScreen' = @{\n        Menu = 'Time'\n        Label = 'Weekly Report'\n        Hotkey = 'W'\n        Order = 10\n        ScreenFile = 'WeeklyTimeReportScreen.ps1'\n    }\n\n    'TimeReportScreen' = @{\n        Menu = 'Time'\n        Label = 'Time Report'\n        Hotkey = 'R'\n        Order = 20\n        ScreenFile = 'TimeReportScreen.ps1'\n    }\n\n    # ===== OPTIONS MENU =====\n    'ThemeEditorScreen' = @{\n        Menu = 'Options'\n        Label = 'Theme Editor'\n        Hotkey = 'T'\n        Order = 10\n        ScreenFile = 'ThemeEditorScreen.ps1'\n    }\n\n    'SettingsScreen' = @{\n        Menu = 'Options'\n        Label = 'Settings'\n        Hotkey = 'S'\n        Order = 20\n        ScreenFile = 'SettingsScreen.ps1'\n    }\n\n    # ===== HELP MENU =====\n    'HelpViewScreen' = @{\n        Menu = 'Help'\n        Label = 'Help'\n        Hotkey = 'H'\n        Order = 10\n        ScreenFile = 'HelpViewScreen.ps1'\n    }\n}\n"}, {"path": "module/Pmc.Strict/consoleui/screens/NotesMenuScreen.ps1", "content": "# NotesMenuScreen.ps1 - List all notes with add/edit/delete capabilities\r\n#\r\n# Displays a list of all notes using StandardListScreen base class\r\n# Allows creating new notes, editing existing notes, and deleting notes\r\n#\r\n# Usage:\r\n#   $screen = New-Object NotesMenuScreen\r\n#   $global:PmcApp.PushScreen($screen)\r\n\r\nusing namespace System\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n. \"$PSScriptRoot/../base/StandardListScreen.ps1\"\r\n\r\n\r\nclass NotesMenuScreen : StandardListScreen {\r\n    # === Configuration ===\r\n    hidden [FileNoteService]$_noteService = $null\r\n    hidden [string]$_ownerType = \"global\"\r\n    hidden [string]$_ownerId = $null\r\n    hidden [string]$_ownerName = \"\"\r\n\r\n    # === Constructor ===\r\n    # Legacy constructor (backward compatible)\r\n    NotesMenuScreen() : base(\"NotesList\", \"Notes\") {\r\n        $this._InitializeScreen(\"global\", $null, \"\")\r\n    }\r\n\r\n    # Container constructor\r\n    NotesMenuScreen([object]$container) : base(\"NotesList\", \"Notes\", $container) {\r\n        $this._InitializeScreen(\"global\", $null, \"\")\r\n    }\r\n\r\n    # Legacy constructor with owner parameters\r\n    NotesMenuScreen([string]$ownerType, [string]$ownerId, [string]$ownerName) : base(\"NotesList\", \"Notes\") {\r\n        $this._InitializeScreen($ownerType, $ownerId, $ownerName)\r\n    }\r\n\r\n    # Container constructor with owner parameters\r\n    NotesMenuScreen([string]$ownerType, [string]$ownerId, [string]$ownerName, [object]$container) : base(\"NotesList\", \"Notes\", $container) {\r\n        $this._InitializeScreen($ownerType, $ownerId, $ownerName)\r\n    }\r\n\r\n    hidden [void] _InitializeScreen([string]$ownerType, [string]$ownerId, [string]$ownerName) {\r\n        $this._ownerType = $ownerType\r\n        $this._ownerId = $ownerId\r\n        $this._ownerName = $ownerName\r\n\r\n        # Get note service instance\r\n        $this._noteService = [FileNoteService]::GetInstance()\r\n\r\n        # Subscribe to note changes\r\n        # Note: Callback may be invoked when screen is not active, so check first\r\n        $self = $this\r\n        $this._noteService.OnNotesChanged = {\r\n            if ($null -ne $self -and $self.IsActive) {\r\n                $self.LoadData()\r\n            }\r\n        }.GetNewClosure()\r\n\r\n        # Configure screen\r\n        $this.AllowAdd = $true\r\n        $this.AllowEdit = $true\r\n        $this.AllowDelete = $true\r\n        $this.AllowFilter = $true\r\n        $this.AllowSearch = $true\r\n\r\n        # Update screen title and breadcrumb based on owner\r\n        if ($this._ownerType -ne \"global\") {\r\n            $ownerLabel = $(if ($ownerType -eq \"project\") { \"Project\" } elseif ($ownerType -eq \"task\") { \"Task\" } else { \"Global\" })\r\n            $this.ScreenTitle = \"Notes - $ownerName\"\r\n            $this.Header.SetBreadcrumb(@($ownerLabel, $ownerName, \"Notes\"))\r\n        }\r\n    }\r\n\r\n    # === Abstract Methods Implementation ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Load notes data into the list\r\n    ##CLOSEBRACKET##\r\n    [void] LoadData() {\r\n        # Write-PmcTuiLog \"NotesMenuScreen.LoadData: Loading notes for owner=$($this._ownerType):$($this._ownerId)\" \"INFO\"\r\n\r\n        try {\r\n            # Get notes from service (filtered by owner if specified)\r\n            if ($this._ownerType -eq \"global\" -or $null -eq $this._ownerId) {\r\n                # Write-PmcTuiLog \"NotesMenuScreen.LoadData: Getting all notes (global)\" \"INFO\"\r\n                $notes = $this._noteService.GetAllNotes()\r\n            } else {\r\n                # Write-PmcTuiLog \"NotesMenuScreen.LoadData: Getting notes by owner type=$($this._ownerType) id=$($this._ownerId)\" \"INFO\"\r\n                $notes = $this._noteService.GetNotesByOwner($this._ownerType, $this._ownerId)\r\n            }\r\n\r\n            # Ensure we have an array\r\n            if ($null -eq $notes) {\r\n                $notes = @()\r\n            } elseif ($notes -isnot [array]) {\r\n                $notes = @($notes)\r\n            }\r\n\r\n            # Write-PmcTuiLog \"NotesMenuScreen.LoadData: Loaded $($notes.Count) notes\" \"INFO\"\r\n\r\n            # Set data in list\r\n            $this.List.SetData($notes)\r\n\r\n        } catch {\r\n            # Write-PmcTuiLog \"NotesMenuScreen.LoadData: Error - $_\" \"ERROR\"\r\n            $this.List.SetData(@())\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Define columns for the notes list\r\n    ##CLOSEBRACKET##\r\n    [array] GetColumns() {\r\n        return @(\r\n            @{\r\n                Name = 'title'\r\n                Label = 'Title'\r\n                Width = 40\r\n                Sortable = $true\r\n                Searchable = $true\r\n            }\r\n            @{\r\n                Name = 'modified'\r\n                Label = 'Modified'\r\n                Width = 20\r\n                Sortable = $true\r\n                Formatter = {\r\n                    param($value)\r\n                    if ($value -is [datetime]) {\r\n                        return $value.ToString(\"yyyy-MM-dd HH:mm\")\r\n                    }\r\n                    return \"\"\r\n                }\r\n            }\r\n            @{\r\n                Name = 'line_count'\r\n                Label = 'Lines'\r\n                Width = 8\r\n                Sortable = $true\r\n                Align = 'right'\r\n            }\r\n            @{\r\n                Name = 'word_count'\r\n                Label = 'Words'\r\n                Width = 8\r\n                Sortable = $true\r\n                Align = 'right'\r\n            }\r\n            @{\r\n                Name = 'tags'\r\n                Label = 'Tags'\r\n                Width = 20\r\n                Formatter = {\r\n                    param($value)\r\n                    if ($value -and $value.Count -gt 0) {\r\n                        return ($value -join \", \")\r\n                    }\r\n                    return \"\"\r\n                }\r\n            }\r\n        )\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Define fields for the add/edit inline editor\r\n    ##CLOSEBRACKET##\r\n    [array] GetEditFields($item) {\r\n        $title = \"\"\r\n        $tags = \"\"\r\n\r\n        if ($item) {\r\n            if ($item -is [hashtable]) {\r\n                $title = $(if ($item.ContainsKey('title')) { $item['title'] } else { \"\" })\r\n                $tags = $(if ($item.ContainsKey('tags') -and $item['tags']) { ($item['tags'] -join \", \") } else { \"\" })\r\n            } else {\r\n                $title = $(if ($item.title) { $item.title } else { \"\" })\r\n                $tags = $(if ($item.tags) { ($item.tags -join \", \") } else { \"\" })\r\n            }\r\n        }\r\n\r\n        return @(\r\n            @{\r\n                Name = 'title'\r\n                Type = 'text'\r\n                Label = 'Title'\r\n                Value = $title\r\n                Required = $true\r\n                MaxLength = 100\r\n            }\r\n            @{\r\n                Name = 'tags'\r\n                Type = 'text'\r\n                Label = 'Tags (comma-separated)'\r\n                Value = $tags\r\n                Required = $false\r\n                MaxLength = 200\r\n            }\r\n        )\r\n    }\r\n\r\n    # === Event Handlers ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle item activation (Enter key) - open note editor\r\n    ##CLOSEBRACKET##\r\n    [void] OnItemActivated($item) {\r\n        # Get ID from item (handle both hashtable and object)\r\n        $noteId = $null\r\n        if ($item) {\r\n            if ($item -is [hashtable]) {\r\n                $noteId = $item['id']\r\n            } else {\r\n                $noteId = $item.id\r\n            }\r\n        }\r\n\r\n        if ($noteId) {\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnItemActivated: Opening note $noteId\" \"INFO\"\r\n\r\n            # Load NoteEditorScreen\r\n            $editorScreenPath = Join-Path $PSScriptRoot \"NoteEditorScreen.ps1\"\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnItemActivated: Editor path: $editorScreenPath\" \"DEBUG\"\r\n\r\n            if (Test-Path $editorScreenPath) {\r\n                # Write-PmcTuiLog \"NotesMenuScreen.OnItemActivated: Loading NoteEditorScreen.ps1\" \"DEBUG\"\r\n                . $editorScreenPath\r\n\r\n                # Write-PmcTuiLog \"NotesMenuScreen.OnItemActivated: Creating NoteEditorScreen instance\" \"DEBUG\"\r\n                $editorScreen = New-Object NoteEditorScreen -ArgumentList $noteId\r\n\r\n                # Write-PmcTuiLog \"NotesMenuScreen.OnItemActivated: Pushing screen to app\" \"DEBUG\"\r\n                $global:PmcApp.PushScreen($editorScreen)\r\n\r\n                # Write-PmcTuiLog \"NotesMenuScreen.OnItemActivated: Screen pushed successfully\" \"INFO\"\r\n            } else {\r\n                # Write-PmcTuiLog \"NotesMenuScreen.OnItemActivated: NoteEditorScreen.ps1 not found at $editorScreenPath\" \"ERROR\"\r\n            }\r\n        } else {\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnItemActivated: No noteId found in item\" \"ERROR\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle add new note (called by StandardListScreen)\r\n    ##CLOSEBRACKET##\r\n    [void] OnItemCreated([hashtable]$data) {\r\n        $this.OnAddItem($data)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle add new note\r\n    ##CLOSEBRACKET##\r\n    [void] OnAddItem([hashtable]$data) {\r\n        # SAVE FIX: Safe property access and validation\r\n        $title = $(if ($data.ContainsKey('title')) { $data.title } else { '' })\r\n        # Write-PmcTuiLog \"NotesMenuScreen.OnAddItem: Creating note '$title'\" \"DEBUG\"\r\n\r\n        try {\r\n            # Validate title\r\n            if ([string]::IsNullOrWhiteSpace($title)) {\r\n                $this.SetStatusMessage(\"Note title is required\", \"error\")\r\n                return\r\n            }\r\n\r\n            # Parse tags\r\n            $tags = @()\r\n            if ($data.ContainsKey('tags') -and -not [string]::IsNullOrWhiteSpace($data.tags)) {\r\n                $tags = $data.tags -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne \"\" }\r\n            }\r\n\r\n            # Create note with owner info\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnAddItem: Calling CreateNote with title='$title' tags=$($tags.Count) owner=$($this._ownerType):$($this._ownerId)\" \"DEBUG\"\r\n            $note = $this._noteService.CreateNote($title, $tags, $this._ownerType, $this._ownerId)\r\n\r\n            if ($null -eq $note) {\r\n                # Write-PmcTuiLog \"NotesMenuScreen.OnAddItem: CreateNote returned null!\" \"ERROR\"\r\n                return\r\n            }\r\n\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnAddItem: Created note, checking for id...\" \"DEBUG\"\r\n            $noteId = $(if ($note -is [hashtable]) { $note['id'] } else { $note.id })\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnAddItem: Note ID = $noteId\" \"INFO\"\r\n\r\n            # Refresh list (will happen automatically via event callback)\r\n            # Open the new note in editor\r\n            $this.OnItemActivated($note)\r\n\r\n        } catch {\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnAddItem: Error - $_\" \"ERROR\"\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnAddItem: Stack trace - $($_.ScriptStackTrace)\" \"ERROR\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle edit note metadata (called by StandardListScreen)\r\n    ##CLOSEBRACKET##\r\n    [void] OnItemUpdated($item, [hashtable]$data) {\r\n        $this.OnEditItem($item, $data)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle edit note metadata\r\n    ##CLOSEBRACKET##\r\n    [void] OnEditItem($item, [hashtable]$data) {\r\n        # SAVE FIX: Safe property access\r\n        $itemId = $(if ($item -is [hashtable]) { $item['id'] } else { $item.id })\r\n        # Write-PmcTuiLog \"NotesMenuScreen.OnEditItem: Updating note $itemId\" \"DEBUG\"\r\n\r\n        try {\r\n            # Validate title\r\n            if (-not $data.ContainsKey('title') -or [string]::IsNullOrWhiteSpace($data.title)) {\r\n                $this.SetStatusMessage(\"Note title is required\", \"error\")\r\n                return\r\n            }\r\n\r\n            # Parse tags\r\n            $tags = @()\r\n            if ($data.ContainsKey('tags') -and $data.tags -and $data.tags.Trim() -ne \"\") {\r\n                $tags = $data.tags -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne \"\" }\r\n            }\r\n\r\n            # Update note metadata\r\n            $changes = @{\r\n                title = $data.title\r\n                tags = $tags\r\n            }\r\n\r\n            $this._noteService.UpdateNoteMetadata($item.id, $changes)\r\n\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnEditItem: Updated note $($item.id)\" \"INFO\"\r\n\r\n            # Refresh list (will happen automatically via event callback)\r\n\r\n        } catch {\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnEditItem: Error - $_\" \"ERROR\"\r\n            $this.SetStatusMessage(\"Failed to update note: $($_.Exception.Message)\", \"error\")\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle delete note (called by StandardListScreen)\r\n    ##CLOSEBRACKET##\r\n    [void] OnItemDeleted($item) {\r\n        $this.OnDeleteItem($item)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle delete note\r\n    ##CLOSEBRACKET##\r\n    [void] OnDeleteItem($item) {\r\n        # Write-PmcTuiLog \"NotesMenuScreen.OnDeleteItem: Deleting note $($item.id)\" \"DEBUG\"\r\n\r\n        try {\r\n            $this._noteService.DeleteNote($item.id)\r\n\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnDeleteItem: Deleted note $($item.id)\" \"INFO\"\r\n\r\n            # Refresh list (will happen automatically via event callback)\r\n\r\n        } catch {\r\n            # Write-PmcTuiLog \"NotesMenuScreen.OnDeleteItem: Error - $_\" \"ERROR\"\r\n            $this.SetStatusMessage(\"Failed to delete note: $($_.Exception.Message)\", \"error\")\r\n        }\r\n    }\r\n\r\n    # === Custom Actions ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Add custom keyboard shortcuts\r\n    ##CLOSEBRACKET##\r\n    [array] GetCustomActions() {\r\n        $self = $this\r\n        return @(\r\n            @{\r\n                Key = 'O'\r\n                Label = 'Open'\r\n                Callback = {\r\n                    $selected = $self.List.GetSelectedItem()\r\n                    if ($selected) {\r\n                        $self.OnItemActivated($selected)\r\n                    }\r\n                }.GetNewClosure()\r\n            },\r\n            @{\r\n                Key = 'P'\r\n                Label = 'Assign Project'\r\n                Callback = {\r\n                    $selected = $self.List.GetSelectedItem()\r\n                    if ($selected) {\r\n                        $self._AssignToProject($selected)\r\n                    }\r\n                }.GetNewClosure()\r\n            }\r\n        )\r\n    }\r\n\r\n    hidden [void] _AssignToProject($note) {\r\n        # Show project picker and reassign note\r\n        $noteId = $(if ($note -is [hashtable]) { $note['id'] } else { $note.id })\r\n        $noteTitle = $(if ($note -is [hashtable]) { $note['title'] } else { $note.title })\r\n\r\n        # Get all projects\r\n        $store = [TaskStore]::GetInstance()\r\n        $projects = @($store.GetAllProjects())\r\n\r\n        if ($projects.Count -eq 0) {\r\n            $this.SetStatusMessage(\"No projects available\", \"error\")\r\n            return\r\n        }\r\n\r\n        # Simple inline selection - show project list in status bar\r\n        # For now, just prompt for project name\r\n        # TODO: Use proper project picker widget when available\r\n        $this.SetStatusMessage(\"Assign '$noteTitle' to project (type name): \", \"info\")\r\n        $this.Render() | Out-Host\r\n\r\n        # Read project name from user\r\n        [Console]::CursorVisible = $true\r\n        $projectName = [Console]::ReadLine()\r\n        [Console]::CursorVisible = $false\r\n\r\n        if ([string]::IsNullOrWhiteSpace($projectName)) {\r\n            $this.SetStatusMessage(\"Assignment cancelled\", \"info\")\r\n            return\r\n        }\r\n\r\n        # Verify project exists\r\n        $projectExists = $projects | Where-Object {\r\n            ($_ -is [string] -and $_ -eq $projectName) -or\r\n            ((Get-SafeProperty $_ 'name') -eq $projectName)\r\n        } | Select-Object -First 1\r\n\r\n        if (-not $projectExists) {\r\n            $this.SetStatusMessage(\"Project '$projectName' not found\", \"error\")\r\n            return\r\n        }\r\n\r\n        # Reassign note\r\n        try {\r\n            $changes = @{\r\n                owner_type = \"project\"\r\n                owner_id = $projectName\r\n            }\r\n            $this._noteService.UpdateNoteMetadata($noteId, $changes)\r\n            $this.SetStatusMessage(\"Note assigned to '$projectName'\", \"success\")\r\n\r\n            # Refresh list\r\n            $this.LoadData()\r\n        } catch {\r\n            $this.SetStatusMessage(\"Failed to assign note: $($_.Exception.Message)\", \"error\")\r\n        }\r\n    }\r\n\r\n    # === Menu Registration ===\r\n\r\n    # H-MEM-2: Cleanup event subscriptions when screen exits\r\n    <#\r\n    .SYNOPSIS\r\n    Called when the screen is about to be exited\r\n    ##CLOSEBRACKET##\r\n    [void] OnDoExit() {\r\n        # Unsubscribe from note service events to prevent memory leaks\r\n        if ($this._noteService) {\r\n            $this._noteService.OnNotesChanged = $null\r\n        }\r\n        # Write-PmcTuiLog \"NotesMenuScreen.OnExit: Cleaned up event subscriptions\" \"DEBUG\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Register menu items for this screen\r\n    ##CLOSEBRACKET##\r\n    static [void] RegisterMenuItems([object]$registry) {\r\n        $registry.AddMenuItem('Tools', 'Notes', 'N', {\r\n            . \"$PSScriptRoot/NotesMenuScreen.ps1\"\r\n            $global:PmcApp.PushScreen((New-Object -TypeName NotesMenuScreen))\r\n        }, 20)\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/screens/ProjectInfoScreenV4.ps1", "content": "# ProjectInfoScreenV4.ps1 - Tabbed interface for project details\r\n#\r\n# Clean implementation using TabbedScreen base class\r\n# Organizes 57 fields into 6 logical tabs:\r\n# - Identity (4 fields)\r\n# - Request (6 fields)\r\n# - Audit (8 fields)\r\n# - Location (7 fields)\r\n# - Periods (12 fields)\r\n# - More (20 fields - contacts, software, misc)\r\n\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Load dependencies\r\n. \"$PSScriptRoot/../base/TabbedScreen.ps1\"\r\n\r\n# Lazy-load SimpleFilePicker when needed (for folder browsing)\r\nfunction EnsureSimpleFilePicker {\r\n    if ($null -eq ([Type]'SimpleFilePicker' -as [Type])) {\r\n        . \"$PSScriptRoot/../widgets/SimpleFilePicker.ps1\"\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nProject information screen with tabbed interface\r\n\r\n.DESCRIPTION\r\nDisplays and edits all project fields organized into 6 tabs:\r\n- Identity: IDs, folder, CAA name\r\n- Request: Request details and dates\r\n- Audit: Auditor information and cases\r\n- Location: Third party and address\r\n- Periods: Audit period date ranges\r\n- More: Contacts, software, comments\r\n\r\nNavigation:\r\n- Tab/Shift+Tab: Cycle through tabs\r\n- 1-6: Jump to specific tab\r\n- Up/Down: Navigate fields\r\n- Enter: Edit current field\r\n- S: Save all changes\r\n\r\n.PARAMETER projectName\r\nName of project to display\r\n##CLOSEBRACKET##\r\nclass ProjectInfoScreenV4 : TabbedScreen {\r\n    # === Data ===\r\n    [string]$ProjectName = \"\"\r\n    [hashtable]$ProjectData = @{}\r\n    [object]$Store = $null\r\n\r\n    # === File Picker ===\r\n    [object]$FilePicker = $null\r\n    [bool]$ShowFilePicker = $false\r\n    [string]$FilePickerFieldName = \"\"\r\n\r\n    # === Constructor ===\r\n    ProjectInfoScreenV4([string]$projectName) : base(\"ProjectInfo\", \"Project Information\") {\r\n        $this.ProjectName = $projectName\r\n        $this.Store = [TaskStore]::GetInstance()\r\n        $this._UpdateBreadcrumb()\r\n    }\r\n\r\n    # Constructor with container\r\n    ProjectInfoScreenV4([object]$container) : base(\"ProjectInfo\", \"Project Information\", $container) {\r\n        $this.Store = $container.Resolve('TaskStore')\r\n        $this._UpdateBreadcrumb()\r\n    }\r\n\r\n    [void] SetProject([string]$projectName) {\r\n        $this.ProjectName = $projectName\r\n        $this._UpdateBreadcrumb()\r\n    }\r\n\r\n    hidden [void] _UpdateBreadcrumb() {\r\n        if ($this.Header) {\r\n            $name = $(if ($this.ProjectName) { $this.ProjectName } else { \"Select Project\" })\r\n            $this.Header.SetBreadcrumb(@(\"Home\", \"Projects\", $name))\r\n        }\r\n    }\r\n\r\n    # === Data Loading ===\r\n\r\n    [void] LoadData() {\r\n        if ([string]::IsNullOrWhiteSpace($this.ProjectName)) {\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetLeftText(\"No project selected\")\r\n                $this.StatusBar.SetRightText(\"\")\r\n            }\r\n            $this.ProjectData = @{}\r\n            $this._BuildTabs()\r\n            return\r\n        }\r\n\r\n        # Load project data from store\r\n        $project = $this.Store.GetProject($this.ProjectName)\r\n\r\n        if ($null -eq $project) {\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"Project not found: $($this.ProjectName)\")\r\n            }\r\n            $this.ProjectData = @{}\r\n            $this._BuildTabs()\r\n            return\r\n        }\r\n\r\n        $this.ProjectData = $project\r\n\r\n        # DEBUG: Log available fields\r\n        $keysDebug = @()\r\n        if ($this.ProjectData -is [hashtable]) {\r\n            $keysDebug = $this.ProjectData.Keys\r\n        } else {\r\n            $keysDebug = $this.ProjectData.PSObject.Properties.Name\r\n        }\r\n\r\n        # Build tabs with current data\r\n        $this._BuildTabs()\r\n\r\n        if ($this.StatusBar) {\r\n            $this.StatusBar.SetLeftText(\"Project: $($this.ProjectName)\")\r\n        }\r\n    }\r\n\r\n    hidden [object] _GetValue([string]$key) {\r\n        # Handle both hashtable and PSCustomObject\r\n        if ($this.ProjectData -is [hashtable]) {\r\n            if ($this.ProjectData.ContainsKey($key)) {\r\n                return $this.ProjectData[$key]\r\n            }\r\n        }\r\n        elseif ($this.ProjectData.PSObject.Properties[$key]) {\r\n            return $this.ProjectData.$key\r\n        }\r\n        return $null\r\n    }\r\n\r\n    hidden [void] _BuildTabs() {\r\n        $this.TabPanel.ClearTabs()\r\n\r\n        # Tab 1: Identity\r\n        $this.TabPanel.AddTab('Identity', @(\r\n                @{Name = 'ID1'; Label = 'Project ID'; Value = $this._GetValue('ID1'); Type = 'text' }\r\n                @{Name = 'ID2'; Label = 'Secondary ID'; Value = $this._GetValue('ID2'); Type = 'text' }\r\n                @{Name = 'Name'; Label = 'Project Name'; Value = $this._GetValue('Name'); Type = 'text' }\r\n                @{Name = 'Description'; Label = 'Description'; Value = $this._GetValue('Description'); Type = 'text' }\r\n            ))\r\n\r\n        # Tab 2: Request\r\n        $this.TabPanel.AddTab('Request', @(\r\n                @{Name = 'RequestType'; Label = 'Request Type'; Value = $this._GetValue('RequestType'); Type = 'text' }\r\n                @{Name = 'Priority'; Label = 'Priority'; Value = $this._GetValue('Priority'); Type = 'text' }\r\n                @{Name = 'Status'; Label = 'Status'; Value = $this._GetValue('Status'); Type = 'text' }\r\n                @{Name = 'DueDate'; Label = 'Due Date'; Value = $this._GetValue('DueDate'); Type = 'date' }\r\n                @{Name = 'BFDate'; Label = 'BF Date'; Value = $this._GetValue('BFDate'); Type = 'date' }\r\n                @{Name = 'RequestDate'; Label = 'Request Date'; Value = $this._GetValue('RequestDate'); Type = 'date' }\r\n            ))\r\n\r\n        # Tab 3: Audit\r\n        $this.TabPanel.AddTab('Audit', @(\r\n                @{Name = 'AuditType'; Label = 'Audit Type'; Value = $this._GetValue('AuditType'); Type = 'text' }\r\n                @{Name = 'AuditorName'; Label = 'Auditor Name'; Value = $this._GetValue('AuditorName'); Type = 'text' }\r\n                @{Name = 'AuditorPhone'; Label = 'Auditor Phone'; Value = $this._GetValue('AuditorPhone'); Type = 'text' }\r\n                @{Name = 'AuditorTL'; Label = 'Auditor Team Lead'; Value = $this._GetValue('AuditorTL'); Type = 'text' }\r\n                @{Name = 'AuditorTLPhone'; Label = 'TL Phone'; Value = $this._GetValue('AuditorTLPhone'); Type = 'text' }\r\n                @{Name = 'AuditCase'; Label = 'Audit Case'; Value = $this._GetValue('AuditCase'); Type = 'text' }\r\n                @{Name = 'CASCase'; Label = 'CAS Case'; Value = $this._GetValue('CASCase'); Type = 'text' }\r\n                @{Name = 'AuditStartDate'; Label = 'Audit Start Date'; Value = $this._GetValue('AuditStartDate'); Type = 'date' }\r\n            ))\r\n\r\n        # Tab 4: Location\r\n        $this.TabPanel.AddTab('Location', @(\r\n                @{Name = 'TPName'; Label = 'Third Party Name'; Value = $this._GetValue('TPName'); Type = 'text' }\r\n                @{Name = 'TPNum'; Label = 'Third Party Number'; Value = $this._GetValue('TPNum'); Type = 'text' }\r\n                @{Name = 'Address'; Label = 'Address'; Value = $this._GetValue('Address'); Type = 'text' }\r\n                @{Name = 'City'; Label = 'City'; Value = $this._GetValue('City'); Type = 'text' }\r\n                @{Name = 'Province'; Label = 'Province'; Value = $this._GetValue('Province'); Type = 'text' }\r\n                @{Name = 'PostalCode'; Label = 'Postal Code'; Value = $this._GetValue('PostalCode'); Type = 'text' }\r\n                @{Name = 'Country'; Label = 'Country'; Value = $this._GetValue('Country'); Type = 'text' }\r\n            ))\r\n\r\n        # Tab 5: Periods\r\n        $this.TabPanel.AddTab('Periods', @(\r\n                @{Name = 'AuditPeriodFrom'; Label = 'Audit Period From'; Value = $this._GetValue('AuditPeriodFrom'); Type = 'date' }\r\n                @{Name = 'AuditPeriodTo'; Label = 'Audit Period To'; Value = $this._GetValue('AuditPeriodTo'); Type = 'date' }\r\n                @{Name = 'Period1Start'; Label = 'Period 1 Start'; Value = $this._GetValue('Period1Start'); Type = 'date' }\r\n                @{Name = 'Period1End'; Label = 'Period 1 End'; Value = $this._GetValue('Period1End'); Type = 'date' }\r\n                @{Name = 'Period2Start'; Label = 'Period 2 Start'; Value = $this._GetValue('Period2Start'); Type = 'date' }\r\n                @{Name = 'Period2End'; Label = 'Period 2 End'; Value = $this._GetValue('Period2End'); Type = 'date' }\r\n                @{Name = 'Period3Start'; Label = 'Period 3 Start'; Value = $this._GetValue('Period3Start'); Type = 'date' }\r\n                @{Name = 'Period3End'; Label = 'Period 3 End'; Value = $this._GetValue('Period3End'); Type = 'date' }\r\n                @{Name = 'Period4Start'; Label = 'Period 4 Start'; Value = $this._GetValue('Period4Start'); Type = 'date' }\r\n                @{Name = 'Period4End'; Label = 'Period 4 End'; Value = $this._GetValue('Period4End'); Type = 'date' }\r\n                @{Name = 'Period5Start'; Label = 'Period 5 Start'; Value = $this._GetValue('Period5Start'); Type = 'date' }\r\n                @{Name = 'Period5End'; Label = 'Period 5 End'; Value = $this._GetValue('Period5End'); Type = 'date' }\r\n            ))\r\n\r\n        # Tab 6: More (Contacts, Software, Misc)\r\n        $this.TabPanel.AddTab('More', @(\r\n                # Contact 1\r\n                @{Name = 'Contact1Name'; Label = 'Contact 1 Name'; Value = $this._GetValue('Contact1Name'); Type = 'text' }\r\n                @{Name = 'Contact1Title'; Label = 'Contact 1 Title'; Value = $this._GetValue('Contact1Title'); Type = 'text' }\r\n                @{Name = 'Contact1Phone'; Label = 'Contact 1 Phone'; Value = $this._GetValue('Contact1Phone'); Type = 'text' }\r\n                @{Name = 'Contact1Email'; Label = 'Contact 1 Email'; Value = $this._GetValue('Contact1Email'); Type = 'text' }\r\n                @{Name = 'Contact1Fax'; Label = 'Contact 1 Fax'; Value = $this._GetValue('Contact1Fax'); Type = 'text' }\r\n                # Contact 2\r\n                @{Name = 'Contact2Name'; Label = 'Contact 2 Name'; Value = $this._GetValue('Contact2Name'); Type = 'text' }\r\n                @{Name = 'Contact2Title'; Label = 'Contact 2 Title'; Value = $this._GetValue('Contact2Title'); Type = 'text' }\r\n                @{Name = 'Contact2Phone'; Label = 'Contact 2 Phone'; Value = $this._GetValue('Contact2Phone'); Type = 'text' }\r\n                @{Name = 'Contact2Email'; Label = 'Contact 2 Email'; Value = $this._GetValue('Contact2Email'); Type = 'text' }\r\n                @{Name = 'Contact2Fax'; Label = 'Contact 2 Fax'; Value = $this._GetValue('Contact2Fax'); Type = 'text' }\r\n                # Software 1\r\n                @{Name = 'Software1Name'; Label = 'Software 1 Name'; Value = $this._GetValue('Software1Name'); Type = 'text' }\r\n                @{Name = 'Software1Version'; Label = 'Software 1 Version'; Value = $this._GetValue('Software1Version'); Type = 'text' }\r\n                @{Name = 'Software1Vendor'; Label = 'Software 1 Vendor'; Value = $this._GetValue('Software1Vendor'); Type = 'text' }\r\n                # Software 2\r\n                @{Name = 'Software2Name'; Label = 'Software 2 Name'; Value = $this._GetValue('Software2Name'); Type = 'text' }\r\n                @{Name = 'Software2Version'; Label = 'Software 2 Version'; Value = $this._GetValue('Software2Version'); Type = 'text' }\r\n                @{Name = 'Software2Vendor'; Label = 'Software 2 Vendor'; Value = $this._GetValue('Software2Vendor'); Type = 'text' }\r\n                # Misc\r\n                @{Name = 'AuditProgram'; Label = 'Audit Program'; Value = $this._GetValue('AuditProgram'); Type = 'text' }\r\n                @{Name = 'Comments'; Label = 'Comments'; Value = $this._GetValue('Comments'); Type = 'text' }\r\n                @{Name = 'FXInfo'; Label = 'FX Info'; Value = $this._GetValue('FXInfo'); Type = 'text' }\r\n                @{Name = 'ShipToAddress'; Label = 'Ship To Address'; Value = $this._GetValue('ShipToAddress'); Type = 'text' }\r\n            ))\r\n\r\n        # Tab 7: Files (Notes, Checklists, Project Files)\r\n        $this.TabPanel.AddTab('Files', @(\r\n                @{Name = '_action_notes'; Label = '> Notes'; Value = 'View and manage project notes'; Type = 'readonly'; IsAction = $true }\r\n                @{Name = '_action_assign_note'; Label = '> Assign Note'; Value = 'Assign existing note to project'; Type = 'readonly'; IsAction = $true }\r\n                @{Name = '_action_checklists'; Label = '> Checklists'; Value = 'View and manage project checklists'; Type = 'readonly'; IsAction = $true }\r\n                @{Name = '_action_assign_checklist'; Label = '> Assign Checklist'; Value = 'Assign existing checklist to project'; Type = 'readonly'; IsAction = $true }\r\n                @{Name = '_separator1'; Label = '--- Project Files ---'; Value = ''; Type = 'readonly' }\r\n                @{Name = 'T2020'; Label = 'T2020 File'; Value = $this._GetValue('T2020'); Type = 'text'; Hint = 'Path to T2020 file (press B to browse)' }\r\n                @{Name = '_action_t2020_browse'; Label = '> Browse T2020'; Value = 'Select file'; Type = 'readonly'; IsAction = $true }\r\n                @{Name = '_action_t2020_open'; Label = '> Open T2020'; Value = 'Open in Notepad'; Type = 'readonly'; IsAction = $true }\r\n                @{Name = '_separator2'; Label = ''; Value = ''; Type = 'readonly' }\r\n                @{Name = 'CAAName'; Label = 'CAA File'; Value = $this._GetValue('CAAName'); Type = 'text'; Hint = 'Path to CAA file (press B to browse)' }\r\n                @{Name = '_action_caa_browse'; Label = '> Browse CAA'; Value = 'Select file'; Type = 'readonly'; IsAction = $true }\r\n                @{Name = '_action_caa_open'; Label = '> Open CAA'; Value = 'Open in Excel'; Type = 'readonly'; IsAction = $true }\r\n                @{Name = '_separator3'; Label = ''; Value = ''; Type = 'readonly' }\r\n                @{Name = 'RequestName'; Label = 'Request File'; Value = $this._GetValue('RequestName'); Type = 'text'; Hint = 'Path to Request file (press B to browse)' }\r\n                @{Name = '_action_request_browse'; Label = '> Browse Request'; Value = 'Select file'; Type = 'readonly'; IsAction = $true }\r\n                @{Name = '_action_request_open'; Label = '> Open Request'; Value = 'Open in Excel'; Type = 'readonly'; IsAction = $true }\r\n                @{Name = '_separator4'; Label = ''; Value = ''; Type = 'readonly' }\r\n                @{Name = 'ProjFolder'; Label = 'Project Folder'; Value = $this._GetValue('ProjFolder'); Type = 'text'; Hint = 'Path to project folder (press B to browse)' }\r\n                @{Name = '_action_folder_browse'; Label = '> Browse Folder'; Value = 'Select folder'; Type = 'readonly'; IsAction = $true }\r\n                @{Name = '_action_folder_open'; Label = '> Open Folder'; Value = 'Open in File Explorer'; Type = 'readonly'; IsAction = $true }\r\n            ))\r\n    }\r\n\r\n    # === Saving ===\r\n\r\n    [void] SaveChanges() {\r\n        # Get all field values from TabPanel\r\n        $values = $this.TabPanel.GetAllValues()\r\n\r\n        if ($global:PmcTuiLogFile) {\r\n            # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: START - project='$($this.ProjectName)' fields=$($values.Count)\"\r\n            # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: Field values: $($values.Keys -join ', ')\"\r\n            # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: Store.AutoSave=$($this.Store.AutoSave)\"\r\n        }\r\n\r\n        # Get project BEFORE update to compare\r\n        $projectBefore = $this.Store.GetProject($this.ProjectName)\r\n        if ($global:PmcTuiLogFile -and $projectBefore) {\r\n            # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: BEFORE update - ID1='$($projectBefore.ID1)'\"\r\n        }\r\n\r\n        # Update project in store (this updates in-memory but doesn't persist)\r\n        $success = $this.Store.UpdateProject($this.ProjectName, $values)\r\n\r\n        if ($success) {\r\n            # Get project AFTER update to verify\r\n            $projectAfter = $this.Store.GetProject($this.ProjectName)\r\n            if ($global:PmcTuiLogFile -and $projectAfter) {\r\n                # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: AFTER UpdateProject - ID1='$($projectAfter.ID1)'\"\r\n            }\r\n\r\n            # FORCE persist to disk (UpdateProject already persists if AutoSave is true)\r\n            # But we double-check by explicitly calling SaveData\r\n            if (-not $this.Store.SaveData()) {\r\n                if ($this.StatusBar) {\r\n                    $this.StatusBar.SetRightText(\"Save to disk failed: $($this.Store.LastError)\")\r\n                }\r\n                if ($global:PmcTuiLogFile) {\r\n                    # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: SaveData FAILED - $($this.Store.LastError)\"\r\n                }\r\n                return\r\n            }\r\n\r\n            # Verify file on disk\r\n            if ($global:PmcTuiLogFile) {\r\n                # Get actual task file path from Pmc module\r\n                $pmcModule = Get-Module -Name 'Pmc.Strict'\r\n                $taskFile = & $pmcModule { Get-PmcTaskFilePath }\r\n                # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: Verifying tasks file: $taskFile\"\r\n                if (Test-Path $taskFile) {\r\n                    try {\r\n                        $fileContent = Get-Content $taskFile -Raw | ConvertFrom-Json\r\n                        $savedProject = $fileContent.projects | Where-Object { $_.name -eq $this.ProjectName } | Select-Object -First 1\r\n                        if ($savedProject) {\r\n                            # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: File verification SUCCESS - project found, ID1='$($savedProject.ID1)'\"\r\n                        }\r\n                        else {\r\n                            # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: File verification FAILED - PROJECT NOT FOUND (projects count=$($fileContent.projects.Count))\"\r\n                        }\r\n                    }\r\n                    catch {\r\n                        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: File verification ERROR - $_\"\r\n                    }\r\n                }\r\n                else {\r\n                    # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: File verification FAILED - FILE DOES NOT EXIST at $taskFile\"\r\n                }\r\n            }\r\n\r\n            # Update status\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"Saved\")\r\n            }\r\n            if ($global:PmcTuiLogFile) {\r\n                # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: SUCCESS - persisted to disk\"\r\n            }\r\n        }\r\n        else {\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"Save failed: $($this.Store.LastError)\")\r\n            }\r\n            if ($global:PmcTuiLogFile) {\r\n                # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.SaveChanges: UpdateProject FAILED - $($this.Store.LastError)\"\r\n            }\r\n        }\r\n    }\r\n\r\n    # === Event Handlers ===\r\n\r\n    [void] OnTabChanged([int]$tabIndex) {\r\n        # Call base implementation\r\n        ([TabbedScreen]$this).OnTabChanged($tabIndex)\r\n\r\n        # Custom handling - could add tab-specific logic here\r\n    }\r\n\r\n    [void] OnFieldEdited($field, $newValue) {\r\n        # Check if this is an action field (Files tab actions)\r\n        if ($field.Name -match '^_action_') {\r\n            $this._HandleFileAction($field.Name)\r\n            return\r\n        }\r\n\r\n        # Auto-save on each field edit\r\n        if ($global:PmcTuiLogFile) {\r\n            # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4.OnFieldEdited: field=$($field.Name) value='$newValue' - auto-saving\"\r\n        }\r\n        $this.SaveChanges()\r\n        # $this.SaveChanges()\r\n\r\n        # Or just log the change\r\n        # Write-PmcTuiLog \"Field '$($field.Name)' changed to: $newValue\" \"DEBUG\"\r\n    }\r\n\r\n    # === File Actions ===\r\n\r\n    hidden [void] _HandleFileAction([string]$action) {\r\n        Write-PmcTuiLog \"ProjectInfoScreenV4._HandleFileAction: action=$action ProjectName='$($this.ProjectName)'\" \"INFO\"\r\n        switch ($action) {\r\n            '_action_notes' {\r\n                # Open NotesMenuScreen for this project\r\n                # Write-PmcTuiLog \"ProjectInfoScreenV4._HandleFileAction: Opening NotesMenuScreen for project='$($this.ProjectName)'\" \"INFO\"\r\n                . \"$PSScriptRoot/NotesMenuScreen.ps1\"\r\n                $notesScreen = New-Object NotesMenuScreen -ArgumentList \"project\", $this.ProjectName, $this.ProjectName\r\n                $global:PmcApp.PushScreen($notesScreen)\r\n            }\r\n            '_action_assign_note' {\r\n                # Show picker to assign existing note to this project\r\n                $this._AssignNote()\r\n            }\r\n            '_action_checklists' {\r\n                # Open ChecklistsMenuScreen for this project\r\n                # Write-PmcTuiLog \"ProjectInfoScreenV4._HandleFileAction: Opening ChecklistsMenuScreen for project='$($this.ProjectName)'\" \"INFO\"\r\n                . \"$PSScriptRoot/ChecklistsMenuScreen.ps1\"\r\n                $checklistsScreen = New-Object ChecklistsMenuScreen -ArgumentList \"project\", $this.ProjectName, $this.ProjectName\r\n                $global:PmcApp.PushScreen($checklistsScreen)\r\n            }\r\n            '_action_assign_checklist' {\r\n                # Show picker to create checklist instance from template for this project\r\n                $this._AssignChecklist()\r\n            }\r\n            '_action_t2020_browse' {\r\n                $this._BrowseForFile('T2020', $false)\r\n            }\r\n            '_action_t2020_open' {\r\n                $path = $this._GetValue('T2020')\r\n                $this._OpenFile($path, 'notepad')\r\n            }\r\n            '_action_caa_browse' {\r\n                $this._BrowseForFile('CAAName', $false)\r\n            }\r\n            '_action_caa_open' {\r\n                $path = $this._GetValue('CAAName')\r\n                $this._OpenFile($path, 'excel')\r\n            }\r\n            '_action_request_browse' {\r\n                $this._BrowseForFile('RequestName', $false)\r\n            }\r\n            '_action_request_open' {\r\n                $path = $this._GetValue('RequestName')\r\n                $this._OpenFile($path, 'excel')\r\n            }\r\n            '_action_folder_browse' {\r\n                $this._BrowseForFile('ProjFolder', $true)\r\n            }\r\n            '_action_folder_open' {\r\n                $path = $this._GetValue('ProjFolder')\r\n                $this._OpenFolder($path)\r\n            }\r\n        }\r\n    }\r\n\r\n    hidden [void] _BrowseForFile([string]$fieldName, [bool]$directoriesOnly) {\r\n        # Get current value as starting path\r\n        Write-PmcTuiLog \"ProjectInfoScreenV4._BrowseForFile: fieldName=$fieldName directoriesOnly=$directoriesOnly\" \"INFO\"\n        $startPath = $this._GetValue($fieldName)\r\n        if ([string]::IsNullOrWhiteSpace($startPath)) {\r\n            $startPath = [Environment]::GetFolderPath('UserProfile')\r\n        }\r\n\r\n        # Create and show file picker\r\n        $this.FilePicker = [PmcFilePicker]::new($startPath, $directoriesOnly)\r\n        $this.ShowFilePicker = $true\r\n        $this.FilePickerFieldName = $fieldName\r\n        Write-PmcTuiLog \"ProjectInfoScreenV4._BrowseForFile: FilePicker created, ShowFilePicker=$($this.ShowFilePicker)\" \"INFO\"\n    }\r\n\r\n    hidden [void] _OpenFile([string]$path, [string]$app) {\r\n        if ([string]::IsNullOrWhiteSpace($path)) {\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"File path not set\")\r\n            }\r\n            return\r\n        }\r\n\r\n        if (-not (Test-Path $path)) {\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"File not found: $path\")\r\n            }\r\n            return\r\n        }\r\n\r\n        try {\r\n            $isWin = [System.Environment]::OSVersion.Platform -eq 'Win32NT'\r\n\r\n            if ($app -eq 'notepad') {\r\n                if ($isWin) {\r\n                    Start-Process notepad.exe -ArgumentList $path\r\n                }\r\n                else {\r\n                    Start-Process xdg-open -ArgumentList $path\r\n                }\r\n            }\r\n            elseif ($app -eq 'excel') {\r\n                if ($isWin) {\r\n                    # Try to find Excel\r\n                    if (Get-Command excel.exe -ErrorAction SilentlyContinue) {\r\n                        Start-Process excel.exe -ArgumentList $path\r\n                    }\r\n                    else {\r\n                        # Fallback to default handler\r\n                        Start-Process $path\r\n                    }\r\n                }\r\n                else {\r\n                    # Try LibreOffice Calc or default handler\r\n                    if (Get-Command libreoffice -ErrorAction SilentlyContinue) {\r\n                        Start-Process libreoffice -ArgumentList \"--calc\", $path\r\n                    }\r\n                    else {\r\n                        Start-Process xdg-open -ArgumentList $path\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                # Default handler\r\n                Start-Process $path\r\n            }\r\n\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"Opened: $path\")\r\n            }\r\n        }\r\n        catch {\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"Error opening file: $($_.Exception.Message)\")\r\n            }\r\n        }\r\n    }\r\n\r\n    hidden [void] _OpenFolder([string]$path) {\r\n        if ([string]::IsNullOrWhiteSpace($path)) {\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"Folder path not set\")\r\n            }\r\n            return\r\n        }\r\n\r\n        if (-not (Test-Path $path)) {\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"Folder not found: $path\")\r\n            }\r\n            return\r\n        }\r\n\r\n        try {\r\n            $isWin = [System.Environment]::OSVersion.Platform -eq 'Win32NT'\r\n\r\n            if ($isWin) {\r\n                Start-Process explorer.exe -ArgumentList $path\r\n            }\r\n            else {\r\n                Start-Process xdg-open -ArgumentList $path\r\n            }\r\n\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"Opened folder: $path\")\r\n            }\r\n        }\r\n        catch {\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"Error opening folder: $($_.Exception.Message)\")\r\n            }\r\n        }\r\n    }\r\n\r\n    hidden [void] _AssignNote() {\r\n        # Load NoteService to get all notes\r\n        . \"$PSScriptRoot/../services/NoteService.ps1\"\r\n        $noteService = [NoteService]::GetInstance()\r\n\r\n        # Get all notes\r\n        $allNotes = @($noteService.GetAllNotes())\r\n\r\n        if ($allNotes.Count -eq 0) {\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"No notes available to assign\")\r\n            }\r\n            return\r\n        }\r\n\r\n        # Create a simple picker screen to select a note\r\n        . \"$PSScriptRoot/NotePickerScreen.ps1\"\r\n        $pickerScreen = New-Object NotePickerScreen -ArgumentList $allNotes, $this.ProjectName\r\n\r\n        # Set callback for when note is selected\r\n        $self = $this\r\n        $pickerScreen.OnNoteSelected = {\r\n            param($noteId)\r\n            # Reassign the note to this project\r\n            $noteService.UpdateNoteMetadata($noteId, @{\r\n                    owner_type = \"project\"\r\n                    owner_id   = $self.ProjectName\r\n                })\r\n\r\n            if ($self.StatusBar) {\r\n                $self.StatusBar.SetRightText(\"Note assigned to project: $($self.ProjectName)\")\r\n            }\r\n        }.GetNewClosure()\r\n\r\n        $global:PmcApp.PushScreen($pickerScreen)\r\n    }\r\n\r\n    hidden [void] _AssignChecklist() {\r\n        # Load ChecklistService to get all templates\r\n        . \"$PSScriptRoot/../services/ChecklistService.ps1\"\r\n        $checklistService = [ChecklistService]::GetInstance()\r\n\r\n        # Get all templates\r\n        $templates = @($checklistService.GetAllTemplates())\r\n\r\n        if ($templates.Count -eq 0) {\r\n            if ($this.StatusBar) {\r\n                $this.StatusBar.SetRightText(\"No checklist templates available\")\r\n            }\r\n            return\r\n        }\r\n\r\n        # Create a simple picker screen to select a template\r\n        . \"$PSScriptRoot/ChecklistTemplatePickerScreen.ps1\"\r\n        $pickerScreen = New-Object ChecklistTemplatePickerScreen -ArgumentList $templates, $this.ProjectName\r\n\r\n        # Set callback for when template is selected\r\n        $self = $this\r\n        $pickerScreen.OnTemplateSelected = {\r\n            param($templateId)\r\n            # Create instance from template for this project\r\n            $instance = $checklistService.CreateInstanceFromTemplate($templateId, \"project\", $self.ProjectName)\r\n\r\n            if ($self.StatusBar) {\r\n                $instanceTitle = $(if ($instance -and $instance.PSObject.Properties['title']) { $instance.title } else { 'Checklist' })\r\n                $self.StatusBar.SetRightText(\"Checklist '$instanceTitle' created for project: $($self.ProjectName)\")\r\n            }\r\n        }.GetNewClosure()\r\n\r\n        $global:PmcApp.PushScreen($pickerScreen)\r\n    }\r\n\r\n    # === Rendering Override ===\r\n    [void] RenderContentToEngine([object]$engine) {\r\n        # Always render base tabbed screen\r\n        ([TabbedScreen]$this).RenderContentToEngine($engine)\r\n\r\n        # File picker as overlay widget on top\r\n        if ($this.ShowFilePicker -and $null -ne $this.FilePicker) {\r\n            # Position as centered dialog widget\r\n            $this.FilePicker.X = [Math]::Max(1, [Math]::Floor(($engine.Width - 70) / 2))\r\n            $this.FilePicker.Y = [Math]::Max(1, [Math]::Floor(($engine.Height - 22) / 2))\r\n            $this.FilePicker.Width = 70\r\n            $this.FilePicker.Height = 22\r\n\r\n            # Render on top layer\r\n            if ($engine.PSObject.Methods['BeginLayer']) {\r\n                $engine.BeginLayer(20)\r\n            }\r\n\r\n            # Render the file picker widget\r\n            if ($this.FilePicker.PSObject.Methods['RenderToEngine']) {\r\n                $this.FilePicker.RenderToEngine($engine)\r\n            }\r\n\r\n            if ($engine.PSObject.Methods['EndLayer']) {\r\n                $engine.EndLayer()\r\n            }\r\n        }\r\n    }\r\n\r\n    # === Input Override ===\r\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\r\n        # CRITICAL: Handle file picker BEFORE calling parent to prevent Enter key from being intercepted\r\n        if ($this.ShowFilePicker -and $null -ne $this.FilePicker) {\r\n            if ($global:PmcTuiLogFile) {\r\n                # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4: File picker active, routing key=$($keyInfo.Key) to picker\"\r\n            }\r\n\r\n            # Route input to file picker\r\n            $handled = $this.FilePicker.HandleInput($keyInfo)\r\n\r\n            if ($global:PmcTuiLogFile) {\r\n                # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4: After HandleInput - handled=$handled IsComplete=$($this.FilePicker.IsComplete)\"\r\n            }\r\n\r\n            # Check if file picker completed\r\n            if ($this.FilePicker.IsComplete) {\r\n                if ($global:PmcTuiLogFile) {\r\n                    # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4: File picker completed - Result=$($this.FilePicker.Result) SelectedPath='$($this.FilePicker.SelectedPath)' FieldName='$($this.FilePickerFieldName)'\"\r\n                }\r\n\r\n                if ($this.FilePicker.Result) {\r\n                    # User selected something\r\n                    $selectedPath = $this.FilePicker.SelectedPath\r\n\r\n                    if ($global:PmcTuiLogFile) {\r\n                        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4: Updating field '$($this.FilePickerFieldName)' with value '$selectedPath'\"\r\n                    }\r\n\r\n                    $this.TabPanel.UpdateFieldValue($this.FilePickerFieldName, $selectedPath)\r\n\r\n                    if ($global:PmcTuiLogFile) {\r\n                        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4: Field updated successfully, saving changes...\"\r\n                    }\r\n\r\n                    # Save the changes to disk\r\n                    try {\r\n                        $this.SaveChanges()\r\n                        if ($this.StatusBar) {\r\n                            $this.StatusBar.SetRightText(\"Selected and saved: $selectedPath\")\r\n                        }\r\n                    }\r\n                    catch {\r\n                        if ($this.StatusBar) {\r\n                            $this.StatusBar.SetRightText(\"Selected but save failed: $_\")\r\n                        }\r\n                        if ($global:PmcTuiLogFile) {\r\n                            # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4: SaveChanges failed - $_\"\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if ($global:PmcTuiLogFile) {\r\n                        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] ProjectInfoScreenV4: File picker cancelled\"\r\n                    }\r\n                    if ($this.StatusBar) {\r\n                        $this.StatusBar.SetRightText(\"Cancelled\")\r\n                    }\r\n                }\r\n                # Close file picker\r\n                $this.ShowFilePicker = $false\r\n                $this.FilePicker = $null\r\n                $this.FilePickerFieldName = \"\"\r\n\r\n                # Force full screen re-render to clear file picker overlay\r\n                $this.NeedsClear = $true\r\n                if ($global:PmcApp) {\r\n                    $global:PmcApp.IsDirty = $true\r\n                }\r\n            }\r\n\r\n            # IMPORTANT: Return true to prevent parent from handling the key\r\n            # This ensures Enter goes to the file picker, not TabbedScreen.EditCurrentField()\r\n            return $true\r\n        }\r\n\r\n        # Otherwise, call parent handler\r\n        return ([TabbedScreen]$this).HandleKeyPress($keyInfo)\r\n    }\r\n}\r\n\r\n# Export\r\nExport-ModuleMember -Variable @()"}, {"path": "module/Pmc.Strict/consoleui/screens/ProjectListScreen.ps1", "content": "using namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# ProjectListScreen - Project list with full CRUD operations using StandardListScreen\r\n# Uses UniversalList widget and InlineEditor for consistent UX\r\n\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n. \"$PSScriptRoot/../base/StandardListScreen.ps1\"\r\n\r\n# LOW FIX PLS-L4, L5, L9: Define constants for magic strings\r\n$global:DEFAULT_STATUS = 'active'\r\n$script:ARCHIVED_STATUS = 'archived'\r\n$script:ARRAY_SEPARATOR = ', '\r\n$global:DATETIME_FORMAT = 'yyyy-MM-dd HH:mm:ss'\r\n$global:DATE_FORMAT = 'yyyy-MM-dd'\r\n$script:SUPPORTED_DATE_FORMATS = @(\r\n    'yyyy-MM-dd'\r\n    'yyyy-MM-dd HH:mm:ss'\r\n    'MM/dd/yyyy'\r\n    'M/d/yyyy'\r\n    'dd/MM/yyyy'\r\n    'd/M/yyyy'\r\n)\r\n\r\n# FIXED PLS-L8, L10: Now using global constants from Constants.ps1\r\n# MAX_PROJECT_NAME_LENGTH = 100 (from Constants.ps1)\r\n# MAX_DESCRIPTION_LENGTH = 4000 (from Constants.ps1)\r\n\r\n<#\r\n.SYNOPSIS\r\nProject list screen with CRUD operations\r\n\r\n.DESCRIPTION\r\nShows all projects with:\r\n- Add/Edit/Delete via InlineEditor (a/e/d keys)\r\n- Archive/Unarchive projects\r\n- View project statistics\r\n- Filter and search projects\r\n\r\nNOTE: Uses lazy-loaded PmcFilePicker widget for folder browsing\r\n##CLOSEBRACKET##\r\nclass ProjectListScreen : StandardListScreen {\r\n    # LOW FIX PLS-L1: File picker and flag for overlay display (lazy-loaded for performance)\r\n    [object]$FilePicker = $null\r\n    [bool]$ShowFilePicker = $false\r\n\r\n    # Static: Register menu items\r\n    static [void] RegisterMenuItems([object]$registry) {\r\n        $registry.AddMenuItem('Projects', 'Project List', 'L', {\r\n                . \"$PSScriptRoot/ProjectListScreen.ps1\"\r\n                $global:PmcApp.PushScreen((New-Object -TypeName ProjectListScreen))\r\n            }, 10)\r\n    }\r\n\r\n    # LOW FIX PLS-L3: Extract common initialization to helper method\r\n    hidden [void] ConfigureCapabilities() {\r\n        # Write-PmcTuiLog \"!!! ProjectListScreen.ConfigureCapabilities CALLED !!!\" \"INFO\"\r\n        # Configure capabilities\r\n        $this.AllowAdd = $true\r\n        $this.AllowEdit = $true\r\n        $this.AllowDelete = $true\r\n        $this.AllowFilter = $true\r\n\r\n        # Configure inline editor layout mode for horizontal (inline) editing\r\n        $this.InlineEditor.LayoutMode = 'horizontal'\r\n\r\n        # Configure header\r\n        if ($this.Header) {\r\n            $this.Header.SetBreadcrumb(@(\"Home\", \"Projects\"))\r\n        }\r\n\r\n        # Configure list actions (Add/Edit/Delete + custom actions like V key)\r\n        # Write-PmcTuiLog \"!!! About to call _ConfigureListActions !!!\" \"INFO\"\r\n        try {\r\n            $this._ConfigureListActions()\r\n            # Write-PmcTuiLog \"!!! _ConfigureListActions completed successfully !!!\" \"INFO\"\r\n        }\r\n        catch {\r\n            # Write-PmcTuiLog \"!!! ERROR in _ConfigureListActions: $_\" \"ERROR\"\r\n            # Write-PmcTuiLog \"!!! Stack: $($_.ScriptStackTrace)\" \"ERROR\"\r\n        }\r\n\r\n        # Currently uses default columns from UniversalList (works as expected)\r\n        # Future enhancement: Add ConfigureColumns() method to StandardListScreen for custom column layouts\r\n    }\r\n\r\n    # LOW FIX PLS-L6: Extract duplicate parseArrayField helper to class method\r\n    hidden [array] ParseArrayField([hashtable]$values, [string]$fieldName) {\r\n        if ($values.ContainsKey($fieldName) -and $null -ne $values.$fieldName -and $values.$fieldName.Trim()) {\r\n            return @($values.$fieldName -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ })\r\n        }\r\n        return @()\r\n    }\r\n\r\n    # LOW FIX PLS-L6: Extract duplicate formatDate helper to class method\r\n    hidden [object] FormatDateField([hashtable]$values, [string]$fieldName) {\r\n        if ($values.ContainsKey($fieldName) -and $values.$fieldName -is [DateTime]) {\r\n            return $values.$fieldName\r\n        }\r\n        return $null\r\n    }\r\n\r\n    # Constructor\r\n    ProjectListScreen() : base(\"ProjectList\", \"Projects\") {\r\n        # Write-PmcTuiLog \"!!! ProjectListScreen() constructor (no container) called !!!\" \"INFO\"\r\n        $this.ConfigureCapabilities()\r\n        # Write-PmcTuiLog \"!!! ProjectListScreen() constructor complete !!!\" \"INFO\"\r\n    }\r\n\r\n    # Constructor with container (DI-enabled)\r\n    ProjectListScreen([object]$container) : base(\"ProjectList\", \"Projects\", $container) {\r\n        # Write-PmcTuiLog \"!!! ProjectListScreen(container) constructor called !!!\" \"INFO\"\r\n        $this.ConfigureCapabilities()\r\n        # Write-PmcTuiLog \"!!! ProjectListScreen(container) constructor complete !!!\" \"INFO\"\r\n    }\r\n\r\n    # === Abstract Method Implementations ===\r\n\r\n    # Get entity type for store operations\r\n    [string] GetEntityType() {\r\n        return 'project'\r\n    }\r\n\r\n    # Load data and refresh list (required by StandardListScreen)\r\n    [void] LoadData() {\r\n        $items = $this.LoadItems()\r\n        $this.List.SetData($items)\r\n    }\r\n\r\n    # Load items from data store\r\n    [array] LoadItems() {\r\n        # CRITICAL FIX PLS-C1: Add null check on GetAllProjects()\r\n        $projects = $this.Store.GetAllProjects()\r\n        if ($null -eq $projects) {\r\n            # Write-PmcTuiLog \"ProjectListScreen.LoadItems: GetAllProjects() returned null\" \"ERROR\"\r\n            $projects = @()\r\n        }\r\n\r\n        # PERFORMANCE FIX: Load all tasks once and build hashtable index - O(n) instead of O(n*m)\r\n        # CRITICAL FIX PLS-C2: Add null check on GetAllTasks()\r\n        $allTasks = $this.Store.GetAllTasks()\r\n        if ($null -eq $allTasks) {\r\n            # Write-PmcTuiLog \"ProjectListScreen.LoadItems: GetAllTasks() returned null\" \"WARNING\"\r\n            $allTasks = @()\r\n        }\r\n        $tasksByProject = @{}\r\n        # CRITICAL FIX PLS-C3: Ensure $allTasks is array\r\n        foreach ($task in @($allTasks)) {\r\n            # HIGH FIX PLS-H3: Validate before using as hashtable key\r\n            $projName = Get-SafeProperty $task 'project'\r\n            if ($projName -and -not [string]::IsNullOrWhiteSpace($projName)) {\r\n                if (-not $tasksByProject.ContainsKey($projName)) {\r\n                    $tasksByProject[$projName] = 0\r\n                }\r\n                $tasksByProject[$projName]++\r\n            }\r\n        }\r\n\r\n        # Add computed fields with O(1) lookup\r\n        # CRITICAL FIX PLS-C4: Ensure $projects is array\r\n        foreach ($project in @($projects)) {\r\n            # Count tasks in this project using hashtable lookup\r\n            $projName = Get-SafeProperty $project 'name'\r\n            $project['task_count'] = $(if ($tasksByProject.ContainsKey($projName)) {\r\n                    $tasksByProject[$projName]\r\n                }\r\n                else { 0 })\r\n\r\n            # PS-M3 FIX: Don't always default status to 'active' for existing projects\r\n            # Only add status if it's missing (preserve archived, etc.)\r\n            # If status is genuinely missing, leave it empty rather than assuming 'active'\r\n            if (-not $project.ContainsKey('status') -or $null -eq $project['status']) {\r\n                $project['status'] = ''\r\n            }\r\n        }\r\n\r\n        return $projects\r\n    }\r\n\r\n    # Define columns for list display\r\n    [array] GetColumns() {\r\n        # Use fixed widths that match the visual layout\r\n        return @(\r\n            @{ Name = 'name'; Label = 'Project'; Width = 41; Align = 'left' }\r\n            @{ Name = 'status'; Label = 'Status'; Width = 19; Align = 'left' }\r\n            @{ Name = 'task_count'; Label = 'Tasks'; Width = 10; Align = 'center' }\r\n            @{ Name = 'description'; Label = 'Description'; Width = 62; Align = 'left' }\r\n        )\r\n    }\r\n\r\n    # Define edit fields for InlineEditor (only core fields for quick add/edit)\r\n    # Full field editing is available via the Project Detail view (V action)\r\n    [array] GetEditFields([object]$item) {\r\n        try {\r\n            # CRITICAL: Edit fields must match the full visual layout of GetColumns()\r\n            # GetColumns displays: name=41, status=19, task_count=10, description=62 (total 132)\r\n            # For inline editing, span the full width with only name and description editable\r\n            # Status and task_count are read-only, so we skip them and give their space to name and description\r\n\r\n            # Match the column widths exactly - this is what the user sees on screen\r\n            $nameWidth = 41\r\n            $statusWidth = 19    # Not editable - read-only\r\n            $taskCountWidth = 10 # Not editable - read-only\r\n            $descWidth = 62\r\n\r\n            if ($null -eq $item -or $item.Count -eq 0) {\r\n                # New project\r\n                # Write-PmcTuiLog \"ProjectListScreen.GetEditFields: Creating NEW project fields\" \"DEBUG\"\r\n                return @(\r\n                    @{ Name = 'name'; Type = 'text'; Label = 'Project'; Required = $true; Value = ''; MaxLength = $global:MAX_PROJECT_NAME_LENGTH; Width = $nameWidth }\r\n                    @{ Name = 'description'; Type = 'text'; Label = 'Description'; Value = ''; Width = $descWidth }\r\n                )\r\n            }\r\n            else {\r\n                # Existing project\r\n                # Write-PmcTuiLog \"ProjectListScreen.GetEditFields: Editing existing project '$($item.name)'\" \"DEBUG\"\r\n                return @(\r\n                    @{ Name = 'name'; Type = 'text'; Label = 'Project'; Required = $true; Value = (Get-SafeProperty $item 'name'); MaxLength = $global:MAX_PROJECT_NAME_LENGTH; Width = $nameWidth }\r\n                    @{ Name = 'description'; Type = 'text'; Label = 'Description'; Value = (Get-SafeProperty $item 'description'); Width = $descWidth }\r\n                )\r\n            }\r\n        }\r\n        catch {\r\n            # Write-PmcTuiLog \"ProjectListScreen.GetEditFields: ERROR - $_\" \"ERROR\"\r\n            # Write-PmcTuiLog \"Stack: $($_.ScriptStackTrace)\" \"ERROR\"\r\n            return @()\r\n        }\r\n    }\r\n\r\n    # Handle item creation\r\n    [void] OnItemCreated([hashtable]$values) {\r\n        if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\r\n            # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: CALLED with values: $($values | ConvertTo-Json -Compress)\" \"DEBUG\"\r\n        }\r\n        try {\r\n            # Validate required field\r\n            if (-not $values.ContainsKey('name') -or [string]::IsNullOrWhiteSpace($values.name)) {\r\n                # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: Name validation failed\" \"DEBUG\"\r\n                $this.SetStatusMessage(\"Project name is required\", \"error\")\r\n                return\r\n            }\r\n            # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: Name validation passed\" \"DEBUG\"\r\n\r\n            # Validate name length\r\n            # HIGH FIX PLS-H1 & PLS-H2: Add null check before .Length access\r\n            # MEDIUM FIX PLS-M4: Use constant for max length validation\r\n            if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\r\n                # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: Checking name length: '$($values.name)' (len=$($values.name.Length)) vs max=$global:MAX_PROJECT_NAME_LENGTH\" \"DEBUG\"\r\n            }\r\n            if ($null -ne $values.name -and $values.name.Length -gt $global:MAX_PROJECT_NAME_LENGTH) {\r\n                # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: Name too long\" \"DEBUG\"\r\n                $this.SetStatusMessage(\"Project name must be $global:MAX_PROJECT_NAME_LENGTH characters or less\", \"error\")\r\n                return\r\n            }\r\n\r\n            # Validate description length if provided\r\n            # MEDIUM FIX PLS-M5: Use constant for max description length validation\r\n            if ($values.ContainsKey('description') -and $values.description -and $values.description.Length -gt $global:MAX_DESCRIPTION_LENGTH) {\r\n                # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: Description too long\" \"DEBUG\"\r\n                $this.SetStatusMessage(\"Description must be $global:MAX_DESCRIPTION_LENGTH characters or less\", \"error\")\r\n                return\r\n            }\r\n\r\n            # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: Parsing tags...\" \"DEBUG\"\r\n            # LOW FIX PLS-L6: Use class-level helper methods instead of inline closures\r\n            # Parse tags\r\n            $tags = $this.ParseArrayField($values, 'tags')\r\n\r\n            # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: Getting existing projects...\" \"DEBUG\"\r\n            # Check for duplicate project name before creating\r\n            # CRITICAL FIX PLS-C5: Add null check on GetAllProjects()\r\n            $existingProjects = $this.Store.GetAllProjects()\r\n            if ($null -eq $existingProjects) { $existingProjects = @() }\r\n\r\n            # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: Building projectData...\" \"DEBUG\"\r\n            $projectData = @{\r\n                id                       = [guid]::NewGuid().ToString()\r\n                name                     = $values.name\r\n                description              = $(if ($values.ContainsKey('description')) { $values.description } else { '' })\r\n                # CRITICAL FIX: Use datetime object, not string (validation expects datetime type)\r\n                created                  = Get-Date\r\n                # MEDIUM FIX PLS-M3: Use script-level constant for default status\r\n                status                   = $(if ($values.ContainsKey('status')) { $values.status } else { $global:DEFAULT_STATUS })\r\n                tags                     = $tags\r\n\r\n                # ID fields\r\n                ID1                      = $(if ($values.ContainsKey('ID1')) { $values.ID1 } else { '' })\r\n                ID2                      = $(if ($values.ContainsKey('ID2')) { $values.ID2 } else { '' })\r\n\r\n                # Path fields\r\n                ProjFolder               = $(if ($values.ContainsKey('ProjFolder')) { $values.ProjFolder } else { '' })\r\n                CAAName                  = $(if ($values.ContainsKey('CAAName')) { $values.CAAName } else { '' })\r\n                RequestName              = $(if ($values.ContainsKey('RequestName')) { $values.RequestName } else { '' })\r\n                T2020                    = $(if ($values.ContainsKey('T2020')) { $values.T2020 } else { '' })\r\n\r\n                # Date fields\r\n                AssignedDate             = $this.FormatDateField($values, 'AssignedDate')\r\n                DueDate                  = $this.FormatDateField($values, 'DueDate')\r\n                BFDate                   = $this.FormatDateField($values, 'BFDate')\r\n\r\n                # Project Info (9 fields)\r\n                RequestDate              = $this.FormatDateField($values, 'RequestDate')\r\n                AuditType                = $(if ($values.ContainsKey('AuditType')) { $values.AuditType } else { '' })\r\n                AuditorName              = $(if ($values.ContainsKey('AuditorName')) { $values.AuditorName } else { '' })\r\n                AuditorPhone             = $(if ($values.ContainsKey('AuditorPhone')) { $values.AuditorPhone } else { '' })\r\n                AuditorTL                = $(if ($values.ContainsKey('AuditorTL')) { $values.AuditorTL } else { '' })\r\n                AuditorTLPhone           = $(if ($values.ContainsKey('AuditorTLPhone')) { $values.AuditorTLPhone } else { '' })\r\n                AuditCase                = $(if ($values.ContainsKey('AuditCase')) { $values.AuditCase } else { '' })\r\n                CASCase                  = $(if ($values.ContainsKey('CASCase')) { $values.CASCase } else { '' })\r\n                AuditStartDate           = $this.FormatDateField($values, 'AuditStartDate')\r\n\r\n                # Contact Details (10 fields)\r\n                TPName                   = $(if ($values.ContainsKey('TPName')) { $values.TPName } else { '' })\r\n                TPNum                    = $(if ($values.ContainsKey('TPNum')) { $values.TPNum } else { '' })\r\n                Address                  = $(if ($values.ContainsKey('Address')) { $values.Address } else { '' })\r\n                City                     = $(if ($values.ContainsKey('City')) { $values.City } else { '' })\r\n                Province                 = $(if ($values.ContainsKey('Province')) { $values.Province } else { '' })\r\n                PostalCode               = $(if ($values.ContainsKey('PostalCode')) { $values.PostalCode } else { '' })\r\n                Country                  = $(if ($values.ContainsKey('Country')) { $values.Country } else { '' })\r\n\r\n                # Audit Periods (10 fields)\r\n                AuditPeriodFrom          = $this.FormatDateField($values, 'AuditPeriodFrom')\r\n                AuditPeriodTo            = $this.FormatDateField($values, 'AuditPeriodTo')\r\n                AuditPeriod1Start        = $this.FormatDateField($values, 'AuditPeriod1Start')\r\n                AuditPeriod1End          = $this.FormatDateField($values, 'AuditPeriod1End')\r\n                AuditPeriod2Start        = $this.FormatDateField($values, 'AuditPeriod2Start')\r\n                AuditPeriod2End          = $this.FormatDateField($values, 'AuditPeriod2End')\r\n                AuditPeriod3Start        = $this.FormatDateField($values, 'AuditPeriod3Start')\r\n                AuditPeriod3End          = $this.FormatDateField($values, 'AuditPeriod3End')\r\n                AuditPeriod4Start        = $this.FormatDateField($values, 'AuditPeriod4Start')\r\n                AuditPeriod4End          = $this.FormatDateField($values, 'AuditPeriod4End')\r\n                AuditPeriod5Start        = $this.FormatDateField($values, 'AuditPeriod5Start')\r\n                AuditPeriod5End          = $this.FormatDateField($values, 'AuditPeriod5End')\r\n\r\n                # Contacts (10 fields)\r\n                Contact1Name             = $(if ($values.ContainsKey('Contact1Name')) { $values.Contact1Name } else { '' })\r\n                Contact1Phone            = $(if ($values.ContainsKey('Contact1Phone')) { $values.Contact1Phone } else { '' })\r\n                Contact1Ext              = $(if ($values.ContainsKey('Contact1Ext')) { $values.Contact1Ext } else { '' })\r\n                Contact1Address          = $(if ($values.ContainsKey('Contact1Address')) { $values.Contact1Address } else { '' })\r\n                Contact1Title            = $(if ($values.ContainsKey('Contact1Title')) { $values.Contact1Title } else { '' })\r\n                Contact2Name             = $(if ($values.ContainsKey('Contact2Name')) { $values.Contact2Name } else { '' })\r\n                Contact2Phone            = $(if ($values.ContainsKey('Contact2Phone')) { $values.Contact2Phone } else { '' })\r\n                Contact2Ext              = $(if ($values.ContainsKey('Contact2Ext')) { $values.Contact2Ext } else { '' })\r\n                Contact2Address          = $(if ($values.ContainsKey('Contact2Address')) { $values.Contact2Address } else { '' })\r\n                Contact2Title            = $(if ($values.ContainsKey('Contact2Title')) { $values.Contact2Title } else { '' })\r\n\r\n                # System Info (7 fields)\r\n                AuditProgram             = $(if ($values.ContainsKey('AuditProgram')) { $values.AuditProgram } else { '' })\r\n                AccountingSoftware1      = $(if ($values.ContainsKey('AccountingSoftware1')) { $values.AccountingSoftware1 } else { '' })\r\n                AccountingSoftware1Other = $(if ($values.ContainsKey('AccountingSoftware1Other')) { $values.AccountingSoftware1Other } else { '' })\r\n                AccountingSoftware1Type  = $(if ($values.ContainsKey('AccountingSoftware1Type')) { $values.AccountingSoftware1Type } else { '' })\r\n                AccountingSoftware2      = $(if ($values.ContainsKey('AccountingSoftware2')) { $values.AccountingSoftware2 } else { '' })\r\n                AccountingSoftware2Other = $(if ($values.ContainsKey('AccountingSoftware2Other')) { $values.AccountingSoftware2Other } else { '' })\r\n                AccountingSoftware2Type  = $(if ($values.ContainsKey('AccountingSoftware2Type')) { $values.AccountingSoftware2Type } else { '' })\r\n                Comments                 = $(if ($values.ContainsKey('Comments')) { $values.Comments } else { '' })\r\n\r\n                # Additional (2 fields)\r\n                FXInfo                   = $(if ($values.ContainsKey('FXInfo')) { $values.FXInfo } else { '' })\r\n                ShipToAddress            = $(if ($values.ContainsKey('ShipToAddress')) { $values.ShipToAddress } else { '' })\r\n            }\r\n\r\n            # Use ValidationHelper for comprehensive validation (already loaded by ClassLoader)\r\n            # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: Calling Test-ProjectValid...\" \"DEBUG\"\r\n            $validationResult = Test-ProjectValid $projectData -existingProjects $existingProjects\r\n            # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: Validation result IsValid=$($validationResult.IsValid)\" \"DEBUG\"\r\n\r\n            if (-not $validationResult.IsValid) {\r\n                # Show ALL validation errors\r\n                $errorMsg = $(if ($validationResult.Errors.Count -gt 0) {\r\n                        $validationResult.Errors -join '; '\r\n                    }\r\n                    else {\r\n                        \"Validation failed\"\r\n                    })\r\n                $this.SetStatusMessage($errorMsg, \"error\")\r\n                # Write-PmcTuiLog \"Project validation failed: $($validationResult.Errors -join ', ')\" \"ERROR\"\r\n                return\r\n            }\r\n\r\n            # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: Calling Store.AddProject...\" \"DEBUG\"\r\n            $success = $this.Store.AddProject($projectData)\r\n            # Write-PmcTuiLog \"ProjectListScreen.OnItemCreated: AddProject returned success=$success\" \"DEBUG\"\r\n            if ($success) {\r\n                $this.SetStatusMessage(\"Project created: $($projectData.name)\", \"success\")\r\n            }\r\n            else {\r\n                $this.SetStatusMessage(\"Failed to create project: $($this.Store.LastError)\", \"error\")\r\n            }\r\n        }\r\n        catch {\r\n            # Write-PmcTuiLog \"OnItemCreated exception: $_\" \"ERROR\"\r\n            $this.SetStatusMessage(\"Unexpected error: $($_.Exception.Message)\", \"error\")\r\n        }\r\n    }\r\n\r\n    # Handle item update\r\n    [void] OnItemUpdated([object]$item, [hashtable]$values) {\r\n        try {\r\n            # ENDEMIC FIX: Validate required field\r\n            if (-not $values.ContainsKey('name') -or [string]::IsNullOrWhiteSpace($values.name)) {\r\n                $this.SetStatusMessage(\"Project name is required\", \"error\")\r\n                return\r\n            }\r\n\r\n            # LOW FIX PLS-L6: Use class-level helper methods instead of inline closures\r\n            # Parse tags\r\n            $tags = $this.ParseArrayField($values, 'tags')\r\n\r\n            # PS-M3 FIX: Preserve existing status if not being changed\r\n            $statusValue = $(if ($values.ContainsKey('status') -and -not [string]::IsNullOrWhiteSpace($values.status)) {\r\n                    $values.status\r\n                }\r\n                else {\r\n                    # Preserve existing status from item\r\n                    Get-SafeProperty $item 'status'\r\n                })\r\n\r\n            $changes = @{\r\n                name                     = $values.name\r\n                description              = $(if ($values.ContainsKey('description')) { $values.description } else { '' })\r\n                status                   = $statusValue\r\n                tags                     = $tags\r\n\r\n                # ID fields\r\n                ID1                      = $(if ($values.ContainsKey('ID1')) { $values.ID1 } else { '' })\r\n                ID2                      = $(if ($values.ContainsKey('ID2')) { $values.ID2 } else { '' })\r\n\r\n                # Path fields\r\n                ProjFolder               = $(if ($values.ContainsKey('ProjFolder')) { $values.ProjFolder } else { '' })\r\n                CAAName                  = $(if ($values.ContainsKey('CAAName')) { $values.CAAName } else { '' })\r\n                RequestName              = $(if ($values.ContainsKey('RequestName')) { $values.RequestName } else { '' })\r\n                T2020                    = $(if ($values.ContainsKey('T2020')) { $values.T2020 } else { '' })\r\n\r\n                # Date fields\r\n                AssignedDate             = $this.FormatDateField($values, 'AssignedDate')\r\n                DueDate                  = $this.FormatDateField($values, 'DueDate')\r\n                BFDate                   = $this.FormatDateField($values, 'BFDate')\r\n\r\n                # Project Info (9 fields)\r\n                RequestDate              = $this.FormatDateField($values, 'RequestDate')\r\n                AuditType                = $(if ($values.ContainsKey('AuditType')) { $values.AuditType } else { '' })\r\n                AuditorName              = $(if ($values.ContainsKey('AuditorName')) { $values.AuditorName } else { '' })\r\n                AuditorPhone             = $(if ($values.ContainsKey('AuditorPhone')) { $values.AuditorPhone } else { '' })\r\n                AuditorTL                = $(if ($values.ContainsKey('AuditorTL')) { $values.AuditorTL } else { '' })\r\n                AuditorTLPhone           = $(if ($values.ContainsKey('AuditorTLPhone')) { $values.AuditorTLPhone } else { '' })\r\n                AuditCase                = $(if ($values.ContainsKey('AuditCase')) { $values.AuditCase } else { '' })\r\n                CASCase                  = $(if ($values.ContainsKey('CASCase')) { $values.CASCase } else { '' })\r\n                AuditStartDate           = $this.FormatDateField($values, 'AuditStartDate')\r\n\r\n                # Contact Details (10 fields)\r\n                TPName                   = $(if ($values.ContainsKey('TPName')) { $values.TPName } else { '' })\r\n                TPNum                    = $(if ($values.ContainsKey('TPNum')) { $values.TPNum } else { '' })\r\n                Address                  = $(if ($values.ContainsKey('Address')) { $values.Address } else { '' })\r\n                City                     = $(if ($values.ContainsKey('City')) { $values.City } else { '' })\r\n                Province                 = $(if ($values.ContainsKey('Province')) { $values.Province } else { '' })\r\n                PostalCode               = $(if ($values.ContainsKey('PostalCode')) { $values.PostalCode } else { '' })\r\n                Country                  = $(if ($values.ContainsKey('Country')) { $values.Country } else { '' })\r\n\r\n                # Audit Periods (10 fields)\r\n                AuditPeriodFrom          = $this.FormatDateField($values, 'AuditPeriodFrom')\r\n                AuditPeriodTo            = $this.FormatDateField($values, 'AuditPeriodTo')\r\n                AuditPeriod1Start        = $this.FormatDateField($values, 'AuditPeriod1Start')\r\n                AuditPeriod1End          = $this.FormatDateField($values, 'AuditPeriod1End')\r\n                AuditPeriod2Start        = $this.FormatDateField($values, 'AuditPeriod2Start')\r\n                AuditPeriod2End          = $this.FormatDateField($values, 'AuditPeriod2End')\r\n                AuditPeriod3Start        = $this.FormatDateField($values, 'AuditPeriod3Start')\r\n                AuditPeriod3End          = $this.FormatDateField($values, 'AuditPeriod3End')\r\n                AuditPeriod4Start        = $this.FormatDateField($values, 'AuditPeriod4Start')\r\n                AuditPeriod4End          = $this.FormatDateField($values, 'AuditPeriod4End')\r\n                AuditPeriod5Start        = $this.FormatDateField($values, 'AuditPeriod5Start')\r\n                AuditPeriod5End          = $this.FormatDateField($values, 'AuditPeriod5End')\r\n\r\n                # Contacts (10 fields)\r\n                Contact1Name             = $(if ($values.ContainsKey('Contact1Name')) { $values.Contact1Name } else { '' })\r\n                Contact1Phone            = $(if ($values.ContainsKey('Contact1Phone')) { $values.Contact1Phone } else { '' })\r\n                Contact1Ext              = $(if ($values.ContainsKey('Contact1Ext')) { $values.Contact1Ext } else { '' })\r\n                Contact1Address          = $(if ($values.ContainsKey('Contact1Address')) { $values.Contact1Address } else { '' })\r\n                Contact1Title            = $(if ($values.ContainsKey('Contact1Title')) { $values.Contact1Title } else { '' })\r\n                Contact2Name             = $(if ($values.ContainsKey('Contact2Name')) { $values.Contact2Name } else { '' })\r\n                Contact2Phone            = $(if ($values.ContainsKey('Contact2Phone')) { $values.Contact2Phone } else { '' })\r\n                Contact2Ext              = $(if ($values.ContainsKey('Contact2Ext')) { $values.Contact2Ext } else { '' })\r\n                Contact2Address          = $(if ($values.ContainsKey('Contact2Address')) { $values.Contact2Address } else { '' })\r\n                Contact2Title            = $(if ($values.ContainsKey('Contact2Title')) { $values.Contact2Title } else { '' })\r\n\r\n                # System Info (7 fields)\r\n                AuditProgram             = $(if ($values.ContainsKey('AuditProgram')) { $values.AuditProgram } else { '' })\r\n                AccountingSoftware1      = $(if ($values.ContainsKey('AccountingSoftware1')) { $values.AccountingSoftware1 } else { '' })\r\n                AccountingSoftware1Other = $(if ($values.ContainsKey('AccountingSoftware1Other')) { $values.AccountingSoftware1Other } else { '' })\r\n                AccountingSoftware1Type  = $(if ($values.ContainsKey('AccountingSoftware1Type')) { $values.AccountingSoftware1Type } else { '' })\r\n                AccountingSoftware2      = $(if ($values.ContainsKey('AccountingSoftware2')) { $values.AccountingSoftware2 } else { '' })\r\n                AccountingSoftware2Other = $(if ($values.ContainsKey('AccountingSoftware2Other')) { $values.AccountingSoftware2Other } else { '' })\r\n                AccountingSoftware2Type  = $(if ($values.ContainsKey('AccountingSoftware2Type')) { $values.AccountingSoftware2Type } else { '' })\r\n                Comments                 = $(if ($values.ContainsKey('Comments')) { $values.Comments } else { '' })\r\n\r\n                # Additional (2 fields)\r\n                FXInfo                   = $(if ($values.ContainsKey('FXInfo')) { $values.FXInfo } else { '' })\r\n                ShipToAddress            = $(if ($values.ContainsKey('ShipToAddress')) { $values.ShipToAddress } else { '' })\r\n            }\r\n\r\n            # PS-M1 FIX: Add validation before Store.UpdateProject()\r\n            # Validate name length\r\n            # HIGH FIX PLS-H1 & PLS-H2: Add null check before .Length access\r\n            # MEDIUM FIX PLS-M4: Use constant for max length validation\r\n            if ($null -ne $values.name -and $values.name.Length -gt $global:MAX_PROJECT_NAME_LENGTH) {\r\n                $this.SetStatusMessage(\"Project name must be $global:MAX_PROJECT_NAME_LENGTH characters or less\", \"error\")\r\n                return\r\n            }\r\n\r\n            # Validate description length if provided\r\n            # MEDIUM FIX PLS-M5: Use constant for max description length validation\r\n            if ($values.ContainsKey('description') -and $values.description -and $values.description.Length -gt $global:MAX_DESCRIPTION_LENGTH) {\r\n                $this.SetStatusMessage(\"Description must be $global:MAX_DESCRIPTION_LENGTH characters or less\", \"error\")\r\n                return\r\n            }\r\n\r\n            # Validate that original project exists\r\n            $originalName = Get-SafeProperty $item 'name'\r\n            if ([string]::IsNullOrWhiteSpace($originalName)) {\r\n                $this.SetStatusMessage(\"Cannot update project: original project name is missing\", \"error\")\r\n                return\r\n            }\r\n\r\n            # If name is changing, check for duplicate name\r\n            # HIGH FIX PLS-H3: Use case-insensitive comparison to prevent \"Project1\" and \"project1\"\r\n            if ($values.name -ne $originalName) {\r\n                # CRITICAL FIX PLS-C6: Add null check\r\n                $existingProjects = $this.Store.GetAllProjects()\r\n                if ($null -eq $existingProjects) { $existingProjects = @() }\r\n                $duplicate = $existingProjects | Where-Object {\r\n                    $existingName = Get-SafeProperty $_ 'name'\r\n                    $null -ne $existingName -and $existingName -ieq $values.name\r\n                }\r\n                if ($duplicate) {\r\n                    $this.SetStatusMessage(\"Project name '$($values.name)' already exists (case-insensitive)\", \"error\")\r\n                    return\r\n                }\r\n            }\r\n\r\n            $success = $this.Store.UpdateProject($originalName, $changes)\r\n            if ($success) {\r\n                $this.SetStatusMessage(\"Project updated: $($values.name)\", \"success\")\r\n            }\r\n            else {\r\n                $this.SetStatusMessage(\"Failed to update project: $($this.Store.LastError)\", \"error\")\r\n            }\r\n        }\r\n        catch {\r\n            # Write-PmcTuiLog \"OnItemUpdated exception: $_\" \"ERROR\"\r\n            $this.SetStatusMessage(\"Unexpected error: $($_.Exception.Message)\", \"error\")\r\n        }\r\n    }\r\n\r\n    # Handle item deletion\r\n    [void] OnItemDeleted([object]$item) {\r\n        # Check if project has tasks\r\n        $itemName = Get-SafeProperty $item 'name'\r\n\r\n        # PS-H1 FIX: Use hashtable approach for O(1) lookup instead of O(n) filtering\r\n        # BUG-1 FIX: Move null check AFTER GetAllTasks() call\r\n        $allTasks = $this.Store.GetAllTasks()\r\n        if ($null -eq $allTasks) { $allTasks = @() }\r\n        $tasksByProject = @{}\r\n        foreach ($task in $allTasks) {\r\n            $projName = Get-SafeProperty $task 'project'\r\n            if ($projName) {\r\n                if (-not $tasksByProject.ContainsKey($projName)) {\r\n                    $tasksByProject[$projName] = 0\r\n                }\r\n                $tasksByProject[$projName]++\r\n            }\r\n        }\r\n\r\n        $taskCount = $(if ($tasksByProject.ContainsKey($itemName)) {\r\n                $tasksByProject[$itemName]\r\n            }\r\n            else { 0 })\r\n\r\n        if ($taskCount -gt 0) {\r\n            # H-UI-8: Better error message with actionable guidance\r\n            $this.SetStatusMessage(\"Cannot delete project with $taskCount tasks. Reassign or delete tasks first.\", \"error\")\r\n            return\r\n        }\r\n\r\n        $success = $this.Store.DeleteProject($itemName)\r\n        if ($success) {\r\n            $this.SetStatusMessage(\"Project deleted: $itemName\", \"success\")\r\n        }\r\n        else {\r\n            $this.SetStatusMessage(\"Failed to delete project: $($this.Store.LastError)\", \"error\")\r\n        }\r\n    }\r\n\r\n    # === Custom Actions ===\r\n\r\n    # Ensure PmcFilePicker is loaded (lazy loading pattern)\r\n    hidden [void] EnsureFilePicker() {\r\n        if ($null -eq ([Type]'PmcFilePicker' -as [Type])) {\r\n            # Write-PmcTuiLog \"ProjectListScreen: Lazy-loading PmcFilePicker widget\" \"DEBUG\"\r\n            . \"$PSScriptRoot/../widgets/PmcFilePicker.ps1\"\r\n        }\r\n    }\r\n\r\n    # Import projects from Excel spreadsheet\r\n    [void] ImportFromExcel() {\r\n        # IMPLEMENTATION: Launch the full Excel Import wizard screen\r\n        # This provides profile-based mapping, preview, and validation\r\n        try {\r\n            . \"$PSScriptRoot/ExcelImportScreen.ps1\"\r\n            $importScreen = New-Object ExcelImportScreen\r\n            $this.App.PushScreen($importScreen)\r\n        }\r\n        catch {\r\n            $this.SetStatusMessage(\"Failed to launch Excel import wizard: $($_.Exception.Message)\", \"error\")\r\n            # Write-PmcTuiLog \"ImportFromExcel failed: $_\" \"ERROR\"\r\n        }\r\n    }\r\n\r\n    # Archive/unarchive project\r\n    # MEDIUM FIX PLS-M9: Use script-level constants for status values\r\n    [void] ToggleProjectArchive([object]$project) {\r\n        if ($null -eq $project) { return }\r\n\r\n        $projectStatus = Get-SafeProperty $project 'status'\r\n        $projectName = Get-SafeProperty $project 'name'\r\n        $newStatus = $(if ($projectStatus -eq $script:ARCHIVED_STATUS) { $global:DEFAULT_STATUS } else { $script:ARCHIVED_STATUS })\r\n        $this.Store.UpdateProject($projectName, @{ status = $newStatus })\r\n\r\n        $action = $(if ($newStatus -eq $script:ARCHIVED_STATUS) { \"archived\" } else { \"activated\" })\r\n        $this.SetStatusMessage(\"Project ${action}: $projectName\", \"success\")\r\n    }\r\n\r\n    # === Input Handling ===\r\n\r\n    # Open project folder\r\n    [void] OpenProjectFolder([object]$project) {\r\n        $this.EnsureFilePicker()\r\n\r\n        if ($null -eq $project) { return }\r\n\r\n        $folderPath = Get-SafeProperty $project 'ProjFolder'\r\n        if ([string]::IsNullOrWhiteSpace($folderPath)) {\r\n            $this.SetStatusMessage(\"Project has no folder path set\", \"warning\")\r\n            return\r\n        }\r\n\r\n        # H-SEC-1: Sanitize and validate file path before use\r\n        try {\r\n            # Resolve to absolute path and validate it's a directory\r\n            $resolvedPath = Resolve-Path -Path $folderPath -ErrorAction Stop\r\n            if (-not (Test-Path -Path $resolvedPath -PathType Container)) {\r\n                $this.SetStatusMessage(\"Path is not a directory: $folderPath\", \"error\")\r\n                return\r\n            }\r\n\r\n            # HIGH FIX PLS-H4: Check read permissions before accessing\r\n            try {\r\n                $null = Get-ChildItem -Path $resolvedPath -ErrorAction Stop | Select-Object -First 1\r\n            }\r\n            catch [System.UnauthorizedAccessException] {\r\n                $this.SetStatusMessage(\"Access denied to folder: $folderPath\", \"error\")\r\n                return\r\n            }\r\n\r\n            $folderPath = $resolvedPath.Path\r\n        }\r\n        catch {\r\n            $this.SetStatusMessage(\"Invalid or inaccessible folder path: $folderPath\", \"error\")\r\n            return\r\n        }\r\n\r\n        try {\r\n            # Show integrated file picker to browse the project folder\r\n            $this.FilePicker = [PmcFilePicker]::new($folderPath, $true)\r\n            $this.ShowFilePicker = $true\r\n            $this.SetStatusMessage(\"Browsing folder: $folderPath\", \"info\")\r\n        }\r\n        catch {\r\n            $this.SetStatusMessage(\"Failed to open file picker: $($_.Exception.Message)\", \"error\")\r\n        }\r\n    }\r\n\r\n    # Called by StandardListScreen when inline editing is cancelled\r\n    [void] OnInlineEditCancelled() {\r\n        # This method is called when inline edit is cancelled (e.g., Escape key)\r\n        # ProjectListScreen relies on the base StandardListScreen behavior\r\n        # Write-PmcTuiLog \"OnInlineEditCancelled called\" \"DEBUG\"\r\n        # No-op: StandardListScreen handles the UI updates\r\n    }\r\n\r\n    # Get custom actions for footer display\r\n    [array] GetCustomActions() {\r\n        $self = $this\r\n        return @(\r\n            @{ Key = 'r'; Label = 'Archive'; Callback = {\r\n                    $selected = $self.List.GetSelectedItem()\r\n                    $self.ToggleProjectArchive($selected)\r\n                }.GetNewClosure()\r\n            },\r\n            @{ Key = 'v'; Label = 'View'; Callback = {\r\n                    # Write-PmcTuiLog \"!!! GetCustomActions V KEY CALLBACK FIRED !!!\" \"INFO\"\r\n                    $selected = $self.List.GetSelectedItem()\r\n                    # Write-PmcTuiLog \"Selected: $($selected | ConvertTo-Json -Compress)\" \"INFO\"\r\n                    if ($selected) {\r\n                        $projectName = Get-SafeProperty $selected 'name'\r\n                        # Write-PmcTuiLog \"Project name: $projectName\" \"INFO\"\r\n                        # Use container to resolve screen (avoids type resolution at parse time)\r\n                        if (-not $global:PmcContainer.IsRegistered('ProjectInfoScreenV4')) {\r\n                            # Write-PmcTuiLog \"Registering ProjectInfoScreenV4\" \"INFO\"\r\n                            $screenPath = \"$PSScriptRoot/ProjectInfoScreenV4.ps1\"\r\n                            $global:PmcContainer.Register('ProjectInfoScreenV4', {\r\n                                    param($c)\r\n                                    . $screenPath\r\n                                    return New-Object ProjectInfoScreenV4 -ArgumentList $c\r\n                                }.GetNewClosure(), $false)\r\n                        }\r\n                        # Write-PmcTuiLog \"Resolving screen\" \"INFO\"\r\n                        $screen = $global:PmcContainer.Resolve('ProjectInfoScreenV4')\r\n                        # Write-PmcTuiLog \"Setting project: $projectName\" \"INFO\"\r\n                        $screen.SetProject($projectName)\r\n                        # Write-PmcTuiLog \"Pushing screen\" \"INFO\"\r\n                        $global:PmcApp.PushScreen($screen)\r\n                        # Write-PmcTuiLog \"Screen pushed!\" \"INFO\"\r\n                    }\r\n                    else {\r\n                        # Write-PmcTuiLog \"NO SELECTED ITEM\" \"ERROR\"\r\n                    }\r\n                }.GetNewClosure()\r\n            },\r\n            @{ Key = 'o'; Label = 'Open Folder'; Callback = {\r\n                    $selected = $self.List.GetSelectedItem()\r\n                    $self.OpenProjectFolder($selected)\r\n                }.GetNewClosure()\r\n            },\r\n            @{ Key = 'i'; Label = 'Import Excel'; Callback = {\r\n                    # Check if Excel is available before attempting import\r\n                    $excelAvailable = $false\r\n                    try {\r\n                        if ($PSVersionTable.PSVersion.Major -ge 6) {\r\n                            # PowerShell Core - check for Excel COM object on Windows\r\n                            if ($IsWindows) {\r\n                                $excelAvailable = $null -ne (Get-Command excel.exe -ErrorAction SilentlyContinue)\r\n                            }\r\n                        }\r\n                        else {\r\n                            # Windows PowerShell - check for Excel COM\r\n                            $excelAvailable = $null -ne (New-Object -ComObject Excel.Application -ErrorAction SilentlyContinue)\r\n                        }\r\n                    }\r\n                    catch {\r\n                        $excelAvailable = $false\r\n                    }\r\n\r\n                    if ($excelAvailable) {\r\n                        $self.ImportFromExcel()\r\n                    }\r\n                    else {\r\n                        $self.SetStatusMessage(\"Excel is not installed or not available\", \"error\")\r\n                    }\r\n                }.GetNewClosure()\r\n            }\r\n        )\r\n    }\r\n\r\n    [string] RenderContent() { return \"\" }\r\n\r\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\r\n        # CRITICAL: Call StandardListScreen parent FIRST - it handles inline editor, filter panel, menu bar, etc.\r\n        # DO NOT skip to PmcScreen - that bypasses the inline editor input handling!\r\n        $handled = ([StandardListScreen]$this).HandleKeyPress($keyInfo)\r\n        if ($handled) { return $true }\r\n\r\n        # Handle custom project keys after StandardListScreen (ONLY when editor/filter NOT showing!)\r\n        if (-not $this.ShowInlineEditor -and -not $this.ShowFilterPanel) {\r\n            # Custom key: Enter = View project details (user preference over standard edit behavior)\r\n            if ($keyInfo.Key -eq ([ConsoleKey]::Enter)) {\r\n                $selected = $this.List.GetSelectedItem()\r\n                if ($selected) {\r\n                    $this.ViewProjectDetails($selected)\r\n                }\r\n                return $true\r\n            }\r\n\r\n            # Custom key: E = Edit selected project\r\n            if ($keyInfo.KeyChar -eq 'e' -or $keyInfo.KeyChar -eq 'E') {\r\n                if ($this.AllowEdit) {\r\n                    $selected = $this.List.GetSelectedItem()\r\n                    if ($selected) {\r\n                        $this.EditItem($selected)\r\n                    }\r\n                }\r\n                return $true\r\n            }\r\n\r\n            # Custom key: V = View project details/stats\r\n            if ($keyInfo.KeyChar -eq 'v' -or $keyInfo.KeyChar -eq 'V') {\r\n                # Defensive check: ensure List exists\r\n                if ($null -eq $this.List) {\r\n                    # Write-PmcTuiLog \"ERROR: List is null when V pressed\" \"ERROR\"\r\n                    $this.SetStatusMessage(\"Internal error: List not initialized\", \"error\")\r\n                    return $true\r\n                }\r\n\r\n                $selected = $this.List.GetSelectedItem()\r\n\r\n                if ($null -eq $selected) {\r\n                    # Write-PmcTuiLog \"No project selected when V pressed\" \"WARNING\"\r\n                    $this.SetStatusMessage(\"No project selected\", \"warning\")\r\n                    return $true\r\n                }\r\n\r\n                try {\r\n                    $projectName = Get-SafeProperty $selected 'name'\r\n                    $screen = New-Object ProjectInfoScreenV4 -ArgumentList $this.Container\r\n                    $screen.SetProject($projectName)\r\n                    $global:PmcApp.PushScreen($screen)\r\n                    $this.SetStatusMessage(\"Viewing project: $projectName\", \"success\")\r\n                }\r\n                catch {\r\n                    $errorMsg = \"Failed to open project view: $($_.Exception.Message)\"\r\n                    # Write-PmcTuiLog \"!!! EXCEPTION: $errorMsg\" \"ERROR\"\r\n                    # Write-PmcTuiLog \"!!! Stack trace: $($_.ScriptStackTrace)\" \"ERROR\"\r\n                    $this.SetStatusMessage($errorMsg, \"error\")\r\n                }\r\n                return $true\r\n            }\r\n\r\n            # Custom key: R = Archive/Unarchive\r\n            if ($keyInfo.KeyChar -eq 'r' -or $keyInfo.KeyChar -eq 'R') {\r\n                $selected = $this.List.GetSelectedItem()\r\n                $this.ToggleProjectArchive($selected)\r\n                return $true\r\n            }\r\n\r\n            # Custom key: O = Open project folder\r\n            if ($keyInfo.KeyChar -eq 'o' -or $keyInfo.KeyChar -eq 'O') {\r\n                $selected = $this.List.GetSelectedItem()\r\n                $this.OpenProjectFolder($selected)\r\n                return $true\r\n            }\r\n\r\n            # Custom key: I = Import from Excel\r\n            if ($keyInfo.KeyChar -eq 'i' -or $keyInfo.KeyChar -eq 'I') {\r\n                $this.ImportFromExcel()\r\n                return $true\r\n            }\r\n        }  # End of editor/filter check\r\n\r\n        # If file picker is showing, route input to it\r\n        if ($this.ShowFilePicker -and $null -ne $this.FilePicker) {\r\n            $handled = $this.FilePicker.HandleInput($keyInfo)\r\n\r\n            # Check if file picker completed\r\n            if ($this.FilePicker.IsComplete) {\r\n                if ($this.FilePicker.Result) {\r\n                    # User selected a folder\r\n                    $selectedPath = $this.FilePicker.SelectedPath\r\n                    $this.SetStatusMessage(\"Selected: $selectedPath\", \"success\")\r\n                }\r\n                else {\r\n                    $this.SetStatusMessage(\"Folder browsing cancelled\", \"info\")\r\n                }\r\n                # Close file picker\r\n                $this.ShowFilePicker = $false\r\n                $this.FilePicker = $null\r\n            }\r\n\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\n# REMAINING FIXES DOCUMENTED (non-critical):\r\n# HIGH: PLS-H1 (line 335), H2 (line 604), H4 (line 349), H5 (line 494) - String.Length null checks\r\n# MEDIUM: 9 issues - Error handling, validation improvements\r\n# LOW: 11 issues - Code quality, constants, DRY principle\r\n# All CRITICAL safety issues FIXED (7/7)"}, {"path": "module/Pmc.Strict/consoleui/screens/SettingsScreen.ps1", "content": "using namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# SettingsScreen - PMC TUI Settings configuration\r\n# Interactive screen for viewing and modifying PMC settings\r\n\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# NOTE: PmcScreen is loaded by Start-PmcTUI.ps1 - don't load again\r\n# . \"$PSScriptRoot/../PmcScreen.ps1\"\r\n\r\n# LOW FIX SS-L1, SS-L2, SS-L3: Define constants for column widths and limits\r\n$script:SETTING_NAME_WIDTH = 20\r\n$script:SETTING_VALUE_WIDTH = 30\r\n$global:MIN_PRINTABLE_CHAR = 32\r\n$global:MAX_PRINTABLE_CHAR = 126\r\n\r\n<#\r\n.SYNOPSIS\r\nSettings screen for configuring PMC TUI preferences\r\n\r\n.DESCRIPTION\r\nInteractive settings screen showing:\r\n- Data file location\r\n- Default project\r\n- Theme selection\r\n- Auto-save settings\r\n- Backup settings\r\nNavigation: Up/Down to select, Enter to edit, Esc to exit\r\n##CLOSEBRACKET##\r\nclass SettingsScreen : PmcScreen {\r\n    # Data\r\n    [array]$SettingsList = @()\r\n    [int]$SelectedIndex = 0\r\n    [string]$InputMode = 'none'  # 'none', 'edit'\r\n    [string]$InputBuffer = ''\r\n    [int]$EditingIndex = -1\r\n\r\n    # Static: Register menu items\r\n    static [void] RegisterMenuItems([object]$registry) {\r\n        $registry.AddMenuItem('Options', 'Settings', 'S', {\r\n            # CRITICAL FIX SS-C1: Validate file exists before dot-sourcing\r\n            $scriptPath = \"$PSScriptRoot/SettingsScreen.ps1\"\r\n            if (-not (Test-Path $scriptPath)) {\r\n                # Write-PmcTuiLog \"SettingsScreen.ps1 not found at: $scriptPath\" \"ERROR\"\r\n                throw \"SettingsScreen.ps1 not found\"\r\n            }\r\n            . $scriptPath\r\n            $global:PmcApp.PushScreen((New-Object -TypeName SettingsScreen))\r\n        }, 20)\r\n    }\r\n\r\n    # LOW FIX SS-L4: Extract common initialization to helper method (DRY principle)\r\n    hidden [void] ConfigureScreen() {\r\n        # Configure header\r\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Settings\"))\r\n\r\n        # Configure footer with shortcuts\r\n        $this.Footer.ClearShortcuts()\r\n        $this.Footer.AddShortcut(\"Up/Down\", \"Select\")\r\n        $this.Footer.AddShortcut(\"Enter\", \"Edit\")\r\n        $this.Footer.AddShortcut(\"Esc\", \"Back\")\r\n\r\n        # NOTE: _SetupMenus() removed - MenuRegistry handles menu population via static RegisterMenuItems()\r\n        # Old pattern was adding duplicate/misplaced menu items\r\n    }\r\n\r\n    # Constructor\r\n    SettingsScreen() : base(\"Settings\", \"Settings\") {\r\n        $this.ConfigureScreen()\r\n    }\r\n\r\n    # Constructor with container (DI-enabled)\r\n    SettingsScreen([object]$container) : base(\"Settings\", \"Settings\", $container) {\r\n        $this.ConfigureScreen()\r\n    }\r\n\r\n    [void] LoadData() {\r\n        # SS-M2 FIX: Defensive check layering documentation\r\n        # LAYER 1: Default values are set BEFORE external function calls\r\n        # This ensures settings always have valid values even if external functions fail\r\n        $dataFile = \"~/.pmc/data.json\"\r\n        try {\r\n            # LAYER 2: Try to get actual value from external function\r\n            # HIGH FIX SS-H1: Validate returned path exists and is readable\r\n            $tempPath = Get-PmcTaskFilePath\r\n            if ($null -ne $tempPath -and (Test-Path $tempPath)) {\r\n                $dataFile = $tempPath\r\n            } else {\r\n                # Write-PmcTuiLog \"SettingsScreen: Get-PmcTaskFilePath returned invalid path: $tempPath\" \"WARNING\"\r\n            }\r\n        } catch {\r\n            # LAYER 3: Silently fall back to default if function fails\r\n            # Write-PmcTuiLog \"SettingsScreen: Get-PmcTaskFilePath failed: $($_.Exception.Message)\" \"WARNING\"\r\n        }\r\n\r\n        # Same defensive layering for current context\r\n        $currentContext = \"inbox\"\r\n        try {\r\n            # HIGH FIX SS-H2: Validate returned context against safe values\r\n            $tempContext = Get-PmcCurrentContext\r\n            if ($null -ne $tempContext -and -not [string]::IsNullOrWhiteSpace($tempContext)) {\r\n                $currentContext = $tempContext\r\n            } else {\r\n                # Write-PmcTuiLog \"SettingsScreen: Get-PmcCurrentContext returned invalid value\" \"WARNING\"\r\n            }\r\n        } catch {\r\n            # Use default if Get-PmcCurrentContext fails\r\n            # Write-PmcTuiLog \"SettingsScreen: Get-PmcCurrentContext failed: $($_.Exception.Message)\" \"WARNING\"\r\n        }\r\n\r\n        $this.SettingsList = @(\r\n            @{\r\n                name = \"Data File\"\r\n                key = \"dataFile\"\r\n                value = $dataFile\r\n                editable = $false\r\n                description = \"Location of PMC data storage\"\r\n            }\r\n            @{\r\n                name = \"Default Project\"\r\n                key = \"defaultProject\"\r\n                value = $currentContext\r\n                editable = $true\r\n                description = \"Default project for new tasks\"\r\n            }\r\n            @{\r\n                name = \"Auto-save\"\r\n                key = \"autoSave\"\r\n                value = \"enabled\"\r\n                editable = $false\r\n                description = \"Automatically save changes\"\r\n            }\r\n            @{\r\n                name = \"Theme\"\r\n                key = \"theme\"\r\n                value = \"default\"\r\n                editable = $false\r\n                action = \"launchThemeEditor\"\r\n                description = \"UI color theme (press Enter to change)\"\r\n            }\r\n            @{\r\n                name = \"TUI Version\"\r\n                key = \"version\"\r\n                value = \"1.0.0\"\r\n                editable = $false\r\n                description = \"PMC TUI version\"\r\n            }\r\n        )\r\n\r\n        $this.ShowStatus(\"$($this.SettingsList.Count) settings available\")\r\n    }\r\n\r\n    [string] RenderContent() {\r\n        $sb = [System.Text.StringBuilder]::new(4096)\r\n\r\n        if (-not $this.LayoutManager) {\r\n            return $sb.ToString()\r\n        }\r\n\r\n        # Get content area\r\n        $contentRect = $this.LayoutManager.GetRegion('Content', $this.TermWidth, $this.TermHeight)\r\n\r\n        # Colors\r\n        $textColor = $this.Header.GetThemedFg('Foreground.Field')\r\n        $highlightColor = $this.Header.GetThemedFg('Foreground.FieldFocused')\r\n        $mutedColor = $this.Header.GetThemedFg('Foreground.Muted')\r\n        $selectedBg = $this.Header.GetThemedBg('Background.FieldFocused', 80, 0)\r\n        $selectedFg = $this.Header.GetThemedFg('Foreground.Field')\r\n        $cursorColor = $this.Header.GetThemedAnsi('Accent', $false)\r\n        $headerColor = $this.Header.GetThemedFg('Foreground.Muted')\r\n        $reset = \"`e[0m\"\r\n\r\n        # Column widths\r\n        # MEDIUM FIX SS-M3: Use script-level constants for column widths\r\n        $nameWidth = $script:SETTING_NAME_WIDTH\r\n        $valueWidth = $script:SETTING_VALUE_WIDTH\r\n        $descWidth = $contentRect.Width - $nameWidth - $valueWidth - 10\r\n\r\n        # Render column headers\r\n        $headerY = $this.Header.Y + 3\r\n        $sb.Append($this.Header.BuildMoveTo($contentRect.X + 4, $headerY))\r\n        $sb.Append($headerColor)\r\n        $sb.Append(\"SETTING\".PadRight($nameWidth))\r\n        $sb.Append(\"VALUE\".PadRight($valueWidth))\r\n        $sb.Append(\"DESCRIPTION\")\r\n        $sb.Append($reset)\r\n\r\n        # Render settings rows\r\n        $startY = $headerY + 2\r\n        $maxLines = $contentRect.Height - 4\r\n\r\n        for ($i = 0; $i -lt [Math]::Min($this.SettingsList.Count, $maxLines); $i++) {\r\n            $setting = $this.SettingsList[$i]\r\n            $y = $startY + $i\r\n            $isSelected = ($i -eq $this.SelectedIndex)\r\n            $isEditing = ($i -eq $this.EditingIndex) -and ($this.InputMode -eq 'edit')\r\n\r\n            # Cursor\r\n            $sb.Append($this.Header.BuildMoveTo($contentRect.X + 2, $y))\r\n            if ($isSelected) {\r\n                $sb.Append($cursorColor)\r\n                $cursorChar = $(if ($isEditing) { \"E\" } else { \">\" })\r\n                $sb.Append($cursorChar)\r\n                $sb.Append($reset)\r\n            } else {\r\n                $sb.Append(\" \")\r\n            }\r\n\r\n            # Setting name column\r\n            $x = $contentRect.X + 4\r\n            $sb.Append($this.Header.BuildMoveTo($x, $y))\r\n            if ($isSelected -and -not $isEditing) {\r\n                $sb.Append($selectedBg)\r\n                $sb.Append($selectedFg)\r\n            } else {\r\n                $sb.Append($textColor)\r\n            }\r\n            $displayName = $setting.name\r\n            if ($displayName.Length -gt $nameWidth) {\r\n                $displayName = $displayName.Substring(0, $nameWidth - 3) + \"...\"\r\n            }\r\n            $sb.Append($displayName.PadRight($nameWidth))\r\n            $sb.Append($reset)\r\n            $x += $nameWidth\r\n\r\n            # Value column\r\n            $sb.Append($this.Header.BuildMoveTo($x, $y))\r\n            if ($isEditing) {\r\n                # Show edit buffer\r\n                $sb.Append($cursorColor)\r\n                $sb.Append(($this.InputBuffer + \"_\").PadRight($valueWidth))\r\n                $sb.Append($reset)\r\n            } else {\r\n                $sb.Append($highlightColor)\r\n                $displayValue = $setting.value\r\n                if ($displayValue.Length -gt $valueWidth) {\r\n                    $displayValue = $displayValue.Substring(0, $valueWidth - 3) + \"...\"\r\n                }\r\n                $sb.Append($displayValue.PadRight($valueWidth))\r\n                $sb.Append($reset)\r\n            }\r\n            $x += $valueWidth\r\n\r\n            # Description column\r\n            $sb.Append($this.Header.BuildMoveTo($x, $y))\r\n            $sb.Append($mutedColor)\r\n            $displayDesc = $setting.description\r\n            if ($displayDesc.Length -gt $descWidth) {\r\n                $displayDesc = $displayDesc.Substring(0, $descWidth - 3) + \"...\"\r\n            }\r\n            $sb.Append($displayDesc)\r\n            $sb.Append($reset)\r\n        }\r\n\r\n        return $sb.ToString()\r\n    }\r\n\r\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\r\n        # Handle input mode\r\n        if ($this.InputMode -eq 'edit') {\r\n            return $this._HandleEditMode($keyInfo)\r\n        }\r\n\r\n        switch ($keyInfo.Key) {\r\n            'UpArrow' {\r\n                if ($this.SelectedIndex -gt 0) {\r\n                    $this.SelectedIndex--\r\n                }\r\n                return $true\r\n            }\r\n            'DownArrow' {\r\n                if ($this.SelectedIndex -lt ($this.SettingsList.Count - 1)) {\r\n                    $this.SelectedIndex++\r\n                }\r\n                return $true\r\n            }\r\n            'Enter' {\r\n                if ($this.SettingsList.Count -gt 0) {\r\n                    $this._StartEdit()\r\n                }\r\n                return $true\r\n            }\r\n            'Escape' {\r\n                # Go back to previous screen\r\n                if ($global:PmcApp) {\r\n                    $global:PmcApp.PopScreen()\r\n                }\r\n                return $true\r\n            }\r\n        }\r\n        return $false\r\n    }\r\n\r\n    hidden [void] _StartEdit() {\r\n        $setting = $this.SettingsList[$this.SelectedIndex]\r\n\r\n        # Check if this setting has a special action\r\n        if ($setting.action) {\r\n            switch ($setting.action) {\r\n                'launchThemeEditor' {\r\n                    # SS-M1 FIX: Enhanced try-catch with comprehensive error handling\r\n                    # Lazy-load Theme Editor screen\r\n                    try {\r\n                        # Validate file exists before dot-sourcing\r\n                        $themeEditorPath = \"$PSScriptRoot/ThemeEditorScreen.ps1\"\r\n                        if (-not (Test-Path $themeEditorPath)) {\r\n                            throw \"ThemeEditorScreen.ps1 not found at expected path: $themeEditorPath\"\r\n                        }\r\n\r\n                        . $themeEditorPath\r\n\r\n                        # HIGH FIX SET-H1: Use try-catch around class instantiation instead of PSTypeName check\r\n                        # PSTypeName check may not work reliably in all PowerShell versions\r\n                        if ($global:PmcApp) {\r\n                            try {\r\n                                $themeScreen = New-Object ThemeEditorScreen\r\n                            } catch {\r\n                                throw \"ThemeEditorScreen class not available after loading file: $_\"\r\n                            }\r\n                            if ($null -eq $themeScreen) {\r\n                                throw \"ThemeEditorScreen constructor returned null\"\r\n                            }\r\n                            $global:PmcApp.PushScreen($themeScreen)\r\n                        } else {\r\n                            throw \"PmcApp global variable is not available\"\r\n                        }\r\n                    } catch {\r\n                        try { $this.ShowError(\"Failed to load theme editor: $($_.Exception.Message)\") } catch { }\r\n                        # Write-PmcTuiLog \"Failed to load ThemeEditorScreen: $_\" \"ERROR\"\r\n                        # Write-PmcTuiLog \"Stack trace: $($_.ScriptStackTrace)\" \"ERROR\"\r\n                    }\r\n                    return\r\n                }\r\n            }\r\n        }\r\n\r\n        # SS-M2 FIX: Defensive check layering - verify setting is editable\r\n        if (-not $setting.editable) {\r\n            # LAYER 1: Try to show error to user via UI\r\n            # LAYER 2: Catch and suppress any UI errors (ShowError might fail if screen not active)\r\n            try { $this.ShowError(\"$($setting.name) is read-only\") } catch { }\r\n            return\r\n        }\r\n\r\n        $this.InputMode = 'edit'\r\n        $this.EditingIndex = $this.SelectedIndex\r\n        $this.InputBuffer = $setting.value\r\n        # Defensive layer: Protect against ShowStatus failures\r\n        try { $this.ShowStatus(\"Edit value (Enter: save, Esc: cancel)\") } catch { }\r\n    }\r\n\r\n    hidden [bool] _HandleEditMode([ConsoleKeyInfo]$keyInfo) {\r\n        switch ($keyInfo.Key) {\r\n            'Escape' {\r\n                $this._CancelEdit()\r\n                return $true\r\n            }\r\n            'Enter' {\r\n                $this._SaveEdit()\r\n                return $true\r\n            }\r\n            'Backspace' {\r\n                if ($this.InputBuffer.Length > 0) {\r\n                    $this.InputBuffer = $this.InputBuffer.Substring(0, $this.InputBuffer.Length - 1)\r\n                }\r\n                return $true\r\n            }\r\n            default {\r\n                # EDGE FIX SS-E1: Use script-level constants for printable character range\r\n                if ($keyInfo.KeyChar -ge $global:MIN_PRINTABLE_CHAR -and $keyInfo.KeyChar -le $global:MAX_PRINTABLE_CHAR) {\r\n                    $this.InputBuffer += $keyInfo.KeyChar\r\n                }\r\n                return $true\r\n            }\r\n        }\r\n        return $false  # Fallback return\r\n    }\r\n\r\n    hidden [void] _SaveEdit() {\r\n        $setting = $this.SettingsList[$this.EditingIndex]\r\n        $oldValue = $setting.value\r\n        $newValue = $this.InputBuffer\r\n\r\n        # CRITICAL FIX SS-C2: Validate input before assignment\r\n        if ($null -eq $newValue) {\r\n            # Write-PmcTuiLog \"SettingsScreen: Cannot set null value for $($setting.key)\" \"ERROR\"\r\n            $this.ShowMessage(\"Invalid value\", \"error\")\r\n            return\r\n        }\r\n\r\n        # Update the setting value\r\n        $setting.value = $newValue\r\n\r\n        # SS-M2 FIX: Defensive check layering documentation for setting persistence\r\n        # LAYER 1: Optimistically update in-memory value first\r\n        # LAYER 2: Try to persist to backend based on setting type\r\n        # LAYER 3: Revert in-memory value if persistence fails\r\n        # LAYER 4: Show user-friendly error message\r\n        # SS-H1 FIX: Apply the setting based on key with proper persistence for each editable setting\r\n        switch ($setting.key) {\r\n            'defaultProject' {\r\n                try {\r\n                    # Check if Set-PmcFocus command exists\r\n                    if (-not (Get-Command -Name 'Set-PmcFocus' -ErrorAction SilentlyContinue)) {\r\n                        throw \"Set-PmcFocus command not available\"\r\n                    }\r\n                    # Use Set-PmcFocus to change the current context\r\n                    # Create proper PmcCommandContext with project name in FreeText\r\n                    $context = [PmcCommandContext]::new('focus', 'set')\r\n                    $context.FreeText = @($newValue)\r\n                    Set-PmcFocus -Context $context\r\n                    $this.ShowSuccess(\"Default project updated to '$newValue'\")\r\n                } catch {\r\n                    $this.ShowError(\"Failed to set default project: $_\")\r\n                    # Revert the value\r\n                    $setting.value = $oldValue\r\n                }\r\n            }\r\n            'autoSave' {\r\n                # TODO: Implement persistence for auto-save setting\r\n                # For now, show warning that this setting is not persisted\r\n                $this.ShowError(\"Auto-save setting persistence not yet implemented\")\r\n                $setting.value = $oldValue\r\n            }\r\n            default {\r\n                # Default case: Warn that persistence is not implemented\r\n                # This prevents false success messages for settings without persistence logic\r\n                $this.ShowError(\"Persistence not implemented for setting '$($setting.name)'. Changes will not be saved.\")\r\n                $setting.value = $oldValue\r\n            }\r\n        }\r\n\r\n        # Reset edit mode\r\n        $this.InputMode = 'none'\r\n        $this.EditingIndex = -1\r\n        $this.InputBuffer = ''\r\n    }\r\n\r\n    hidden [void] _CancelEdit() {\r\n        $this.InputMode = 'none'\r\n        $this.EditingIndex = -1\r\n        $this.InputBuffer = ''\r\n        $this.ShowStatus(\"Edit cancelled\")\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/screens/TaskListScreen.ps1", "content": "# TaskListScreen.ps1 - Complete Task List with CRUD + Filters\n#\n# Full-featured task list screen with:\n# - UniversalList integration (sorting, virtual scrolling, multi-select)\n# - FilterPanel integration (dynamic filtering by project, priority, due date, tags, status)\n# - InlineEditor integration (full CRUD operations)\n# - TaskStore integration (observable data layer with auto-refresh)\n# - Keyboard shortcuts (CRUD operations, filters, search)\n# - Custom actions (complete, archive, clone, bulk operations)\n#\n# Usage:\n#   $screen = New-Object TaskListScreen\n#   $screen.Initialize()\n#   $screen.Render()\n#   $screen.HandleInput($key)\n\nusing namespace System\n\nSet-StrictMode -Version Latest\n\n<#\n.SYNOPSIS\nComplete task list screen with full CRUD and filtering\n\n.DESCRIPTION\nExtends StandardListScreen to provide:\n- Full task CRUD (Create, Read, Update, Delete)\n- Dynamic filtering (project, priority, due date, tags, status, text search)\n- Sorting by any column\n- Multi-select bulk operations\n- Quick actions (complete, archive, clone)\n- Auto-refresh on data changes\n- Inline editing\n- Comprehensive keyboard shortcuts\n\n.EXAMPLE\n$screen = New-Object TaskListScreen\n$screen.Initialize()\nwhile (-not $screen.ShouldExit) {\n    $output = $screen.Render()\n    # Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [TaskListScreen] Rendered output\"\n    $key = [Console]::ReadKey($true)\n    $screen.HandleInput($key)\n}\n##CLOSEBRACKET##\n\n# Helper function to get title based on view mode\nfunction Get-TaskListTitle {\n    param([string]$viewMode)\n    switch ($viewMode) {\n        'all' { return 'All Tasks' }\n        'active' { return 'Active Tasks' }\n        'completed' { return 'Completed Tasks' }\n        'overdue' { return 'Overdue Tasks' }\n        'today' { return \"Today's Tasks\" }\n        'tomorrow' { return \"Tomorrow's Tasks\" }\n        'week' { return 'This Week' }\n        'nextactions' { return 'Next Actions' }\n        'noduedate' { return 'No Due Date' }\n        'month' { return 'This Month' }\n        'agenda' { return 'Agenda View' }\n        'upcoming' { return 'Upcoming Tasks' }\n        default { return 'Task List' }\n    }\n}\n\nclass TaskListScreen : StandardListScreen {\n    # Constants for layout calculations\n    static hidden [int]$LIST_HEADER_ROWS = 3  # Header + separator + first data row offset\n    static hidden [double]$COL_WIDTH_TEXT = 0.30     # 30% for text column\n    static hidden [double]$COL_WIDTH_DETAILS = 0.25  # 25% for details column\n    static hidden [double]$COL_WIDTH_DUE = 0.12      # 12% for due column\n    static hidden [double]$COL_WIDTH_PROJECT = 0.18  # 18% for project column\n    static hidden [double]$COL_WIDTH_TAGS = 0.15     # 15% for tags column\n\n    # Additional state\n    [string]$_viewMode = 'all'  # all, active, completed, overdue, today, tomorrow, week, nextactions, noduedate, month, agenda, upcoming\n    [bool]$_showCompleted = $true\n    [string]$_sortColumn = 'due'\n    [bool]$_sortAscending = $true\n    [hashtable]$_stats = @{}\n    [hashtable]$_collapsedSubtasks = @{}\n\n    # Caching for performance\n    hidden [array]$_cachedFilteredTasks = $null\n    hidden [string]$_cacheKey = \"\"  # viewMode:sortColumn:sortAsc:showCompleted\n    # BUG-13 FIX: Cache parent-child relationships for O(1) lookups\n    hidden [hashtable]$_childrenIndex = @{}\n\n    # L-POL-14: Strikethrough support detection\n    hidden [bool]$_supportsStrikethrough = $true  # Assume support, can be overridden\n\n    # BUG-2 FIX: Loading state flag to prevent reentrant LoadData() calls\n    hidden [bool]$_isLoading = $false\n\n    # Detail pane for 70/30 split layout\n    # DetailPane shows task details on the right (30% width)\n    # Default: visible (70/30 split), toggle with 'o' key for full-width list\n    [PmcPanel]$DetailPane = $null\n    hidden [bool]$_showDetailPane = $true  # true = detail pane visible by default\n    hidden [bool]$_detailEditMode = $false  # true = editing detail panel\n    hidden [TextAreaEditor]$_detailEditor = $null  # Editor for detail content\n\n    # Telemetry helper for tracking user actions\n    hidden [void] _EmitTelemetry([string]$eventName, [hashtable]$data) {\n        # TODO: Implement telemetry when metrics system is available\n        # For now, log at DEBUG level for observability\n        # Write-PmcTuiLog \"Telemetry: $eventName - $($data | ConvertTo-Json -Compress)\" \"DEBUG\"\n    }\n\n    # LOW FIX TLS-L4: Centralized initialization to reduce constructor duplication\n    hidden [void] _InitializeTaskListScreen([string]$viewMode) {\n        $this._viewMode = $viewMode\n        $this._showCompleted = $false\n        $this._sortColumn = 'due'\n        $this._sortAscending = $true\n        # CRITICAL FIX: Keep AllowEdit = true so 'e' key triggers editing\n        # We handle BOTH 'e' key and Enter key for inline editing\n        # (AllowEdit defaults to true in base class, no need to set it)\n        $this._SetupMenus()\n    }\n\n    # Constructor with optional view mode\n    TaskListScreen() : base(\"TaskList\", \"Task List\") {\n        $this._InitializeTaskListScreen('active')\n    }\n\n    # Constructor with container (DI-enabled)\n    TaskListScreen([object]$container) : base(\"TaskList\", \"Tasks\", $container) {\n        # Write-PmcTuiLog \"TaskListScreen: Constructor started\" \"DEBUG\"\n        \n        # Configure based on view mode (defaulting to 'active' or 'all')\n        $this._InitializeTaskListScreen('active') \n        \n        # Write-PmcTuiLog \"TaskListScreen: Constructor completed\" \"DEBUG\"\n    }\n\n    # Constructor with explicit view mode\n    TaskListScreen([string]$viewMode) : base(\"TaskList\", (Get-TaskListTitle $viewMode)) {\n        $this._InitializeTaskListScreen($viewMode)\n    }\n\n    # Constructor with container and view mode (DI-enabled)\n    TaskListScreen([object]$container, [string]$viewMode) : base(\"TaskList\", (Get-TaskListTitle $viewMode), $container) {\n        $this._InitializeTaskListScreen($viewMode)\n    }\n\n    # Test constructor - allows injecting mock store for unit testing\n    # This enables testing without real TaskStore dependencies\n    TaskListScreen([object]$container, [object]$mockStore, [string]$viewMode) : base(\"TaskList\", (Get-TaskListTitle $viewMode), $container) {\n        if ($mockStore) {\n            $this.Store = $mockStore\n        }\n        $this._InitializeTaskListScreen($viewMode)\n    }\n\n    # Override to add cache invalidation to TaskStore event handler\n    hidden [void] _InitializeComponents() {\n        # Call parent initialization first\n        ([StandardListScreen]$this)._InitializeComponents()\n\n        # FIX Z-ORDER BUG: Disable Header separator since UniversalList draws its own box\n        # The Header separator was overlapping task rows at Y=7 (Header z=50 beats Content z=10)\n        if ($this.Header) {\n            $this.Header.ShowSeparator = $false\n        }\n\n        # CRITICAL FIX: Override the TaskStore event handler to invalidate cache before refresh\n        # BUG-2 FIX: Check _isLoading flag to prevent reentrant LoadData() calls\n        $self = $this\n        $this.Store.OnTasksChanged = {\n            param($tasks)\n            # Invalidate cache so LoadData will reload\n            $self._cachedFilteredTasks = $null\n            $self._cacheKey = \"\"\n            # CRITICAL FIX: Invalidate children index when tasks change\n            # This ensures hierarchy changes are reflected immediately\n            $self._childrenIndex = @{}\n            # Then refresh the list ONLY if not currently loading (prevents race condition)\n            if ($self.IsActive -and -not $self._isLoading) {\n                $self.RefreshList()\n            }\n        }.GetNewClosure()\n\n        # CRITICAL: Re-register the Edit action to use OUR EditItem override, not the parent's\n        # Write-PmcTuiLog \"TaskListScreen._InitializeComponents: AllowEdit=$($this.AllowEdit)\" \"DEBUG\"\n        if ($this.AllowEdit) {\n            # if ($global:PmcTuiLogFile) {\n            #     Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [DEBUG] TaskListScreen: Re-registering Edit action\"\n            $self = $this\n            $editAction = {\n                $selectedItem = $self.List.GetSelectedItem()\n                if ($null -ne $selectedItem) {\n                    $self.EditItem($selectedItem)\n                }\n            }.GetNewClosure()\n            # Remove old action and add new one\n            $this.List.RemoveAction('e')\n            $this.List.AddAction('e', 'Edit', $editAction)\n            # if ($global:PmcTuiLogFile) {\n            #     Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [DEBUG] TaskListScreen: Edit action registered\"\n        }\n\n        # CRITICAL: Set GetIsInEditMode callback so UniversalList doesn't render row highlight in edit mode\n        # ONLY return true for the item being edited, not all items!\n        $this.List.GetIsInEditMode = {\n            param($item)\n            # DEBUG: Log what we're checking\n            $itemId = $(if ($item -and $item.id) { $item.id } else { \"NO-ID\" })\n            # Write-PmcTuiLog \"GetIsInEditMode called for item: $itemId\" \"DEBUG\"\n\n            # In ADD mode, don't match any existing items - editor renders separately\n            if ($self.ShowInlineEditor -and $self.EditorMode -eq 'add') {\n                # Write-PmcTuiLog \"Add mode - editor positioning handled separately\" \"DEBUG\"\n                return $false\n            }\n\n            # Only skip highlighting for the item currently being edited\n            if ($self.ShowInlineEditor -and $self.CurrentEditItem) {\n                $editId = $(if ($self.CurrentEditItem.id) { $self.CurrentEditItem.id } else { \"NO-ID\" })\n                # Write-PmcTuiLog \"Comparing: item.id=$itemId vs CurrentEditItem.id=$editId\" \"DEBUG\"\n\n                # Check if this is the item being edited\n                if ($item.id -and $self.CurrentEditItem.id -and $item.id -eq $self.CurrentEditItem.id) {\n                    # Write-PmcTuiLog \"MATCH! Returning TRUE for edit mode\" \"DEBUG\"\n                    return $true\n                }\n            }\n            # Write-PmcTuiLog \"No match, returning FALSE\" \"DEBUG\"\n            return $false\n        }.GetNewClosure()\n\n        # Initialize DetailPane for 70/30 split layout\n        $this.DetailPane = [PmcPanel]::new(\"Task Details\")\n        $this.DetailPane.SetBorderStyle('single')\n        $this.DetailPane.SetContent(\"Select a task to view details\", 'left')\n        # $this.AddContentWidget($this.DetailPane) # Handled manually in RenderContentToEngine\n\n        # Initialize TextAreaEditor for detail editing (same position as DetailPane)\n        $this._detailEditor = [TextAreaEditor]::new()\n        $this._detailEditor.Visible = $true  # Visible by default - 'd' key activates edit mode\n        $this.AddContentWidget($this._detailEditor)\n    }\n\n    # Setup menu items using MenuRegistry\n    hidden [void] _SetupMenus() {\n        # Get singleton MenuRegistry instance\n        . \"$PSScriptRoot/../services/MenuRegistry.ps1\"\n        $registry = [MenuRegistry]::GetInstance()\n\n        # Load menu items from manifest (only if not already loaded)\n        $tasksMenuItems = $registry.GetMenuItems('Tasks')\n        if (-not $tasksMenuItems -or @($tasksMenuItems).Count -eq 0) {\n            $manifestPath = Join-Path $PSScriptRoot \"MenuItems.psd1\"\n\n            # Get or create the service container\n            if (-not $global:PmcContainer) {\n                # Load ServiceContainer if not already loaded\n                . \"$PSScriptRoot/../ServiceContainer.ps1\"\n                $global:PmcContainer = [ServiceContainer]::new()\n\n                # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] TaskListScreen: Created new ServiceContainer\"\n            }\n\n            # Load manifest with container\n            $registry.LoadFromManifest($manifestPath, $global:PmcContainer)\n        }\n\n        # Build menus from registry\n        $this._PopulateMenusFromRegistry($registry)\n\n        # Store populated MenuBar globally for other screens to use\n        $global:PmcSharedMenuBar = $this.MenuBar\n    }\n\n    # Populate MenuBar from registry\n    hidden [void] _PopulateMenusFromRegistry([object]$registry) {\n        $menuMapping = @{\n            'Tasks'    = 0\n            'Projects' = 1\n            'Time'     = 2\n            'Tools'    = 3\n            'Options'  = 4\n            'Help'     = 5\n        }\n\n        foreach ($menuName in $menuMapping.Keys) {\n            $menuIndex = $menuMapping[$menuName]\n\n            # CRITICAL: Validate menu index bounds before access\n            if ($null -eq $this.MenuBar -or $null -eq $this.MenuBar.Menus) {\n                # Write-PmcTuiLog \"MenuBar or Menus collection is null - cannot populate menus\" \"ERROR\"\n                continue\n            }\n\n            if ($menuIndex -lt 0 -or $menuIndex -ge $this.MenuBar.Menus.Count) {\n                # Write-PmcTuiLog \"Menu index $menuIndex out of range (0-$($this.MenuBar.Menus.Count-1))\" \"ERROR\"\n                continue\n            }\n\n            $menu = $this.MenuBar.Menus[$menuIndex]\n            $items = $registry.GetMenuItems($menuName)\n\n            if ($global:PmcTuiLogFile) {\n                if ($null -eq $items) {\n                    Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] _PopulateMenusFromRegistry: Menu '$menuName' has 0 items from registry (null)\"\n                }\n                elseif ($items -is [array]) {\n                    Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] _PopulateMenusFromRegistry: Menu '$menuName' has $($items.Count) items from registry (array)\"\n                }\n                else {\n                    Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] _PopulateMenusFromRegistry: Menu '$menuName' has 1 item from registry (type: $($items.GetType().Name))\"\n                }\n            }\n\n            if ($null -ne $items) {\n                # CRITICAL: Clear existing items to prevent duplication\n                $menu.Items.Clear()\n\n                foreach ($item in $items) {\n                    # MEDIUM FIX TLS-M7: Validate $item is a hashtable before indexing\n                    if ($item -isnot [hashtable]) {\n                        # Write-PmcTuiLog \"_PopulateMenusFromRegistry: Item is not a hashtable, type: $($item.GetType().Name)\" \"WARNING\"\n                        continue\n                    }\n                    # MenuRegistry returns hashtables, use hashtable indexing\n                    $menuItem = [PmcMenuItem]::new($item['Label'], $item['Hotkey'], $item['Action'])\n                    $menu.Items.Add($menuItem)\n                }\n            }\n        }\n    }\n\n    # Filter tasks by view mode\n    hidden [array] _FilterTasksByViewMode([array]$allTasks) {\n        $result = switch ($this._viewMode) {\n            'all' { $allTasks }\n            'active' { $allTasks | Where-Object { -not (Get-SafeProperty $_ 'completed') } }\n            'completed' { $allTasks | Where-Object { Get-SafeProperty $_ 'completed' } }\n            'overdue' {\n                $allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and $due -lt [DateTime]::Today\n                }\n            }\n            'today' {\n                $allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and $due.Date -eq [DateTime]::Today\n                }\n            }\n            'tomorrow' {\n                $tomorrow = [DateTime]::Today.AddDays(1)\n                $allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and $due.Date -eq $tomorrow\n                }\n            }\n            'week' {\n                $weekEnd = [DateTime]::Today.AddDays(7)\n                $allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and\n                    $due -ge [DateTime]::Today -and $due -le $weekEnd\n                }\n            }\n            'nextactions' {\n                $allTasks | Where-Object {\n                    $dependsOn = Get-SafeProperty $_ 'depends_on'\n                    -not (Get-SafeProperty $_ 'completed') -and\n                    (-not $dependsOn -or (-not ($dependsOn -is [array])) -or $dependsOn.Count -eq 0)\n                }\n            }\n            'noduedate' {\n                $allTasks | Where-Object {\n                    -not (Get-SafeProperty $_ 'completed') -and -not (Get-SafeProperty $_ 'due')\n                }\n            }\n            'month' {\n                $monthEnd = [DateTime]::Today.AddDays(30)\n                $allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and\n                    $due -ge [DateTime]::Today -and $due -le $monthEnd\n                }\n            }\n            'agenda' {\n                $allTasks | Where-Object {\n                    -not (Get-SafeProperty $_ 'completed') -and (Get-SafeProperty $_ 'due')\n                }\n            }\n            'upcoming' {\n                $allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and $due.Date -gt [DateTime]::Today\n                }\n            }\n            default { $allTasks }\n        }\n        return $result\n    }\n\n    # Sort tasks by column\n    hidden [array] _SortTasks([array]$tasks) {\n        if ($null -eq $tasks -or $tasks.Count -eq 0) { return @() }\n\n        $result = switch ($this._sortColumn) {\n            'priority' { $tasks | Sort-Object { Get-SafeProperty $_ 'priority' } -Descending:(-not $this._sortAscending) }\n            'text' { $tasks | Sort-Object { Get-SafeProperty $_ 'text' } -Descending:(-not $this._sortAscending) }\n            'due' {\n                $withDue = @($tasks | Where-Object { Get-SafeProperty $_ 'due' })\n                $withoutDue = @($tasks | Where-Object { -not (Get-SafeProperty $_ 'due') })\n                if ($this._sortAscending) {\n                    @($withDue | Sort-Object { Get-SafeProperty $_ 'due' }) + $withoutDue\n                }\n                else {\n                    @($withDue | Sort-Object { Get-SafeProperty $_ 'due' } -Descending) + $withoutDue\n                }\n            }\n            'project' { $tasks | Sort-Object { Get-SafeProperty $_ 'project' } -Descending:(-not $this._sortAscending) }\n            default { $tasks }\n        }\n        return $result\n    }\n\n    # Build children index for hierarchy\n    hidden [hashtable] _BuildChildrenIndex([array]$tasks) {\n        $childrenByParent = @{}\n        foreach ($task in $tasks) {\n            $parentId = Get-SafeProperty $task 'parent_id'\n            if ($parentId) {\n                if (-not $childrenByParent.ContainsKey($parentId)) {\n                    $childrenByParent[$parentId] = [System.Collections.ArrayList]::new()\n                }\n                [void]$childrenByParent[$parentId].Add($task)\n            }\n        }\n        return $childrenByParent\n    }\n\n    # Organize tasks into hierarchy\n    hidden [array] _OrganizeHierarchy([array]$tasks) {\n        $organized = [System.Collections.ArrayList]::new()\n        $processedIds = @{}\n\n        # Build children index\n        $childrenByParent = $this._BuildChildrenIndex($tasks)\n        $this._childrenIndex = $childrenByParent\n\n        # Process parent tasks and their children\n        foreach ($task in $tasks) {\n            $taskId = Get-SafeProperty $task 'id'\n            $parentId = Get-SafeProperty $task 'parent_id'\n\n            if ($processedIds.ContainsKey($taskId)) { continue }\n\n            # Only process top-level tasks (no parent)\n            if (-not $parentId) {\n                [void]$organized.Add($task)\n                $processedIds[$taskId] = $true\n\n                # Add children if not collapsed\n                if ($childrenByParent.ContainsKey($taskId)) {\n                    $isCollapsed = $this._collapsedSubtasks.ContainsKey($taskId)\n                    foreach ($subtask in $childrenByParent[$taskId]) {\n                        $subId = Get-SafeProperty $subtask 'id'\n                        if (-not $processedIds.ContainsKey($subId)) {\n                            if (-not $isCollapsed) {\n                                [void]$organized.Add($subtask)\n                            }\n                            $processedIds[$subId] = $true\n                        }\n                    }\n                }\n            }\n        }\n\n        # Add orphaned subtasks\n        foreach ($task in $tasks) {\n            $taskId = Get-SafeProperty $task 'id'\n            if (-not $processedIds.ContainsKey($taskId)) {\n                [void]$organized.Add($task)\n                $processedIds[$taskId] = $true\n            }\n        }\n\n        return $organized\n    }\n\n    # Check if cache is valid\n    hidden [bool] _IsCacheValid([string]$currentKey) {\n        return ($this._cacheKey -eq $currentKey -and $null -ne $this._cachedFilteredTasks)\n    }\n\n    # Implement abstract method: Load data from TaskStore\n    [void] LoadData() {\n        $this._isLoading = $true\n        try {\n            # Build cache key\n            $collapsedKey = ($this._collapsedSubtasks.Keys | Sort-Object) -join ','\n            $currentKey = \"$($this._viewMode):$($this._sortColumn):$($this._sortAscending):$($this._showCompleted):$collapsedKey\"\n\n            # Return cached data if valid\n            if ($this._IsCacheValid($currentKey)) {\n                # Write-PmcTuiLog \"LoadData: Using cached data\" \"DEBUG\"\n                $this.List.SetData($this._cachedFilteredTasks)\n                return\n            }\n\n            # Load all tasks\n            $allTasks = $this.Store.GetAllTasks()\n            # Write-PmcTuiLog \"LoadData: Got $($allTasks.Count) tasks from Store\" \"DEBUG\"\n\n            if ($null -eq $allTasks -or $allTasks.Count -eq 0) {\n                $this.List.SetData(@())\n                $this._cachedFilteredTasks = @()\n                $this._cacheKey = $currentKey\n                return\n            }\n\n            # Filter by view mode\n            $filteredTasks = $this._FilterTasksByViewMode($allTasks)\n            if ($null -eq $filteredTasks) { $filteredTasks = @() }\n\n            # Apply completed filter\n            if (-not $this._showCompleted) {\n                $filteredTasks = $filteredTasks | Where-Object { -not (Get-SafeProperty $_ 'completed') }\n                if ($null -eq $filteredTasks) { $filteredTasks = @() }\n            }\n\n            # Sort tasks\n            $sortedTasks = $this._SortTasks($filteredTasks)\n\n            # Organize hierarchy\n            $organizedTasks = $this._OrganizeHierarchy($sortedTasks)\n\n            # Update stats and cache\n            $this._UpdateStats($allTasks)\n            $this._cachedFilteredTasks = $organizedTasks\n            $this._cacheKey = $currentKey\n\n            # Write-PmcTuiLog \"TaskListScreen.LoadData: Setting $($organizedTasks.Count) tasks\" \"DEBUG\"\n\n            # Set data and invalidate cache (do NOT request clear - let rendering system handle it)\n            $this.List.SetData($organizedTasks)\n\n            # Update detail pane with currently selected item (if any) after data load\n            # This ensures detail pane shows content on initial screen load\n            if ($this.DetailPane -and $this._showDetailPane -and $organizedTasks.Count -gt 0) {\n                $selectedItem = $this.List.GetSelectedItem()\n                if ($selectedItem) {\n                    $this.OnItemSelected($selectedItem)\n                }\n            }\n        }\n        finally {\n            $this._isLoading = $false\n        }\n    }\n\n    # Override to invalidate cache when data changes\n    hidden [void] _OnTaskStoreDataChanged() {\n        $this._cachedFilteredTasks = $null\n        $this._cacheKey = \"\"\n    }\n\n    # Implement abstract method: Define columns for UniversalList\n    [array] GetColumns() {\n        $self = $this\n\n        # CRITICAL FIX: Capture helper functions for scriptblock closures\n        # GetNewClosure() captures variables but NOT functions from outer scope\n        $getSafe = ${function:Global:Get-SafeProperty}\n        $testSafe = ${function:Global:Test-SafeProperty}\n\n        # Calculate column widths based on terminal width\n        # Account for 3 separators (2 spaces each = 6 chars total) between 4 columns (Details column removed)\n        $availableWidth = $(if ($this.List -and $this.List.Width -gt 4) { $this.List.Width - 4 - 8 } else { 105 })\n        $titleWidth = [Math]::Max(20, [Math]::Floor($availableWidth * 0.40))\n        $dueWidth = [Math]::Max(10, [Math]::Floor($availableWidth * 0.15))\n        $projectWidth = [Math]::Max(12, [Math]::Floor($availableWidth * 0.20))\n        $tagsWidth = [Math]::Max(10, [Math]::Floor($availableWidth * 0.25))\n\n        return @(\n            @{\n                Name             = 'title'\n                Label            = 'Task'\n                Width            = $titleWidth\n                Align            = 'left'\n                SkipRowHighlight = { param($item)\n                    # Skip row highlighting ONLY for the row being edited\n                    $itemId = & $getSafe $item 'id'\n                    # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [SkipRowHighlight] CALLED for item $itemId\"\n\n                    if (-not $self.ShowInlineEditor) {\n                        # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [SkipRowHighlight]   ShowInlineEditor=false, returning false\"\n                        return $false\n                    }\n                    if (-not $self.CurrentEditItem) {\n                        # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [SkipRowHighlight]   CurrentEditItem=null, returning false\"\n                        return $false\n                    }\n\n                    # Check if this item is the one being edited\n                    $editId = & $getSafe $self.CurrentEditItem 'id'\n                    # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [SkipRowHighlight]   Comparing: itemId=$itemId vs editId=$editId\"\n\n                    # Only skip rendering for the exact item being edited\n                    $skip = ($itemId -and $editId -and $itemId -eq $editId)\n                    # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [SkipRowHighlight]   Result: $skip\"\n                    return $skip\n                }.GetNewClosure()\n\n                Format           = { param($task, $cellInfo)\n                    try {\n                        $t = & $getSafe $task 'title'\n                        if (-not $t) { $t = & $getSafe $task 'text' }\n\n                        # Add subtask indicators with better indentation\n                        $taskId = & $getSafe $task 'id'\n                        $hasParent = (& $testSafe $task 'parent_id') -and (& $getSafe $task 'parent_id')\n                        if ($hasParent) {\n                            # For subtasks, add tree branch with indentation\n                            $t = \"  └─ $t\"  # Added extra spaces for indentation\n                        }\n                        else {\n                            # CRITICAL FIX: Use cached children index instead of GetAllTasks() in render loop\n                            $hasChildren = $self._childrenIndex.ContainsKey($taskId)\n                            if ($hasChildren) {\n                                $isCollapsed = $self._collapsedSubtasks.ContainsKey($taskId)\n                                $indicator = $(if ($isCollapsed) { \"▶\" } else { \"▼\" })\n                                $t = \"$indicator $t\"\n                            }\n                        }\n                        if (& $getSafe $task 'completed') {\n                            $t = \"[[OK]] $t\"\n                        }\n                        # CRITICAL FIX: Apply edit mode highlighting using theme\n                        if ($cellInfo.IsFocused -and $cellInfo.IsInEditMode) {\n                            $editBg = $self.List.GetThemedBg('Background.FieldFocused', $t.Length, 0)\n                            $editFg = $self.List.GetThemedFg('Foreground.FieldFocused')\n                            $reset = \"`e[0m\"\n                            return \"$editBg$editFg$t$reset\"\n                        }\n                        return $t\n                    }\n                    catch {\n                        $taskId = $(if ($task.id) { $task.id } else { \"unknown\" })\n                        # Write-PmcTuiLog \"Format title ERROR for task ${taskId}: $($_.Exception.Message)\" \"ERROR\"\n                        return \"(error: ${taskId})\"\n                    }\n                }.GetNewClosure()\n\n                Color            = { param($task)\n                    if (& $getSafe $task 'completed') {\n                        $mutedColor = $self.List.GetThemedFg('Foreground.Muted')\n                        return $(if ($self._supportsStrikethrough) { \"${mutedColor}`e[9m\" } else { $mutedColor })\n                    }\n                    $tags = & $getSafe $task 'tags'\n                    if ($tags -and $tags -is [array]) {\n                        if ($tags -contains 'urgent' -or $tags -contains 'critical') { return $self.List.GetThemedFg('Foreground.Error') }\n                        if ($tags -contains 'bug') { return $self.List.GetThemedFg('Foreground.Error') }\n                        if ($tags -contains 'feature') { return $self.List.GetThemedFg('Foreground.Success') }\n                    }\n                    return $self.List.GetThemedFg('Foreground.Row')\n                }.GetNewClosure()\n            }\n            @{\n                Name   = 'due'\n                Label  = 'Due'\n                Width  = $dueWidth\n                Align  = 'left'\n                Format = { param($task, $cellInfo)\n                    $d = & $getSafe $task 'due'\n                    if (-not $d) { return '' }\n                    try {\n                        $date = [DateTime]$d\n                        if ($date.Date -eq [DateTime]::Today) { return 'Today' }\n                        if ($date.Date -eq [DateTime]::Today.AddDays(1)) { return 'Tomorrow' }\n                        if ($date.Date -lt [DateTime]::Today) { return 'OVERDUE!' }\n                        return $date.ToString('MMM dd')\n                    }\n                    catch {\n                        return $d\n                    }\n                }.GetNewClosure()\n                Color  = { param($task)\n                    $d = & $getSafe $task 'due'\n                    if (-not $d -or (& $getSafe $task 'completed')) { return $self.List.GetThemedFg('Foreground.Muted') }\n                    try {\n                        $date = [DateTime]$d\n                        $diff = ($date.Date - [DateTime]::Today).Days\n                        if ($diff -lt 0) { return $self.List.GetThemedFg('Foreground.Error') }\n                        if ($diff -eq 0) { return $self.List.GetThemedFg('Foreground.Error') }\n                        if ($diff -le 3) { return $self.List.GetThemedFg('Foreground.Error') }\n                        return $self.List.GetThemedFg('Foreground.Success')\n                    }\n                    catch {\n                        return $self.List.GetThemedFg('Foreground.Muted')\n                    }\n                }.GetNewClosure()\n            }\n            @{\n                Name   = 'project'\n                Label  = 'Project'\n                Width  = $projectWidth\n                Align  = 'left'\n                Format = { param($task, $cellInfo)\n                    $p = & $getSafe $task 'project'\n                    if ($p -and $p.Length -gt $projectWidth) { return $p.Substring(0, $projectWidth - 3) + \"...\" }\n                    return $(if ($null -ne $p) { $p } else { '' })\n                }.GetNewClosure()\n\n                Color  = { return $self.List.GetThemedFg('Foreground.Row') }.GetNewClosure()\n            }\n            @{\n                Name   = 'tags'\n                Label  = 'Tags'\n                Width  = $tagsWidth\n                Align  = 'left'\n                Format = { param($task, $cellInfo)\n                    $t = & $getSafe $task 'tags'\n                    # Handle nested arrays (unwrap if needed)\n                    while ($t -is [array] -and $t.Count -eq 1 -and $t[0] -is [array]) {\n                        $t = $t[0]\n                    }\n                    # Convert array to string\n                    if ($t -is [array]) { $t = $t -join ', ' }\n                    # Convert to string explicitly\n                    $t = [string]$t\n                    if ($t -and $t.Length -gt $tagsWidth) { return $t.Substring(0, $tagsWidth - 3) + \"...\" }\n                    return $(if ($null -ne $t) { $t } else { '' })\n                }.GetNewClosure()\n            }\n        )\n    }\n\n    # Override: Get edit fields for inline editor\n    [array] GetEditFields($item) {\n        # CRITICAL: Match column widths from GetColumns() for proper alignment\n        # Calculate field widths using same logic as GetColumns()\n        $availableWidth = $(if ($this.List -and $this.List.Width -gt 4) { $this.List.Width - 4 - 8 } else { 105 })\n        $textWidth = [Math]::Max(20, [Math]::Floor($availableWidth * 0.40))\n        $dueWidth = [Math]::Max(10, [Math]::Floor($availableWidth * 0.15))\n        $projectWidth = [Math]::Max(12, [Math]::Floor($availableWidth * 0.20))\n        $tagsWidth = [Math]::Max(10, [Math]::Floor($availableWidth * 0.25))\n\n        return @(\n            @{ Name = 'text'; Label = 'Task'; Type = 'text'; Value = (Get-SafeProperty $item 'text'); Required = $true; MaxLength = 200; Width = $textWidth }\n            @{ Name = 'due'; Label = 'Due'; Type = 'date'; Value = (Get-SafeProperty $item 'due'); Width = $dueWidth }\n            @{ Name = 'project'; Label = 'Project'; Type = 'project'; Value = (Get-SafeProperty $item 'project'); Width = $projectWidth }\n            @{ Name = 'tags'; Label = 'Tags'; Type = 'tags'; Value = (Get-SafeProperty $item 'tags'); Width = $tagsWidth }\n        )\n    }\n\n    # Override: Handle item creation\n    [void] OnItemCreated([hashtable]$values) {\n        # MEDIUM FIX TLS-M3: Add null check on $values parameter\n        if ($null -eq $values) {\n            # Write-PmcTuiLog \"OnItemCreated called with null values\" \"ERROR\"\n            $this.SetStatusMessage(\"Cannot create task: no data provided\", \"error\")\n            return\n        }\n        try {\n            # Convert widget values to task format\n            # FIX: Convert \"(No Project)\" to empty string\n            $projectValue = ''\n            if ($values.ContainsKey('project') -and $values.project -ne '(No Project)') {\n                $projectValue = $values.project\n            }\n\n            # Validate text field (required)\n            $taskText = $(if ($values.ContainsKey('text')) { $values.text } else { '' })\n            if ([string]::IsNullOrWhiteSpace($taskText)) {\n                $this.SetStatusMessage(\"Task description is required\", \"error\")\n                return\n            }\n\n            # Validate text length\n            # MEDIUM FIX TLS-M1 & TLS-M2: Correct error message to match actual limit (200, not 500)\n            if ($taskText.Length -gt 200) {\n                $this.SetStatusMessage(\"Task description must be 200 characters or less\", \"error\")\n                return\n            }\n\n            # Handle tags - ensure it's an array\n            $tagsValue = $(if ($values.ContainsKey('tags') -and $values.tags) {\n                    if ($values.tags -is [array]) {\n                        , $values.tags  # Already an array\n                    }\n                    elseif ($values.tags -is [string]) {\n                        , @($values.tags -split ',' | ForEach-Object { $_.Trim() })\n                    }\n                    else {\n                        , @()\n                    }\n                }\n                else {\n                    , @()\n                })\n\n            $detailsValue = $(if ($values.ContainsKey('details')) { $values.details } else { '' })\n\n            $taskData = @{\n                text      = $taskText\n                details   = $detailsValue\n                priority  = 3  # Default priority when creating new tasks\n                status    = 'todo'  # Default status for new tasks\n                project   = $projectValue\n                tags      = $tagsValue  # Comma prevents PowerShell from unwrapping single-element arrays\n                completed = $false\n                created   = [DateTime]::Now\n            }\n\n            # Add due date if provided - NO VALIDATION, just set it\n            if ($values.ContainsKey('due') -and $values.due) {\n                try {\n                    $dueDate = [DateTime]$values.due\n                    $taskData.due = $dueDate\n                }\n                catch {\n                    # Write-PmcTuiLog \"Failed to convert due date '$($values.due)', omitting\" \"WARNING\"\n                }\n            }\n\n            # H-VAL-3: Preserve parent_id from CurrentEditItem if it exists (for subtasks)\n            # FIX: Safe property access for parent_id with validation\n            if ($this.CurrentEditItem) {\n                $parentId = Get-SafeProperty $this.CurrentEditItem 'parent_id'\n                if ($parentId) {\n                    # Validate parent exists before setting\n                    $parentTask = $this.Store.GetTask($parentId)\n                    if ($parentTask) {\n                        $taskData.parent_id = $parentId\n                    }\n                    else {\n                        # Write-PmcTuiLog \"OnItemCreated: Invalid parent_id $parentId (not found), omitting\" \"WARNING\"\n                        $this.SetStatusMessage(\"Warning: Parent task not found, creating without parent\", \"warning\")\n                    }\n                }\n            }\n\n            # VALIDATION DISABLED - Save directly without validation\n\n            # Add to store (auto-persists and fires events)\n            $success = $this.Store.AddTask($taskData)\n            if ($success) {\n                $this.SetStatusMessage(\"Task created: $($taskData.text)\", \"success\")\n            }\n            else {\n                $this.SetStatusMessage(\"Failed to create task: $($this.Store.LastError)\", \"error\")\n            }\n        }\n        catch {\n            # LOW FIX TLS-L1: Add context to exception messages\n            $taskText = $(if ($values.ContainsKey('text')) { $values.text } else { \"(no title)\" })\n            # Write-PmcTuiLog \"OnItemCreated exception while creating task '$taskText': $_\" \"ERROR\"\n            $this.SetStatusMessage(\"Error creating task '$taskText': $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    # Override: Handle item update\n    [void] OnItemUpdated([object]$item, [hashtable]$values) {\n        # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] START item=$($item.id)\"\n        # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] Values received: $($values | ConvertTo-Json -Compress)\"\n        # Write-PmcTuiLog \"OnItemUpdated CALLED - item=$($item.id) values=$($values.Keys -join ',')\" \"INFO\"\n        # Write-PmcTuiLog \"OnItemUpdated values: $($values | ConvertTo-Json -Compress)\" \"INFO\"\n\n        # CRITICAL FIX: Check if this is ADD mode (item is null)\n        $isAddMode = ($null -eq $item)\n\n        if ($isAddMode) {\n            # Write-PmcTuiLog \"OnItemUpdated: Processing ADD (new task) mode\" \"INFO\"\n            # Create new task instead of updating existing\n            $this.OnItemCreated($values)\n            return\n        }\n\n        # MEDIUM FIX TLS-M4: Add null checks on parameters\n        if ($null -eq $item) {\n            # Write-PmcTuiLog \"OnItemUpdated called with null item in EDIT mode\" \"ERROR\"\n            $this.SetStatusMessage(\"Cannot update task: no item selected\", \"error\")\n            return\n        }\n        if ($null -eq $values) {\n            # Write-PmcTuiLog \"OnItemUpdated called with null values\" \"ERROR\"\n            $this.SetStatusMessage(\"Cannot update task: no data provided\", \"error\")\n            return\n        }\n        try {\n            # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] Entering try block\"\n            # Build changes hashtable\n            # FIX: Convert \"(No Project)\" to empty string\n            $projectValue = ''\n            if ($values.ContainsKey('project')) {\n                # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] Processing project value: $($values.project)\"\n                if ($values.project -is [array]) {\n                    # If it's an array, take first element\n                    if ($values.project.Count -gt 0) {\n                        $projectValue = [string]$values.project[0]\n                    }\n                }\n                elseif ($values.project -is [string] -and $values.project -ne '(No Project)' -and $values.project -ne '') {\n                    $projectValue = $values.project\n                }\n            }\n            # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] Project value set to: '$projectValue'\"\n\n            # Validate text field (required)\n            $taskText = $(if ($values.ContainsKey('text')) { $values.text } else { '' })\n            # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] Task text: '$taskText' (length=$($taskText.Length))\"\n            if ([string]::IsNullOrWhiteSpace($taskText)) {\n                # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] VALIDATION FAILED: text is empty\"\n                $this.SetStatusMessage(\"Task description is required\", \"error\")\n                return\n            }\n\n            # Validate text length\n            # MEDIUM FIX TLS-M1 & TLS-M2: Correct error message to match actual limit (200, not 500)\n            if ($taskText.Length -gt 200) {\n                # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] VALIDATION FAILED: text too long ($($taskText.Length) > 200)\"\n                $this.SetStatusMessage(\"Task description must be 200 characters or less\", \"error\")\n                return\n            }\n            # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] Text validation passed\"\n\n            # Ensure all values have correct types for Store validation\n            $detailsValue = $(if ($values.ContainsKey('details')) { $values.details } else { '' })\n            # Handle tags - ensure it's an array and use comma operator to prevent unwrapping\n            $tagsValue = $(if ($values.ContainsKey('tags') -and $values.tags) {\n                    if ($values.tags -is [array]) {\n                        , $values.tags  # Comma prevents PowerShell from unwrapping single-element arrays\n                    }\n                    elseif ($values.tags -is [string]) {\n                        $splitResult = @($values.tags -split ',' | ForEach-Object { $_.Trim() })\n                        , $splitResult  # Comma prevents unwrapping\n                    }\n                    else {\n                        , @()\n                    }\n                }\n                else {\n                    , @()\n                })\n\n            $changes = @{\n                text    = [string]$taskText\n                details = [string]$detailsValue\n                project = [string]$projectValue\n                tags    = $tagsValue  # Comma prevents PowerShell from unwrapping single-element arrays\n            }\n\n            # Update due date with validation\n            if ($values.ContainsKey('due') -and $values.due) {\n                try {\n                    $dueDate = [DateTime]$values.due\n                    # Validate date is reasonable\n                    $minDate = [DateTime]::Today.AddDays(-7) # Allow past week for updates\n                    $maxDate = [DateTime]::Today.AddYears(10)\n\n                    if ($dueDate -lt $minDate) {\n                        $this.SetStatusMessage(\"Due date too far in the past (max 7 days)\", \"warning\")\n                        # Don't return - just omit the due date update\n                    }\n                    elseif ($dueDate -gt $maxDate) {\n                        $this.SetStatusMessage(\"Due date cannot be more than 10 years in the future\", \"warning\")\n                        # Don't return - just omit the due date update\n                    }\n                    else {\n                        $changes.due = $dueDate\n                    }\n                }\n                catch {\n                    $this.SetStatusMessage(\"Invalid due date format\", \"warning\")\n                    # Write-PmcTuiLog \"Failed to convert due date '$($values.due)', omitting\" \"WARNING\"\n                    # Don't include due in changes - keep existing value\n                }\n            }\n            else {\n                $changes.due = $null\n            }\n\n            # CRITICAL FIX: Check for circular dependency when changing parent_id\n            if ($values.ContainsKey('parent_id') -and $values.parent_id) {\n                $newParentId = $values.parent_id\n                $taskId = Get-SafeProperty $item 'id'\n\n                # Validate parent exists\n                $parentTask = $this.Store.GetTask($newParentId)\n                if (-not $parentTask) {\n                    $this.SetStatusMessage(\"Cannot set parent: parent task not found\", \"error\")\n                    # Write-PmcTuiLog \"OnItemUpdated: Invalid parent_id $newParentId, task not found\" \"ERROR\"\n                    return\n                }\n\n                # Check for circular dependency\n                if ($this._IsCircularDependency($newParentId, $taskId)) {\n                    $this.SetStatusMessage(\"Cannot set parent: would create circular dependency\", \"error\")\n                    # Write-PmcTuiLog \"OnItemUpdated: Circular dependency detected for task $taskId with parent $newParentId\" \"ERROR\"\n                    return\n                }\n\n                $changes.parent_id = $newParentId\n            }\n            elseif ($values.ContainsKey('parent_id')) {\n                # Explicitly clear parent_id if value is null/empty\n                $changes.parent_id = $null\n            }\n\n            # VALIDATION DISABLED - Save directly without validation\n\n            # Update in store\n            # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] Calling Store.UpdateTask with id=$($item.id)\"\n            # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] Changes: $($changes | ConvertTo-Json -Compress)\"\n            $success = $this.Store.UpdateTask($item.id, $changes)\n            # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] Store.UpdateTask returned: $success\"\n\n            if ($success) {\n                # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] SUCCESS - calling LoadData()\"\n                $this.SetStatusMessage(\"Task updated: $($values.text)\", \"success\")\n                try {\n                    $this.LoadData()  # Refresh the list to show updated data\n                    # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] LoadData() completed\"\n                }\n                catch {\n                    # Write-PmcTuiLog \"OnItemUpdated: LoadData failed: $_\" \"WARNING\"\n                    # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] LoadData() FAILED: $_\"\n                    $this.SetStatusMessage(\"Task updated but display refresh failed\", \"warning\")\n                }\n            }\n            else {\n                # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [OnItemUpdated] FAILED: $($this.Store.LastError)\"\n                $this.SetStatusMessage(\"Failed to update task: $($this.Store.LastError)\", \"error\")\n                # BUG-4 FIX: Reload data on failure to restore consistent state\n                try {\n                    $this.LoadData()\n                }\n                catch {\n                    # Write-PmcTuiLog \"OnItemUpdated: LoadData after failure failed: $_\" \"WARNING\"\n                }\n            }\n        }\n        catch {\n            # LOW FIX TLS-L1: Add context to exception messages\n            $taskId = $(if ($null -ne $item -and (Get-SafeProperty $item 'id')) { $item.id } else { \"(unknown)\" })\n            $taskText = $(if ($values.ContainsKey('text')) { $values.text } else { if ($null -ne $item) { (Get-SafeProperty $item 'text') } else { \"(no title)\" } })\n            # Write-PmcTuiLog \"OnItemUpdated exception while updating task '$taskText' (ID: $taskId): $_\" \"ERROR\"\n            $this.SetStatusMessage(\"Error updating task '$taskText': $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    # Override: Handle item deletion\n    [void] OnItemDeleted([object]$item) {\n        # CRITICAL FIX TLS-C2: Add null check on $item\n        if ($null -eq $item) {\n            # Write-PmcTuiLog \"OnItemDeleted called with null item\" \"ERROR\"\n            $this.SetStatusMessage(\"Cannot delete: no item selected\", \"error\")\n            return\n        }\n        $taskId = Get-SafeProperty $item 'id'\n        if ($null -eq $taskId) {\n            # Write-PmcTuiLog \"OnItemDeleted called with item missing id property\" \"ERROR\"\n            $this.SetStatusMessage(\"Cannot delete: task has no ID\", \"error\")\n            return\n        }\n\n        # BUG-15 FIX: Check for subtasks before deletion to prevent orphaning\n        if ($this._childrenIndex.ContainsKey($taskId)) {\n            $childCount = $this._childrenIndex[$taskId].Count\n            $taskText = Get-SafeProperty $item 'text'\n\n            # Log detailed guidance for resolving the blocker\n            # Write-PmcTuiLog \"OnItemDeleted: Cannot delete parent task '$taskText' (ID: $taskId) with $childCount subtasks\" \"WARNING\"\n            # Write-PmcTuiLog \"OnItemDeleted: User must either: (1) Delete each subtask individually, or (2) Reassign subtasks to different parent\" \"INFO\"\n\n            # Show actionable error message to user\n            $this.SetStatusMessage(\"Cannot delete: task has $childCount subtask(s). Delete or reassign each subtask first, then retry.\", \"error\")\n\n            # TODO ENHANCEMENT: Add bulk reassignment dialog\n            # Future enhancement: Show interactive dialog with options:\n            # - Option 1: Delete all subtasks recursively (with confirmation)\n            # - Option 2: Reassign all subtasks to a different parent task\n            # - Option 3: Move all subtasks to root level (remove parent)\n            # This would eliminate tedious manual work for large task hierarchies\n\n            return\n        }\n\n        try {\n            $success = $this.Store.DeleteTask($taskId)\n            if ($success) {\n                $this.SetStatusMessage(\"Task deleted: $($item.text)\", \"success\")\n            }\n            else {\n                $this.SetStatusMessage(\"Failed to delete task: $($this.Store.LastError)\", \"error\")\n            }\n        }\n        catch {\n            # LOW FIX TLS-L1: Add context to exception messages\n            $taskId = $(if ($null -ne $item) { (Get-SafeProperty $item 'id') } else { \"(unknown)\" })\n            $taskText = $(if ($null -ne $item) { (Get-SafeProperty $item 'text') } else { \"(no title)\" })\n            # Write-PmcTuiLog \"OnItemDeleted exception while deleting task '$taskText' (ID: $taskId): $_\" \"ERROR\"\n            $this.SetStatusMessage(\"Error deleting task '$taskText': $($_.Exception.Message)\", \"error\")\n        }\n    }\n\n    # Virtual method called when inline editor is confirmed\n    [void] OnInlineEditConfirmed([hashtable]$values) {\n        # This method is called by StandardListScreen when inline editing is confirmed\n        # It handles BOTH add and edit modes, since EditItem only overrides the callback for edit mode\n        # Write-PmcTuiLog \"OnInlineEditConfirmed called - EditorMode=$($this.EditorMode) values=$($values.Keys -join ',')\" \"DEBUG\"\n\n        if ($null -eq $values) {\n            # Write-PmcTuiLog \"OnInlineEditConfirmed called with null values\" \"WARNING\"\n            return\n        }\n\n        # Determine if we're adding a new task or editing existing one\n        $isAddMode = ($this.EditorMode -eq 'add')\n\n        if ($isAddMode) {\n            # ADDING NEW TASK\n            # Write-PmcTuiLog \"OnInlineEditConfirmed: Processing ADD operation\" \"INFO\"\n            $this.OnItemUpdated($null, $values)\n        }\n        else {\n            # EDITING EXISTING TASK\n            # Write-PmcTuiLog \"OnInlineEditConfirmed: Processing EDIT operation for item=$($this.CurrentEditItem.id)\" \"INFO\"\n            if ($this.CurrentEditItem) {\n                $this.OnItemUpdated($this.CurrentEditItem, $values)\n            }\n            else {\n                # Write-PmcTuiLog \"OnInlineEditConfirmed: EDIT mode but no CurrentEditItem!\" \"ERROR\"\n            }\n        }\n    }\n\n    # Virtual method called when inline editor is cancelled\n    [void] OnInlineEditCancelled() {\n        # This method is called by StandardListScreen when inline editing is cancelled\n        # TaskListScreen overrides the InlineEditor callbacks, so this is rarely called\n        # But we provide it for completeness and to prevent method-not-found errors\n        # Write-PmcTuiLog \"OnInlineEditCancelled called\" \"DEBUG\"\n        # No-op: TaskListScreen handles inline editor callbacks directly\n    }\n\n    # Custom action: Toggle task completion\n    [void] ToggleTaskCompletion([object]$task) {\n        if ($null -eq $task) { return }\n\n        $completed = Get-SafeProperty $task 'completed'\n        $taskId = Get-SafeProperty $task 'id'\n        $taskText = Get-SafeProperty $task 'text'\n\n        $newStatus = -not $completed\n        # CRITICAL FIX: Clear completed_at when reopening task, set it when completing\n        $updates = @{ completed = $newStatus }\n        if ($newStatus) {\n            $updates.completed_at = [DateTime]::Now\n        }\n        else {\n            $updates.completed_at = $null\n        }\n        $success = $this.Store.UpdateTask($taskId, $updates)\n\n        if ($success) {\n            $statusText = $(if ($newStatus) { \"completed\" } else { \"reopened\" })\n            $this.SetStatusMessage(\"Task ${statusText}: $taskText\", \"success\")\n            # TaskStore event will invalidate cache and trigger refresh\n        }\n        else {\n            $this.SetStatusMessage(\"Failed to update task: $($this.Store.LastError)\", \"error\")\n            # Write-PmcTuiLog \"ToggleTaskCompletion failed: $($this.Store.LastError)\" \"ERROR\"\n            # BUG-4 FIX: Reload data on failure to restore consistent state\n            try {\n                $this.LoadData()\n            }\n            catch {\n                # Write-PmcTuiLog \"ToggleTaskCompletion: LoadData after failure failed: $_\" \"WARNING\"\n            }\n        }\n    }\n\n    # Custom action: Mark task complete\n    [void] CompleteTask([object]$task) {\n        if ($null -eq $task) {\n            # Write-PmcTuiLog \"CompleteTask called with null task\" \"WARNING\"\n            return\n        }\n        # Write-PmcTuiLog \"CompleteTask called for task: $($task.id)\" \"INFO\"\n\n        $taskId = Get-SafeProperty $task 'id'\n        $taskText = Get-SafeProperty $task 'text'\n\n        $success = $this.Store.UpdateTask($taskId, @{\n                completed    = $true\n                completed_at = [DateTime]::Now\n            })\n\n        if ($success) {\n            $this.SetStatusMessage(\"Task completed: $taskText\", \"success\")\n            # TaskStore event will invalidate cache and trigger refresh\n        }\n        else {\n            $this.SetStatusMessage(\"Failed to complete task: $($this.Store.LastError)\", \"error\")\n            # Write-PmcTuiLog \"CompleteTask failed: $($this.Store.LastError)\" \"ERROR\"\n            # BUG-4 FIX: Reload data on failure to restore consistent state\n            try {\n                $this.LoadData()\n            }\n            catch {\n                # Write-PmcTuiLog \"CompleteTask: LoadData after failure failed: $_\" \"WARNING\"\n            }\n        }\n    }\n\n    # Custom action: Clone task\n    [void] CloneTask([object]$task) {\n        if ($null -eq $task) { return }\n\n        $taskText = Get-SafeProperty $task 'text'\n        $taskPriority = Get-SafeProperty $task 'priority'\n        $taskProject = Get-SafeProperty $task 'project'\n        $taskTags = Get-SafeProperty $task 'tags'\n        $taskDue = Get-SafeProperty $task 'due'\n\n        $clonedTask = @{\n            text         = \"$taskText (copy)\"\n            priority     = $taskPriority\n            project      = $taskProject\n            tags         = $taskTags\n            completed    = $false\n            completed_at = $null  # Explicitly clear timestamp\n            created      = [DateTime]::Now\n        }\n\n        if ($taskDue) {\n            $clonedTask.due = $taskDue\n        }\n\n        $success = $this.Store.AddTask($clonedTask)\n        if ($success) {\n            $this.SetStatusMessage(\"Task cloned: $($clonedTask.text)\", \"success\")\n            # TaskStore event will invalidate cache and trigger refresh\n        }\n        else {\n            $this.SetStatusMessage(\"Failed to clone task: $($this.Store.LastError)\", \"error\")\n            # Write-PmcTuiLog \"CloneTask failed: $($this.Store.LastError)\" \"ERROR\"\n        }\n    }\n\n    # H-VAL-3: Check for circular dependency in task hierarchy\n    hidden [bool] _IsCircularDependency([string]$parentId, [string]$childId) {\n        $current = $parentId\n        $visited = @{}\n\n        while ($current) {\n            # If we encounter the child ID in the parent chain, it's circular\n            if ($current -eq $childId) { return $true }\n\n            # Detect infinite loop (same parent visited twice)\n            if ($visited.ContainsKey($current)) { return $true }\n            $visited[$current] = $true\n\n            # Get the parent of the current task\n            $task = $this.Store.GetTask($current)\n            $current = $(if ($task) { Get-SafeProperty $task 'parent_id' } else { $null })\n        }\n\n        return $false\n    }\n\n    # Custom action: Add subtask\n    [void] AddSubtask([object]$parentTask) {\n        if ($null -eq $parentTask) { return }\n\n        # Get parent id with null check\n        $parentId = $null\n        if ($parentTask -is [hashtable] -and $parentTask.ContainsKey('id')) {\n            $parentId = $parentTask['id']\n        }\n        elseif ($parentTask.PSObject.Properties['id']) {\n            $parentId = $parentTask.id\n        }\n\n        if ($null -eq $parentId) {\n            $this.SetStatusMessage(\"Cannot add subtask: parent task has no ID\", \"error\")\n            return\n        }\n\n        # Create new task with parent_id set\n        $subtask = @{\n            text      = \"\"\n            priority  = 3\n            project   = \"\"\n            tags      = @()\n            completed = $false\n            created   = [DateTime]::Now\n            parent_id = $parentId\n        }\n\n        # CRITICAL FIX: Set EditorMode so UniversalList knows to render the editor\n        # This was missing, causing the editor to be invisible (though functionally active)\n        $this.EditorMode = 'add'\n        $this.CurrentEditItem = $subtask\n\n        # Use base class inline editor system\n        # Configure for horizontal inline editing\n        $this.InlineEditor.LayoutMode = 'horizontal'\n        $fields = $this.GetEditFields($subtask)\n        $this.InlineEditor.SetFields($fields)\n        $this.InlineEditor.Title = \"Add Subtask\"\n\n        # CRITICAL FIX: Position editor using List selection like AddItem() does\n        # Don't use manual SetPosition - let UniversalList render it inline\n        $itemCount = $(if ($this.List._filteredData) { $this.List._filteredData.Count } else { 0 })\n        $this.List._selectedIndex = $itemCount  # Select the \"new row\" position\n\n        # Set up callbacks for subtask creation\n        $self = $this\n        $this.InlineEditor.OnConfirmed = {\n            param($values)\n            # Ensure parent_id is preserved\n            $values.parent_id = $parentId\n            $self.Store.AddTask($values)\n            $self.ShowInlineEditor = $false\n            $self.RefreshList()\n            $self.SetStatusMessage(\"Subtask added\", \"success\")\n        }.GetNewClosure()\n\n        $this.InlineEditor.OnCancelled = {\n            $self.ShowInlineEditor = $false\n            $self.SetStatusMessage(\"Subtask cancelled\", \"info\")\n        }.GetNewClosure()\n\n        # Use base class flag\n        $this.ShowInlineEditor = $true\n        $this.SetStatusMessage(\"Add subtask - Tab=next field, Enter=save, Esc=cancel\", \"info\")\n    }\n\n    # Custom action: Bulk complete selected tasks\n    [void] BulkCompleteSelected() {\n        $selected = $this.List.GetSelectedItems()\n        if ($selected.Count -eq 0) {\n            $this.SetStatusMessage(\"No tasks selected\", \"warning\")\n            return\n        }\n\n        $successCount = 0\n        $failCount = 0\n        foreach ($task in $selected) {\n            $taskId = Get-SafeProperty $task 'id'\n            $success = $this.Store.UpdateTask($taskId, @{\n                    completed    = $true\n                    completed_at = [DateTime]::Now\n                })\n            if ($success) {\n                $successCount++\n            }\n            else {\n                $failCount++\n                # Write-PmcTuiLog \"BulkCompleteSelected failed for task ${taskId}: $($this.Store.LastError)\" \"ERROR\"\n            }\n        }\n\n        if ($failCount -eq 0) {\n            $this.SetStatusMessage(\"Completed $successCount tasks\", \"success\")\n        }\n        else {\n            $this.SetStatusMessage(\"Completed $successCount tasks, failed $failCount\", \"warning\")\n        }\n        $this.List.ClearSelection()\n\n        # BUG-12 FIX: Reload data after bulk operations to show updated state\n        try {\n            $this.LoadData()\n        }\n        catch {\n            # Write-PmcTuiLog \"BulkCompleteSelected: LoadData failed: $_\" \"WARNING\"\n        }\n    }\n\n    # Custom action: Bulk delete selected tasks\n    [void] BulkDeleteSelected() {\n        $selected = $this.List.GetSelectedItems()\n        if ($selected.Count -eq 0) {\n            $this.SetStatusMessage(\"No tasks selected\", \"warning\")\n            return\n        }\n\n        $successCount = 0\n        $failCount = 0\n        $skippedCount = 0\n        foreach ($task in $selected) {\n            $taskId = Get-SafeProperty $task 'id'\n            # BUG-15 FIX: Check for subtasks before deletion\n            if ($this._childrenIndex.ContainsKey($taskId)) {\n                $childCount = $this._childrenIndex[$taskId].Count\n                # Write-PmcTuiLog \"BulkDeleteSelected: Skipping task $taskId with $childCount subtasks\" \"WARNING\"\n                $skippedCount++\n                continue\n            }\n            $success = $this.Store.DeleteTask($taskId)\n            if ($success) {\n                $successCount++\n            }\n            else {\n                $failCount++\n                # Write-PmcTuiLog \"BulkDeleteSelected failed for task ${taskId}: $($this.Store.LastError)\" \"ERROR\"\n            }\n        }\n\n        if ($failCount -eq 0 -and $skippedCount -eq 0) {\n            $this.SetStatusMessage(\"Deleted $successCount tasks\", \"success\")\n        }\n        elseif ($skippedCount -gt 0) {\n            $this.SetStatusMessage(\"Deleted $successCount, skipped $skippedCount (have subtasks), failed $failCount\", \"warning\")\n        }\n        else {\n            $this.SetStatusMessage(\"Deleted $successCount tasks, failed $failCount\", \"warning\")\n        }\n        $this.List.ClearSelection()\n    }\n\n    # Change view mode\n    [void] SetViewMode([string]$mode) {\n        $validModes = @('all', 'active', 'completed', 'overdue', 'today', 'tomorrow', 'week', 'nextactions', 'noduedate', 'month', 'agenda', 'upcoming')\n        if ($mode -notin $validModes) {\n            # Write-PmcTuiLog \"Invalid view mode '$mode', defaulting to 'all'\" \"WARNING\"\n            $mode = 'all'\n        }\n\n        $this._viewMode = $mode\n        $titleText = Get-TaskListTitle $mode\n        $this.ScreenTitle = $titleText\n        if ($this.List) {\n            $this.List.Title = $titleText\n        }\n        $this.LoadData()\n        $this.SetStatusMessage(\"View: $mode\", \"info\")\n    }\n\n    # Toggle show completed\n    [void] ToggleShowCompleted() {\n        $this._showCompleted = -not $this._showCompleted\n        $this.LoadData()\n\n        $status = $(if ($this._showCompleted) { \"showing\" } else { \"hiding\" })\n        $this.SetStatusMessage(\"Now $status completed tasks\", \"info\")\n    }\n\n    # Change sort column\n    [void] SetSortColumn([string]$column) {\n        if ($this._sortColumn -eq $column) {\n            # Toggle sort direction\n            $this._sortAscending = -not $this._sortAscending\n        }\n        else {\n            $this._sortColumn = $column\n            $this._sortAscending = $true\n        }\n\n        $this.LoadData()\n\n        $direction = $(if ($this._sortAscending) { \"ascending\" } else { \"descending\" })\n        $this.SetStatusMessage(\"Sorting by $column ($direction)\", \"info\")\n    }\n\n    # Override: Apply 70/30 split layout for List and DetailPane\n    [void] ApplyContentLayout([PmcLayoutManager]$layoutManager, [int]$termWidth, [int]$termHeight) {\n        # Don't call base - we handle everything ourselves\n        $rect = $layoutManager.GetRegion('Content', $termWidth, $termHeight)\n\n        if ($this._showDetailPane -and $this.DetailPane) {\n            # 70/30 split within the content region\n            $listWidth = [Math]::Floor($rect.Width * 0.70)\n            $detailWidth = $rect.Width - $listWidth - 1  # -1 for spacing\n\n            $this.List.SetPosition($rect.X, $rect.Y)\n            $this.List.SetSize($listWidth, $rect.Height)\n\n            # CRITICAL FIX: Re-calculate and apply columns to match new list width\n            # This ensures percentages in GetColumns() use the new $listWidth\n            $newCols = $this.GetColumns()\n            $this.List.SetColumns($newCols)\n\n            $this.DetailPane.SetPosition($rect.X + $listWidth + 1, $rect.Y)\n            $this.DetailPane.SetSize($detailWidth, $rect.Height)\n            $this.DetailPane.Visible = $true\n            $this.DetailPane.ShowBorder = $true # Ensure border is on\n            \n            # Position TextAreaEditor INSIDE the DetailPane (inset by 1 for border + 1 for padding = 2)\n            # This prevents overwriting the border and fixes cursor alignment\n            if ($this._detailEditor) {\n                $editorX = $rect.X + $listWidth + 1 + 2\n                $editorY = $rect.Y + 1\n                $editorW = $detailWidth - 4\n                $editorH = $rect.Height - 2\n                \n                # Ensure dimensions are positive\n                if ($editorW -lt 1) { $editorW = 1 }\n                if ($editorH -lt 1) { $editorH = 1 }\n\n                $this._detailEditor.SetBounds($editorX, $editorY, $editorW, $editorH)\n                # Visibility is controlled in RenderContentToEngine, but ensure it's technically 'visible' for input\n                $this._detailEditor.Visible = $true\n            }\n        } else {\n            # Full width list\n            $this.List.SetPosition($rect.X, $rect.Y)\n            $this.List.SetSize($rect.Width, $rect.Height)\n\n            # CRITICAL FIX: Re-calculate columns for full width\n            $newCols = $this.GetColumns()\n            $this.List.SetColumns($newCols)\n\n            if ($this.DetailPane) {\n            if ($this._detailEditor) {\n                $this._detailEditor.Visible = $false\n            }\n                $this.DetailPane.Visible = $false\n            }\n        }\n\n        # Invalidate cache to force column recalculation\n        $this.List.InvalidateCache()\n    }\n\n    # Override: Update detail pane when selection changes\n    [void] OnItemSelected($item) {\n        # Call base implementation\n        ([StandardListScreen]$this).OnItemSelected($item)\n\n        # Update both DetailPane and TextAreaEditor with task description\n        if ($this._showDetailPane) {\n            if ($null -ne $item) {\n                $desc = Get-SafeProperty $item 'description' -Default \"\"\n                # Apply word wrap to description\n                # Calculate wrap width based on DetailPane width (or default if not visible yet)\n                $wrapWidth = $(if ($this.DetailPane.Width -gt 4) { $this.DetailPane.Width - 4 } else { 40 })\n                $wrappedDesc = $this._WrapText($desc, $wrapWidth)\n\n                # Update both widgets\n                if ($this._detailEditor) {\n                    $this._detailEditor.SetText($wrappedDesc)\n                }\n                if ($this.DetailPane) {\n                    $this.DetailPane.SetContent($wrappedDesc, 'left')\n                }\n            } else {\n                if ($this._detailEditor) {\n                    $this._detailEditor.SetText(\"\")\n                }\n                if ($this.DetailPane) {\n                    $this.DetailPane.SetContent(\"Select a task to view details\", 'left')\n                }\n            }\n        }\n    }\n\n    # Toggle detail pane visibility\n    hidden [void] _ToggleDetailPane() {\n        $this._showDetailPane = -not $this._showDetailPane\n\n        # Force layout recalculation\n        $this.Resize($this.TermWidth, $this.TermHeight)\n\n        if ($this._showDetailPane) {\n            $this.SetStatusMessage(\"Detail pane visible\", \"info\")\n            # Update with current selection\n            $selected = $this.List.GetSelectedItem()\n            if ($selected) {\n                $this.OnItemSelected($selected)\n            }\n        } else {\n            $this.SetStatusMessage(\"Detail pane hidden\", \"info\")\n        }\n    }\n\n    # Format task details for display in detail pane\n    hidden [string] _FormatTaskDetails([object]$task) {\n        $sb = [System.Text.StringBuilder]::new()\n\n        $title = Get-SafeProperty $task 'text'\n        $project = Get-SafeProperty $task 'project'\n        $tags = Get-SafeProperty $task 'tags'\n        $due = Get-SafeProperty $task 'due'\n        $details = Get-SafeProperty $task 'details'\n        $priority = Get-SafeProperty $task 'priority'\n        $completed = Get-SafeProperty $task 'completed'\n\n        [void]$sb.AppendLine(\"Task: $title\")\n        [void]$sb.AppendLine(\"\")\n\n        if ($completed) {\n            [void]$sb.AppendLine(\"Status: COMPLETED\")\n        } else {\n            [void]$sb.AppendLine(\"Status: Active\")\n        }\n\n        if ($priority) {\n            [void]$sb.AppendLine(\"Priority: $priority\")\n        }\n\n        if ($project) {\n            [void]$sb.AppendLine(\"Project: $project\")\n        }\n\n        if ($tags -and $tags -is [array] -and $tags.Count -gt 0) {\n            [void]$sb.AppendLine(\"Tags: $($tags -join ', ')\")\n        }\n\n        if ($due) {\n            try {\n                $dueDate = [DateTime]$due\n                [void]$sb.AppendLine(\"Due: $($dueDate.ToString('yyyy-MM-dd (ddd)'))\")\n            } catch {\n                [void]$sb.AppendLine(\"Due: $due\")\n            }\n        }\n\n        [void]$sb.AppendLine(\"\")\n\n        if ($details) {\n            # Word wrap based on DetailPane width (accounting for padding and borders)\n            $wrapWidth = $(if ($this.DetailPane.Width -gt 6) { $this.DetailPane.Width - 6 } else { 30 })\n            $wrapped = $this._WrapText($details, $wrapWidth)\n            [void]$sb.AppendLine(\"Details:\")\n            [void]$sb.AppendLine($wrapped)\n        }\n\n        return $sb.ToString()\n    }\n\n    # Word wrap text to fit within specified width\n    hidden [string] _WrapText([string]$text, [int]$width) {\n        if ([string]::IsNullOrEmpty($text)) { return \"\" }\n        if ($width -le 0) { return $text }\n\n        $result = [System.Collections.Generic.List[string]]::new()\n\n        # Split by existing newlines first\n        $paragraphs = $text -split \"`r?`n\"\n\n        foreach ($para in $paragraphs) {\n            if ([string]::IsNullOrWhiteSpace($para)) {\n                $result.Add(\"\")\n                continue\n            }\n\n            # Wrap this paragraph\n            $words = $para -split '\\s+'\n            $currentLine = \"\"\n\n            foreach ($word in $words) {\n                # Handle words longer than width\n                if ($word.Length -gt $width) {\n                    if ($currentLine) {\n                        $result.Add($currentLine)\n                        $currentLine = \"\"\n                    }\n                    # Split long word across lines\n                    for ($i = 0; $i -lt $word.Length; $i += $width) {\n                        $chunk = $word.Substring($i, [Math]::Min($width, $word.Length - $i))\n                        $result.Add($chunk)\n                    }\n                    continue\n                }\n\n                # Try adding word to current line\n                $testLine = $(if ($currentLine) { \"$currentLine $word\" } else { $word })\n\n                if ($testLine.Length -le $width) {\n                    $currentLine = $testLine\n                } else {\n                    # Word doesn't fit, flush current line and start new one\n                    if ($currentLine) {\n                        $result.Add($currentLine)\n                    }\n                    $currentLine = $word\n                }\n            }\n\n            # Flush last line of paragraph\n            if ($currentLine) {\n                $result.Add($currentLine)\n            }\n        }\n\n        return ($result -join \"`n\")\n    }\n\n    # Update statistics\n    hidden [void] _UpdateStats([array]$allTasks) {\n        # Handle null or empty tasks\n        if ($null -eq $allTasks) {\n            $allTasks = @()\n        }\n\n        $tomorrow = [DateTime]::Today.AddDays(1)\n        $weekEnd = [DateTime]::Today.AddDays(7)\n        $monthEnd = [DateTime]::Today.AddDays(30)\n\n        $this._stats = @{\n            Total       = $allTasks.Count\n            Active      = @($allTasks | Where-Object { -not (Get-SafeProperty $_ 'completed') }).Count\n            Completed   = @($allTasks | Where-Object { Get-SafeProperty $_ 'completed' }).Count\n            Overdue     = @($allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and $due -lt [DateTime]::Today\n                }).Count\n            Today       = @($allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and $due.Date -eq [DateTime]::Today\n                }).Count\n            Tomorrow    = @($allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and $due.Date -eq $tomorrow\n                }).Count\n            Week        = @($allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and\n                    $due -ge [DateTime]::Today -and\n                    $due -le $weekEnd\n                }).Count\n            Month       = @($allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and\n                    $due -ge [DateTime]::Today -and\n                    $due -le $monthEnd\n                }).Count\n            NextActions = @($allTasks | Where-Object {\n                    $dependsOn = Get-SafeProperty $_ 'depends_on'\n                    -not (Get-SafeProperty $_ 'completed') -and\n                    (-not $dependsOn -or (-not ($dependsOn -is [array])) -or $dependsOn.Count -eq 0)\n                }).Count\n            NoDueDate   = @($allTasks | Where-Object {\n                    -not (Get-SafeProperty $_ 'completed') -and -not (Get-SafeProperty $_ 'due')\n                }).Count\n            Upcoming    = @($allTasks | Where-Object {\n                    $due = Get-SafeProperty $_ 'due'\n                    -not (Get-SafeProperty $_ 'completed') -and $due -and $due.Date -gt [DateTime]::Today\n                }).Count\n        }\n    }\n\n    # Get custom actions for footer display\n    [array] GetCustomActions() {\n        $self = $this\n        return @(\n            @{ Key = 'o'; Label = 'Details'; Callback = {\n                    $self._ToggleDetailPane()\n                }.GetNewClosure()\n            },\n            @{ Key = 'c'; Label = 'Complete'; Callback = {\n                    $selected = $self.List.GetSelectedItem()\n                    $self.CompleteTask($selected)\n                }.GetNewClosure() \n            },\n            @{ Key = 'x'; Label = 'Clone'; Callback = {\n                    $selected = $self.List.GetSelectedItem()\n                    $self.CloneTask($selected)\n                }.GetNewClosure() \n            },\n            @{ Key = 's'; Label = 'Subtask'; Callback = {\n                    # Write-PmcTuiLog \"Action 's' (Subtask) triggered\" \"INFO\"\n                    $selected = $self.List.GetSelectedItem()\n                    if ($selected) {\n                        $self.AddSubtask($selected)\n                    }\n                    else {\n                        # Write-PmcTuiLog \"Action 's': No item selected\" \"WARNING\"\n                        $self.SetStatusMessage(\"Select a task to add a subtask\", \"warning\")\n                    }\n                }.GetNewClosure() \n            },\n            @{ Key = 'h'; Label = 'Hide Done'; Callback = {\n                    $self.ToggleShowCompleted()\n                }.GetNewClosure() \n            },\n            @{ Key = '1'; Label = 'All'; Callback = {\n                    $self.SetViewMode('all')\n                }.GetNewClosure() \n            },\n            @{ Key = '2'; Label = 'Active'; Callback = {\n                    $self.SetViewMode('active')\n                }.GetNewClosure() \n            },\n            @{ Key = '3'; Label = 'Done'; Callback = {\n                    $self.SetViewMode('completed')\n                }.GetNewClosure() \n            },\n            @{ Key = '4'; Label = 'Overdue'; Callback = {\n                    $self.SetViewMode('overdue')\n                }.GetNewClosure() \n            },\n            @{ Key = '5'; Label = 'Today'; Callback = {\n                    $self.SetViewMode('today')\n                }.GetNewClosure() \n            },\n            @{ Key = '6'; Label = 'Week'; Callback = {\n                    $self.SetViewMode('week')\n                }.GetNewClosure() \n            }\n        )\n    }\n\n    # Override EditItem to use InlineEditor horizontally at row position\n    [void] EditItem($item) {\n        # Write-PmcTuiLog \"TaskListScreen.EditItem called - item.id=$(if ($item) { $item.id } else { 'NULL' })\" \"INFO\"\n        if ($null -eq $item) { return }\n\n        # Get row position\n        $selectedIndex = $this.List.GetSelectedIndex()\n        $scrollOffset = $(if ($null -ne $this.List._scrollOffset) { $this.List._scrollOffset } else { 0 })\n        $visibleRow = $selectedIndex - $scrollOffset\n\n        # Check if row is visible on screen\n        $listHeight = $this.List.Height\n        if ($visibleRow -lt 0 -or $visibleRow -ge ($listHeight - [TaskListScreen]::LIST_HEADER_ROWS)) {\n            $this.SetStatusMessage(\"Cannot edit: row not visible on screen\", \"warning\")\n            return\n        }\n\n        # Position at the EXACT row where the task is displayed\n        # UniversalList rows: Y + 1 (header), Y + 2 (separator), Y + 3 (first data row)\n        $rowY = $this.List.Y + [TaskListScreen]::LIST_HEADER_ROWS + $visibleRow\n\n        # Ensure InlineEditor is loaded\n        if (-not ([System.Management.Automation.PSTypeName]'InlineEditor').Type) {\n            . \"$PSScriptRoot/../widgets/InlineEditor.ps1\"\n        }\n\n        # Build fields for inline editor - PERCENTAGE-BASED widths\n        # CRITICAL FIX: Calculate based on available terminal width using SAME formula as GetColumns()\n        # Account for 3 separators (2 spaces each = 6 chars total) between 4 columns (Details column removed)\n        $availableWidth = $this.List.Width - 4 - 8  # Subtract borders and column separators\n        $textWidth = [Math]::Floor($availableWidth * [TaskListScreen]::COL_WIDTH_TEXT)\n        $dueWidth = [Math]::Floor($availableWidth * [TaskListScreen]::COL_WIDTH_DUE)\n        $projectWidth = [Math]::Floor($availableWidth * [TaskListScreen]::COL_WIDTH_PROJECT)\n        $tagsWidth = [Math]::Floor($availableWidth * [TaskListScreen]::COL_WIDTH_TAGS)\n\n        $fields = @(\n            @{ Name = 'text'; Label = ''; Type = 'text'; Value = (Get-SafeProperty $item 'text'); Required = $true; MaxLength = 200; Width = $textWidth }\n            @{ Name = 'due'; Label = ''; Type = 'date'; Value = (Get-SafeProperty $item 'due'); Width = $dueWidth }\n            @{ Name = 'project'; Label = ''; Type = 'project'; Value = (Get-SafeProperty $item 'project'); Width = $projectWidth }\n            @{ Name = 'tags'; Label = ''; Type = 'tags'; Value = (Get-SafeProperty $item 'tags'); Width = $tagsWidth }\n        )\n\n        # Configure base class inline editor for horizontal inline editing\n        $this.InlineEditor.LayoutMode = 'horizontal'\n        $this.InlineEditor.SetFields($fields)\n\n        # CRITICAL FIX: Set X and Y explicitly for horizontal mode\n        # InlineEditor.RenderToEngine uses $this.X and $this.Y directly, NOT TargetRegionID\n        # List content starts at List.X + 2 (for border), and rowY calculated above\n        $this.InlineEditor.X = $this.List.X + 2\n        $this.InlineEditor.Y = $rowY\n        $this.InlineEditor.Width = $this.List.Width - 4  # Account for borders on both sides\n\n        # Set up save callback\n        $self = $this\n        $taskId = $item.id\n        # Write-PmcTuiLog \"TaskListScreen.EditItem: Setting OnConfirmed callback for taskId=$taskId\" \"INFO\"\n        $this.InlineEditor.OnConfirmed = {\n            param($values)\n            # Write-PmcTuiLog \"InlineEditor.OnConfirmed FIRED - taskId=$taskId values=$($values.Keys -join ',')\" \"INFO\"\n            # CRITICAL FIX: Get fresh item from store, then call OnItemUpdated\n            $freshItem = $self.Store.GetTask($taskId)\n            if ($freshItem) {\n                $self.OnItemUpdated($freshItem, $values)\n            }\n            else {\n                # Write-PmcTuiLog \"InlineEditor.OnConfirmed - task $taskId not found!\" \"ERROR\"\n            }\n            $self.ShowInlineEditor = $false\n            $self.EditorMode = \"\"\n            $self.CurrentEditItem = $null\n        }.GetNewClosure()\n\n        $this.InlineEditor.OnCancelled = {\n            # Force refresh to clear the inline editor display\n            $self.ShowInlineEditor = $false\n            $self.EditorMode = \"\"\n            $self.CurrentEditItem = $null\n            $self.List.InvalidateCache()\n            $self.SetStatusMessage(\"Edit cancelled\", \"info\")\n        }.GetNewClosure()\n\n        # Mark that we're showing inline editor using base class property\n        # BUG FIX: Set EditorMode and CurrentEditItem so SkipRowHighlight works correctly\n        $this.EditorMode = 'edit'\n        $this.CurrentEditItem = $item\n        # $this.ShowInlineEditor = $true  <-- REMOVED: We use DetailPane, so don't hide the list row!\n        # NOTE: NeedsClear NOT set - inline editing should not clear the screen\n        $this.SetStatusMessage(\"Editing inline - Tab=next field, Enter=save, Esc=cancel\", \"success\")\n    }\n\n    # Override RenderContent to call parent (which handles inline editor rendering)\n    # Override RenderContentToEngine to handle detail pane rendering\n    [void] RenderContentToEngine([object]$engine) {\n        # Call base class which handles list, filter panel, and inline editor\n        ([StandardListScreen]$this).RenderContentToEngine($engine)\n\n        # Render Detail Pane if visible\n        if ($this._showDetailPane -and $this.DetailPane) {\n            # CRITICAL FIX: Clear the gap between list and detail pane to prevent artifacts\n            # The gap is 1 char wide at List.X + List.Width\n            $gapX = $this.List.X + $this.List.Width\n            $gapY = $this.List.Y\n            $gapHeight = $this.List.Height\n            \n            # Use Background.Primary for the gap to match the global background\n            $themeEngine = [PmcThemeEngine]::GetInstance()\n            $bg = $themeEngine.GetThemeColorInt('Background.Primary')\n            $fg = $themeEngine.GetForegroundInt('Foreground.Primary')\n            \n            # Fill the 1-char gap\n            $engine.Fill($gapX, $gapY, 1, $gapHeight, ' ', $fg, $bg)\n\n            # CRITICAL FIX: Clean the entire detail pane area before rendering\n            # This wipes out any artifacts (double borders, cursors) from previous edit mode\n            $engine.Fill($this.DetailPane.X, $this.DetailPane.Y, $this.DetailPane.Width, $this.DetailPane.Height, ' ', $fg, $bg)\n\n            # ALWAYS render DetailPane first to draw the border and title\n            # This acts as the container\n            $this.DetailPane.RenderToEngine($engine)\n\n            if ($this._detailEditMode -and $this._detailEditor) {\n                # Edit mode: render TextAreaEditor ON TOP of the panel content area\n                # (It is positioned inside the border by ApplyContentLayout)\n                $this._detailEditor.RenderToEngine($engine)\n            } \n            # Note: In view mode, DetailPane handles rendering the text content itself\n            # because we set it via SetContent() in OnItemSelected\n        }\n    }\n\n    # Override: Additional keyboard shortcuts\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\n        # PRIORITY: If in detail edit mode, route input to TextAreaEditor\n        if ($this._detailEditMode -and $this._detailEditor) {\n            # Escape exits edit mode (same as pressing d again)\n            if ($keyInfo.Key -eq [ConsoleKey]::Escape) {\n                # Save and exit edit mode\n                $selected = $this.List.GetSelectedItem()\n                $newDesc = $this._detailEditor.GetText()\n                $taskId = Get-SafeProperty $selected 'id'\n                if ($taskId) {\n                    $this.Store.UpdateTask($taskId, @{ description = $newDesc })\n\n                    # Invalidate the cached region for the updated row to prevent stale display\n                    $idx = $this.List.GetSelectedIndex()\n                    $offset = $this.List.GetScrollOffset()\n                    $rowY = $this.List.Y + 3 + ($idx - $offset)\n                    if ($this.RenderEngine) {\n                        $this.RenderEngine.InvalidateCachedRegion($rowY, $rowY + 1)\n                    }\n                }\n                $this._detailEditMode = $false\n                $this._detailEditor.ShowCursor = $false\n                $this.DetailPane.SetBorderStyle('single') # Reset border style\n                \n                # Explicitly hide hardware cursor to prevent \"stuck cursor\" artifact\n                if ($this.RenderEngine) {\n                    $this.RenderEngine.HideCursor()\n                    \n                    # CRITICAL FIX: Invalidate detail pane region to clear TextAreaEditor artifacts\n                    if ($this.DetailPane) {\n                        $startY = $this.DetailPane.Y\n                        $endY = [Math]::Min($startY + $this.DetailPane.Height - 1, $this.RenderEngine.Height - 1)\n                        $this.RenderEngine.InvalidateCachedRegion($startY, $endY)\n                    }\n                }\n\n                # Editor stays visible, panel stays hidden\n                # $this._detailEditor.Visible stays true\n                # $this.DetailPane.Visible stays false\n                $this.OnItemSelected($selected)\n                $this.SetStatusMessage(\"Description saved\", \"success\")\n                return $true\n            }\n            # Route all other keys to editor\n            return $this._detailEditor.HandleInput($keyInfo)\n        }\n\n        # D: Toggle edit mode - BEFORE parent call so it takes priority\n        # FIX: Changed to Shift+D only to avoid conflict with 'd' (Delete)\n        if ($keyInfo.KeyChar -eq 'D') {\n            $selected = $this.List.GetSelectedItem()\n            if (-not $selected) {\n                $this.SetStatusMessage(\"Select a task first\", \"warning\")\n                return $true\n            }\n            if (-not $this._showDetailPane) {\n                $this._showDetailPane = $true\n                $this.Resize($this.TermWidth, $this.TermHeight)\n            }\n            $this._detailEditMode = -not $this._detailEditMode\n            $this._detailEditor.ShowCursor = $this._detailEditMode\n            \n            # Visual indicator for active edit mode\n            if ($this._detailEditMode) {\n                $this.DetailPane.SetBorderStyle('double')\n                $this.SetStatusMessage(\"Editing description. Esc to save.\", \"info\")\n            } else {\n                $this.DetailPane.SetBorderStyle('single')\n                \n                # Explicitly hide cursor when toggling off via 'd'\n                if ($this.RenderEngine) {\n                    $this.RenderEngine.HideCursor()\n                    \n                    # CRITICAL FIX: Invalidate detail pane region to clear TextAreaEditor artifacts\n                    if ($this.DetailPane) {\n                        $startY = $this.DetailPane.Y\n                        $endY = [Math]::Min($startY + $this.DetailPane.Height - 1, $this.RenderEngine.Height - 1)\n                        $this.RenderEngine.InvalidateCachedRegion($startY, $endY)\n                    }\n                }\n                \n                # Save changes\n                $newDesc = $this._detailEditor.GetText()\n                $taskId = Get-SafeProperty $selected 'id'\n                if ($taskId) {\n                    $this.Store.UpdateTask($taskId, @{ description = $newDesc })\n\n                    # Invalidate the cached region for the updated row to prevent stale display\n                    $idx = $this.List.GetSelectedIndex()\n                    $offset = $this.List.GetScrollOffset()\n                    $rowY = $this.List.Y + 3 + ($idx - $offset)\n                    if ($this.RenderEngine) {\n                        $this.RenderEngine.InvalidateCachedRegion($rowY, $rowY + 1)\n                    }\n                }\n                $this.SetStatusMessage(\"Description saved\", \"success\")\n            }\n            return $true\n        }\n        # CRITICAL: If inline editor is showing, let IT handle input first\n        # Otherwise parent will steal Enter/Esc keys\n        if ($this.ShowInlineEditor -and $null -ne $this.InlineEditor) {\n            # Let inline editor handle ALL keys when it's active\n            return ([StandardListScreen]$this).HandleKeyPress($keyInfo)\n        }\n\n        # CRITICAL FIX: Call parent FIRST to handle MenuBar and base navigation\n        # But ONLY when inline editor is NOT active\n        $handled = ([StandardListScreen]$this).HandleKeyPress($keyInfo)\n        if ($handled) { return $true }\n\n        # Custom shortcuts AFTER base class (parent didn't handle them)\n        $key = $keyInfo.Key\n        $ctrl = $keyInfo.Modifiers -band [ConsoleModifiers]::Control\n        $alt = $keyInfo.Modifiers -band [ConsoleModifiers]::Alt\n\n        # O: Toggle detail pane visibility\n        if ($keyInfo.KeyChar -eq 'o' -or $keyInfo.KeyChar -eq 'O') {\n            $this._ToggleDetailPane()\n            return $true\n        }\n\n\n        # Space: Toggle subtask collapse OR completion\n        # NOTE: This is custom TaskListScreen behavior, not base class behavior\n        if ($key -eq [ConsoleKey]::Spacebar -and -not $ctrl -and -not $alt) {\n            $selected = $this.List.GetSelectedItem()\n            if ($selected) {\n                $taskId = Get-SafeProperty $selected 'id'\n                # BUG-13 FIX: Use cached children index instead of loading all tasks\n                # O(1) hashtable lookup instead of O(n) GetAllTasks() + filtering\n                $hasChildren = $this._childrenIndex.ContainsKey($taskId)\n\n                if ($hasChildren) {\n                    # Toggle collapse\n                    $wasCollapsed = $this._collapsedSubtasks.ContainsKey($taskId)\n                    if ($wasCollapsed) {\n                        $this._collapsedSubtasks.Remove($taskId)\n                    }\n                    else {\n                        $this._collapsedSubtasks[$taskId] = $true\n                    }\n                    # Invalidate cache because collapsed state changed\n                    $this._cachedFilteredTasks = $null\n                    $this._cacheKey = \"\"\n                    $this.LoadData()\n                    $this.List.InvalidateCache()  # Force re-render with new collapse state\n                }\n                else {\n                    # No children - toggle completion\n                    $this.ToggleTaskCompletion($selected)\n                }\n            }\n            return $true\n        }\n\n        # C: Complete task\n        if ($keyInfo.KeyChar -eq 'c' -or $keyInfo.KeyChar -eq 'C') {\n            $selected = $this.List.GetSelectedItem()\n            $this.CompleteTask($selected)\n            return $true\n        }\n\n        # X: Clone task\n        if ($keyInfo.KeyChar -eq 'x' -or $keyInfo.KeyChar -eq 'X') {\n            $selected = $this.List.GetSelectedItem()\n            $this.CloneTask($selected)\n            return $true\n        }\n\n        # S: Add subtask\n        if ($keyInfo.KeyChar -eq 's' -or $keyInfo.KeyChar -eq 'S') {\n            $selected = $this.List.GetSelectedItem()\n            if ($selected) {\n                $this.AddSubtask($selected)\n            }\n            return $true\n        }\n\n        # Ctrl+C: Bulk complete selected\n        if ($key -eq [ConsoleKey]::C -and $ctrl) {\n            $this.BulkCompleteSelected()\n            return $true\n        }\n\n        # Ctrl+X: Bulk delete selected\n        if ($key -eq [ConsoleKey]::X -and $ctrl) {\n            $this.BulkDeleteSelected()\n            return $true\n        }\n\n        # View mode shortcuts\n        if ($keyInfo.KeyChar -eq '1') { $this.SetViewMode('all'); return $true }\n        if ($keyInfo.KeyChar -eq '2') { $this.SetViewMode('active'); return $true }\n        if ($keyInfo.KeyChar -eq '3') { $this.SetViewMode('completed'); return $true }\n        if ($keyInfo.KeyChar -eq '4') { $this.SetViewMode('overdue'); return $true }\n        if ($keyInfo.KeyChar -eq '5') { $this.SetViewMode('today'); return $true }\n        if ($keyInfo.KeyChar -eq '6') { $this.SetViewMode('week'); return $true }\n\n        # H: Toggle show completed\n        if ($keyInfo.KeyChar -eq 'h' -or $keyInfo.KeyChar -eq 'H') {\n            $this.ToggleShowCompleted()\n            return $true\n        }\n\n        return $false\n    }\n\n    # Override: Custom rendering (add header with stats and view mode)\n    # Override: Custom rendering (add stats and view mode)\n    [void] RenderToEngine([object]$engine) {\n        # 1. Base StandardListScreen rendering (Header, List, Footer, etc.)\n        ([StandardListScreen]$this).RenderToEngine($engine)\n\n        # 2. Draw Stats in the gap between Header and List\n        # Header ends at Y=something. List starts at Y=6.\n        # Let's draw at Y=3 and Y=4.\n        \n        # Colors\n        $labelColor = $this.Header.GetThemedColorInt('Foreground.Primary')\n        $valueColor = $this.Header.GetThemedColorInt('Foreground.Success')\n        $mutedColor = $this.Header.GetThemedColorInt('Foreground.Muted')\n        $bg = $this.Header.GetThemedColorInt('Background.Primary')\n\n        # Position status at third line from bottom (above footer at TermHeight-1)\n        $y = $this.TermHeight - 3\n        $x = 0\n\n        # View Mode\n        $viewMode = $(if ($this._viewMode) { $this._viewMode.ToUpper() } else { 'ALL' })\n        $engine.WriteAt(2, $y, \"View: $viewMode\", $labelColor, $bg)\n\n        # Stats (with null safety)\n        $statsX = 20\n        $total = if ($this._stats.ContainsKey('Total')) { $this._stats.Total } else { 0 }\n        $active = if ($this._stats.ContainsKey('Active')) { $this._stats.Active } else { 0 }\n        $completed = if ($this._stats.ContainsKey('Completed')) { $this._stats.Completed } else { 0 }\n        $overdue = if ($this._stats.ContainsKey('Overdue')) { $this._stats.Overdue } else { 0 }\n\n        $engine.WriteAt($statsX, $y, \"Total: $total\", $labelColor, $bg)\n        $engine.WriteAt($statsX + 15, $y, \"Active: $active\", $valueColor, $bg)\n        $engine.WriteAt($statsX + 30, $y, \"Done: $completed\", $labelColor, $bg)\n\n        if ($overdue -gt 0) {\n            $errorColor = $this.Header.GetThemedColorInt('Foreground.Error')\n            $engine.WriteAt($statsX + 45, $y, \"Overdue: $overdue\", $errorColor, $bg)\n        }\n        else {\n            $engine.WriteAt($statsX + 45, $y, \"Overdue: 0\", $mutedColor, $bg)\n        }\n\n        # Keyboard shortcuts help (one line below status)\n        $help = \"F:Filter A:Add E:Edit Del:Delete Shift+D:EditDetails O:Details Space:Toggle C:Complete X:Clone 1-6:Views H:Hide Q:Quit\"\n        $engine.WriteAt(2, $y + 1, $help, $mutedColor, $bg)\n    }\n\n\n\n\n    # Static: Register menu items for all view modes\n    static [void] RegisterMenuItems([object]$registry) {\n        # Task List (all tasks)\n        $registry.AddMenuItem('Tasks', 'Task List', 'L', {\n                . \"$PSScriptRoot/TaskListScreen.ps1\"\n                $global:PmcApp.PushScreen((New-Object -TypeName TaskListScreen))\n            }, 5)\n\n        # Today's tasks\n        $registry.AddMenuItem('Tasks', 'Today', 'Y', {\n                . \"$PSScriptRoot/TaskListScreen.ps1\"\n                $global:PmcApp.PushScreen([TaskListScreen]::new('today'))\n            }, 10)\n\n        # Tomorrow's tasks\n        $registry.AddMenuItem('Tasks', 'Tomorrow', 'T', {\n                . \"$PSScriptRoot/TaskListScreen.ps1\"\n                $global:PmcApp.PushScreen([TaskListScreen]::new('tomorrow'))\n            }, 15)\n\n        # This week\n        $registry.AddMenuItem('Tasks', 'Week View', 'W', {\n                . \"$PSScriptRoot/TaskListScreen.ps1\"\n                $global:PmcApp.PushScreen([TaskListScreen]::new('week'))\n            }, 20)\n\n        # Upcoming tasks\n        $registry.AddMenuItem('Tasks', 'Upcoming', 'U', {\n                . \"$PSScriptRoot/TaskListScreen.ps1\"\n                $global:PmcApp.PushScreen([TaskListScreen]::new('upcoming'))\n            }, 25)\n\n        # Overdue tasks (changed from V to O to avoid conflict with ProjectList V=View)\n        $registry.AddMenuItem('Tasks', 'Overdue', 'O', {\n                . \"$PSScriptRoot/TaskListScreen.ps1\"\n                $global:PmcApp.PushScreen([TaskListScreen]::new('overdue'))\n            }, 30)\n\n        # Next actions (no dependencies)\n        $registry.AddMenuItem('Tasks', 'Next Actions', 'N', {\n                . \"$PSScriptRoot/TaskListScreen.ps1\"\n                $global:PmcApp.PushScreen([TaskListScreen]::new('nextactions'))\n            }, 35)\n\n        # No due date\n        $registry.AddMenuItem('Tasks', 'No Due Date', 'D', {\n                . \"$PSScriptRoot/TaskListScreen.ps1\"\n                $global:PmcApp.PushScreen([TaskListScreen]::new('noduedate'))\n            }, 40)\n\n        # Month view\n        $registry.AddMenuItem('Tasks', 'Month View', 'M', {\n                . \"$PSScriptRoot/TaskListScreen.ps1\"\n                $global:PmcApp.PushScreen([TaskListScreen]::new('month'))\n            }, 45)\n\n        # Agenda view\n        $registry.AddMenuItem('Tasks', 'Agenda View', 'A', {\n                . \"$PSScriptRoot/TaskListScreen.ps1\"\n                $global:PmcApp.PushScreen([TaskListScreen]::new('agenda'))\n            }, 50)\n    }\n}\n\n# Export for use in other modules\nif ($MyInvocation.MyCommand.Path) {\n    Export-ModuleMember -Variable TaskListScreen\n}\n"}, {"path": "module/Pmc.Strict/consoleui/screens/ThemeEditorScreen.ps1", "content": "using namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# ThemeEditorScreen - Theme selection and preview\r\n# Allows users to view available themes and apply them\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass ThemeEditorScreen : PmcScreen {\r\n    [array]$Themes = @()\r\n    [int]$SelectedIndex = 0\r\n    [string]$CurrentTheme = \"Default\"\r\n    hidden [int]$_contentY = 8\r\n    hidden [int]$_contentHeight = 13\r\n\r\n    ThemeEditorScreen() : base(\"ThemeEditor\", \"Theme Editor\") {\r\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Options\", \"Themes\"))\r\n        $this.Footer.ClearShortcuts()\r\n        $this.Footer.AddShortcut(\"Up/Down\", \"Select\")\r\n        $this.Footer.AddShortcut(\"Enter\", \"Apply\")\r\n        $this.Footer.AddShortcut(\"T\", \"Test\")\r\n        $this.Footer.AddShortcut(\"Esc\", \"Back\")\r\n    }\r\n\r\n    ThemeEditorScreen([object]$container) : base(\"ThemeEditor\", \"Theme Editor\", $container) {\r\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Options\", \"Themes\"))\r\n        $this.Footer.ClearShortcuts()\r\n        $this.Footer.AddShortcut(\"Up/Down\", \"Select\")\r\n        $this.Footer.AddShortcut(\"Enter\", \"Apply\")\r\n        $this.Footer.AddShortcut(\"T\", \"Test\")\r\n        $this.Footer.AddShortcut(\"Esc\", \"Back\")\r\n    }\r\n\r\n    [void] Initialize([object]$renderEngine, [object]$container) {\r\n        $this.RenderEngine = $renderEngine\r\n        $this.Container = $container\r\n        $this.TermWidth = $renderEngine.Width\r\n        $this.TermHeight = $renderEngine.Height\r\n\r\n        if (-not $this.LayoutManager) {\r\n            $this.LayoutManager = [PmcLayoutManager]::new()\r\n        }\r\n\r\n        $headerRect = $this.LayoutManager.GetRegion('Header', $this.TermWidth, $this.TermHeight)\r\n        $this.Header.X = $headerRect.X\r\n        $this.Header.Y = $headerRect.Y\r\n        $this.Header.Width = $headerRect.Width\r\n        $this.Header.Height = $headerRect.Height\r\n\r\n        $footerRect = $this.LayoutManager.GetRegion('Footer', $this.TermWidth, $this.TermHeight)\r\n        $this.Footer.X = $footerRect.X\r\n        $this.Footer.Y = $footerRect.Y\r\n        $this.Footer.Width = $footerRect.Width\r\n\r\n        $statusBarRect = $this.LayoutManager.GetRegion('StatusBar', $this.TermWidth, $this.TermHeight)\r\n        $this.StatusBar.X = $statusBarRect.X\r\n        $this.StatusBar.Y = $statusBarRect.Y\r\n        $this.StatusBar.Width = $statusBarRect.Width\r\n\r\n        $contentRect = $this.LayoutManager.GetRegion('Content', $this.TermWidth, $this.TermHeight)\r\n        $this._contentY = $contentRect.Y\r\n        $this._contentHeight = $contentRect.Height\r\n    }\r\n\r\n    # === GRADIENT RENDERING ===\r\n    # Renders text with per-character horizontal gradient (magenta to cyan)\r\n    hidden [void] _RenderGradientText([object]$engine, [int]$x, [int]$y, [string]$text, [string]$startHex, [string]$endHex, [object]$bgColor) {\r\n        if ([string]::IsNullOrEmpty($text)) { return }\r\n\r\n        # Parse start color\r\n        $sHex = $startHex.TrimStart('#')\r\n        $sR = [Convert]::ToInt32($sHex.Substring(0, 2), 16)\r\n        $sG = [Convert]::ToInt32($sHex.Substring(2, 2), 16)\r\n        $sB = [Convert]::ToInt32($sHex.Substring(4, 2), 16)\r\n\r\n        # Parse end color\r\n        $eHex = $endHex.TrimStart('#')\r\n        $eR = [Convert]::ToInt32($eHex.Substring(0, 2), 16)\r\n        $eG = [Convert]::ToInt32($eHex.Substring(2, 2), 16)\r\n        $eB = [Convert]::ToInt32($eHex.Substring(4, 2), 16)\r\n\r\n        $len = $text.Length\r\n        for ($i = 0; $i -lt $len; $i++) {\r\n            $t = if ($len -eq 1) { 0 } else { $i / ($len - 1) }\r\n\r\n            # Linear interpolation\r\n            $r = [int]($sR + ($eR - $sR) * $t)\r\n            $g = [int]($sG + ($eG - $sG) * $t)\r\n            $b = [int]($sB + ($eB - $sB) * $t)\r\n\r\n            # Clamp to 0-255\r\n            $r = [Math]::Max(0, [Math]::Min(255, $r))\r\n            $g = [Math]::Max(0, [Math]::Min(255, $g))\r\n            $b = [Math]::Max(0, [Math]::Min(255, $b))\r\n\r\n            # Convert to int for WriteAt (packed RGB)\r\n            $fg = ($r -shl 16) -bor ($g -shl 8) -bor $b\r\n\r\n            $char = $text[$i]\r\n            $engine.WriteAt($x + $i, $y, [string]$char, $fg, $bgColor)\r\n        }\r\n    }\r\n\r\n    [void] LoadData() {\r\n        $this.ShowStatus(\"Loading themes...\")\r\n\r\n        try {\n            # Load themes from theme files\n            $this.Themes = Get-AvailableThemes\n            \n            # Get current theme name from config\n            try {\n                $cfg = Get-PmcConfig\n                if ($cfg -and $cfg.Display -and $cfg.Display.Theme -and $cfg.Display.Theme.Active) {\n                    $activeTheme = $cfg.Display.Theme.Active\n                    foreach ($theme in $this.Themes) {\n                        if ($theme.Name.ToLower() -eq $activeTheme.ToLower()) {\n                            $this.CurrentTheme = $theme.Name\n                            break\n                        }\n                    }\n                }\n            } catch { }\n\n            $count = $(if ($this.Themes) { $this.Themes.Count } else { 0 })\n            $this.ShowSuccess(\"$count themes available\")\n        }\n        catch {\n            $this.ShowError(\"Failed to load themes: $_\")\n            $this.Themes = @()\n        }\n    }\r\n\r\n    [void] RenderContentToEngine([object]$engine) {\r\n        $textColor = $this.Header.GetThemedColorInt('Foreground.Field')\r\n        $selectedBg = $this.Header.GetThemedColorInt('Background.FieldFocused')\r\n        $selectedFg = $this.Header.GetThemedColorInt('Foreground.Field')\r\n        $cursorColor = $this.Header.GetThemedColorInt('Foreground.FieldFocused')\r\n        $mutedColor = $this.Header.GetThemedColorInt('Foreground.Muted')\r\n        $headerColor = $this.Header.GetThemedColorInt('Foreground.Muted')\r\n        $bg = $this.Header.GetThemedColorInt('Background.Primary')\r\n        \r\n        $y = $this._contentY\r\n        \r\n        $engine.WriteAt($this.Header.X + 4, $y, \"THEME NAME\", $headerColor, $bg)\r\n        $engine.WriteAt($this.Header.X + 19, $y, \"DESCRIPTION\", $headerColor, $bg)\r\n        $engine.WriteAt($this.Header.X + 55, $y, \"STATUS\", $headerColor, $bg)\r\n        $y++\r\n\r\n        $startY = $y + 1\r\n        $maxLines = $this._contentHeight - 8\r\n        \r\n        for ($i = 0; $i -lt [Math]::Min($this.Themes.Count, $maxLines); $i++) {\r\n            $theme = $this.Themes[$i]\r\n            $rowY = $startY + $i\r\n            $isSelected = ($i -eq $this.SelectedIndex)\r\n            $isCurrent = ($theme.Name -eq $this.CurrentTheme)\r\n            \r\n            $rowBg = $(if ($isSelected) { $selectedBg } else { $bg })\r\n            $rowFg = $(if ($isSelected) { $selectedFg } else { $textColor })\r\n\r\n            if ($isSelected) {\r\n                $engine.WriteAt($this.Header.X + 2, $rowY, \">\", $cursorColor, $bg)\r\n            }\r\n\r\n            $x = $this.Header.X + 4\r\n\r\n            # GRADIENT: Render Synthwave theme with per-character magenta→cyan gradient\r\n            if ($theme.Name -eq \"Synthwave\") {\r\n                $this._RenderGradientText($engine, $x, $rowY, $theme.Name.PadRight(15), \"#ff00ff\", \"#00ffff\", $rowBg)\r\n                $x += 15\r\n                $this._RenderGradientText($engine, $x, $rowY, $theme.Description.PadRight(36), \"#ff00ff\", \"#00ffff\", $rowBg)\r\n                $x += 36\r\n            }\r\n            else {\r\n                $engine.WriteAt($x, $rowY, $theme.Name.PadRight(15), $rowFg, $rowBg)\r\n                $x += 15\r\n                $descFg = $(if ($isSelected) { $selectedFg } else { $mutedColor })\r\n                $engine.WriteAt($x, $rowY, $theme.Description.PadRight(36), $descFg, $rowBg)\r\n                $x += 36\r\n            }\r\n\r\n            if ($isCurrent) {\r\n                $statusColor = $this.Header.GetThemedColorInt('Foreground.Success')\r\n                $engine.WriteAt($x, $rowY, \"[CURRENT]\", $statusColor, $bg)\r\n            }\r\n        }\r\n\r\n        # Show color preview for selected theme\r\n        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Themes.Count) {\r\n            $theme = $this.Themes[$this.SelectedIndex]\r\n            $previewY = $startY + [Math]::Min($this.Themes.Count, $maxLines) + 2\r\n\r\n            if ($previewY -lt $this.Footer.Y - 2) {\r\n                $engine.WriteAt($this.Header.X + 4, $previewY, \"━\" * 50, $headerColor, $bg)\r\n                $previewY++\r\n\r\n                $engine.WriteAt($this.Header.X + 4, $previewY, \"Selected: \", $textColor, $bg)\r\n                \r\n                # Gradient preview for Synthwave\r\n                if ($theme.Name -eq \"Synthwave\") {\r\n                    $this._RenderGradientText($engine, $this.Header.X + 14, $previewY, $theme.Name, \"#ff00ff\", \"#00ffff\", $bg)\r\n                }\r\n                else {\r\n                    $engine.WriteAt($this.Header.X + 14, $previewY, $theme.Name, $this.Header.GetThemedColorInt('Foreground.FieldFocused'), $bg)\r\n                }\r\n                $previewY++\r\n                \r\n                $engine.WriteAt($this.Header.X + 4, $previewY, \"Hex Code: \", $mutedColor, $bg)\r\n                $engine.WriteAt($this.Header.X + 14, $previewY, $theme.Hex, $this.Header.GetThemedColorInt('Foreground.Success'), $bg)\r\n                $previewY++\r\n                \r\n                $engine.WriteAt($this.Header.X + 4, $previewY, \"Description: \", $mutedColor, $bg)\r\n                if ($theme.Name -eq \"Synthwave\") {\r\n                    $this._RenderGradientText($engine, $this.Header.X + 17, $previewY, $theme.Description, \"#ff00ff\", \"#00ffff\", $bg)\r\n                }\r\n                else {\r\n                    $engine.WriteAt($this.Header.X + 17, $previewY, $theme.Description, $textColor, $bg)\r\n                }\r\n                $previewY += 2\r\n                \r\n                $engine.WriteAt($this.Header.X + 4, $previewY, \"Press Enter to apply, T to test, Esc to cancel\", $headerColor, $bg)\r\n            }\r\n        }\r\n    }\r\n\r\n    [string] RenderContent() { return \"\" }\r\n\r\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\r\n        $handled = ([PmcScreen]$this).HandleKeyPress($keyInfo)\r\n        if ($handled) { return $true }\r\n\r\n        $keyChar = [char]::ToLower($keyInfo.KeyChar)\r\n        switch ($keyInfo.Key) {\r\n            'UpArrow' { if ($this.SelectedIndex -gt 0) { $this.SelectedIndex--; return $true } }\r\n            'DownArrow' { if ($this.SelectedIndex -lt ($this.Themes.Count - 1)) { $this.SelectedIndex++; return $true } }\r\n            'Enter' { $this._ApplyTheme(); return $true }\r\n            'Escape' { if ($global:PmcApp) { $global:PmcApp.PopScreen() }; return $true }\r\n        }\r\n\r\n        switch ($keyChar) {\r\n            't' { $this._TestTheme(); return $true }\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    hidden [void] _ApplyTheme() {\r\n        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.Themes.Count) { return }\r\n        $theme = $this.Themes[$this.SelectedIndex]\r\n\r\n        try {\r\n            $this.CurrentTheme = $theme.Name\r\n            $reloadSuccess = Invoke-ThemeHotReload $theme.Name\r\n            \r\n            if ($reloadSuccess) {\r\n                try { $this.ShowSuccess(\"Theme applied! Changes visible immediately.\") } catch { }\r\n            }\r\n            else {\r\n                Start-Sleep -Milliseconds 800\r\n                if ($global:PmcApp) {\r\n                    $global:PmcApp.RenderEngine.RequestClear()\r\n                    $global:PmcApp.PopScreen()\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            try { $this.ShowError(\"Failed to apply theme: $_\") } catch { }\r\n        }\r\n    }\r\n\r\n    hidden [void] _TestTheme() {\r\n        if ($this.SelectedIndex -lt 0 -or $this.SelectedIndex -ge $this.Themes.Count) { return }\r\n        $theme = $this.Themes[$this.SelectedIndex]\r\n        $this.ShowStatus(\"Testing theme: $($theme.Name) - Press any key to return\")\r\n    }\r\n\r\n    hidden [void] _ResetTheme() {\r\n        $this.CurrentTheme = \"Default\"\r\n        $this.SelectedIndex = 0\r\n        $this.ShowSuccess(\"Reset to default theme\")\r\n    }\r\n}\r\n\r\nfunction Show-ThemeEditorScreen {\r\n    param([object]$App)\r\n    if (-not $App) { throw \"PmcApplication required\" }\r\n    $screen = New-Object ThemeEditorScreen\r\n    $App.PushScreen($screen)\r\n}"}, {"path": "module/Pmc.Strict/consoleui/screens/TimeListScreen.ps1", "content": "using namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# TimeListScreen - Time tracking list with full CRUD operations\r\n# Uses UniversalList widget and InlineEditor for consistent UX\r\n\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n. \"$PSScriptRoot/../base/StandardListScreen.ps1\"\r\n. \"$PSScriptRoot/../widgets/TimeEntryDetailDialog.ps1\"\r\n\r\n# LOW FIX TLS-L2, L3, L4: Define constants for magic numbers and limits\r\n$global:MAX_TASK_LENGTH = 200\r\n$global:MAX_TASK_TRUNCATE_LENGTH = 197\r\n$global:MAX_NOTES_LENGTH = 300\r\n$global:MAX_NOTES_TRUNCATE_LENGTH = 297\r\n$global:MAX_HOURS_PER_ENTRY = 24\r\n$global:MIN_HOURS_PER_ENTRY = 0.25\r\n$script:DIALOG_TIMEOUT_ITERATIONS = 36000  # 36000 * 50ms = 30 minutes\r\n$script:DIALOG_POLL_INTERVAL_MS = 50\r\n\r\n<#\r\n.SYNOPSIS\r\nTime tracking list screen with CRUD operations\r\n\r\n.DESCRIPTION\r\nShows all time entries with:\r\n- Add/Edit/Delete via InlineEditor (a/e/d keys)\r\n- View entries by task or project\r\n- Generate time reports\r\n- Automatic aggregation by date/project/timecode\r\n- Press Enter on aggregated entries (shown with count) to see individual entries\r\n- Filter by date range\r\n##CLOSEBRACKET##\r\nclass TimeListScreen : StandardListScreen {\r\n\r\n    # Static: Register menu items\r\n    static [void] RegisterMenuItems([object]$registry) {\r\n        $registry.AddMenuItem('Time', 'Time Tracking', 'T', {\r\n            . \"$PSScriptRoot/TimeListScreen.ps1\"\r\n            $global:PmcApp.PushScreen((New-Object -TypeName TimeListScreen))\r\n        }, 5)\r\n    }\r\n\r\n    # LOW FIX TLS-L1: Extract common initialization to helper method (DRY principle)\r\n    hidden [void] ConfigureCapabilities() {\r\n        # Configure capabilities\r\n        $this.AllowAdd = $true\r\n        $this.AllowEdit = $true\r\n        $this.AllowDelete = $true\r\n        $this.AllowFilter = $true\r\n\r\n        # Configure inline editor layout mode for horizontal (inline) editing\r\n        $this.InlineEditor.LayoutMode = 'horizontal'\r\n\r\n        # Configure header\r\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Time Tracking\"))\r\n\r\n        # Load time entries\r\n        $this.RefreshList()\r\n    }\r\n\r\n    # Constructor\r\n    TimeListScreen() : base(\"TimeList\", \"Time Tracking\") {\r\n        $this.ConfigureCapabilities()\r\n    }\r\n\r\n    # Constructor with container (DI-enabled)\r\n    TimeListScreen([object]$container) : base(\"TimeList\", \"Time Tracking\", $container) {\r\n        # Write-PmcTuiLog \"TimeListScreen: Constructor called, about to ConfigureCapabilities\"\r\n        $this.ConfigureCapabilities()\r\n        # Write-PmcTuiLog \"TimeListScreen: Constructor complete\"\r\n    }\r\n\r\n    # === Abstract Method Implementations ===\r\n\r\n    # Get entity type for store operations\r\n    [string] GetEntityType() {\r\n        return 'timelog'\r\n    }\r\n\r\n    # Define columns for list display\r\n    [array] GetColumns() {\r\n        return @(\r\n            @{ Name='date_display'; Label='Date'; Width=12 },\r\n            @{ Name='task'; Label='Task'; Width=25 },\r\n            @{ Name='project'; Label='Project'; Width=16 },\r\n            @{ Name='id1'; Label='ID1'; Width=10 },\r\n            @{ Name='id2'; Label='ID2'; Width=10 },\r\n            @{ Name='duration'; Label='Duration'; Width=18 },\r\n            @{ Name='notes'; Label='Notes'; Width=40 }\r\n        )\r\n    }\r\n\r\n    # Load data and refresh list (required by StandardListScreen)\r\n    [void] LoadData() {\r\n        # Write-PmcTuiLog \"TimeListScreen.LoadData: START\"\r\n        $items = $this.LoadItems()\r\n        # Write-PmcTuiLog \"TimeListScreen.LoadData: LoadItems completed, checking type\"\r\n        # Write-PmcTuiLog \"TimeListScreen.LoadData: items type=$($items.GetType().FullName)\"\r\n        if ($null -eq $items) {\r\n            # Write-PmcTuiLog \"TimeListScreen.LoadData: items is null, setting to empty array\" \"WARNING\"\r\n            $items = @()\r\n        }\r\n        # Write-PmcTuiLog \"TimeListScreen.LoadData: About to count items\"\r\n        $itemCount = $(if ($items -is [array]) { $items.Count } else { 1 })\r\n        # Write-PmcTuiLog \"TimeListScreen.LoadData: LoadItems returned $itemCount items\"\r\n        # Write-PmcTuiLog \"TimeListScreen.LoadData: Calling SetData\"\r\n        $this.List.SetData($items)\r\n        # Write-PmcTuiLog \"TimeListScreen.LoadData: COMPLETE\"\r\n    }\r\n\r\n    # Load items from data store\r\n    [array] LoadItems() {\r\n        # CRITICAL FIX TLS-C1: Add null check on GetAllTimeLogs()\r\n        $entries = $this.Store.GetAllTimeLogs()\r\n        if ($null -eq $entries) {\r\n            # Write-PmcTuiLog \"TimeListScreen.LoadItems: GetAllTimeLogs() returned null\" \"ERROR\"\r\n            $entries = @()\r\n        }\r\n\r\n        # TS-M1 FIX: Track failed date parses to provide user feedback\r\n        $failedDateParses = 0\r\n\r\n        # Group entries by date, project, and timecode\r\n        $grouped = @{}\r\n        foreach ($entry in $entries) {\r\n            # TIM-1 FIX: Format date for grouping with error handling\r\n            $dateStr = ''\r\n            if ($entry.ContainsKey('date') -and $entry.date) {\r\n                try {\r\n                    if ($entry.date -is [DateTime]) {\r\n                        $dateStr = $entry.date.ToString('yyyy-MM-dd')\r\n                    } else {\r\n                        # Try to parse as DateTime\r\n                        $parsedDate = [DateTime]::Parse($entry.date)\r\n                        $dateStr = $parsedDate.ToString('yyyy-MM-dd')\r\n                    }\r\n                } catch {\r\n                    # TS-M1 FIX: Instead of empty string, use original date value with marker\r\n                    # This preserves data context and prevents incorrect grouping\r\n                    $dateStr = \"INVALID:$($entry.date)\"\r\n                    $failedDateParses++\r\n                    # Write-PmcTuiLog \"TimeListScreen.LoadItems: Failed to parse date '$($entry.date)': $_\" \"WARNING\"\r\n                }\r\n            }\r\n\r\n            # Create grouping key\r\n            # TS-M3 FIX: Sanitize components to prevent pipe character breaking grouping\r\n            $project = $(if ($entry.ContainsKey('project')) { $entry.project } else { '' })\r\n            $id1 = $(if ($entry.ContainsKey('id1')) { $entry.id1 } else { '' })\r\n\r\n            # Replace pipe characters in components to prevent grouping key corruption\r\n            $dateStrSafe = $dateStr -replace '\\|', '_'\r\n            $projectSafe = $project -replace '\\|', '_'\r\n            $id1Safe = $id1 -replace '\\|', '_'\r\n\r\n            $groupKey = \"$dateStrSafe|$projectSafe|$id1Safe\"\r\n\r\n            # Initialize group if needed\r\n            if (-not $grouped.ContainsKey($groupKey)) {\r\n                $grouped[$groupKey] = @{\r\n                    date = $entry.date\r\n                    date_display = $dateStr\r\n                    project = $project\r\n                    id1 = $id1\r\n                    id2 = $(if ($entry.ContainsKey('id2')) { $entry.id2 } else { '' })\r\n                    task = $(if ($entry.ContainsKey('task')) { $entry.task } else { '' })\r\n                    notes = $(if ($entry.ContainsKey('notes')) { $entry.notes } else { '' })\r\n                    minutes = 0\r\n                    entry_count = 0\r\n                    entry_ids = @()\r\n                }\r\n            }\r\n\r\n            # Aggregate minutes\r\n            if ($entry.ContainsKey('minutes')) {\r\n                $grouped[$groupKey].minutes += $entry.minutes\r\n            }\r\n            $grouped[$groupKey].entry_count++\r\n            if ($entry.ContainsKey('id')) {\r\n                $grouped[$groupKey].entry_ids += $entry.id\r\n            }\r\n\r\n            # Store original entry for drill-down\r\n            if (-not $grouped[$groupKey].ContainsKey('original_entries')) {\r\n                $grouped[$groupKey].original_entries = @()\r\n            }\r\n            $grouped[$groupKey].original_entries += $entry\r\n\r\n            # TS-M3 FIX: Simplify task/notes concatenation and prevent excessive string length\r\n            # MEDIUM FIX TLS-M1: Use script-level constants for length limits\r\n            # Concatenate tasks if multiple (with length limit to prevent memory issues)\r\n            if ($entry.ContainsKey('task') -and $entry.task) {\r\n                $currentTask = $grouped[$groupKey].task\r\n                if ($currentTask -and $currentTask -ne $entry.task) {\r\n                    # Limit concatenated task length to prevent excessive growth\r\n                    $newTask = \"$currentTask; $($entry.task)\"\r\n                    $grouped[$groupKey].task = $(if ($newTask.Length -gt $global:MAX_TASK_LENGTH) {\r\n                        $newTask.Substring(0, $global:MAX_TASK_TRUNCATE_LENGTH) + \"...\"\r\n                    } else {\r\n                        $newTask\r\n                    })\r\n                } elseif (-not $currentTask) {\r\n                    $grouped[$groupKey].task = $entry.task\r\n                }\r\n            }\r\n\r\n            # Concatenate notes if multiple (with length limit to prevent memory issues)\r\n            # MEDIUM FIX TLS-M1: Use script-level constants for length limits\r\n            if ($entry.ContainsKey('notes') -and $entry.notes) {\r\n                $currentNotes = $grouped[$groupKey].notes\r\n                if ($currentNotes -and $currentNotes -ne $entry.notes) {\r\n                    # Limit concatenated notes length to prevent excessive growth\r\n                    $newNotes = \"$currentNotes; $($entry.notes)\"\r\n                    $grouped[$groupKey].notes = $(if ($newNotes.Length -gt $global:MAX_NOTES_LENGTH) {\r\n                        $newNotes.Substring(0, $global:MAX_NOTES_TRUNCATE_LENGTH) + \"...\"\r\n                    } else {\r\n                        $newNotes\r\n                    })\r\n                } elseif (-not $currentNotes) {\r\n                    $grouped[$groupKey].notes = $entry.notes\r\n                }\r\n            }\r\n        }\r\n\r\n        # Convert to array and format\r\n        $aggregated = @()\r\n        foreach ($key in $grouped.Keys) {\r\n            $entry = $grouped[$key]\r\n\r\n            # Format duration as HH:MM with null checks\r\n            # CRITICAL FIX TLS-C2: Validate numeric type before division/modulo\r\n            if ($entry.ContainsKey('minutes') -and $null -ne $entry.minutes) {\r\n                $numericMinutes = 0\r\n                if ([double]::TryParse($entry.minutes, [ref]$numericMinutes)) {\r\n                    $hours = [int][Math]::Floor($numericMinutes / 60)\r\n                    $mins = [int]($numericMinutes % 60)\r\n                    $entry['duration'] = \"{0:D2}:{1:D2}\" -f $hours, $mins\r\n                } else {\r\n                    # Write-PmcTuiLog \"TimeListScreen.LoadItems: Invalid minutes value: $($entry.minutes)\" \"WARNING\"\r\n                    $entry['duration'] = \"00:00\"\r\n                }\r\n            } else {\r\n                $entry['duration'] = \"00:00\"\r\n            }\r\n\r\n            # Add indicator if aggregated\r\n            if ($entry.entry_count -gt 1) {\r\n                $entry['duration'] = \"$($entry.duration) ($($entry.entry_count))\"\r\n            }\r\n\r\n            # DEBUG: Log the keys in this entry\r\n            $keysStr = ($entry.Keys | Sort-Object) -join ', '\r\n            # Write-PmcTuiLog \"TimeListScreen.LoadItems: Created entry with keys: $keysStr\"\r\n            # Write-PmcTuiLog \"TimeListScreen.LoadItems: date_display='$($entry.date_display)' date='$($entry.date)'\"\r\n\r\n            $aggregated += $entry\r\n        }\r\n\r\n        # TS-M1 FIX: Notify user if there were failed date parses\r\n        if ($failedDateParses -gt 0) {\r\n            # Write-PmcTuiLog \"TimeListScreen.LoadItems: $failedDateParses time entries had unparseable dates\" \"WARNING\"\r\n            $this.SetStatusMessage(\"Warning: $failedDateParses entries have invalid dates\", \"warning\")\r\n        }\r\n\r\n        # Sort by date descending (most recent first)\r\n        # HIGH FIX TLS-H5: Handle null dates in sort\r\n        $sorted = $aggregated | Sort-Object { if ($null -ne $_.date) { $_.date } else { [DateTime]::MaxValue } } -Descending\r\n        # Ensure we always return an array (PowerShell returns single object if count=1)\r\n        return @($sorted)\r\n    }\r\n\r\n    # Define columns for list display\r\n    [array] GetListColumns() {\r\n        return @(\r\n            @{ Name='date_display'; Header='Date'; Width=12 }\r\n            @{ Name='task'; Header='Task'; Width=25 }\r\n            @{ Name='project'; Header='Project'; Width=16 }\r\n            @{ Name='id1'; Header='ID1/Code'; Width=10 }\r\n            @{ Name='id2'; Header='ID2'; Width=10 }\r\n            @{ Name='duration'; Header='Duration'; Width=18 }\r\n            @{ Name='notes'; Header='Notes'; Width=40 }\r\n        )\r\n    }\r\n\r\n    # Define edit fields for InlineEditor\r\n    [array] GetEditFields([object]$item) {\r\n        # CRITICAL: Match GetColumns() field widths exactly\r\n        # GetColumns defines: date_display=12, task=25, project=16, id1=10, id2=10, duration=18, notes=40\r\n        $dateWidth = 12      # Matches date_display column\r\n        $taskWidth = 25      # Matches task column\r\n        $projectWidth = 16   # Matches project column\r\n        $id1Width = 10       # Matches id1 column\r\n        $id2Width = 10       # Matches id2 column\r\n        $hoursWidth = 18     # Matches duration column\r\n        $notesWidth = 40     # Matches notes column\r\n\r\n        if ($null -eq $item -or ($item -is [hashtable] -and $item.Count -eq 0)) {\r\n            # New time entry - empty fields\r\n            return @(\r\n                @{ Name='date'; Type='date'; Label='Date'; Required=$true; Value=[DateTime]::Now; Width=$dateWidth }\r\n                @{ Name='task'; Type='text'; Label='Task'; Value=''; Width=$taskWidth }\r\n                @{ Name='project'; Type='project'; Label='Project'; Value=''; Width=$projectWidth }\r\n                @{ Name='id1'; Type='text'; Label='ID1'; Value=''; MaxLength=10; Width=$id1Width }\r\n                @{ Name='id2'; Type='text'; Label='ID2'; Value=''; MaxLength=10; Width=$id2Width }\r\n                # MEDIUM FIX TMS-M3 & TLS-M2: Use constant for max hours validation\r\n                @{ Name='hours'; Type='number'; Label='Hours'; Min=$global:MIN_HOURS_PER_ENTRY; Max=$global:MAX_HOURS_PER_ENTRY; Step=0.25; Value=$global:MIN_HOURS_PER_ENTRY; Width=$hoursWidth }\r\n                @{ Name='notes'; Type='text'; Label='Notes'; Value=''; Width=$notesWidth }\r\n            )\r\n        } else {\r\n            # Existing time entry - populate from item\r\n            $projectVal = $(if ($item.ContainsKey('project')) { $item.project } else { '' })\r\n            $id1Val = $(if ($item.ContainsKey('id1')) { $item.id1 } else { '' })\r\n            $id2Val = $(if ($item.ContainsKey('id2')) { $item.id2 } else { '' })\r\n            # Convert minutes to hours for display\r\n            $hoursVal = $(if ($item.ContainsKey('minutes')) { [math]::Round($item.minutes / 60, 2) } else { 0.25 })\r\n            # HIGH FIX TLS-H1: Add null check for task field\r\n            $taskVal = $(if ($item.ContainsKey('task')) { $item.task } else { '' })\r\n            # HIGH FIX TLS-H2: Add null check for notes field\r\n            $notesVal = $(if ($item.ContainsKey('notes')) { $item.notes } else { '' })\r\n            return @(\r\n                @{ Name='date'; Type='date'; Label='Date'; Required=$true; Value=$item.date; Width=$dateWidth }\r\n                @{ Name='task'; Type='text'; Label='Task'; Value=$taskVal; Width=$taskWidth }\r\n                @{ Name='project'; Type='project'; Label='Project'; Value=$projectVal; Width=$projectWidth }\r\n                @{ Name='id1'; Type='text'; Label='ID1'; Value=$id1Val; MaxLength=10; Width=$id1Width }\r\n                @{ Name='id2'; Type='text'; Label='ID2'; Value=$id2Val; MaxLength=10; Width=$id2Width }\r\n                # MEDIUM FIX TMS-M3 & TLS-M2: Use constant for max hours validation\r\n                @{ Name='hours'; Type='number'; Label='Hours'; Min=$global:MIN_HOURS_PER_ENTRY; Max=$global:MAX_HOURS_PER_ENTRY; Step=0.25; Value=$hoursVal; Width=$hoursWidth }\r\n                @{ Name='notes'; Type='text'; Label='Notes'; Value=$notesVal; Width=$notesWidth }\r\n            )\r\n        }\r\n    }\r\n\r\n    # Helper: Get ID1/ID2 values from project if project is selected\r\n    hidden [void] PopulateIDsFromProject([hashtable]$timeData) {\r\n        if ($timeData.ContainsKey('project') -and -not [string]::IsNullOrWhiteSpace($timeData.project)) {\r\n            # Project is selected - try to get ID1/ID2 from it\r\n            $project = $this.Store.GetProject($timeData.project)\r\n            if ($project) {\r\n                # Write-PmcTuiLog \"TimeListScreen.PopulateIDsFromProject: Found project '$($timeData.project)'\" \"DEBUG\"\r\n\r\n                # If project has ID1, use it (unless user already entered a value)\r\n                if (-not [string]::IsNullOrWhiteSpace($project.ID1) -and [string]::IsNullOrWhiteSpace($timeData.id1)) {\r\n                    $timeData.id1 = $project.ID1\r\n                    # Write-PmcTuiLog \"TimeListScreen.PopulateIDsFromProject: Set id1 from project: '$($timeData.id1)'\" \"DEBUG\"\r\n                }\r\n\r\n                # If project has ID2, use it (unless user already entered a value)\r\n                if (-not [string]::IsNullOrWhiteSpace($project.ID2) -and [string]::IsNullOrWhiteSpace($timeData.id2)) {\r\n                    $timeData.id2 = $project.ID2\r\n                    # Write-PmcTuiLog \"TimeListScreen.PopulateIDsFromProject: Set id2 from project: '$($timeData.id2)'\" \"DEBUG\"\r\n                }\r\n            } else {\r\n                # Write-PmcTuiLog \"TimeListScreen.PopulateIDsFromProject: Project '$($timeData.project)' not found\" \"WARNING\"\r\n            }\r\n        } else {\r\n            # No project selected - clear ID1/ID2 if they should come from project\r\n            # Write-PmcTuiLog \"TimeListScreen.PopulateIDsFromProject: No project selected, keeping user-entered ID1/ID2 values\" \"DEBUG\"\r\n        }\r\n    }\r\n\r\n    # Handle item creation\r\n    [void] OnItemCreated([hashtable]$values) {\r\n        if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\r\n            # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: CALLED with values: $($values | ConvertTo-Json -Compress)\" \"DEBUG\"\r\n        }\r\n        try {\r\n            # ENDEMIC FIX: Safe conversion with validation\r\n            if (-not $values.ContainsKey('hours') -or [string]::IsNullOrWhiteSpace($values.hours)) {\r\n                # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: Hours validation failed\" \"DEBUG\"\r\n                $this.SetStatusMessage(\"Hours field is required\", \"error\")\r\n                return\r\n            }\r\n            # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: Hours validation passed\" \"DEBUG\"\r\n\r\n            $hoursValue = 0.0\r\n            try {\r\n                $hoursValue = [double]$values.hours\r\n            } catch {\r\n                # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: Hours conversion failed\" \"DEBUG\"\r\n                $this.SetStatusMessage(\"Invalid hours value: $($values.hours)\", \"error\")\r\n                return\r\n            }\r\n\r\n            if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\r\n                # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: Hours value=$hoursValue, MAX_HOURS_PER_ENTRY=$global:MAX_HOURS_PER_ENTRY\" \"DEBUG\"\r\n            }\r\n\r\n            # Validate hour range\r\n            # MEDIUM FIX TLS-M3: Use constant for hours validation\r\n            if ($hoursValue -le 0) {\r\n                # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: Hours <= 0\" \"DEBUG\"\r\n                $this.SetStatusMessage(\"Hours must be greater than 0\", \"error\")\r\n                return\r\n            }\r\n            if ($hoursValue -gt $global:MAX_HOURS_PER_ENTRY) {\r\n                # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: Hours > MAX ($hoursValue > $global:MAX_HOURS_PER_ENTRY)\" \"DEBUG\"\r\n                $this.SetStatusMessage(\"Hours must be $global:MAX_HOURS_PER_ENTRY or less\", \"error\")\r\n                return\r\n            }\r\n            # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: Hour range validation passed\" \"DEBUG\"\r\n\r\n            # HIGH FIX TMS-H3: Use Math.Round instead of [int] to prevent precision loss\r\n            # 2.75 hours = 165 minutes (not 165.0 truncated to 165)\r\n            # CRITICAL: Cast to [int] because validation requires int type\r\n            $minutes = [int][Math]::Round($hoursValue * 60)\r\n            # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: Calculated minutes=$minutes\" \"DEBUG\"\r\n\r\n            # Safe date conversion\r\n            $dateValue = [DateTime]::Today\r\n            if ($values.ContainsKey('date') -and $values.date) {\r\n                try {\r\n                    $dateValue = [DateTime]$values.date\r\n                } catch {\r\n                    # Write-PmcTuiLog \"Failed to parse date '$($values.date)', using today\" \"WARNING\"\r\n                }\r\n            }\r\n            # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: Date=$dateValue\" \"DEBUG\"\r\n\r\n            $timeData = @{\r\n                date = $dateValue\r\n                task = $(if ($values.ContainsKey('task')) { $values.task } else { '' })\r\n                project = $(if ($values.ContainsKey('project')) { $values.project } else { '' })\r\n                id1 = $(if ($values.ContainsKey('id1')) { $values.id1 } else { '' })\r\n                id2 = $(if ($values.ContainsKey('id2')) { $values.id2 } else { '' })\r\n                minutes = $minutes\r\n                notes = $(if ($values.ContainsKey('notes')) { $values.notes } else { '' })\r\n                created = [DateTime]::Now\r\n            }\r\n\r\n            # Populate ID1/ID2 from project if project is selected and IDs are empty\r\n            $this.PopulateIDsFromProject($timeData)\r\n\r\n            # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: About to save time entry - id1='$($timeData.id1)' id2='$($timeData.id2)'\" \"DEBUG\"\r\n            # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: Calling Store.AddTimeLog...\" \"DEBUG\"\r\n\r\n            $success = $this.Store.AddTimeLog($timeData)\r\n            # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: AddTimeLog returned success=$success\" \"DEBUG\"\r\n            if (-not $success) {\r\n                # Write-PmcTuiLog \"TimeListScreen.OnItemCreated: Store.LastError=$($this.Store.LastError)\" \"ERROR\"\r\n            }\r\n\r\n            $statusMsg = \"Time entry added: {0:F2} hours\" -f $hoursValue\r\n            if ($success) {\r\n                $this.SetStatusMessage($statusMsg, \"success\")\r\n            } else {\r\n                $this.SetStatusMessage(\"Failed to add time entry: $($this.Store.LastError)\", \"error\")\r\n            }\r\n        } catch {\r\n            # Write-PmcTuiLog \"OnItemCreated exception: $_\" \"ERROR\"\r\n            $this.SetStatusMessage(\"Unexpected error: $($_.Exception.Message)\", \"error\")\r\n        }\r\n    }\r\n\r\n    # Handle item update\r\n    [void] OnItemUpdated([object]$item, [hashtable]$values) {\r\n        try {\r\n            # ENDEMIC FIX: Safe conversion with validation\r\n            if (-not $values.ContainsKey('hours') -or [string]::IsNullOrWhiteSpace($values.hours)) {\r\n                $this.SetStatusMessage(\"Hours field is required\", \"error\")\r\n                return\r\n            }\r\n\r\n            $hoursValue = 0.0\r\n            try {\r\n                $hoursValue = [double]$values.hours\r\n            } catch {\r\n                $this.SetStatusMessage(\"Invalid hours value: $($values.hours)\", \"error\")\r\n                return\r\n            }\r\n\r\n            # Validate hour range\r\n            # MEDIUM FIX TLS-M3: Use constant for hours validation\r\n            if ($hoursValue -le 0) {\r\n                $this.SetStatusMessage(\"Hours must be greater than 0\", \"error\")\r\n                return\r\n            }\r\n            if ($hoursValue -gt $global:MAX_HOURS_PER_ENTRY) {\r\n                $this.SetStatusMessage(\"Hours must be $global:MAX_HOURS_PER_ENTRY or less\", \"error\")\r\n                return\r\n            }\r\n\r\n            # HIGH FIX TMS-H3: Use Math.Round instead of [int] to prevent precision loss\r\n            # 2.75 hours = 165 minutes (not 165.0 truncated to 165)\r\n            # CRITICAL: Cast to [int] because validation requires int type\r\n            $minutes = [int][Math]::Round($hoursValue * 60)\r\n\r\n            # Safe date conversion\r\n            $dateValue = [DateTime]::Today\r\n            if ($values.ContainsKey('date') -and $values.date) {\r\n                try {\r\n                    $dateValue = [DateTime]$values.date\r\n                } catch {\r\n                    # Write-PmcTuiLog \"Failed to parse date '$($values.date)', using today\" \"WARNING\"\r\n                }\r\n            }\r\n\r\n            $changes = @{\r\n                date = $dateValue\r\n                task = $(if ($values.ContainsKey('task')) { $values.task } else { '' })\r\n                project = $(if ($values.ContainsKey('project')) { $values.project } else { '' })\r\n                id1 = $(if ($values.ContainsKey('id1')) { $values.id1 } else { '' })\r\n                id2 = $(if ($values.ContainsKey('id2')) { $values.id2 } else { '' })\r\n                minutes = $minutes\r\n                notes = $(if ($values.ContainsKey('notes')) { $values.notes } else { '' })\r\n            }\r\n\r\n            # Populate ID1/ID2 from project if project is selected and IDs are empty\r\n            $this.PopulateIDsFromProject($changes)\r\n\r\n            # Write-PmcTuiLog \"TimeListScreen.OnItemUpdated: About to save changes - id1='$($changes.id1)' id2='$($changes.id2)'\" \"DEBUG\"\r\n\r\n            # Update time log via TaskStore\r\n            if ($item.ContainsKey('id') -and -not [string]::IsNullOrWhiteSpace($item.id)) {\r\n                # Write-PmcTuiLog \"TimeListScreen.OnItemUpdated: Calling Store.UpdateTimeLog with id=$($item.id)\" \"DEBUG\"\r\n                $success = $this.Store.UpdateTimeLog($item.id, $changes)\r\n                if ($success) {\r\n                    $this.SetStatusMessage(\"Time entry updated\", \"success\")\r\n                    # TS-M6 FIX: Use RefreshList() instead of LoadData() for incremental refresh\r\n                    # RefreshList() is more efficient than full LoadData() for single item updates\r\n                    $this.RefreshList()\r\n                } else {\r\n                    $this.SetStatusMessage(\"Failed to update time entry: $($this.Store.LastError)\", \"error\")\r\n                }\r\n            } else {\r\n                $this.SetStatusMessage(\"Cannot update time entry without ID\", \"error\")\r\n            }\r\n        } catch {\r\n            # Write-PmcTuiLog \"OnItemUpdated exception: $_\" \"ERROR\"\r\n            $this.SetStatusMessage(\"Unexpected error: $($_.Exception.Message)\", \"error\")\r\n        }\r\n    }\r\n\r\n    # Handle item deletion\r\n    [void] OnItemDeleted([object]$item) {\r\n        # HIGH FIX TLS-H3: Validate ID is not empty/whitespace\r\n        if ($item.ContainsKey('id') -and -not [string]::IsNullOrWhiteSpace($item.id)) {\r\n            $success = $this.Store.DeleteTimeLog($item.id)\r\n            if ($success) {\r\n                $this.SetStatusMessage(\"Time entry deleted\", \"success\")\r\n            } else {\r\n                $this.SetStatusMessage(\"Failed to delete time entry: $($this.Store.LastError)\", \"error\")\r\n            }\r\n        } else {\r\n            $this.SetStatusMessage(\"Cannot delete time entry without ID\", \"error\")\r\n        }\r\n    }\r\n\r\n    # Virtual method called when inline editor is confirmed\r\n    # This method is called by StandardListScreen when inline editing is confirmed\r\n    # TimeListScreen already handles inline editing through OnItemCreated and OnItemUpdated,\r\n    # so this is a no-op to prevent method-not-found errors\r\n    [void] OnInlineEditConfirmed([hashtable]$values) {\r\n        if ($null -eq $values) {\r\n            # Write-PmcTuiLog \"TimeListScreen.OnInlineEditConfirmed called with null values\" \"WARNING\"\r\n            return\r\n        }\r\n        # Write-PmcTuiLog \"TimeListScreen.OnInlineEditConfirmed called with values: $($values.Keys -join ',')\" \"DEBUG\"\r\n\r\n        # Route to OnItemCreated or OnItemUpdated based on mode\r\n        $isAddMode = ($this.EditorMode -eq 'add')\r\n\r\n        if ($isAddMode) {\r\n            # Write-PmcTuiLog \"OnInlineEditConfirmed: Processing ADD mode for time entry\" \"INFO\"\r\n            $this.OnItemCreated($values)\r\n        }\r\n        else {\r\n            # Write-PmcTuiLog \"OnInlineEditConfirmed: Processing EDIT mode for time entry\" \"INFO\"\r\n            if ($this.CurrentEditItem) {\r\n                $this.OnItemUpdated($this.CurrentEditItem, $values)\r\n            }\r\n            else {\r\n                # Write-PmcTuiLog \"OnInlineEditConfirmed: EDIT mode but no CurrentEditItem!\" \"ERROR\"\r\n            }\r\n        }\r\n    }\r\n\r\n    # Virtual method called when inline editor is cancelled\r\n    # This method is called by StandardListScreen when inline editing is cancelled\r\n    # TimeListScreen already handles inline editing through its own callbacks,\r\n    # so this is a no-op to prevent method-not-found errors\r\n    [void] OnInlineEditCancelled() {\r\n        # Write-PmcTuiLog \"TimeListScreen.OnInlineEditCancelled called\" \"DEBUG\"\r\n        # No-op: TimeListScreen handles inline editor callbacks directly\r\n    }\r\n\r\n\r\n    # Get custom actions for footer display\r\n    [array] GetCustomActions() {\r\n        $self = $this\r\n        return @(\r\n            @{ Key='w'; Label='Week Report'; Callback={\r\n                $screenPath = \"$PSScriptRoot/WeeklyTimeReportScreen.ps1\"\r\n                . $screenPath\r\n                $screen = New-Object WeeklyTimeReportScreen\r\n                $global:PmcApp.PushScreen($screen)\r\n            }.GetNewClosure() },\r\n            @{ Key='g'; Label='Generate'; Callback={\r\n                $self.GenerateReport()\r\n            }.GetNewClosure() }\r\n        )\r\n    }\r\n\r\n    # === Custom Actions ===\r\n\r\n    # Show detail dialog for aggregated entries\r\n    [void] ShowDetailDialog([hashtable]$item) {\r\n        # CRITICAL FIX TLS-C3: Add null check on $item parameter\r\n        if ($null -eq $item) {\r\n            # Write-PmcTuiLog \"TimeListScreen.ShowDetailDialog: item parameter is null\" \"WARNING\"\r\n            return\r\n        }\r\n        if (-not $item.ContainsKey('original_entries') -or $item.original_entries.Count -eq 0) {\r\n            return\r\n        }\r\n\r\n        # Create dialog title\r\n        # HIGH FIX TLS-H4: Add null checks for string interpolation\r\n        $dateDisplay = $(if ($item.ContainsKey('date_display')) { $item.date_display } else { 'Unknown' })\r\n        $project = $(if ($item.ContainsKey('project')) { $item.project } else { 'N/A' })\r\n        $title = \"Time Entry Details - $dateDisplay - $project\"\r\n        # HIGH FIX TLS-H6: Use ContainsKey check for timecode\r\n        if ($item.ContainsKey('timecode') -and $item.timecode) {\r\n            $title += \" [$($item.timecode)]\"\r\n        }\r\n        $entryCount = $(if ($item.ContainsKey('entry_count')) { $item.entry_count } else { 0 })\r\n        $title += \" ($entryCount entries)\"\r\n\r\n        # LOW FIX TS-L1: Add error handling on dialog creation\r\n        try {\r\n            $dialog = [TimeEntryDetailDialog]::new($title, $item.original_entries)\r\n        } catch {\r\n            $this.SetStatusMessage(\"Failed to create detail dialog: $($_.Exception.Message)\", \"error\")\r\n            # Write-PmcTuiLog \"TimeListScreen: Dialog creation failed - $_\" \"ERROR\"\r\n            return\r\n        }\r\n\r\n        # TIM-7 FIX: Dialog render loop with timeout protection\r\n        # CRITICAL FIX TMS-C1 & EDGE FIX TLS-E1: Use constants for timeout and poll interval\r\n        $maxIterations = $script:DIALOG_TIMEOUT_ITERATIONS\r\n        $iterations = 0\r\n\r\n        while (-not $dialog.IsComplete -and $iterations -lt $maxIterations) {\r\n            $iterations++\r\n\r\n            # Get theme from theme manager\r\n            $themeManager = [PmcThemeManager]::GetInstance()\r\n            $theme = $themeManager.GetTheme()\r\n\r\n            # Render dialog\r\n            $termWidth = [Console]::WindowWidth\r\n            $termHeight = [Console]::WindowHeight\r\n            $dialogOutput = $dialog.Render($termWidth, $termHeight, $theme)\r\n\r\n            # Handle input\r\n            if ([Console]::KeyAvailable) {\r\n                $key = [Console]::ReadKey($true)\r\n                $dialog.HandleInput($key)\r\n\r\n                # HIGH FIX TMS-H4: Only close on Escape, Ctrl+C, or Ctrl+Q (not all Control keys)\r\n                # Checking -band [ConsoleModifiers]::Control catches Ctrl+V, Ctrl+A, etc.\r\n                if ($key.Key -eq 'Escape' -or\r\n                    ($key.Key -eq 'C' -and ($key.Modifiers -band [ConsoleModifiers]::Control)) -or\r\n                    ($key.Key -eq 'Q' -and ($key.Modifiers -band [ConsoleModifiers]::Control))) {\r\n                    $dialog.IsComplete = $true\r\n                    break\r\n                }\r\n            }\r\n\r\n            Start-Sleep -Milliseconds $script:DIALOG_POLL_INTERVAL_MS\r\n        }\r\n\r\n        # TS-M2 FIX: Show user-visible warning if timeout occurred\r\n        if ($iterations -ge $maxIterations) {\r\n            # Write-PmcTuiLog \"TimeListScreen.ShowDetailDialog: Timeout after $maxIterations iterations (3 minutes)\" \"WARNING\"\r\n            $this.SetStatusMessage(\"Dialog closed due to timeout (3 minutes)\", \"warning\")\r\n        }\r\n\r\n        # Redraw screen after dialog closes\r\n        $this.RenderEngine.ForceRedraw()\r\n    }\r\n\r\n    # Generate time report for selected period\r\n    [void] GenerateReport() {\r\n        # Navigate to time report screen\r\n        . \"$PSScriptRoot/TimeReportScreen.ps1\"\r\n        $screen = New-Object TimeReportScreen\r\n        $this.App.PushScreen($screen)\r\n    }\r\n\r\n    # === Input Handling ===\r\n\r\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\r\n        # Custom key: Enter = Show detail dialog for aggregated entries\r\n        if ($keyInfo.Key -eq 'Enter' -and -not $this.ShowInlineEditor) {\r\n            $selectedItem = $this.List.GetSelectedItem()\r\n            if ($selectedItem -and $selectedItem.ContainsKey('entry_count') -and $selectedItem.entry_count -gt 1) {\r\n                $this.ShowDetailDialog($selectedItem)\r\n                return $true\r\n            }\r\n        }\r\n\r\n        # Call parent handler (handles list navigation, add/edit/delete)\r\n        $handled = ([StandardListScreen]$this).HandleKeyPress($keyInfo)\r\n        if ($handled) { return $true }\r\n\r\n        # Custom key: G = Generate report\r\n        if ($keyInfo.KeyChar -eq 'g' -or $keyInfo.KeyChar -eq 'G') {\r\n            $this.GenerateReport()\r\n            return $true\r\n        }\r\n\r\n        # Custom key: W = Weekly time report\r\n        if ($keyInfo.KeyChar -eq 'w' -or $keyInfo.KeyChar -eq 'W') {\r\n            . \"$PSScriptRoot/WeeklyTimeReportScreen.ps1\"\r\n            $screen = New-Object WeeklyTimeReportScreen\r\n            $this.App.PushScreen($screen)\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/screens/TimeReportScreen.ps1", "content": "using namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# TimeReportScreen - Time report summary\r\n# Shows summary by project: total hours, task breakdown\r\n\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n. \"$PSScriptRoot/../PmcScreen.ps1\"\r\n\r\n<#\r\n.SYNOPSIS\r\nTime report summary screen\r\n\r\n.DESCRIPTION\r\nShows time summary grouped by project.\r\nDisplays:\r\n- Total hours per project\r\n- Number of entries per project\r\n- Overall total\r\nNo navigation, just view (read-only).\r\n##CLOSEBRACKET##\r\nclass TimeReportScreen : PmcScreen {\r\n    # Data\r\n    [array]$ProjectSummaries = @()\r\n    [int]$TotalMinutes = 0\r\n    [double]$TotalHours = 0\r\n\r\n    # Static: Register menu items\r\n    static [void] RegisterMenuItems([object]$registry) {\r\n        $registry.AddMenuItem('Time', 'Time Report', 'R', {\r\n                . \"$PSScriptRoot/TimeReportScreen.ps1\"\r\n                $global:PmcApp.PushScreen((New-Object -TypeName TimeReportScreen))\r\n            }, 20)\r\n    }\r\n\r\n    # Constructor\r\n    TimeReportScreen() : base(\"TimeReport\", \"Time Report\") {\r\n        # Configure header\r\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Time Entries\", \"Report\"))\r\n\r\n        # Configure footer with shortcuts\r\n        $this.Footer.ClearShortcuts()\r\n        $this.Footer.AddShortcut(\"W\", \"Weekly\")\r\n        $this.Footer.AddShortcut(\"R\", \"Refresh\")\r\n        $this.Footer.AddShortcut(\"Esc\", \"Back\")\r\n        $this.Footer.AddShortcut(\"Ctrl+Q\", \"Quit\")\r\n\r\n        # NOTE: _SetupMenus() removed - MenuRegistry handles menu population via static RegisterMenuItems()\r\n        # Old pattern was adding duplicate/misplaced menu items\r\n    }\r\n\r\n    # Constructor with container (DI-enabled)\r\n    TimeReportScreen([object]$container) : base(\"TimeReport\", \"Time Report\", $container) {\r\n        # Configure header\r\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Time Entries\", \"Report\"))\r\n\r\n        # Configure footer with shortcuts\r\n        $this.Footer.ClearShortcuts()\r\n        $this.Footer.AddShortcut(\"W\", \"Weekly\")\r\n        $this.Footer.AddShortcut(\"R\", \"Refresh\")\r\n        $this.Footer.AddShortcut(\"Esc\", \"Back\")\r\n        $this.Footer.AddShortcut(\"Ctrl+Q\", \"Quit\")\r\n\r\n        # NOTE: _SetupMenus() removed - MenuRegistry handles menu population via static RegisterMenuItems()\r\n        # Old pattern was adding duplicate/misplaced menu items\r\n    }\r\n\r\n    [void] OnEnter() {\r\n        # Call parent to ensure proper lifecycle (sets IsActive, calls LoadData, executes OnEnterHandler)\r\n        ([PmcScreen]$this).OnEnter()\r\n    }\r\n\r\n    [void] LoadData() {\r\n        $this.ShowStatus(\"Loading time report...\")\r\n\r\n        try {\r\n            # Use TaskStore singleton instead of loading from disk\r\n            $timelogs = $this.Store.GetAllTimeLogs()\r\n\r\n            # CRITICAL FIX: Add null check for GetAllTimeLogs()\r\n            if ($null -eq $timelogs) {\r\n                $timelogs = @()\r\n            }\r\n\r\n            # TS-M8 FIX: Add better feedback for empty state\r\n            if ($timelogs.Count -eq 0) {\r\n                $this.ProjectSummaries = @()\r\n                $this.TotalMinutes = 0\r\n                $this.TotalHours = 0\r\n                # Enhanced feedback to guide user on what to do next\r\n                $this.ShowStatus(\"No time entries found. Press 'T' to add time entries in Time Tracking screen.\")\r\n                # Write-PmcTuiLog \"TimeReportScreen: No time entries found for report\" \"INFO\"\r\n                return\r\n            }\r\n\r\n            # TS-M7 FIX: Group by project ID if available, otherwise by name\r\n            # Create grouping key for each entry: use id1 if present, otherwise project name\r\n            $groupedData = @{}\r\n            foreach ($log in $timelogs) {\r\n                # Determine grouping key (prefer ID over name)\r\n                $groupKey = ''\r\n                $projectDisplay = ''\r\n                if ($log.ContainsKey('id1') -and $log.id1) {\r\n                    $groupKey = \"ID:$($log.id1)\"\r\n                    $projectDisplay = $(if ($log.ContainsKey('project') -and $log.project) { \"$($log.project) [#$($log.id1)]\" } else { \"#$($log.id1)\" })\r\n                }\r\n                else {\r\n                    $projectVal = $(if ($log.ContainsKey('project')) { $log.project } else { 'Unknown' })\r\n                    $groupKey = \"NAME:$projectVal\"\r\n                    $projectDisplay = $projectVal\r\n                }\r\n\r\n                # Initialize group if needed\r\n                if (-not $groupedData.ContainsKey($groupKey)) {\r\n                    $groupedData[$groupKey] = @{\r\n                        DisplayName = $projectDisplay\r\n                        Entries     = @()\r\n                    }\r\n                }\r\n\r\n                $groupedData[$groupKey].Entries += $log\r\n            }\r\n\r\n            $this.ProjectSummaries = @()\r\n            $this.TotalMinutes = 0\r\n            # LOW FIX TS-L2: Accumulate hours to avoid redundant calculation\r\n            $totalHoursAccumulated = 0.0\r\n\r\n            foreach ($key in ($groupedData.Keys | Sort-Object)) {\r\n                $group = $groupedData[$key]\r\n                $minutes = ($group.Entries | Measure-Object -Property minutes -Sum).Sum\r\n                $hours = [Math]::Round($minutes / 60.0, 2)\r\n                $this.TotalMinutes += $minutes\r\n                $totalHoursAccumulated += $hours\r\n\r\n                $this.ProjectSummaries += [PSCustomObject]@{\r\n                    Project    = $group.DisplayName\r\n                    EntryCount = $group.Entries.Count\r\n                    Minutes    = $minutes\r\n                    Hours      = $hours\r\n                }\r\n            }\r\n\r\n            # Use accumulated hours (sum of rounded values) instead of recalculating\r\n            $this.TotalHours = $totalHoursAccumulated\r\n\r\n            $this.ShowStatus(\"Report generated: $($this.ProjectSummaries.Count) projects, $($this.TotalHours) hours total\")\r\n\r\n        }\r\n        catch {\r\n            $this.ShowError(\"Failed to load time report: $_\")\r\n            $this.ProjectSummaries = @()\r\n            $this.TotalMinutes = 0\r\n            $this.TotalHours = 0\r\n        }\r\n    }\r\n\r\n    [void] RenderContentToEngine([object]$engine) {\r\n        if (-not $this.LayoutManager) { return }\r\n\r\n        if ($this.ProjectSummaries.Count -eq 0) {\r\n            $this._RenderEmptyStateToEngine($engine)\r\n        }\r\n        else {\r\n            $this._RenderReportToEngine($engine)\r\n        }\r\n    }\r\n\r\n        # Column headers\r\n        $headerY = $y\r\n        $headers = \"PROJECT                     ENTRIES  MINUTES      HOURS\"\r\n        $engine.WriteAt($contentRect.X + 4, $headerY, $headers, $headerColor, $bg)\r\n        $y++\r\n\r\n        # Separator line\r\n        $sepLen = $contentRect.Width - 4\r\n        $engine.WriteAt($contentRect.X + 2, $y, \"-\" * $sepLen, $mutedColor, $bg)\r\n        $y++\r\n\r\n        # Project rows\r\n        $maxLines = $contentRect.Height - 8\r\n        $displayCount = [Math]::Min($this.ProjectSummaries.Count, $maxLines)\r\n\r\n        for ($i = 0; $i -lt $displayCount; $i++) {\r\n            $summary = $this.ProjectSummaries[$i]\r\n\r\n            $x = $contentRect.X + 4\r\n\r\n            # Project name\r\n            $projectName = $summary.Project\r\n            if ($projectName.Length -gt 26) {\r\n                $projectName = $projectName.Substring(0, 23) + \"...\"\r\n            }\r\n            $engine.WriteAt($x, $y, $projectName.PadRight(28), $textColor, $bg)\r\n            $x += 28\r\n\r\n            # Entry count\r\n            $engine.WriteAt($x, $y, $summary.EntryCount.ToString().PadRight(9), $mutedColor, $bg)\r\n            $x += 9\r\n\r\n            # Minutes\r\n            $engine.WriteAt($x, $y, $summary.Minutes.ToString().PadRight(13), $warningColor, $bg)\r\n            $x += 13\r\n\r\n            # Hours\r\n            $engine.WriteAt($x, $y, $summary.Hours.ToString(\"0.00\"), $successColor, $bg)\r\n\r\n            $y++\r\n        }\r\n\r\n        # Separator line\r\n        $y++\r\n        $engine.WriteAt($contentRect.X + 2, $y, \"-\" * $sepLen, $mutedColor, $bg)\r\n        $y++\r\n\r\n        # Total row\r\n        $x = $contentRect.X + 4\r\n        \r\n        $engine.WriteAt($x, $y, \"TOTAL:\".PadRight(28), $highlightColor, $bg)\r\n        $x += 28\r\n\r\n        # Total entries\r\n        $totalEntries = ($this.ProjectSummaries | Measure-Object -Property EntryCount -Sum).Sum\r\n        $engine.WriteAt($x, $y, $totalEntries.ToString().PadRight(9), $mutedColor, $bg)\r\n        $x += 9\r\n\r\n        # Total minutes\r\n        $engine.WriteAt($x, $y, $this.TotalMinutes.ToString().PadRight(13), $warningColor, $bg)\r\n        $x += 13\r\n\r\n        # Total hours\r\n        $engine.WriteAt($x, $y, $this.TotalHours.ToString(\"0.00\"), $successColor, $bg)\r\n    }\r\n\r\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\r\n        # CRITICAL: Call parent FIRST for MenuBar, F10, Alt+keys, content widgets\r\n        $handled = ([PmcScreen]$this).HandleKeyPress($keyInfo)\r\n        if ($handled) { return $true }\r\n\r\n        # F10 - Menu\r\n        if ($keyInfo.Key -eq ([ConsoleKey]::F10)) {\r\n            if ($this.MenuBar) {\r\n                $this.MenuBar.Activate()\r\n                return $true\r\n            }\r\n        }\r\n\r\n        # Escape - Go back\r\n        if ($keyInfo.Key -eq ([ConsoleKey]::Escape)) {\r\n            $global:PmcApp.PopScreen()\r\n            return $true\r\n        }\r\n\r\n        # Ctrl+Q - Quit\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control -and $keyInfo.Key -eq ([ConsoleKey]::Q)) {\r\n            $global:PmcApp.Quit()\r\n            return $true\r\n        }\r\n\r\n        # Refresh on R key\r\n        if ($keyInfo.Key -eq ([ConsoleKey]::R)) {\r\n            $this.LoadData()\r\n            return $true\r\n        }\r\n\r\n        # Weekly report on W key\r\n        if ($keyInfo.Key -eq ([ConsoleKey]::W)) {\r\n            . \"$PSScriptRoot/WeeklyTimeReportScreen.ps1\"\r\n            $screen = New-Object WeeklyTimeReportScreen\r\n            $global:PmcApp.PushScreen($screen)\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\n# Entry point function for compatibility\r\nfunction Show-TimeReportScreen {\r\n    param([object]$App)\r\n\r\n    if (-not $App) {\r\n        throw \"PmcApplication required\"\r\n    }\r\n\r\n    $screen = New-Object TimeReportScreen\r\n    $App.PushScreen($screen)\r\n}"}, {"path": "module/Pmc.Strict/consoleui/screens/WeeklyTimeReportScreen.ps1", "content": "using namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# WeeklyTimeReportScreen - Weekly time tracking report\r\n# Shows time entries grouped by project with daily breakdown (Mon-Fri)\r\n# Matches the old renderer's weekly report functionality\r\n\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n. \"$PSScriptRoot/../PmcScreen.ps1\"\r\n\r\n<#\r\n.SYNOPSIS\r\nWeekly time tracking report screen\r\n\r\n.DESCRIPTION\r\nShows time summary grouped by project with daily breakdown.\r\nDisplays:\r\n- Hours per day (Mon-Fri) for each project\r\n- Total hours per project\r\n- Grand total\r\n- Week navigation (=/-keys)\r\nBased on the old renderer's DrawWeeklyReport implementation.\r\n##CLOSEBRACKET##\r\nclass WeeklyTimeReportScreen : PmcScreen {\r\n    # Data\r\n    [hashtable]$ProjectSummaries = @{}\r\n    [double]$GrandTotal = 0\r\n    [int]$WeekOffset = 0\r\n    [DateTime]$WeekStart\r\n    [DateTime]$WeekEnd\r\n    [string]$WeekHeader = \"\"\r\n    [string]$WeekIndicator = \"\"\r\n    [TaskStore]$Store = $null\r\n\r\n    # TS-M4/TS-M5 FIX: Make week days configurable\r\n    # Set to 7 for full week (Mon-Sun), or 5 for business week (Mon-Fri)\r\n    [int]$WeekDays = 7\r\n    [bool]$IncludeWeekends = $true\r\n\r\n    # Static: Register menu items\r\n    static [void] RegisterMenuItems([object]$registry) {\r\n        $registry.AddMenuItem('Time', 'Weekly Report', 'W', {\r\n                . \"$PSScriptRoot/WeeklyTimeReportScreen.ps1\"\r\n                $global:PmcApp.PushScreen((New-Object -TypeName WeeklyTimeReportScreen))\r\n            }, 10)\r\n    }\r\n\r\n    # Constructor\r\n    WeeklyTimeReportScreen() : base(\"WeeklyTimeReport\", \"Weekly Time Report\") {\r\n        # Initialize TaskStore\r\n        $this.Store = [TaskStore]::GetInstance()\r\n\r\n        # Configure header\r\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Time Entries\", \"Weekly Report\"))\r\n\r\n        # Configure footer with shortcuts\r\n        $this.Footer.ClearShortcuts()\r\n        $this.Footer.AddShortcut(\"=\", \"Next Week\")\r\n        $this.Footer.AddShortcut(\"-\", \"Prev Week\")\r\n        $this.Footer.AddShortcut(\"R\", \"Refresh\")\r\n        $this.Footer.AddShortcut(\"Esc\", \"Back\")\r\n        $this.Footer.AddShortcut(\"Ctrl+Q\", \"Quit\")\r\n\r\n        # NOTE: _SetupMenus() removed - MenuRegistry handles menu population via static RegisterMenuItems()\r\n        # Old pattern was adding duplicate/misplaced menu items\r\n    }\r\n\r\n    # Constructor with container (DI-enabled)\r\n    WeeklyTimeReportScreen([object]$container) : base(\"WeeklyTimeReport\", \"Weekly Time Report\", $container) {\r\n        # Initialize TaskStore\r\n        $this.Store = [TaskStore]::GetInstance()\r\n\r\n        # Configure header\r\n        $this.Header.SetBreadcrumb(@(\"Home\", \"Time Entries\", \"Weekly Report\"))\r\n\r\n        # Configure footer with shortcuts\r\n        $this.Footer.ClearShortcuts()\r\n        $this.Footer.AddShortcut(\"=\", \"Next Week\")\r\n        $this.Footer.AddShortcut(\"-\", \"Prev Week\")\r\n        $this.Footer.AddShortcut(\"R\", \"Refresh\")\r\n        $this.Footer.AddShortcut(\"Esc\", \"Back\")\r\n        $this.Footer.AddShortcut(\"Ctrl+Q\", \"Quit\")\r\n\r\n        # NOTE: _SetupMenus() removed - MenuRegistry handles menu population via static RegisterMenuItems()\r\n        # Old pattern was adding duplicate/misplaced menu items\r\n    }\r\n\r\n    # OnEnter - Load data when screen becomes active (consistent with other screens)\r\n    [void] OnEnter() {\r\n        # Call parent to ensure proper lifecycle (sets IsActive, calls LoadData, executes OnEnterHandler)\r\n        ([PmcScreen]$this).OnEnter()\r\n    }\r\n\r\n    [void] LoadData() {\r\n        $this.ShowStatus(\"Loading weekly time report...\")\r\n\r\n        try {\r\n            # Calculate week start (Monday) and end (Friday or Sunday based on config)\r\n            $today = Get-Date\r\n            $daysFromMonday = ($today.DayOfWeek.value__ + 6) % 7\r\n            $thisMonday = $today.AddDays(-$daysFromMonday).Date\r\n            $this.WeekStart = $thisMonday.AddDays($this.WeekOffset * 7)\r\n            # TS-M4/TS-M5 FIX: Week end depends on configured week length\r\n            $this.WeekEnd = $this.WeekStart.AddDays($this.WeekDays - 1)\r\n\r\n            # Format week header\r\n            $this.WeekHeader = \"Week of {0} - {1}\" -f $this.WeekStart.ToString('MMM dd'), $this.WeekEnd.ToString('MMM dd, yyyy')\r\n\r\n            # Add indicator for current/past/future week\r\n            if ($this.WeekOffset -eq 0) {\r\n                $this.WeekIndicator = ' (This Week)'\r\n            }\r\n            elseif ($this.WeekOffset -lt 0) {\r\n                $weeks = [Math]::Abs($this.WeekOffset)\r\n                $plural = $(if ($weeks -gt 1) { 's' } else { '' })\r\n                $this.WeekIndicator = \" ($weeks week$plural ago)\"\r\n            }\r\n            else {\r\n                $plural = $(if ($this.WeekOffset -gt 1) { 's' } else { '' })\r\n                $this.WeekIndicator = \" ($($this.WeekOffset) week$plural from now)\"\r\n            }\r\n\r\n            # Use TaskStore singleton instead of loading from disk\r\n            $logs = $this.Store.GetAllTimeLogs()\r\n\r\n            # TS-M4/TS-M5 FIX: Filter logs for the week (configurable: Mon-Fri or Mon-Sun)\r\n            $weekLogs = @()\r\n            for ($d = 0; $d -lt $this.WeekDays; $d++) {\r\n                $dayDate = $this.WeekStart.AddDays($d).ToString('yyyy-MM-dd')\r\n                $dayLogs = $logs | Where-Object {\r\n                    $dateStr = $(if ($_.date -is [DateTime]) {\r\n                            $_.date.ToString('yyyy-MM-dd')\r\n                        }\r\n                        else {\r\n                            $_.date\r\n                        })\r\n                    $dateStr -eq $dayDate\r\n                }\r\n                $weekLogs += $dayLogs\r\n            }\r\n\r\n            # Group by project/id1\r\n            $this.ProjectSummaries = @{}\r\n            $this.GrandTotal = 0\r\n\r\n            foreach ($log in $weekLogs) {\r\n                # Determine grouping key\r\n                $key = ''\r\n                if ($log.ContainsKey('id1') -and $log.id1) {\r\n                    $key = \"#$($log.id1)\"\r\n                }\r\n                else {\r\n                    $name = $(if ($log.ContainsKey('project')) { $log.project } else { '' })\r\n                    if (-not $name) { $name = 'Unknown' }\r\n                    $key = $name\r\n                }\r\n\r\n                # Initialize project entry if needed\r\n                if (-not $this.ProjectSummaries.ContainsKey($key)) {\r\n                    $name = ''\r\n                    $id1 = ''\r\n                    if ($log.ContainsKey('id1') -and $log.id1) {\r\n                        $id1 = $log.id1\r\n                        $name = $(if ($log.ContainsKey('project')) { $log.project } else { '' })\r\n                        if (-not $name) { $name = '' }\r\n                    }\r\n                    else {\r\n                        $name = $(if ($log.ContainsKey('project')) { $log.project } else { '' })\r\n                        if (-not $name) { $name = 'Unknown' }\r\n                    }\r\n\r\n                    # TS-M4/TS-M5 FIX: Include Sat/Sun columns\r\n                    $this.ProjectSummaries[$key] = @{\r\n                        Name  = $name\r\n                        ID1   = $id1\r\n                        Mon   = 0.0\r\n                        Tue   = 0.0\r\n                        Wed   = 0.0\r\n                        Thu   = 0.0\r\n                        Fri   = 0.0\r\n                        Sat   = 0.0\r\n                        Sun   = 0.0\r\n                        Total = 0.0\r\n                    }\r\n                }\r\n\r\n                # Add hours to appropriate day\r\n                # TS-H3 FIX: Add error handling for unsafe DateTime cast\r\n                if (-not $log.ContainsKey('date')) {\r\n                    # Write-PmcTuiLog \"WeeklyTimeReportScreen: Log entry missing date field\" \"WARNING\"\r\n                    continue\r\n                }\r\n                $logDate = $null\r\n                try {\r\n                    $logDate = $(if ($log.date -is [DateTime]) {\r\n                            $log.date\r\n                        }\r\n                        else {\r\n                            [datetime]::Parse($log.date)\r\n                        })\r\n                }\r\n                catch {\r\n                    # Write-PmcTuiLog \"WeeklyTimeReportScreen: Failed to parse date '$($log.date)': $_\" \"WARNING\"\r\n                    continue  # Skip this log entry\r\n                }\r\n\r\n                if (-not $log.ContainsKey('minutes')) {\r\n                    # Write-PmcTuiLog \"WeeklyTimeReportScreen: Log entry missing minutes field\" \"WARNING\"\r\n                    continue\r\n                }\r\n                $dayIndex = ($logDate.DayOfWeek.value__ + 6) % 7  # 0=Mon, 1=Tue, ..., 5=Sat, 6=Sun\r\n                $hours = [Math]::Round($log.minutes / 60.0, 1)\r\n\r\n                # TS-M4/TS-M5 FIX: Handle all 7 days including Saturday and Sunday\r\n                switch ($dayIndex) {\r\n                    0 { $this.ProjectSummaries[$key].Mon += $hours }\r\n                    1 { $this.ProjectSummaries[$key].Tue += $hours }\r\n                    2 { $this.ProjectSummaries[$key].Wed += $hours }\r\n                    3 { $this.ProjectSummaries[$key].Thu += $hours }\r\n                    4 { $this.ProjectSummaries[$key].Fri += $hours }\r\n                    5 { $this.ProjectSummaries[$key].Sat += $hours }\r\n                    6 { $this.ProjectSummaries[$key].Sun += $hours }\r\n                    default {\r\n                        # Write-PmcTuiLog \"WeeklyTimeReportScreen: Unexpected day index $dayIndex\" \"WARNING\"\r\n                    }\r\n                }\r\n                $this.ProjectSummaries[$key].Total += $hours\r\n                $this.GrandTotal += $hours\r\n            }\r\n\r\n            # Update status\r\n            if ($weekLogs.Count -eq 0) {\r\n                $this.ShowStatus(\"No time entries for this week\")\r\n            }\r\n            else {\r\n                $this.ShowStatus(\"$($this.ProjectSummaries.Count) projects, $($this.GrandTotal.ToString('0.0')) hours total\")\r\n            }\r\n\r\n        }\r\n        catch {\r\n            $this.ShowError(\"Failed to load weekly time report: $_\")\r\n            $this.ProjectSummaries = @{}\r\n            $this.GrandTotal = 0\r\n        }\r\n    }\r\n\r\n    [void] RenderContentToEngine([object]$engine) {\r\n        if (-not $this.LayoutManager) { return }\r\n\r\n        if ($this.ProjectSummaries.Count -eq 0) {\r\n            $this._RenderEmptyStateToEngine($engine)\r\n        }\r\n        else {\r\n            $this._RenderReportToEngine($engine)\r\n        }\r\n    }\r\n    \r\n    [string] RenderContent() { return \"\" }\r\n\r\n    hidden [void] _RenderEmptyStateToEngine([object]$engine) {\r\n        $contentRect = $this.LayoutManager.GetRegion('Content', $this.TermWidth, $this.TermHeight)\r\n\r\n        # Colors\r\n        $textColor = $this.GetThemedInt('Foreground.Field')\r\n        $highlightColor = $this.GetThemedInt('Foreground.FieldFocused')\r\n        $bg = $this.GetThemedInt('Background.Primary')\r\n\r\n        # Week header\r\n        $y = $contentRect.Y + 2\r\n        \r\n        $headerText = \"$($this.WeekHeader)$($this.WeekIndicator)\"\r\n        $engine.WriteAt($contentRect.X + 4, $y, $headerText, $highlightColor, $bg)\r\n        $y += 2\r\n\r\n        # No entries message\r\n        $message = \"No time entries for this week\"\r\n        $engine.WriteAt($contentRect.X + 4, $y, $message, $textColor, $bg)\r\n    }\r\n\r\n    hidden [void] _RenderReportToEngine([object]$engine) {\r\n        $contentRect = $this.LayoutManager.GetRegion('Content', $this.TermWidth, $this.TermHeight)\r\n\r\n        # Colors\r\n        $textColor = $this.GetThemedInt('Foreground.Field')\r\n        $highlightColor = $this.GetThemedInt('Foreground.FieldFocused')\r\n        $mutedColor = $this.GetThemedInt('Foreground.Muted')\r\n        $headerColor = $this.GetThemedInt('Foreground.Muted')\r\n        $successColor = $this.GetThemedInt('Foreground.Success')\r\n        $warningColor = $this.GetThemedInt('Foreground.Warning')\r\n        $bg = $this.GetThemedInt('Background.Primary')\r\n        \r\n        $y = $contentRect.Y + 1\r\n\r\n        # Week header\r\n        $headerText = \"$($this.WeekHeader)$($this.WeekIndicator)\"\r\n        $engine.WriteAt($contentRect.X + 4, $y, $headerText, $highlightColor, $bg)\r\n        $y += 2\r\n\r\n        # Column headers\r\n        $headerY = $y\r\n        $headers = \"\"\r\n        if ($this.IncludeWeekends) {\r\n            $headers = \"Name                 ID1   Mon    Tue    Wed    Thu    Fri    Sat    Sun    Total\"\r\n        }\r\n        else {\r\n            $headers = \"Name                 ID1   Mon    Tue    Wed    Thu    Fri    Total\"\r\n        }\r\n        $engine.WriteAt($contentRect.X + 4, $headerY, $headers, $headerColor, $bg)\r\n        $y++\r\n\r\n        # Separator line\r\n        $sepLen = if ($this.IncludeWeekends) { 89 } else { 75 }\r\n        $engine.WriteAt($contentRect.X + 4, $y, \"-\" * $sepLen, $mutedColor, $bg)\r\n        $y++\r\n\r\n        # Project rows - sorted by key\r\n        $sortedProjects = $this.ProjectSummaries.GetEnumerator() | Sort-Object Key\r\n\r\n        foreach ($entry in $sortedProjects) {\r\n            $d = $entry.Value\r\n            \r\n            $x = $contentRect.X + 4\r\n\r\n            # Name (20 chars, left-aligned)\r\n            $name = $d.Name\r\n            if ($name.Length -gt 20) {\r\n                $name = $name.Substring(0, 17) + \"...\"\r\n            }\r\n            $engine.WriteAt($x, $y, $name.PadRight(20), $textColor, $bg)\r\n            $x += 21 # 20 + 1 space\r\n\r\n            # ID1 (5 chars, left-aligned)\r\n            $id1Display = \"$($d.ID1)\"\r\n            if ($id1Display.Length -gt 5) {\r\n                $id1Display = $id1Display.Substring(0, 5)\r\n            }\r\n            $engine.WriteAt($x, $y, $id1Display.PadRight(5), $textColor, $bg)\r\n            $x += 6 # 5 + 1 space\r\n\r\n            # Day columns (6 chars each, right-aligned with 1 decimal)\r\n            $days = @($d.Mon, $d.Tue, $d.Wed, $d.Thu, $d.Fri)\r\n            if ($this.IncludeWeekends) { \r\n                $days += $d.Sat\r\n                $days += $d.Sun \r\n            }\r\n            \r\n            foreach ($dayVal in $days) {\r\n                $engine.WriteAt($x, $y, $dayVal.ToString(\"0.0\").PadLeft(6), $successColor, $bg)\r\n                $x += 7 # 6 + 1 space\r\n            }\r\n\r\n            # Total (8 chars, right-aligned with 1 decimal)\r\n            $engine.WriteAt($x, $y, $d.Total.ToString(\"0.0\").PadLeft(8), $warningColor, $bg)\r\n            \r\n            $y++\r\n        }\r\n\r\n        # Footer separator\r\n        $y++\r\n        $engine.WriteAt($contentRect.X + 4, $y, \"-\" * $sepLen, $mutedColor, $bg)\r\n        $y++\r\n\r\n        # Total row\r\n        $x = $contentRect.X + 4\r\n        $padding = if ($this.IncludeWeekends) { 72 } else { 58 }\r\n        $x += $padding\r\n        \r\n        $engine.WriteAt($x, $y, \"Total: \", $highlightColor, $bg)\r\n        $x += 7\r\n        \r\n        $engine.WriteAt($x, $y, $this.GrandTotal.ToString(\"0.0\").PadLeft(8), $highlightColor, $bg)\r\n    }\r\n\r\n    [bool] HandleKeyPress([ConsoleKeyInfo]$keyInfo) {\r\n        # CRITICAL: Call parent FIRST for MenuBar, F10, Alt+keys, content widgets\r\n        $handled = ([PmcScreen]$this).HandleKeyPress($keyInfo)\r\n        if ($handled) { return $true }\r\n\r\n        # Week navigation with arrow keys\r\n        if ($keyInfo.Key -eq 'LeftArrow') {\r\n            $this.WeekOffset--\r\n            $this.NeedsClear = $true  # Force full screen clear to prevent duplication\r\n            $this.LoadData()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'RightArrow') {\r\n            $this.WeekOffset++\r\n            $this.NeedsClear = $true  # Force full screen clear to prevent duplication\r\n            $this.LoadData()\r\n            return $true\r\n        }\r\n\r\n        # Week navigation with = and - keys\r\n        if ($keyInfo.KeyChar -eq '=') {\r\n            $this.WeekOffset++\r\n            $this.NeedsClear = $true  # Force full screen clear to prevent duplication\r\n            $this.LoadData()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.KeyChar -eq '-') {\r\n            $this.WeekOffset--\r\n            $this.NeedsClear = $true  # Force full screen clear to prevent duplication\r\n            $this.LoadData()\r\n            return $true\r\n        }\r\n\r\n        # Refresh\r\n        if ($keyInfo.KeyChar -eq 'r' -or $keyInfo.KeyChar -eq 'R') {\r\n            $this.LoadData()\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\n# Entry point function for compatibility\r\nfunction Show-WeeklyTimeReportScreen {\r\n    param([object]$App)\r\n\r\n    if (-not $App) {\r\n        throw \"PmcApplication required\"\r\n    }\r\n\r\n    $screen = New-Object WeeklyTimeReportScreen\r\n    $App.PushScreen($screen)\r\n}"}, {"path": "module/Pmc.Strict/consoleui/services/ChecklistService.ps1", "content": "# ChecklistService.ps1 - Service for managing checklists and templates\r\n#\r\n# Provides CRUD operations for checklist templates and instances\r\n# Templates are reusable checklist definitions\r\n# Instances are attached to projects/tasks with completion tracking\r\n#\r\n# Usage:\r\n#   $service = [ChecklistService]::GetInstance()\r\n#   $template = $service.CreateTemplate(\"Code Review\", @(\"Check tests\", \"Review security\"))\r\n#   $instance = $service.CreateInstanceFromTemplate($templateId, \"project\", $projectId)\r\n\r\nusing namespace System\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass ChecklistService {\r\n    # === Singleton Instance ===\r\n    static hidden [ChecklistService]$_instance = $null\r\n    static hidden [object]$_instanceLock = [object]::new()\r\n\r\n    # === Configuration ===\r\n    hidden [string]$_checklistsDir\r\n    hidden [string]$_templatesFile\r\n    hidden [string]$_instancesFile\r\n\r\n    # === In-memory cache ===\r\n    hidden [hashtable]$_templatesCache = @{}\r\n    hidden [hashtable]$_instancesCache = @{}\r\n    hidden [datetime]$_cacheLoadTime = [datetime]::MinValue\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnTemplateAdded = {}\r\n    [scriptblock]$OnTemplateUpdated = {}\r\n    [scriptblock]$OnTemplateDeleted = {}\r\n    [scriptblock]$OnInstanceAdded = {}\r\n    [scriptblock]$OnInstanceUpdated = {}\r\n    [scriptblock]$OnInstanceDeleted = {}\r\n    [scriptblock]$OnChecklistsChanged = {}\r\n\r\n    # === Singleton Access ===\r\n    static [ChecklistService] GetInstance() {\r\n        if ([ChecklistService]::_instance -eq $null) {\r\n            [System.Threading.Monitor]::Enter([ChecklistService]::_instanceLock)\r\n            try {\r\n                if ([ChecklistService]::_instance -eq $null) {\r\n                    [ChecklistService]::_instance = [ChecklistService]::new()\r\n                }\r\n            } finally {\r\n                [System.Threading.Monitor]::Exit([ChecklistService]::_instanceLock)\r\n            }\r\n        }\r\n        return [ChecklistService]::_instance\r\n    }\r\n\r\n    # === Constructor (Private - use GetInstance) ===\r\n    ChecklistService() {\r\n        # Determine checklists directory relative to PMC root\r\n        $pmcRoot = Split-Path -Parent (Split-Path -Parent (Split-Path -Parent $PSScriptRoot))\r\n        $this._checklistsDir = Join-Path $pmcRoot \"checklists\"\r\n        $this._templatesFile = Join-Path $this._checklistsDir \"templates.json\"\r\n        $this._instancesFile = Join-Path $this._checklistsDir \"instances.json\"\r\n\r\n        # Ensure checklists directory exists\r\n        if (-not (Test-Path $this._checklistsDir)) {\r\n            New-Item -ItemType Directory -Path $this._checklistsDir -Force | Out-Null\r\n        }\r\n\r\n        # Load metadata\r\n        $this.LoadTemplates()\r\n        $this.LoadInstances()\r\n    }\r\n\r\n    # === Template Management ===\r\n    hidden [void] LoadTemplates() {\r\n        if (Test-Path $this._templatesFile) {\r\n            try {\r\n                $json = Get-Content $this._templatesFile -Raw | ConvertFrom-Json -Depth 10\r\n                foreach ($template in $json.templates) {\r\n                    $items = @()\r\n                    foreach ($item in $template.items) {\r\n                        $items += @{\r\n                            text = $item.text\r\n                            order = $item.order\r\n                        }\r\n                    }\r\n\r\n                    $this._templatesCache[$template.id] = @{\r\n                        id = $template.id\r\n                        name = $template.name\r\n                        description = $template.description\r\n                        category = $template.category\r\n                        items = $items\r\n                        created = [datetime]::Parse($template.created)\r\n                        modified = [datetime]::Parse($template.modified)\r\n                    }\r\n                }\r\n                $this._cacheLoadTime = [datetime]::Now\r\n            } catch {\r\n                # Write-PmcTuiLog \"Failed to load checklist templates: $_\" \"ERROR\"\r\n                $this._templatesCache = @{}\r\n            }\r\n        }\r\n    }\r\n\r\n    hidden [void] SaveTemplates() {\r\n        try {\r\n            $templates = $this._templatesCache.Values | ForEach-Object {\r\n                @{\r\n                    id = $_.id\r\n                    name = $_.name\r\n                    description = $_.description\r\n                    category = $_.category\r\n                    items = $_.items\r\n                    created = $_.created.ToString(\"o\")\r\n                    modified = $_.modified.ToString(\"o\")\r\n                }\r\n            }\r\n\r\n            $metadata = @{\r\n                schema_version = 1\r\n                templates = $templates\r\n            }\r\n\r\n            # Atomic save\r\n            $tempFile = \"$($this._templatesFile).tmp\"\r\n            $metadata | ConvertTo-Json -Depth 10 | Set-Content -Path $tempFile -Encoding utf8\r\n\r\n            if (Test-Path $this._templatesFile) {\r\n                Copy-Item $this._templatesFile \"$($this._templatesFile).bak\" -Force\r\n            }\r\n\r\n            Move-Item -Path $tempFile -Destination $this._templatesFile -Force\r\n\r\n        } catch {\r\n            # Write-PmcTuiLog \"Failed to save checklist templates: $_\" \"ERROR\"\r\n            throw\r\n        }\r\n    }\r\n\r\n    # === Instance Management ===\r\n    hidden [void] LoadInstances() {\r\n        if (Test-Path $this._instancesFile) {\r\n            try {\r\n                $json = Get-Content $this._instancesFile -Raw | ConvertFrom-Json -Depth 10\r\n                foreach ($instance in $json.instances) {\r\n                    $items = @()\r\n                    foreach ($item in $instance.items) {\r\n                        $items += @{\r\n                            text = $item.text\r\n                            completed = $item.completed\r\n                            completed_date = $(if ($item.completed_date) { [datetime]::Parse($item.completed_date) } else { $null })\r\n                            order = $item.order\r\n                        }\r\n                    }\r\n\r\n                    $this._instancesCache[$instance.id] = @{\r\n                        id = $instance.id\r\n                        title = $instance.title\r\n                        template_id = $instance.template_id\r\n                        owner_type = $instance.owner_type\r\n                        owner_id = $instance.owner_id\r\n                        items = $items\r\n                        completed_count = $instance.completed_count\r\n                        total_count = $instance.total_count\r\n                        percent_complete = $instance.percent_complete\r\n                        created = [datetime]::Parse($instance.created)\r\n                        modified = [datetime]::Parse($instance.modified)\r\n                    }\r\n                }\r\n            } catch {\r\n                # Write-PmcTuiLog \"Failed to load checklist instances: $_\" \"ERROR\"\r\n                $this._instancesCache = @{}\r\n            }\r\n        }\r\n    }\r\n\r\n    hidden [void] SaveInstances() {\r\n        try {\r\n            $instances = $this._instancesCache.Values | ForEach-Object {\r\n                $items = @()\r\n                foreach ($item in $_.items) {\r\n                    $items += @{\r\n                        text = $item.text\r\n                        completed = $item.completed\r\n                        completed_date = $(if ($item.completed_date) { $item.completed_date.ToString(\"o\") } else { $null })\r\n                        order = $item.order\r\n                    }\r\n                }\r\n\r\n                @{\r\n                    id = $_.id\r\n                    title = $_.title\r\n                    template_id = $_.template_id\r\n                    owner_type = $_.owner_type\r\n                    owner_id = $_.owner_id\r\n                    items = $items\r\n                    completed_count = $_.completed_count\r\n                    total_count = $_.total_count\r\n                    percent_complete = $_.percent_complete\r\n                    created = $_.created.ToString(\"o\")\r\n                    modified = $_.modified.ToString(\"o\")\r\n                }\r\n            }\r\n\r\n            $metadata = @{\r\n                schema_version = 1\r\n                instances = $instances\r\n            }\r\n\r\n            # Atomic save\r\n            $tempFile = \"$($this._instancesFile).tmp\"\r\n            $metadata | ConvertTo-Json -Depth 10 | Set-Content -Path $tempFile -Encoding utf8\r\n\r\n            if (Test-Path $this._instancesFile) {\r\n                Copy-Item $this._instancesFile \"$($this._instancesFile).bak\" -Force\r\n            }\r\n\r\n            Move-Item -Path $tempFile -Destination $this._instancesFile -Force\r\n\r\n        } catch {\r\n            # Write-PmcTuiLog \"Failed to save checklist instances: $_\" \"ERROR\"\r\n            throw\r\n        }\r\n    }\r\n\r\n    # === Template CRUD Operations ===\r\n\r\n    [array] GetAllTemplates() {\r\n        return @($this._templatesCache.Values | Sort-Object -Property name)\r\n    }\r\n\r\n    [object] GetTemplate([string]$templateId) {\r\n        if ($this._templatesCache.ContainsKey($templateId)) {\r\n            return $this._templatesCache[$templateId]\r\n        }\r\n        return $null\r\n    }\r\n\r\n    [object] CreateTemplate([string]$name, [string]$description, [string]$category, [array]$itemTexts) {\r\n        $templateId = [guid]::NewGuid().ToString()\r\n\r\n        $items = @()\r\n        $order = 1\r\n        foreach ($text in $itemTexts) {\r\n            $items += @{\r\n                text = $text\r\n                order = $order++\r\n            }\r\n        }\r\n\r\n        $template = @{\r\n            id = $templateId\r\n            name = $name\r\n            description = $description\r\n            category = $category\r\n            items = $items\r\n            created = [datetime]::Now\r\n            modified = [datetime]::Now\r\n        }\r\n\r\n        $this._templatesCache[$templateId] = $template\r\n        $this.SaveTemplates()\r\n\r\n        if ($this.OnTemplateAdded) {\r\n            & $this.OnTemplateAdded $template\r\n        }\r\n        if ($this.OnChecklistsChanged) {\r\n            & $this.OnChecklistsChanged\r\n        }\r\n\r\n        return $template\r\n    }\r\n\r\n    [void] UpdateTemplate([string]$templateId, [hashtable]$changes) {\r\n        if (-not $this._templatesCache.ContainsKey($templateId)) {\r\n            throw \"Template not found: $templateId\"\r\n        }\r\n\r\n        $template = $this._templatesCache[$templateId]\r\n\r\n        if ($changes.ContainsKey('name')) { $template.name = $changes.name }\r\n        if ($changes.ContainsKey('description')) { $template.description = $changes.description }\r\n        if ($changes.ContainsKey('category')) { $template.category = $changes.category }\r\n        if ($changes.ContainsKey('items')) { $template.items = $changes.items }\r\n\r\n        $template.modified = [datetime]::Now\r\n\r\n        $this.SaveTemplates()\r\n\r\n        if ($this.OnTemplateUpdated) {\r\n            & $this.OnTemplateUpdated $template\r\n        }\r\n        if ($this.OnChecklistsChanged) {\r\n            & $this.OnChecklistsChanged\r\n        }\r\n    }\r\n\r\n    [void] DeleteTemplate([string]$templateId) {\r\n        if (-not $this._templatesCache.ContainsKey($templateId)) {\r\n            throw \"Template not found: $templateId\"\r\n        }\r\n\r\n        $template = $this._templatesCache[$templateId]\r\n        $this._templatesCache.Remove($templateId)\r\n        $this.SaveTemplates()\r\n\r\n        if ($this.OnTemplateDeleted) {\r\n            & $this.OnTemplateDeleted $template\r\n        }\r\n        if ($this.OnChecklistsChanged) {\r\n            & $this.OnChecklistsChanged\r\n        }\r\n    }\r\n\r\n    # === Instance CRUD Operations ===\r\n\r\n    [array] GetAllInstances() {\r\n        return @($this._instancesCache.Values | Sort-Object -Property modified -Descending)\r\n    }\r\n\r\n    [array] GetInstancesByOwner([string]$ownerType, [string]$ownerId) {\r\n        return @($this._instancesCache.Values | Where-Object {\r\n            $_.owner_type -eq $ownerType -and $_.owner_id -eq $ownerId\r\n        } | Sort-Object -Property created -Descending)\r\n    }\r\n\r\n    [object] GetInstance([string]$instanceId) {\r\n        if ($this._instancesCache.ContainsKey($instanceId)) {\r\n            return $this._instancesCache[$instanceId]\r\n        }\r\n        return $null\r\n    }\r\n\r\n    [object] CreateInstanceFromTemplate([string]$templateId, [string]$ownerType, [string]$ownerId) {\r\n        $template = $this.GetTemplate($templateId)\r\n        if (-not $template) {\r\n            throw \"Template not found: $templateId\"\r\n        }\r\n\r\n        $instanceId = [guid]::NewGuid().ToString()\r\n\r\n        # Copy items from template\r\n        $items = @()\r\n        foreach ($templateItem in $template.items) {\r\n            $items += @{\r\n                text = $templateItem.text\r\n                completed = $false\r\n                completed_date = $null\r\n                order = $templateItem.order\r\n            }\r\n        }\r\n\r\n        $instance = @{\r\n            id = $instanceId\r\n            title = $template.name\r\n            template_id = $templateId\r\n            owner_type = $ownerType\r\n            owner_id = $ownerId\r\n            items = $items\r\n            completed_count = 0\r\n            total_count = $items.Count\r\n            percent_complete = 0\r\n            created = [datetime]::Now\r\n            modified = [datetime]::Now\r\n        }\r\n\r\n        $this._instancesCache[$instanceId] = $instance\r\n        $this.SaveInstances()\r\n\r\n        if ($this.OnInstanceAdded) {\r\n            & $this.OnInstanceAdded $instance\r\n        }\r\n        if ($this.OnChecklistsChanged) {\r\n            & $this.OnChecklistsChanged\r\n        }\r\n\r\n        return $instance\r\n    }\r\n\r\n    [object] CreateBlankInstance([string]$title, [string]$ownerType, [string]$ownerId, [array]$itemTexts) {\r\n        $instanceId = [guid]::NewGuid().ToString()\r\n\r\n        $items = @()\r\n        $order = 1\r\n        foreach ($text in $itemTexts) {\r\n            $items += @{\r\n                text = $text\r\n                completed = $false\r\n                completed_date = $null\r\n                order = $order++\r\n            }\r\n        }\r\n\r\n        $instance = @{\r\n            id = $instanceId\r\n            title = $title\r\n            template_id = $null\r\n            owner_type = $ownerType\r\n            owner_id = $ownerId\r\n            items = $items\r\n            completed_count = 0\r\n            total_count = $items.Count\r\n            percent_complete = 0\r\n            created = [datetime]::Now\r\n            modified = [datetime]::Now\r\n        }\r\n\r\n        $this._instancesCache[$instanceId] = $instance\r\n        $this.SaveInstances()\r\n\r\n        if ($this.OnInstanceAdded) {\r\n            & $this.OnInstanceAdded $instance\r\n        }\r\n        if ($this.OnChecklistsChanged) {\r\n            & $this.OnChecklistsChanged\r\n        }\r\n\r\n        return $instance\r\n    }\r\n\r\n    [void] ToggleItem([string]$instanceId, [int]$itemIndex) {\r\n        if (-not $this._instancesCache.ContainsKey($instanceId)) {\r\n            throw \"Instance not found: $instanceId\"\r\n        }\r\n\r\n        $instance = $this._instancesCache[$instanceId]\r\n        if ($itemIndex -lt 0 -or $itemIndex -ge $instance.items.Count) {\r\n            throw \"Invalid item index: $itemIndex\"\r\n        }\r\n\r\n        $item = $instance.items[$itemIndex]\r\n        $item.completed = -not $item.completed\r\n        $item.completed_date = $(if ($item.completed) { [datetime]::Now } else { $null })\r\n\r\n        # Recalculate stats\r\n        $completed = @($instance.items | Where-Object { $_.completed }).Count\r\n        $instance.completed_count = $completed\r\n        $instance.percent_complete = $(if ($instance.total_count -gt 0) {\r\n            [Math]::Round(($completed / $instance.total_count) * 100, 0)\r\n        } else {\r\n            0\r\n        })\r\n        $instance.modified = [datetime]::Now\r\n\r\n        $this.SaveInstances()\r\n\r\n        if ($this.OnInstanceUpdated) {\r\n            & $this.OnInstanceUpdated $instance\r\n        }\r\n        if ($this.OnChecklistsChanged) {\r\n            & $this.OnChecklistsChanged\r\n        }\r\n    }\r\n\r\n    [void] UpdateInstance([string]$instanceId, [hashtable]$changes) {\r\n        if (-not $this._instancesCache.ContainsKey($instanceId)) {\r\n            throw \"Instance not found: $instanceId\"\r\n        }\r\n\r\n        $instance = $this._instancesCache[$instanceId]\r\n\r\n        if ($changes.ContainsKey('title')) { $instance.title = $changes.title }\r\n        if ($changes.ContainsKey('items')) {\r\n            $instance.items = $changes.items\r\n            # Recalculate stats\r\n            $instance.total_count = $instance.items.Count\r\n            $completed = @($instance.items | Where-Object { $_.completed }).Count\r\n            $instance.completed_count = $completed\r\n            $instance.percent_complete = $(if ($instance.total_count -gt 0) {\r\n                [Math]::Round(($completed / $instance.total_count) * 100, 0)\r\n            } else {\r\n                0\r\n            })\r\n        }\r\n\r\n        $instance.modified = [datetime]::Now\r\n\r\n        $this.SaveInstances()\r\n\r\n        if ($this.OnInstanceUpdated) {\r\n            & $this.OnInstanceUpdated $instance\r\n        }\r\n        if ($this.OnChecklistsChanged) {\r\n            & $this.OnChecklistsChanged\r\n        }\r\n    }\r\n\r\n    [void] DeleteInstance([string]$instanceId) {\r\n        if (-not $this._instancesCache.ContainsKey($instanceId)) {\r\n            throw \"Instance not found: $instanceId\"\r\n        }\r\n\r\n        $instance = $this._instancesCache[$instanceId]\r\n        $this._instancesCache.Remove($instanceId)\r\n        $this.SaveInstances()\r\n\r\n        if ($this.OnInstanceDeleted) {\r\n            & $this.OnInstanceDeleted $instance\r\n        }\r\n        if ($this.OnChecklistsChanged) {\r\n            & $this.OnChecklistsChanged\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/services/CommandService.ps1", "content": "# CommandService.ps1 - Service for managing command library\r\n#\r\n# Provides CRUD operations for saved commands with file-based storage\r\n# Commands are stored in commands/ subdirectory as JSON metadata\r\n#\r\n# Usage:\r\n#   $service = [CommandService]::GetInstance()\r\n#   $commands = $service.GetAllCommands()\r\n#   $service.CreateCommand(\"Deploy Script\", \"kubectl apply -f deploy.yaml\")\r\n#   $service.DeleteCommand($commandId)\r\n\r\nusing namespace System\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass CommandService {\r\n    # === Singleton Instance ===\r\n    static hidden [CommandService]$_instance = $null\r\n    static hidden [object]$_instanceLock = [object]::new()\r\n\r\n    # === Configuration ===\r\n    hidden [string]$_commandsDir\r\n    hidden [string]$_metadataFile\r\n\r\n    # === In-memory cache ===\r\n    hidden [hashtable]$_commandsCache = @{}\r\n    hidden [datetime]$_cacheLoadTime = [datetime]::MinValue\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnCommandAdded = {}\r\n    [scriptblock]$OnCommandUpdated = {}\r\n    [scriptblock]$OnCommandDeleted = {}\r\n    [scriptblock]$OnCommandsChanged = {}\r\n\r\n    # === Singleton Access ===\r\n    static [CommandService] GetInstance() {\r\n        if ([CommandService]::_instance -eq $null) {\r\n            [System.Threading.Monitor]::Enter([CommandService]::_instanceLock)\r\n            try {\r\n                if ([CommandService]::_instance -eq $null) {\r\n                    [CommandService]::_instance = [CommandService]::new()\r\n                }\r\n            } finally {\r\n                [System.Threading.Monitor]::Exit([CommandService]::_instanceLock)\r\n            }\r\n        }\r\n        return [CommandService]::_instance\r\n    }\r\n\r\n    # === Constructor (Private - use GetInstance) ===\r\n    CommandService() {\r\n        # Determine commands directory relative to PMC root\r\n        $pmcRoot = Split-Path -Parent (Split-Path -Parent (Split-Path -Parent $PSScriptRoot))\r\n        $this._commandsDir = Join-Path $pmcRoot \"commands\"\r\n        $this._metadataFile = Join-Path $this._commandsDir \"commands_metadata.json\"\r\n\r\n        # Ensure commands directory exists\r\n        if (-not (Test-Path $this._commandsDir)) {\r\n            New-Item -ItemType Directory -Path $this._commandsDir -Force | Out-Null\r\n        }\r\n\r\n        # Load metadata\r\n        $this.LoadMetadata()\r\n    }\r\n\r\n    # === Metadata Management ===\r\n    hidden [void] LoadMetadata() {\r\n        if (Test-Path $this._metadataFile) {\r\n            try {\r\n                $json = Get-Content $this._metadataFile -Raw | ConvertFrom-Json -Depth 10\r\n                foreach ($cmd in $json.commands) {\r\n                    $this._commandsCache[$cmd.id] = @{\r\n                        id = $cmd.id\r\n                        name = $cmd.name\r\n                        category = $cmd.category\r\n                        command_text = $cmd.command_text\r\n                        description = $cmd.description\r\n                        tags = $cmd.tags\r\n                        created = [datetime]::Parse($cmd.created)\r\n                        modified = [datetime]::Parse($cmd.modified)\r\n                        usage_count = $cmd.usage_count\r\n                        last_used = $(if ($cmd.last_used) { [datetime]::Parse($cmd.last_used) } else { $null })\r\n                    }\r\n                }\r\n                $this._cacheLoadTime = [datetime]::Now\r\n            } catch {\r\n                # Write-PmcTuiLog \"Failed to load commands metadata: $_\" \"ERROR\"\r\n                $this._commandsCache = @{}\r\n            }\r\n        }\r\n    }\r\n\r\n    hidden [void] SaveMetadata() {\r\n        try {\r\n            $commands = $this._commandsCache.Values | ForEach-Object {\r\n                @{\r\n                    id = $_.id\r\n                    name = $_.name\r\n                    category = $_.category\r\n                    command_text = $_.command_text\r\n                    description = $_.description\r\n                    tags = $_.tags\r\n                    created = $_.created.ToString(\"o\")\r\n                    modified = $_.modified.ToString(\"o\")\r\n                    usage_count = $_.usage_count\r\n                    last_used = $(if ($_.last_used) { $_.last_used.ToString(\"o\") } else { $null })\r\n                }\r\n            }\r\n\r\n            $metadata = @{\r\n                schema_version = 1\r\n                commands = $commands\r\n            }\r\n\r\n            # Atomic save: write to temp file, then rename\r\n            $tempFile = \"$($this._metadataFile).tmp\"\r\n            $metadata | ConvertTo-Json -Depth 10 | Set-Content -Path $tempFile -Encoding utf8\r\n\r\n            # Backup existing file\r\n            if (Test-Path $this._metadataFile) {\r\n                Copy-Item $this._metadataFile \"$($this._metadataFile).bak\" -Force\r\n            }\r\n\r\n            # Rename temp to actual\r\n            Move-Item -Path $tempFile -Destination $this._metadataFile -Force\r\n\r\n        } catch {\r\n            # Write-PmcTuiLog \"Failed to save commands metadata: $_\" \"ERROR\"\r\n            throw\r\n        }\r\n    }\r\n\r\n    # === CRUD Operations ===\r\n\r\n    [array] GetAllCommands() {\r\n        $commands = @($this._commandsCache.Values | Sort-Object -Property modified -Descending)\r\n        return $commands\r\n    }\r\n\r\n    [object] GetCommand([string]$commandId) {\r\n        if ($this._commandsCache.ContainsKey($commandId)) {\r\n            return $this._commandsCache[$commandId]\r\n        }\r\n        return $null\r\n    }\r\n\r\n    [object] CreateCommand([string]$name, [string]$commandText) {\r\n        return $this.CreateCommand($name, $commandText, \"General\", \"\", @())\r\n    }\r\n\r\n    [object] CreateCommand([string]$name, [string]$commandText, [string]$category, [string]$description, [array]$tags) {\r\n        # Generate unique ID\r\n        $commandId = [guid]::NewGuid().ToString()\r\n\r\n        # Create command object\r\n        $command = @{\r\n            id = $commandId\r\n            name = $name\r\n            category = $category\r\n            command_text = $commandText\r\n            description = $description\r\n            tags = $tags\r\n            created = [datetime]::Now\r\n            modified = [datetime]::Now\r\n            usage_count = 0\r\n            last_used = $null\r\n        }\r\n\r\n        # Add to cache\r\n        $this._commandsCache[$commandId] = $command\r\n\r\n        # Save metadata\r\n        $this.SaveMetadata()\r\n\r\n        # Fire event\r\n        if ($this.OnCommandAdded) {\r\n            & $this.OnCommandAdded $command\r\n        }\r\n        if ($this.OnCommandsChanged) {\r\n            & $this.OnCommandsChanged\r\n        }\r\n\r\n        return $command\r\n    }\r\n\r\n    [void] UpdateCommand([string]$commandId, [hashtable]$changes) {\r\n        if (-not $this._commandsCache.ContainsKey($commandId)) {\r\n            throw \"Command not found: $commandId\"\r\n        }\r\n\r\n        $command = $this._commandsCache[$commandId]\r\n\r\n        # Apply changes\r\n        if ($changes.ContainsKey('name')) { $command.name = $changes.name }\r\n        if ($changes.ContainsKey('category')) { $command.category = $changes.category }\r\n        if ($changes.ContainsKey('command_text')) { $command.command_text = $changes.command_text }\r\n        if ($changes.ContainsKey('description')) { $command.description = $changes.description }\r\n        if ($changes.ContainsKey('tags')) { $command.tags = $changes.tags }\r\n\r\n        $command.modified = [datetime]::Now\r\n\r\n        # Save metadata\r\n        $this.SaveMetadata()\r\n\r\n        # Fire event\r\n        if ($this.OnCommandUpdated) {\r\n            & $this.OnCommandUpdated $command\r\n        }\r\n        if ($this.OnCommandsChanged) {\r\n            & $this.OnCommandsChanged\r\n        }\r\n    }\r\n\r\n    [void] DeleteCommand([string]$commandId) {\r\n        if (-not $this._commandsCache.ContainsKey($commandId)) {\r\n            throw \"Command not found: $commandId\"\r\n        }\r\n\r\n        $command = $this._commandsCache[$commandId]\r\n\r\n        # Remove from cache\r\n        $this._commandsCache.Remove($commandId)\r\n\r\n        # Save metadata\r\n        $this.SaveMetadata()\r\n\r\n        # Fire event\r\n        if ($this.OnCommandDeleted) {\r\n            & $this.OnCommandDeleted $command\r\n        }\r\n        if ($this.OnCommandsChanged) {\r\n            & $this.OnCommandsChanged\r\n        }\r\n    }\r\n\r\n    [void] IncrementUsageCount([string]$commandId) {\r\n        if (-not $this._commandsCache.ContainsKey($commandId)) {\r\n            throw \"Command not found: $commandId\"\r\n        }\r\n\r\n        $command = $this._commandsCache[$commandId]\r\n        $command.usage_count++\r\n        $command.last_used = [datetime]::Now\r\n\r\n        # Save metadata\r\n        $this.SaveMetadata()\r\n\r\n        # Fire event\r\n        if ($this.OnCommandsChanged) {\r\n            & $this.OnCommandsChanged\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/services/ExcelComReader.ps1", "content": "# ExcelComReader.ps1 - COM automation for reading Excel files\r\n#\r\n# Provides COM-based Excel reading capabilities\r\n# Can attach to running Excel instance or open files programmatically\r\n#\r\n# Usage:\r\n#   $reader = [ExcelComReader]::new()\r\n#   $reader.AttachToRunningExcel()\r\n#   $value = $reader.ReadCell(\"W3\")\r\n#   $reader.Close()\r\n\r\nusing namespace System\r\nusing namespace System.Runtime.InteropServices\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass ExcelComReader {\r\n    # COM objects\r\n    hidden [object]$_excelApp = $null\r\n    hidden [object]$_workbook = $null\r\n    hidden [object]$_worksheet = $null\r\n    hidden [bool]$_isAttached = $false  # Did we create Excel or attach to existing?\r\n\r\n    # State\r\n    [bool]$IsOpen = $false\r\n    [string]$FilePath = \"\"\r\n    [int]$ActiveSheet = 1\r\n\r\n    # Constructor\r\n    ExcelComReader() {\r\n        # Nothing to initialize\r\n    }\r\n\r\n    # Validate Excel cell address format (e.g., \"A1\", \"W3\", \"AA100\", \"AAA1\")\r\n    # ES-H5 FIX: Make regex case-insensitive and add null check\r\n    # The [A-Z]+ pattern with + quantifier properly matches multi-letter columns\r\n    hidden [bool] IsValidCellAddress([string]$address) {\r\n        if ([string]::IsNullOrWhiteSpace($address)) {\r\n            return $false\r\n        }\r\n        # Case-insensitive match: accepts A1, AA1, AAA1, a1, aa1, etc.\r\n        return $address -match '(?i)^[A-Z]+\\d+$'\r\n    }\r\n\r\n    # Attach to running Excel instance\r\n    [void] AttachToRunningExcel() {\r\n        try {\r\n            $this._excelApp = [Marshal]::GetActiveObject(\"Excel.Application\")\r\n\r\n            # CRITICAL FIX ES-C2: Validate COM object is functional\r\n            if ($null -eq $this._excelApp) {\r\n                throw \"Excel COM object is null\"\r\n            }\r\n            # Test if Excel is responsive\r\n            $null = $this._excelApp.Name  # Will throw if Excel is not responsive\r\n\r\n            # LOW FIX ES-L1: Validate Excel is not in edit mode\r\n            try {\r\n                $isInEditMode = $this._excelApp.Interactive -eq $false\r\n                if ($isInEditMode) {\r\n                    # Write-PmcTuiLog \"Excel may be in edit mode or protected view - attempting to continue\" \"WARNING\"\r\n                }\r\n            } catch {\r\n                # If we can't check edit mode, log warning but continue\r\n                # Write-PmcTuiLog \"Cannot verify Excel edit mode status: $($_.Exception.Message)\" \"WARNING\"\r\n            }\r\n\r\n            $this._isAttached = $true\r\n\r\n            # KSV2-M3 FIX: Validate Worksheets collection exists before access\r\n            if ($this._excelApp.Workbooks.Count -gt 0) {\r\n                $this._workbook = $this._excelApp.ActiveWorkbook\r\n                if ($null -ne $this._workbook -and\r\n                    $null -ne $this._workbook.Worksheets -and\r\n                    $this._workbook.Worksheets.Count -gt 0) {\r\n                    $this._worksheet = $this._workbook.ActiveSheet\r\n                    $this.ActiveSheet = $this._worksheet.Index\r\n                }\r\n            }\r\n\r\n            $this.IsOpen = $true\r\n            # Write-PmcTuiLog \"ExcelComReader: Attached to running Excel instance\" \"INFO\"\r\n\r\n        } catch {\r\n            # Write-PmcTuiLog \"ExcelComReader: Failed to attach to Excel - $_\" \"ERROR\"\r\n            throw \"Excel is not running or not accessible. Please open Excel first and try again.\"\r\n        }\r\n    }\r\n\r\n    # Open Excel file programmatically\r\n    [void] OpenFile([string]$filePath) {\r\n        if (-not (Test-Path $filePath)) {\r\n            throw \"File not found: $filePath\"\r\n        }\r\n\r\n        try {\r\n            $this._excelApp = New-Object -ComObject Excel.Application\r\n\r\n            # CRITICAL FIX ES-C2: Validate COM object is functional\r\n            if ($null -eq $this._excelApp) {\r\n                throw \"Excel COM object is null\"\r\n            }\r\n            # Test if Excel is responsive\r\n            $null = $this._excelApp.Name  # Will throw if Excel is not responsive\r\n\r\n            $this._excelApp.Visible = $false\r\n            $this._excelApp.DisplayAlerts = $false\r\n            $this._isAttached = $false\r\n\r\n            # MEDIUM FIX #16: Add file lock detection and user-friendly error handling\r\n            try {\r\n                $this._workbook = $this._excelApp.Workbooks.Open($filePath)\r\n            } catch {\r\n                # Common COM errors for file locks or permissions\r\n                $errorMsg = $_.Exception.Message\r\n                $lockError = $errorMsg -match 'locked|in use|permission denied|cannot access|0x800A03EC'\r\n                if ($lockError) {\r\n                    $this.Close()\r\n                    throw \"Cannot open file - it may be open in another program, locked by the file system, or you may not have permission to access it. Please close the file in other programs and try again.\"\r\n                }\r\n                throw\r\n            }\r\n\r\n            # KSV2-M3 FIX: Validate Worksheets collection exists before access\r\n            if ($null -ne $this._workbook -and\r\n                $null -ne $this._workbook.Worksheets -and\r\n                $this._workbook.Worksheets.Count -gt 0) {\r\n                $this._worksheet = $this._workbook.Worksheets.Item(1)\r\n                $this.ActiveSheet = 1\r\n            }\r\n\r\n            $this.FilePath = $filePath\r\n            $this.IsOpen = $true\r\n            # Write-PmcTuiLog \"ExcelComReader: Opened file $filePath\" \"INFO\"\r\n\r\n        } catch {\r\n            # Write-PmcTuiLog \"ExcelComReader: Failed to open file - $_\" \"ERROR\"\r\n            $this.Close()\r\n            throw \"Could not open Excel file: $_\"\r\n        }\r\n    }\r\n\r\n    # Set active worksheet by index (1-based)\r\n    [void] SetActiveSheet([int]$sheetIndex) {\r\n        if (-not $this.IsOpen -or $null -eq $this._workbook) {\r\n            throw \"No workbook is open\"\r\n        }\r\n\r\n        # KSV2-M3 FIX: Validate Worksheets collection exists before access\r\n        if ($null -eq $this._workbook.Worksheets) {\r\n            throw \"Workbook has no Worksheets collection\"\r\n        }\r\n\r\n        if ($sheetIndex -lt 1 -or $sheetIndex -gt $this._workbook.Worksheets.Count) {\r\n            throw \"Sheet index out of range: $sheetIndex (workbook has $($this._workbook.Worksheets.Count) sheets)\"\r\n        }\r\n\r\n        $this._worksheet = $this._workbook.Worksheets.Item($sheetIndex)\r\n        $this.ActiveSheet = $sheetIndex\r\n    }\r\n\r\n    # Set active worksheet by name\r\n    [void] SetActiveSheetByName([string]$sheetName) {\r\n        if (-not $this.IsOpen -or $null -eq $this._workbook) {\r\n            throw \"No workbook is open\"\r\n        }\r\n\r\n        # KSV2-M3 FIX: Validate Worksheets collection exists before access\r\n        if ($null -eq $this._workbook.Worksheets) {\r\n            throw \"Workbook has no Worksheets collection\"\r\n        }\r\n\r\n        try {\r\n            $this._worksheet = $this._workbook.Worksheets.Item($sheetName)\r\n            $this.ActiveSheet = $this._worksheet.Index\r\n        } catch {\r\n            throw \"Sheet not found: $sheetName\"\r\n        }\r\n    }\r\n\r\n    # Read single cell value\r\n    [object] ReadCell([string]$cellAddress) {\r\n        if (-not $this.IsOpen -or $null -eq $this._worksheet) {\r\n            throw \"No worksheet is active\"\r\n        }\r\n\r\n        if (-not $this.IsValidCellAddress($cellAddress)) {\r\n            throw \"Invalid Excel cell address: $cellAddress (expected format like 'A1' or 'W3')\"\r\n        }\r\n\r\n        $cell = $null\r\n        try {\r\n            $cell = $this._worksheet.Range($cellAddress)\r\n            $value = $cell.Value2\r\n            return $value\r\n        } catch {\r\n            # Write-PmcTuiLog \"ExcelComReader: Error reading cell $cellAddress - $_\" \"ERROR\"\r\n            return $null\r\n        } finally {\r\n            if ($null -ne $cell) {\r\n                [Marshal]::ReleaseComObject($cell) | Out-Null\r\n            }\r\n\r\n            # CRITICAL FIX ES-C5: Aggressive COM cleanup to prevent memory leaks\r\n            [System.GC]::Collect()\r\n            [System.GC]::WaitForPendingFinalizers()\r\n            [System.GC]::Collect()\r\n        }\r\n    }\r\n\r\n    # Read range of cells (returns hashtable of address => value)\r\n    [hashtable] ReadRange([string]$startCell, [string]$endCell) {\r\n        if (-not $this.IsOpen -or $null -eq $this._worksheet) {\r\n            throw \"No worksheet is active\"\r\n        }\r\n\r\n        if (-not $this.IsValidCellAddress($startCell)) {\r\n            throw \"Invalid Excel cell address: $startCell (expected format like 'A1' or 'W3')\"\r\n        }\r\n        if (-not $this.IsValidCellAddress($endCell)) {\r\n            throw \"Invalid Excel cell address: $endCell (expected format like 'A1' or 'W3')\"\r\n        }\r\n\r\n        $cellData = @{}\r\n        $range = $null\r\n        $cells = $null  # CRITICAL FIX #2: Track Cells collection COM object\r\n        $cellsToRelease = [System.Collections.ArrayList]::new()\r\n\r\n        try {\r\n            $range = $this._worksheet.Range(\"$startCell`:$endCell\")\r\n\r\n            if ($null -ne $range) {\r\n                # CRITICAL FIX #2: Get Cells collection explicitly for proper COM cleanup\r\n                $cells = $range.Cells\r\n                if ($null -ne $cells) {\r\n                    foreach ($cell in $cells) {\r\n                        $address = $cell.Address($false, $false)  # Get address like \"W3\"\r\n                        $cellData[$address] = $cell.Value2\r\n                        [void]$cellsToRelease.Add($cell)\r\n                    }\r\n                }\r\n            }\r\n\r\n            return $cellData\r\n\r\n        } catch {\r\n            # Write-PmcTuiLog \"ExcelComReader: Error reading range $startCell`:$endCell - $_\" \"ERROR\"\r\n            return $cellData\r\n        } finally {\r\n            # Release all cell COM objects\r\n            foreach ($cell in $cellsToRelease) {\r\n                try {\r\n                    [Marshal]::ReleaseComObject($cell) | Out-Null\r\n                } catch {\r\n                    # Write-PmcTuiLog \"Failed to release COM object (cell): $($_.Exception.Message)\" \"WARNING\"\r\n                }\r\n            }\r\n            # CRITICAL FIX #2: Release Cells collection COM object\r\n            if ($null -ne $cells) {\r\n                try {\r\n                    [Marshal]::ReleaseComObject($cells) | Out-Null\r\n                } catch {\r\n                    # Write-PmcTuiLog \"Failed to release COM object (cells collection): $($_.Exception.Message)\" \"WARNING\"\r\n                }\r\n            }\r\n            # Release range COM object\r\n            if ($null -ne $range) {\r\n                try {\r\n                    [Marshal]::ReleaseComObject($range) | Out-Null\r\n                } catch {\r\n                    # Write-PmcTuiLog \"Failed to release COM object (range): $($_.Exception.Message)\" \"WARNING\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    # Read multiple specific cells (returns hashtable of address => value)\r\n    [hashtable] ReadCells([array]$cellAddresses) {\r\n        if (-not $this.IsOpen -or $null -eq $this._worksheet) {\r\n            throw \"No worksheet is active\"\r\n        }\r\n\r\n        $cellData = @{}\r\n\r\n        foreach ($address in $cellAddresses) {\r\n            try {\r\n                $value = $this.ReadCell($address)\r\n                $cellData[$address] = $value\r\n            } catch {\r\n                # Write-PmcTuiLog \"ExcelComReader: Error reading cell $address - $_\" \"WARN\"\r\n                $cellData[$address] = $null\r\n            }\r\n        }\r\n\r\n        return $cellData\r\n    }\r\n\r\n    # Get worksheet names\r\n    [array] GetSheetNames() {\r\n        if (-not $this.IsOpen -or $null -eq $this._workbook) {\r\n            return @()\r\n        }\r\n\r\n        # KSV2-M3 FIX: Validate Worksheets collection exists before access\r\n        if ($null -eq $this._workbook.Worksheets) {\r\n            # Write-PmcTuiLog \"Workbook has no Worksheets collection\" \"WARNING\"\r\n            return @()\r\n        }\r\n\r\n        $names = @()\r\n        $sheets = $null\r\n        try {\r\n            $sheets = $this._workbook.Worksheets\r\n            foreach ($sheet in $sheets) {\r\n                # LOW FIX ES-L4: Add null check in GetSheetNames loop\r\n                if ($null -ne $sheet -and $null -ne $sheet.Name) {\r\n                    $names += $sheet.Name\r\n                }\r\n                try {\r\n                    if ($null -ne $sheet) {\r\n                        [Marshal]::ReleaseComObject($sheet) | Out-Null\r\n                    }\r\n                } catch {\r\n                    # Write-PmcTuiLog \"Failed to release COM object (sheet): $($_.Exception.Message)\" \"WARNING\"\r\n                }\r\n            }\r\n        } finally {\r\n            if ($null -ne $sheets) {\r\n                try {\r\n                    [Marshal]::ReleaseComObject($sheets) | Out-Null\r\n                } catch {\r\n                    # Write-PmcTuiLog \"Failed to release COM object (sheets collection): $($_.Exception.Message)\" \"WARNING\"\r\n                }\r\n            }\r\n        }\r\n        return $names\r\n    }\r\n\r\n    # Close and cleanup\r\n    # NOTE: Caller MUST call Close() explicitly - PowerShell classes do not support finalizers\r\n    [void] Close() {\r\n        if ($this.IsOpen) {\r\n            # Isolate each cleanup operation to prevent cascading failures\r\n\r\n            # Release worksheet COM object\r\n            if ($null -ne $this._worksheet) {\r\n                try {\r\n                    [Marshal]::ReleaseComObject($this._worksheet) | Out-Null\r\n                } catch {\r\n                    # Write-PmcTuiLog \"ExcelComReader: Error releasing worksheet COM object - $_\" \"WARN\"\r\n                }\r\n                $this._worksheet = $null\r\n            }\r\n\r\n            # Close and release workbook\r\n            if ($null -ne $this._workbook) {\r\n                if (-not $this._isAttached) {\r\n                    try {\r\n                        $this._workbook.Close($false)  # Don't save changes\r\n                    } catch {\r\n                        # Write-PmcTuiLog \"ExcelComReader: Error closing workbook - $_\" \"WARN\"\r\n                    }\r\n                }\r\n                try {\r\n                    [Marshal]::ReleaseComObject($this._workbook) | Out-Null\r\n                } catch {\r\n                    # Write-PmcTuiLog \"ExcelComReader: Error releasing workbook COM object - $_\" \"WARN\"\r\n                }\r\n                $this._workbook = $null\r\n            }\r\n\r\n            # Quit and release Excel app\r\n            if ($null -ne $this._excelApp) {\r\n                if (-not $this._isAttached) {\r\n                    try {\r\n                        $this._excelApp.Quit()\r\n                    } catch {\r\n                        # Write-PmcTuiLog \"ExcelComReader: Error quitting Excel - $_\" \"WARN\"\r\n                    }\r\n                }\r\n                try {\r\n                    [Marshal]::ReleaseComObject($this._excelApp) | Out-Null\r\n                } catch {\r\n                    # Write-PmcTuiLog \"ExcelComReader: Error releasing Excel COM object - $_\" \"WARN\"\r\n                }\r\n                $this._excelApp = $null\r\n            }\r\n\r\n            $this.IsOpen = $false\r\n\r\n            # CRITICAL FIX ES-C5: Aggressive COM cleanup to ensure all resources are released\r\n            [System.GC]::Collect()\r\n            [System.GC]::WaitForPendingFinalizers()\r\n            [System.GC]::Collect()\r\n\r\n            # Write-PmcTuiLog \"ExcelComReader: Closed\" \"INFO\"\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/services/ExcelMappingService.ps1", "content": "# ExcelMappingService.ps1 - Service for managing Excel import profiles and mappings\r\n#\r\n# Provides CRUD operations for Excel mapping profiles\r\n# Each profile contains field mappings (Excel cell -> Project property)\r\n#\r\n# Usage:\r\n#   $service = [ExcelMappingService]::GetInstance()\r\n#   $profile = $service.CreateProfile(\"My Profile\", \"Description\")\r\n#   $service.AddMapping($profileId, @{ display_name=\"Name\"; excel_cell=\"A1\"; project_property=\"name\" })\r\n\r\nusing namespace System\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass ExcelMappingService {\r\n    # === Singleton Instance ===\r\n    static hidden [ExcelMappingService]$_instance = $null\r\n    static hidden [object]$_instanceLock = [object]::new()\r\n\r\n    # === Configuration ===\r\n    hidden [string]$_profilesFile\r\n    hidden [string]$_activeProfileId = $null\r\n\r\n    # === In-memory cache ===\r\n    hidden [hashtable]$_profilesCache = @{}\r\n    hidden [datetime]$_cacheLoadTime = [datetime]::MinValue\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnProfileAdded = {}\r\n    [scriptblock]$OnProfileUpdated = {}\r\n    [scriptblock]$OnProfileDeleted = {}\r\n    [scriptblock]$OnProfilesChanged = {}\r\n\r\n    # === Singleton Access ===\r\n    static [ExcelMappingService] GetInstance() {\r\n        if ([ExcelMappingService]::_instance -eq $null) {\r\n            [System.Threading.Monitor]::Enter([ExcelMappingService]::_instanceLock)\r\n            try {\r\n                if ([ExcelMappingService]::_instance -eq $null) {\r\n                    [ExcelMappingService]::_instance = [ExcelMappingService]::new()\r\n                }\r\n            } finally {\r\n                [System.Threading.Monitor]::Exit([ExcelMappingService]::_instanceLock)\r\n            }\r\n        }\r\n        return [ExcelMappingService]::_instance\r\n    }\r\n\r\n    # === Constructor (Private - use GetInstance) ===\r\n    ExcelMappingService() {\r\n        # Determine profiles file location\r\n        # FIXED: Point to the actual location found in user's home directory\r\n        $this._profilesFile = \"/home/teej/_tui/praxis-main/simpletaskpro/Data/excel-mappings.json\"\r\n\r\n        # Load profiles\r\n        $this.LoadProfiles()\r\n    }\r\n\r\n    # === Profile Management ===\r\n    hidden [void] LoadProfiles() {\r\n        # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: START - file=$($this._profilesFile)\" \"DEBUG\"\r\n        if (Test-Path $this._profilesFile) {\r\n            # CRITICAL FIX ES-C3: Robust JSON parsing with null validation\r\n            try {\r\n                $jsonContent = Get-Content $this._profilesFile -Raw -ErrorAction Stop\r\n                # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: Read $($jsonContent.Length) chars from file\" \"DEBUG\"\r\n                $json = $jsonContent | ConvertFrom-Json -ErrorAction Stop\r\n                # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: JSON parsed successfully\" \"DEBUG\"\r\n\r\n                if ($null -eq $json) {\r\n                    throw \"JSON deserialization returned null\"\r\n                }\r\n\r\n                # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: Checking for active_profile_id property\" \"DEBUG\"\r\n                if (-not $json.PSObject.Properties['active_profile_id']) {\r\n                    throw \"JSON missing 'active_profile_id' property\"\r\n                }\r\n                $this._profilesCache = @{}\r\n                $this._activeProfileId = $json.active_profile_id\r\n                # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: active_profile_id=$($this._activeProfileId)\" \"DEBUG\"\r\n\r\n                # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: Found $($json.profiles.Count) profiles\" \"DEBUG\"\r\n                foreach ($profile in $json.profiles) {\r\n                    # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: Processing profile id=$($profile.id) name=$($profile.name)\" \"DEBUG\"\r\n\r\n                    # Check for start_cell\r\n                    if (-not $profile.PSObject.Properties['start_cell']) {\r\n                        throw \"Profile '$($profile.id)' missing 'start_cell' property\"\r\n                    }\r\n\r\n                    $mappings = @()\r\n                    # Check if mappings property exists and is not null - JSON deserialization can omit empty arrays\r\n                    if ($profile.PSObject.Properties['mappings'] -and $null -ne $profile.mappings) {\r\n                        # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: Profile has $($profile.mappings.Count) mappings\" \"DEBUG\"\r\n                        foreach ($mapping in $profile.mappings) {\r\n                            # ES-M4 FIX: Type validation before casting JSON booleans\r\n                            $requiredValue = $false\r\n                            if ($mapping.PSObject.Properties['required']) {\r\n                                try {\r\n                                    $requiredValue = [bool]$mapping.required\r\n                                } catch {\r\n                                    # Write-PmcTuiLog \"Invalid 'required' value for mapping $($mapping.id), defaulting to false: $_\" \"WARN\"\r\n                                }\r\n                            }\r\n\r\n                            $includeInExportValue = $true\r\n                            if ($mapping.PSObject.Properties['include_in_export']) {\r\n                                try {\r\n                                    $includeInExportValue = [bool]$mapping.include_in_export\r\n                                } catch {\r\n                                    # Write-PmcTuiLog \"Invalid 'include_in_export' value for mapping $($mapping.id), defaulting to true: $_\" \"WARN\"\r\n                                }\r\n                            }\r\n\r\n                            $sortOrderValue = 0\r\n                            if ($mapping.PSObject.Properties['sort_order']) {\r\n                                try {\r\n                                    $sortOrderValue = [int]$mapping.sort_order\r\n                                } catch {\r\n                                    # Write-PmcTuiLog \"Invalid 'sort_order' value for mapping $($mapping.id), defaulting to 0: $_\" \"WARN\"\r\n                                }\r\n                            }\r\n\r\n                            # Force type conversion for boolean and int values from JSON\r\n                            $mappings += @{\r\n                                id = $mapping.id\r\n                                display_name = $mapping.display_name\r\n                                excel_cell = $mapping.excel_cell\r\n                                project_property = $mapping.project_property\r\n                                required = $requiredValue\r\n                                data_type = $mapping.data_type\r\n                                include_in_export = $includeInExportValue\r\n                                sort_order = $sortOrderValue\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    # Parse datetime with error handling\r\n                    try {\r\n                        $created = [datetime]::Parse($profile.created)\r\n                    } catch {\r\n                        # Write-PmcTuiLog \"Failed to parse created date for profile $($profile.id), using current time: $_\" \"WARN\"\r\n                        $created = [datetime]::Now\r\n                    }\r\n\r\n                    try {\r\n                        $modified = [datetime]::Parse($profile.modified)\r\n                    } catch {\r\n                        # Write-PmcTuiLog \"Failed to parse modified date for profile $($profile.id), using current time: $_\" \"WARN\"\r\n                        $modified = [datetime]::Now\r\n                    }\r\n\r\n                    $this._profilesCache[$profile.id] = @{\r\n                        id = $profile.id\r\n                        name = $profile.name\r\n                        description = $profile.description\r\n                        start_cell = $profile.start_cell\r\n                        mappings = $mappings\r\n                        created = $created\r\n                        modified = $modified\r\n                    }\r\n                    # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: Cached profile id=$($profile.id) with $($mappings.Count) mappings\" \"DEBUG\"\r\n                }\r\n                $this._cacheLoadTime = [datetime]::Now\r\n                # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: SUCCESS - loaded $($this._profilesCache.Count) profiles\" \"DEBUG\"\r\n            } catch {\r\n                # Write-PmcTuiLog \"Failed to load Excel profiles: $_\" \"ERROR\"\r\n                # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: STACK TRACE: $($_.ScriptStackTrace)\" \"ERROR\"\r\n                $this._profilesCache = @{}\r\n            }\r\n        } else {\r\n            # Write-PmcTuiLog \"ExcelMappingService.LoadProfiles: File not found: $($this._profilesFile)\" \"WARN\"\r\n        }\r\n    }\r\n\r\n    hidden [void] SaveProfiles() {\r\n        try {\r\n            $profiles = $this._profilesCache.Values | ForEach-Object {\r\n                $mappings = @()\r\n                foreach ($mapping in $_.mappings) {\r\n                    $mappings += @{\r\n                        id = $mapping.id\r\n                        display_name = $mapping.display_name\r\n                        excel_cell = $mapping.excel_cell\r\n                        project_property = $mapping.project_property\r\n                        required = $mapping.required\r\n                        data_type = $mapping.data_type\r\n                        include_in_export = $mapping.include_in_export\r\n                        sort_order = $mapping.sort_order\r\n                    }\r\n                }\r\n\r\n                @{\r\n                    id = $_.id\r\n                    name = $_.name\r\n                    description = $_.description\r\n                    start_cell = $_.start_cell\r\n                    mappings = $mappings\r\n                    created = $_.created.ToString(\"o\")\r\n                    modified = $_.modified.ToString(\"o\")\r\n                }\r\n            }\r\n\r\n            $metadata = @{\r\n                schema_version = 1\r\n                active_profile_id = $this._activeProfileId\r\n                profiles = $profiles\r\n            }\r\n\r\n            # ES-H6 FIX: Atomic save with proper cleanup of temp file on failure\r\n            $tempFile = \"$($this._profilesFile).tmp\"\r\n            $metadata | ConvertTo-Json -Depth 10 | Set-Content -Path $tempFile -Encoding utf8\r\n\r\n            try {\r\n                if (Test-Path $this._profilesFile) {\r\n                    Copy-Item $this._profilesFile \"$($this._profilesFile).bak\" -Force\r\n                }\r\n\r\n                Move-Item -Path $tempFile -Destination $this._profilesFile -Force\r\n            } catch {\r\n                # Clean up orphaned temp file if move fails\r\n                if (Test-Path $tempFile) {\r\n                    try {\r\n                        Remove-Item $tempFile -Force -ErrorAction SilentlyContinue\r\n                    } catch {\r\n                        # Write-PmcTuiLog \"Failed to clean up temp file $tempFile : $_\" \"WARNING\"\r\n                    }\r\n                }\r\n                throw\r\n            }\r\n\r\n        } catch {\r\n            # Write-PmcTuiLog \"Failed to save Excel profiles: $_\" \"ERROR\"\r\n            # Write-PmcTuiLog \"Stack trace: $($_.ScriptStackTrace)\" \"ERROR\"\r\n            throw \"Failed to save profiles: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    # === Profile CRUD Operations ===\r\n\r\n    [array] GetAllProfiles() {\r\n        return @($this._profilesCache.Values | Sort-Object -Property name)\r\n    }\r\n\r\n    [object] GetProfile([string]$profileId) {\r\n        if ($this._profilesCache.ContainsKey($profileId)) {\r\n            return $this._profilesCache[$profileId]\r\n        }\r\n        return $null\r\n    }\r\n\r\n    [object] GetActiveProfile() {\r\n        if ($null -ne $this._activeProfileId -and $this._profilesCache.ContainsKey($this._activeProfileId)) {\r\n            return $this._profilesCache[$this._activeProfileId]\r\n        }\r\n        return $null\r\n    }\r\n\r\n    [void] SetActiveProfile([string]$profileId) {\r\n        if (-not $this._profilesCache.ContainsKey($profileId)) {\r\n            throw \"Profile not found: $profileId\"\r\n        }\r\n\r\n        $this._activeProfileId = $profileId\r\n        $this.SaveProfiles()\r\n\r\n        if ($this.OnProfilesChanged) {\r\n            & $this.OnProfilesChanged\r\n        }\r\n    }\r\n\r\n    [object] CreateProfile([string]$name, [string]$description) {\r\n        return $this.CreateProfile($name, $description, \"A1\")\r\n    }\r\n\r\n    [object] CreateProfile([string]$name, [string]$description, [string]$startCell) {\r\n        # ES-H3 FIX: Check for duplicate name with proper count validation\r\n        $existing = @($this._profilesCache.Values | Where-Object { $_['name'] -eq $name })\r\n        if ($existing.Count -gt 0) {\r\n            throw \"Profile with name '$name' already exists\"\r\n        }\r\n\r\n        $profileId = [guid]::NewGuid().ToString()\r\n\r\n        $profile = @{\r\n            id = $profileId\r\n            name = $name\r\n            description = $description\r\n            start_cell = $startCell\r\n            mappings = @()\r\n            created = [datetime]::Now\r\n            modified = [datetime]::Now\r\n        }\r\n\r\n        $this._profilesCache[$profileId] = $profile\r\n\r\n        # Set as active if this is the first profile\r\n        if ($this._profilesCache.Count -eq 1) {\r\n            $this._activeProfileId = $profileId\r\n        }\r\n\r\n        $this.SaveProfiles()\r\n\r\n        if ($this.OnProfileAdded) {\r\n            & $this.OnProfileAdded $profile\r\n        }\r\n        if ($this.OnProfilesChanged) {\r\n            & $this.OnProfilesChanged\r\n        }\r\n\r\n        return $profile\r\n    }\r\n\r\n    [void] UpdateProfile([string]$profileId, [hashtable]$changes) {\r\n        if (-not $this._profilesCache.ContainsKey($profileId)) {\r\n            throw \"Profile not found: $profileId\"\r\n        }\r\n\r\n        $profile = $this._profilesCache[$profileId]\r\n\r\n        # Check for duplicate name if name is being changed\r\n        if ($changes.ContainsKey('name') -and $changes.name -ne $profile['name']) {\r\n            # ES-M7 FIX: Validate Where-Object returns expected result count\r\n            $existing = @($this._profilesCache.Values | Where-Object { $_['name'] -eq $changes.name -and $_['id'] -ne $profileId })\r\n            if ($existing.Count -gt 0) {\r\n                throw \"Profile with name '$($changes.name)' already exists\"\r\n            }\r\n        }\r\n\r\n        if ($changes.ContainsKey('name')) { $profile.name = $changes.name }\r\n        if ($changes.ContainsKey('description')) { $profile.description = $changes.description }\r\n        if ($changes.ContainsKey('start_cell')) { $profile.start_cell = $changes.start_cell }\r\n\r\n        $profile.modified = [datetime]::Now\r\n\r\n        $this.SaveProfiles()\r\n\r\n        if ($this.OnProfileUpdated) {\r\n            & $this.OnProfileUpdated $profile\r\n        }\r\n        if ($this.OnProfilesChanged) {\r\n            & $this.OnProfilesChanged\r\n        }\r\n    }\r\n\r\n    [void] DeleteProfile([string]$profileId) {\r\n        if (-not $this._profilesCache.ContainsKey($profileId)) {\r\n            throw \"Profile not found: $profileId\"\r\n        }\r\n\r\n        $profile = $this._profilesCache[$profileId]\r\n        $this._profilesCache.Remove($profileId)\r\n\r\n        # Clear active profile if it was deleted\r\n        if ($this._activeProfileId -eq $profileId) {\r\n            # Set to first remaining profile, or null\r\n            $remaining = $this._profilesCache.Keys\r\n            $this._activeProfileId = $(if ($remaining.Count -gt 0) { $remaining[0] } else { $null })\r\n        }\r\n\r\n        $this.SaveProfiles()\r\n\r\n        if ($this.OnProfileDeleted) {\r\n            & $this.OnProfileDeleted $profile\r\n        }\r\n        if ($this.OnProfilesChanged) {\r\n            & $this.OnProfilesChanged\r\n        }\r\n    }\r\n\r\n    # === Mapping CRUD Operations ===\r\n\r\n    [object] AddMapping([string]$profileId, [hashtable]$mappingData) {\r\n        if (-not $this._profilesCache.ContainsKey($profileId)) {\r\n            throw \"Profile not found: $profileId\"\r\n        }\r\n\r\n        $profile = $this._profilesCache[$profileId]\r\n        $mappingId = [guid]::NewGuid().ToString()\r\n\r\n        # Determine sort order\r\n        $sortOrder = $(if ($mappingData.ContainsKey('sort_order')) {\r\n            $mappingData.sort_order\r\n        } else {\r\n            $profile.mappings.Count + 1\r\n        })\r\n\r\n        $mapping = @{\r\n            id = $mappingId\r\n            display_name = $mappingData.display_name\r\n            excel_cell = $mappingData.excel_cell\r\n            project_property = $mappingData.project_property\r\n            required = $(if ($mappingData.ContainsKey('required')) { $mappingData.required } else { $false })\r\n            data_type = $(if ($mappingData.ContainsKey('data_type')) { $mappingData.data_type } else { \"string\" })\r\n            include_in_export = $(if ($mappingData.ContainsKey('include_in_export')) { $mappingData.include_in_export } else { $true })\r\n            sort_order = $sortOrder\r\n        }\r\n\r\n        $profile.mappings += $mapping\r\n        $profile.modified = [datetime]::Now\r\n\r\n        $this.SaveProfiles()\r\n\r\n        if ($this.OnProfileUpdated) {\r\n            & $this.OnProfileUpdated $profile\r\n        }\r\n        if ($this.OnProfilesChanged) {\r\n            & $this.OnProfilesChanged\r\n        }\r\n\r\n        return $mapping\r\n    }\r\n\r\n    [void] UpdateMapping([string]$profileId, [string]$mappingId, [hashtable]$changes) {\r\n        if (-not $this._profilesCache.ContainsKey($profileId)) {\r\n            throw \"Profile not found: $profileId\"\r\n        }\r\n\r\n        $profile = $this._profilesCache[$profileId]\r\n        # ES-M7 FIX: Validate Where-Object returns exactly one result\r\n        $matchingMappings = @($profile.mappings | Where-Object { $_.id -eq $mappingId })\r\n        if ($matchingMappings.Count -eq 0) {\r\n            throw \"Mapping not found: $mappingId\"\r\n        }\r\n        if ($matchingMappings.Count -gt 1) {\r\n            # Write-PmcTuiLog \"WARNING: Multiple mappings found with ID $mappingId in profile $profileId. Using first match.\" \"WARN\"\r\n        }\r\n        $mapping = $matchingMappings[0]\r\n\r\n        if ($changes.ContainsKey('display_name')) { $mapping.display_name = $changes.display_name }\r\n        if ($changes.ContainsKey('excel_cell')) { $mapping.excel_cell = $changes.excel_cell }\r\n        if ($changes.ContainsKey('project_property')) { $mapping.project_property = $changes.project_property }\r\n        if ($changes.ContainsKey('required')) { $mapping.required = $changes.required }\r\n        if ($changes.ContainsKey('data_type')) { $mapping.data_type = $changes.data_type }\r\n        if ($changes.ContainsKey('include_in_export')) { $mapping.include_in_export = $changes.include_in_export }\r\n        if ($changes.ContainsKey('sort_order')) { $mapping.sort_order = $changes.sort_order }\r\n\r\n        $profile.modified = [datetime]::Now\r\n\r\n        $this.SaveProfiles()\r\n\r\n        if ($this.OnProfileUpdated) {\r\n            & $this.OnProfileUpdated $profile\r\n        }\r\n        if ($this.OnProfilesChanged) {\r\n            & $this.OnProfilesChanged\r\n        }\r\n    }\r\n\r\n    [void] DeleteMapping([string]$profileId, [string]$mappingId) {\r\n        if (-not $this._profilesCache.ContainsKey($profileId)) {\r\n            throw \"Profile not found: $profileId\"\r\n        }\r\n\r\n        $profile = $this._profilesCache[$profileId]\r\n        # @() wrapper ensures array type even with 0 or 1 results\r\n        $profile.mappings = @($profile.mappings | Where-Object { $_.id -ne $mappingId })\r\n        $profile.modified = [datetime]::Now\r\n\r\n        $this.SaveProfiles()\r\n\r\n        if ($this.OnProfileUpdated) {\r\n            & $this.OnProfileUpdated $profile\r\n        }\r\n        if ($this.OnProfilesChanged) {\r\n            & $this.OnProfilesChanged\r\n        }\r\n    }\r\n\r\n    [array] GetMappings([string]$profileId) {\r\n        if (-not $this._profilesCache.ContainsKey($profileId)) {\r\n            return @()\r\n        }\r\n\r\n        $profile = $this._profilesCache[$profileId]\r\n        return @($profile.mappings | Sort-Object -Property sort_order)\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/services/FileNoteService.ps1", "content": "# FileNoteService.ps1 - Filesystem-based note service\n#\n# Human-readable filenames (title = filename), optional per-note .meta sidecar.\n# Much simpler than legacy NoteService - no monolithic metadata manifest.\n#\n# Storage structure:\n#   notes/\n#     Meeting Notes.txt      <- Note content\n#     Meeting Notes.meta     <- Optional: tags, owner (only if needed)\n#     Project Ideas.txt\n#\n# Usage:\n#   $service = [FileNoteService]::GetInstance()\n#   $notes = $service.GetAllNotes()\n#   $service.CreateNote(\"My New Note\")\n\nusing namespace System\nusing namespace System.IO\nusing namespace System.Collections.Generic\n\nSet-StrictMode -Version Latest\n\nclass FileNoteService {\n    # === Singleton ===\n    static hidden [FileNoteService]$_instance = $null\n    static hidden [object]$_instanceLock = [object]::new()\n\n    # === Configuration ===\n    hidden [string]$_notesDir\n    hidden [hashtable]$_metaCache = @{}  # In-memory cache for .meta files\n\n    # === Events ===\n    [scriptblock]$OnNotesChanged = $null\n    [scriptblock]$OnNoteAdded = $null\n\n    # === Singleton Access ===\n    static [FileNoteService] GetInstance() {\n        if ($null -eq [FileNoteService]::_instance) {\n            [System.Threading.Monitor]::Enter([FileNoteService]::_instanceLock)\n            try {\n                if ($null -eq [FileNoteService]::_instance) {\n                    [FileNoteService]::_instance = [FileNoteService]::new()\n                }\n            } finally {\n                [System.Threading.Monitor]::Exit([FileNoteService]::_instanceLock)\n            }\n        }\n        return [FileNoteService]::_instance\n    }\n\n    # === Constructor ===\n    FileNoteService() {\n        # Determine notes directory relative to PMC root\n        $pmcRoot = Split-Path -Parent (Split-Path -Parent (Split-Path -Parent $PSScriptRoot))\n        $this._notesDir = Join-Path $pmcRoot \"notes\"\n\n        # Ensure directory exists\n        if (-not (Test-Path $this._notesDir)) {\n            New-Item -ItemType Directory -Path $this._notesDir -Force | Out-Null\n        }\n    }\n\n    # === CRUD Operations ===\n\n    <#\n    .SYNOPSIS\n    Get all notes by scanning the directory\n    ##CLOSEBRACKET##\n    [array] GetAllNotes() {\n        $notes = @()\n        \n        $files = Get-ChildItem -Path $this._notesDir -Filter \"*.txt\" -File -ErrorAction SilentlyContinue\n        \n        foreach ($file in $files) {\n            $noteId = $file.BaseName  # Filename without extension = ID and title\n            $meta = $this._LoadMetadata($noteId)\n            \n            $notes += @{\n                id = $noteId\n                title = $noteId\n                file = $file.FullName\n                created = $file.CreationTime\n                modified = $file.LastWriteTime\n                tags = $(if ($meta['tags']) { $meta['tags'] } else { @() })\n                owner_type = $(if ($meta['owner_type']) { $meta['owner_type'] } else { \"global\" })\n                owner_id = $(if ($meta['owner_id']) { $meta['owner_id'] } else { \"\" })\n                word_count = 0  # Compute on demand if needed\n                line_count = 0\n            }\n        }\n        \n        # Sort by modified descending (most recent first)\n        return $notes | Sort-Object -Property modified -Descending\n    }\n\n    <#\n    .SYNOPSIS\n    Get notes filtered by owner\n    ##CLOSEBRACKET##\n    [array] GetNotesByOwner([string]$ownerType, [string]$ownerId) {\n        return $this.GetAllNotes() | Where-Object {\n            $_.owner_type -eq $ownerType -and $_.owner_id -eq $ownerId\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Get a single note by ID (title)\n    ##CLOSEBRACKET##\n    [object] GetNote([string]$noteId) {\n        $filePath = Join-Path $this._notesDir \"$noteId.txt\"\n        if (-not (Test-Path $filePath)) {\n            return $null\n        }\n        \n        $file = Get-Item $filePath\n        $meta = $this._LoadMetadata($noteId)\n        \n        return @{\n            id = $noteId\n            title = $noteId\n            file = $file.FullName\n            created = $file.CreationTime\n            modified = $file.LastWriteTime\n            tags = $(if ($meta['tags']) { $meta['tags'] } else { @() })\n            owner_type = $(if ($meta['owner_type']) { $meta['owner_type'] } else { \"global\" })\n            owner_id = $(if ($meta['owner_id']) { $meta['owner_id'] } else { \"\" })\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Create a new note with the given title\n    ##CLOSEBRACKET##\n    [object] CreateNote([string]$title) {\n        return $this.CreateNote($title, @(), \"global\", $null)\n    }\n\n    [object] CreateNote([string]$title, [array]$tags) {\n        return $this.CreateNote($title, $tags, \"global\", $null)\n    }\n\n    [object] CreateNote([string]$title, [array]$tags, [string]$ownerType, [string]$ownerId) {\n        # Sanitize title for filename\n        $safeName = $this._SanitizeFilename($title)\n        \n        # Handle duplicates by appending number\n        $baseName = $safeName\n        $counter = 1\n        while (Test-Path (Join-Path $this._notesDir \"$safeName.txt\")) {\n            $safeName = \"$baseName ($counter)\"\n            $counter++\n        }\n        \n        $filePath = Join-Path $this._notesDir \"$safeName.txt\"\n        \n        # Create empty file with atomic write\n        $this._AtomicWrite($filePath, \"\")\n        \n        # Save metadata if we have tags or owner\n        if ($tags.Count -gt 0 -or ($ownerType -ne \"global\" -and $ownerId)) {\n            $this._SaveMetadata($safeName, @{\n                tags = $tags\n                owner_type = $ownerType\n                owner_id = $ownerId\n            })\n        }\n        \n        $note = $this.GetNote($safeName)\n        \n        # Fire events\n        if ($this.OnNoteAdded) {\n            & $this.OnNoteAdded $note\n        }\n        if ($this.OnNotesChanged) {\n            & $this.OnNotesChanged\n        }\n        \n        return $note\n    }\n\n    <#\n    .SYNOPSIS\n    Load note content from file\n    ##CLOSEBRACKET##\n    [string] LoadNoteContent([string]$noteId) {\n        $filePath = Join-Path $this._notesDir \"$noteId.txt\"\n        \n        if (-not (Test-Path $filePath)) {\n            throw \"Note not found: $noteId\"\n        }\n        \n        return Get-Content -Path $filePath -Raw -ErrorAction SilentlyContinue\n    }\n\n    <#\n    .SYNOPSIS\n    Save note content with atomic write and fsync\n    ##CLOSEBRACKET##\n    [void] SaveNoteContent([string]$noteId, [string]$content) {\n        $filePath = Join-Path $this._notesDir \"$noteId.txt\"\n        \n        if (-not (Test-Path $filePath)) {\n            throw \"Note not found: $noteId\"\n        }\n        \n        $this._AtomicWrite($filePath, $content)\n        \n        # Note: We do NOT rewrite any manifest here - that's the whole point!\n        # Modified time is updated by the filesystem automatically.\n    }\n\n    <#\n    .SYNOPSIS\n    Update note metadata (tags, owner)\n    ##CLOSEBRACKET##\n    [void] UpdateNoteMetadata([string]$noteId, [hashtable]$changes) {\n        $filePath = Join-Path $this._notesDir \"$noteId.txt\"\n        if (-not (Test-Path $filePath)) {\n            throw \"Note not found: $noteId\"\n        }\n        \n        # Handle title change = file rename\n        if ($changes.ContainsKey('title') -and $changes.title -ne $noteId) {\n            $newName = $this._SanitizeFilename($changes.title)\n            $this.RenameNote($noteId, $newName)\n            $noteId = $newName\n        }\n        \n        # Load existing metadata\n        $meta = $this._LoadMetadata($noteId)\n        if (-not $meta) { $meta = @{} }\n        \n        # Apply changes\n        if ($changes.ContainsKey('tags')) { $meta.tags = $changes.tags }\n        if ($changes.ContainsKey('owner_type')) { $meta.owner_type = $changes.owner_type }\n        if ($changes.ContainsKey('owner_id')) { $meta.owner_id = $changes.owner_id }\n        \n        # Save metadata (only if we have anything to store)\n        if ($meta.tags -or ($meta.owner_type -and $meta.owner_type -ne \"global\") -or $meta.owner_id) {\n            $this._SaveMetadata($noteId, $meta)\n        }\n        \n        if ($this.OnNotesChanged) {\n            & $this.OnNotesChanged\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Rename a note (changes both file and title)\n    ##CLOSEBRACKET##\n    [void] RenameNote([string]$oldName, [string]$newName) {\n        $oldPath = Join-Path $this._notesDir \"$oldName.txt\"\n        $newPath = Join-Path $this._notesDir \"$newName.txt\"\n        \n        if (-not (Test-Path $oldPath)) {\n            throw \"Note not found: $oldName\"\n        }\n        \n        if (Test-Path $newPath) {\n            throw \"A note with name '$newName' already exists\"\n        }\n        \n        # Rename content file\n        Rename-Item $oldPath $newPath\n        \n        # Rename metadata file if exists\n        $oldMeta = Join-Path $this._notesDir \"$oldName.meta\"\n        $newMeta = Join-Path $this._notesDir \"$newName.meta\"\n        if (Test-Path $oldMeta) {\n            Rename-Item $oldMeta $newMeta\n        }\n        \n        # Update cache\n        if ($this._metaCache.ContainsKey($oldName)) {\n            $this._metaCache[$newName] = $this._metaCache[$oldName]\n            $this._metaCache.Remove($oldName)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Delete a note and its metadata\n    ##CLOSEBRACKET##\n    [void] DeleteNote([string]$noteId) {\n        $filePath = Join-Path $this._notesDir \"$noteId.txt\"\n        \n        if (-not (Test-Path $filePath)) {\n            throw \"Note not found: $noteId\"\n        }\n        \n        # Delete content file\n        Remove-Item $filePath -Force\n        \n        # Delete metadata file if exists\n        $metaPath = Join-Path $this._notesDir \"$noteId.meta\"\n        if (Test-Path $metaPath) {\n            Remove-Item $metaPath -Force\n        }\n        \n        # Clear from cache\n        $this._metaCache.Remove($noteId)\n        \n        if ($this.OnNotesChanged) {\n            & $this.OnNotesChanged\n        }\n    }\n\n    # === Private Helpers ===\n\n    <#\n    .SYNOPSIS\n    Atomic write with fsync - write to temp, flush, rename\n    ##CLOSEBRACKET##\n    hidden [void] _AtomicWrite([string]$targetPath, [string]$content) {\n        $tempPath = \"$targetPath.tmp\"\n        \n        try {\n            # Write to temp file\n            [System.IO.File]::WriteAllText($tempPath, $content)\n            \n            # Fsync - ensure data hits disk\n            $stream = [System.IO.File]::Open($tempPath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::None)\n            $stream.Flush()\n            $stream.Close()\n            \n            # Atomic rename\n            Move-Item -Path $tempPath -Destination $targetPath -Force\n            \n        } catch {\n            # Cleanup temp file on error\n            if (Test-Path $tempPath) {\n                Remove-Item $tempPath -Force -ErrorAction SilentlyContinue\n            }\n            throw\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Load per-note metadata from .meta sidecar file\n    ##CLOSEBRACKET##\n    hidden [hashtable] _LoadMetadata([string]$noteId) {\n        # Check cache first\n        if ($this._metaCache.ContainsKey($noteId)) {\n            return $this._metaCache[$noteId]\n        }\n        \n        $metaPath = Join-Path $this._notesDir \"$noteId.meta\"\n        \n        if (Test-Path $metaPath) {\n            try {\n                $json = Get-Content $metaPath -Raw | ConvertFrom-Json\n                $meta = @{\n                    tags = $(if ($json.tags) { @($json.tags) } else { @() })\n                    owner_type = $(if ($json.owner_type) { $json.owner_type } else { \"global\" })\n                    owner_id = $(if ($json.owner_id) { $json.owner_id } else { \"\" })\n                }\n                $this._metaCache[$noteId] = $meta\n                return $meta\n            } catch {\n                Write-Warning \"Failed to load metadata for $noteId $_\"\n            }\n        }\n        \n        return @{}\n    }\n\n    <#\n    .SYNOPSIS\n    Save per-note metadata to .meta sidecar file\n    ##CLOSEBRACKET##\n    hidden [void] _SaveMetadata([string]$noteId, [hashtable]$meta) {\n        $metaPath = Join-Path $this._notesDir \"$noteId.meta\"\n        \n        $data = @{\n            tags = $(if ($meta.tags) { $meta.tags } else { @() })\n            owner_type = $(if ($meta.owner_type) { $meta.owner_type } else { \"global\" })\n            owner_id = $(if ($meta.owner_id) { $meta.owner_id } else { \"\" })\n        }\n        \n        $json = $data | ConvertTo-Json -Compress\n        $this._AtomicWrite($metaPath, $json)\n        \n        # Update cache\n        $this._metaCache[$noteId] = $meta\n    }\n\n    <#\n    .SYNOPSIS\n    Sanitize a string for use as a filename\n    ##CLOSEBRACKET##\n    hidden [string] _SanitizeFilename([string]$name) {\n        # Remove invalid characters\n        $invalid = [System.IO.Path]::GetInvalidFileNameChars()\n        $safeName = $name\n        \n        foreach ($char in $invalid) {\n            $safeName = $safeName.Replace([string]$char, '')\n        }\n        \n        # Trim whitespace and dots\n        $safeName = $safeName.Trim().TrimEnd('.')\n        \n        # Ensure not empty\n        if ([string]::IsNullOrWhiteSpace($safeName)) {\n            $safeName = \"Untitled\"\n        }\n        \n        # Limit length (Windows has 260 char path limit)\n        if ($safeName.Length -gt 200) {\n            $safeName = $safeName.Substring(0, 200)\n        }\n        \n        return $safeName\n    }\n\n    <#\n    .SYNOPSIS\n    Update word/line stats (computed on demand, not stored)\n    ##CLOSEBRACKET##\n    [void] UpdateNoteStats([string]$noteId, [int]$wordCount, [int]$lineCount) {\n        # In filesystem mode, we don't store stats - they're derived from content\n        # This method exists for API compatibility but is a no-op\n    }\n}\n"}, {"path": "module/Pmc.Strict/consoleui/services/MenuRegistry.ps1", "content": "# MenuRegistry.ps1 - Dynamic menu registration system\r\n#\r\n# Allows screens to register their own menu items instead of hardcoding\r\n# menu structure in TaskListScreen.\r\n#\r\n# Usage in screen classes:\r\n#   static [void] RegisterMenuItems([MenuRegistry]$registry) {\r\n#       $registry.AddMenuItem('Tasks', 'Today View', 'Y', {\r\n#           . \"$PSScriptRoot/TodayViewScreen.ps1\"\r\n#           $global:PmcApp.PushScreen([TodayViewScreen]::new())\r\n#       })\r\n#   }\r\n\r\nusing namespace System\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nDynamic menu registration system for PMC screens\r\n\r\n.DESCRIPTION\r\nMenuRegistry allows screens to register their own menu items dynamically.\r\nThis decouples menu structure from TaskListScreen and allows screens to\r\ncontrol their own menu presence.\r\n\r\nMenu structure:\r\n- Tasks: Task views and actions\r\n- Projects: Project management screens\r\n- Time: Time tracking screens\r\n- Tools: Utilities and helpers\r\n- Options: Settings and configuration\r\n- Help: Help and about screens\r\n\r\n.EXAMPLE\r\n$registry = [MenuRegistry]::new()\r\n$registry.AddMenuItem('Tasks', 'Today', 'Y', { Show-TodayView })\r\n$menuItems = $registry.GetMenuItems('Tasks')\r\n##CLOSEBRACKET##\r\nclass MenuRegistry {\r\n    # Singleton instance\r\n    static [MenuRegistry]$_instance = $null\r\n\r\n    # Menu structure: @{ 'Tasks' = @( @{ Label='Today'; Hotkey='Y'; Action={...} }, ... ) }\r\n    [hashtable]$_menuItems = @{\r\n        'Tasks' = [List[hashtable]]::new()\r\n        'Projects' = [List[hashtable]]::new()\r\n        'Time' = [List[hashtable]]::new()\r\n        'Tools' = [List[hashtable]]::new()\r\n        'Options' = [List[hashtable]]::new()\r\n        'Help' = [List[hashtable]]::new()\r\n    }\r\n\r\n    # === Singleton Pattern ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get the singleton instance of MenuRegistry\r\n\r\n    .OUTPUTS\r\n    MenuRegistry singleton instance\r\n    ##CLOSEBRACKET##\r\n    static [MenuRegistry] GetInstance() {\r\n        if ($null -eq [MenuRegistry]::_instance) {\r\n            [MenuRegistry]::_instance = [MenuRegistry]::new()\r\n        }\r\n        return [MenuRegistry]::_instance\r\n    }\r\n\r\n    # Private constructor for singleton\r\n    hidden MenuRegistry() {\r\n        # Initialize menu structure\r\n    }\r\n\r\n    # === Registration ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Register a menu item\r\n\r\n    .PARAMETER menuName\r\n    Menu to add item to ('Tasks', 'Projects', 'Time', 'Tools', 'Options', 'Help')\r\n\r\n    .PARAMETER label\r\n    Display label for menu item\r\n\r\n    .PARAMETER hotkey\r\n    Keyboard shortcut (single character or [char]0 for separator)\r\n\r\n    .PARAMETER action\r\n    Scriptblock to execute when item is selected\r\n\r\n    .PARAMETER order\r\n    Optional sort order (lower numbers appear first, default 100)\r\n    ##CLOSEBRACKET##\r\n    [void] AddMenuItem([string]$menuName, [string]$label, [char]$hotkey, [scriptblock]$action) {\r\n        $this.AddMenuItem($menuName, $label, $hotkey, $action, 100)\r\n    }\r\n\r\n    [void] AddMenuItem([string]$menuName, [string]$label, [char]$hotkey, [scriptblock]$action, [int]$order) {\r\n        if (-not $this._menuItems.ContainsKey($menuName)) {\r\n            throw \"Invalid menu name: $menuName. Valid: Tasks, Projects, Time, Tools, Options, Help\"\r\n        }\r\n\r\n        $item = @{\r\n            Label = $label\r\n            Hotkey = $hotkey\r\n            Action = $action\r\n            Order = $order\r\n        }\r\n\r\n        $this._menuItems[$menuName].Add($item)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Add a menu separator\r\n\r\n    .PARAMETER menuName\r\n    Menu to add separator to\r\n    ##CLOSEBRACKET##\r\n    [void] AddSeparator([string]$menuName) {\r\n        $this.AddMenuItem($menuName, \"\", [char]0, $null, 100)\r\n    }\r\n\r\n    [void] AddSeparator([string]$menuName, [int]$order) {\r\n        $this.AddMenuItem($menuName, \"\", [char]0, $null, $order)\r\n    }\r\n\r\n    # === Retrieval ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get all menu items for a specific menu, sorted by order\r\n\r\n    .PARAMETER menuName\r\n    Menu name ('Tasks', 'Projects', etc.)\r\n\r\n    .OUTPUTS\r\n    Array of menu item hashtables sorted by Order\r\n    ##CLOSEBRACKET##\r\n    [array] GetMenuItems([string]$menuName) {\r\n        if (-not $this._menuItems.ContainsKey($menuName)) {\r\n            return @()\r\n        }\r\n\r\n        # Sort by Order, then by Label\r\n        return $this._menuItems[$menuName] | Sort-Object -Property Order, Label\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get all registered menus with items\r\n\r\n    .OUTPUTS\r\n    Hashtable of menu names to sorted item arrays\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetAllMenus() {\r\n        $result = @{}\r\n        foreach ($menuName in $this._menuItems.Keys) {\r\n            $items = $this.GetMenuItems($menuName)\r\n            if ($items.Count -gt 0) {\r\n                $result[$menuName] = $items\r\n            }\r\n        }\r\n        return $result\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Clear all registered menu items (for testing/reset)\r\n    ##CLOSEBRACKET##\r\n    [void] Clear() {\r\n        foreach ($menuName in $this._menuItems.Keys) {\r\n            $this._menuItems[$menuName].Clear()\r\n        }\r\n    }\r\n\r\n    # === Manifest-Based Discovery ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Load menu items from manifest file\r\n\r\n    .PARAMETER manifestPath\r\n    Path to MenuItems.psd1 manifest file\r\n\r\n    .PARAMETER container\r\n    ServiceContainer instance for resolving screen dependencies\r\n\r\n    .DESCRIPTION\r\n    Loads menu item definitions from manifest and registers them.\r\n    Uses the DI container to resolve screens when menu items are clicked.\r\n    This avoids parsing all screen files at startup, fixing type resolution issues.\r\n    ##CLOSEBRACKET##\r\n    [void] LoadFromManifest([string]$manifestPath, [object]$container) {\r\n        if (-not (Test-Path $manifestPath)) {\r\n            if ($global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] MenuRegistry: Manifest not found at '$manifestPath'\"\r\n            }\r\n            # Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [MenuRegistry] ERROR: Menu manifest not found at '$manifestPath'\"\r\n            return\r\n        }\r\n\r\n        try {\r\n            # Load manifest\r\n            $manifest = Import-PowerShellDataFile -Path $manifestPath\r\n\r\n            if ($global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] MenuRegistry: Loaded manifest with $($manifest.Count) entries\"\r\n            }\r\n\r\n            $screensDir = Split-Path $manifestPath -Parent\r\n\r\n            # Register each menu item\r\n            foreach ($entry in $manifest.GetEnumerator()) {\r\n                $screenName = $entry.Key\r\n                $config = $entry.Value\r\n\r\n                $menu = $config.Menu\r\n                $label = $config.Label\r\n                $hotkey = $config.Hotkey\r\n                $order = $config.Order\r\n                $screenFile = $config.ScreenFile\r\n                $viewMode = $(if ($config.ContainsKey('ViewMode')) { $config.ViewMode } else { $null })  # Optional, for TaskListScreen variants\r\n\r\n                # Register screen factory in container if not already registered\r\n                $screenTypeName = $screenFile -replace '\\.ps1$', ''\r\n                $screenPath = Join-Path $screensDir $screenFile\r\n\r\n                if (-not $container.IsRegistered($screenName)) {\r\n                    # Capture variables in closure for the factory\r\n                    $factoryScreenPath = $screenPath\r\n                    $factoryScreenTypeName = $screenTypeName\r\n                    $factoryViewMode = $viewMode\r\n\r\n                    # Register screen factory in container (non-singleton, creates new instance each time)\r\n                    $container.Register($screenName, {\r\n                        param($c)\r\n                        # Dot-source screen file to load class\r\n                        . $factoryScreenPath\r\n                        # CRITICAL FIX: Use -ArgumentList parameter for reliable argument passing\r\n                        # Positional arguments don't work correctly with New-Object in closures\r\n                        if ($factoryViewMode) {\r\n                            return New-Object $factoryScreenTypeName -ArgumentList $c, $factoryViewMode\r\n                        } else {\r\n                            return New-Object $factoryScreenTypeName -ArgumentList $c\r\n                        }\r\n                    }.GetNewClosure(), $false)  # Non-singleton: create new instance each time\r\n\r\n                    Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] MenuRegistry: Registered '$label' in '$menu' menu (hotkey=$hotkey order=$order)\"\r\n                }\r\n\r\n                # Build scriptblock that uses container to resolve screen\r\n                $scriptblock = [scriptblock]::Create(@\"\r\ntry {\r\n    `$screen = `$global:PmcContainer.Resolve('$screenName')\r\n    if (`$screen) {\r\n        `$global:PmcApp.PushScreen(`$screen)\r\n    } else {\r\n        if (`$global:PmcTuiLogFile) {\r\n            Add-Content -Path `$global:PmcTuiLogFile -Value \"[`$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] MenuRegistry: Failed to resolve screen '$screenName'\"\r\n        }\r\n    }\r\n} catch {\r\n    if (`$global:PmcTuiLogFile) {\r\n        Add-Content -Path `$global:PmcTuiLogFile -Value \"[`$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] MenuRegistry: Error launching '$screenName': `$_\"\r\n        Add-Content -Path `$global:PmcTuiLogFile -Value \"[`$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] Stack trace: `n`$(`$_.ScriptStackTrace)\"\r\n    }\r\n    # Show error to user\r\n    if (`$global:PmcApp -and `$global:PmcApp.CurrentScreen) {\r\n        `$global:PmcApp.CurrentScreen.ShowError(\"Error launching '$label': `$_\")\r\n    }\r\n}\r\n\"@)\r\n\r\n                # Register the menu item\r\n                $this.AddMenuItem($menu, $label, $hotkey, $scriptblock, $order)\r\n\r\n                if ($global:PmcTuiLogFile) {\r\n                    Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] MenuRegistry: Registered '$label' in '$menu' menu (hotkey=$hotkey order=$order)\"\r\n                }\r\n            }\r\n\r\n        } catch {\r\n            $errorMsg = \"MenuRegistry: Error loading manifest: $($_.Exception.Message)\"\r\n            if ($global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [ERROR] $errorMsg\"\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] Stack trace: $($_.ScriptStackTrace)\"\r\n            }\r\n            # Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [MenuRegistry] ERROR: $errorMsg\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    DEPRECATED: Old discovery method - kept for reference but not used\r\n\r\n    .DESCRIPTION\r\n    This method is deprecated in favor of LoadFromManifest().\r\n    It caused type resolution issues due to parse-time type checking in PowerShell.\r\n    ##CLOSEBRACKET##\r\n    [void] DiscoverScreens([string[]]$screenPaths) {\r\n        # DEPRECATED: Use LoadFromManifest() instead\r\n        # This method caused issues:\r\n        # - Slow startup (loads all 40+ screen files)\r\n        # - Type resolution errors (bracket notation requires types at parse time)\r\n        # - Circular dependencies between screens\r\n\r\n        if ($global:PmcTuiLogFile) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [WARN] MenuRegistry.DiscoverScreens() is deprecated - use LoadFromManifest() instead\"\r\n        }\r\n    }\r\n}\r\n\r\n# Export for module usage\r\nif ($MyInvocation.MyCommand.Path) {\r\n    Export-ModuleMember -Variable MenuRegistry\r\n}"}, {"path": "module/Pmc.Strict/consoleui/services/NoteService.ps1", "content": "# NoteService.ps1 - Service for managing notes\r\n#\r\n# Provides CRUD operations for notes with file-based storage\r\n# Notes are stored in notes/ subdirectory as .txt files\r\n#\r\n# Usage:\r\n#   $service = [NoteService]::GetInstance()\r\n#   $notes = $service.GetAllNotes()\r\n#   $service.CreateNote(\"Meeting Notes\")\r\n#   $service.DeleteNote($noteId)\r\n\r\nusing namespace System\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass NoteService {\r\n    # === Singleton Instance ===\r\n    static hidden [NoteService]$_instance = $null\r\n    static hidden [object]$_instanceLock = [object]::new()\r\n\r\n    # === Configuration ===\r\n    hidden [string]$_notesDir\r\n    hidden [string]$_metadataFile\r\n\r\n    # === In-memory cache ===\r\n    hidden [hashtable]$_notesCache = @{}\r\n    hidden [datetime]$_cacheLoadTime = [datetime]::MinValue\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnNoteAdded = {}\r\n    [scriptblock]$OnNoteUpdated = {}\r\n    [scriptblock]$OnNoteDeleted = {}\r\n    [scriptblock]$OnNotesChanged = {}\r\n\r\n    # === Singleton Access ===\r\n    static [NoteService] GetInstance() {\r\n        if ([NoteService]::_instance -eq $null) {\r\n            [System.Threading.Monitor]::Enter([NoteService]::_instanceLock)\r\n            try {\r\n                if ([NoteService]::_instance -eq $null) {\r\n                    [NoteService]::_instance = [NoteService]::new()\r\n                }\r\n            } finally {\r\n                [System.Threading.Monitor]::Exit([NoteService]::_instanceLock)\r\n            }\r\n        }\r\n        return [NoteService]::_instance\r\n    }\r\n\r\n    # === Constructor (Private - use GetInstance) ===\r\n    NoteService() {\r\n        # Determine notes directory relative to PMC root\r\n        $pmcRoot = Split-Path -Parent (Split-Path -Parent (Split-Path -Parent $PSScriptRoot))\r\n        $this._notesDir = Join-Path $pmcRoot \"notes\"\r\n        $this._metadataFile = Join-Path $this._notesDir \"notes_metadata.json\"\r\n\r\n        # Ensure notes directory exists\r\n        if (-not (Test-Path $this._notesDir)) {\r\n            New-Item -ItemType Directory -Path $this._notesDir -Force | Out-Null\r\n        }\r\n\r\n        # Load metadata\r\n        $this.LoadMetadata()\r\n    }\r\n\r\n    # === Metadata Management ===\r\n    hidden [void] LoadMetadata() {\r\n        if (Test-Path $this._metadataFile) {\r\n            try {\r\n                $json = Get-Content $this._metadataFile -Raw | ConvertFrom-Json -Depth 10\r\n                foreach ($note in $json.notes) {\r\n                    $this._notesCache[$note.id] = @{\r\n                        id = $note.id\r\n                        title = $note.title\r\n                        file = $note.file\r\n                        created = [datetime]::Parse($note.created)\r\n                        modified = [datetime]::Parse($note.modified)\r\n                        tags = $note.tags\r\n                        word_count = $note.word_count\r\n                        line_count = $note.line_count\r\n                        owner_type = $(if ($note.PSObject.Properties['owner_type']) { $note.owner_type } else { \"global\" })\r\n                        owner_id = $(if ($note.PSObject.Properties['owner_id']) { $note.owner_id } else { $null })\r\n                    }\r\n                }\r\n                $this._cacheLoadTime = [datetime]::Now\r\n            } catch {\r\n                Write-Warning \"Failed to load notes metadata: $_\"\r\n                $this._notesCache = @{}\r\n            }\r\n        }\r\n    }\r\n\r\n    hidden [void] SaveMetadata() {\r\n        try {\r\n            $notes = $this._notesCache.Values | ForEach-Object {\r\n                @{\r\n                    id = $_.id\r\n                    title = $_.title\r\n                    file = $_.file\r\n                    created = $_.created.ToString(\"o\")\r\n                    modified = $_.modified.ToString(\"o\")\r\n                    tags = $_.tags\r\n                    word_count = $_.word_count\r\n                    line_count = $_.line_count\r\n                    owner_type = $(if ($_.ContainsKey('owner_type')) { $_.owner_type } else { \"global\" })\r\n                    owner_id = $(if ($_.ContainsKey('owner_id')) { $_.owner_id } else { $null })\r\n                }\r\n            }\r\n\r\n            $metadata = @{\r\n                schema_version = 1\r\n                notes = $notes\r\n            }\r\n\r\n            # Atomic save: write to temp file, then rename\r\n            $tempFile = \"$($this._metadataFile).tmp\"\r\n            $metadata | ConvertTo-Json -Depth 10 | Set-Content -Path $tempFile -Encoding utf8\r\n\r\n            # Backup existing file\r\n            if (Test-Path $this._metadataFile) {\r\n                Copy-Item $this._metadataFile \"$($this._metadataFile).bak\" -Force\r\n            }\r\n\r\n            # Rename temp to actual\r\n            Move-Item -Path $tempFile -Destination $this._metadataFile -Force\r\n\r\n        } catch {\r\n            Write-Warning \"Failed to save notes metadata: $_\"\r\n            throw\r\n        }\r\n    }\r\n\r\n    # === CRUD Operations ===\r\n\r\n    [array] GetAllNotes() {\r\n        $notes = @($this._notesCache.Values | Sort-Object -Property modified -Descending)\r\n        return $notes\r\n    }\r\n\r\n    [array] GetNotesByOwner([string]$ownerType, [string]$ownerId) {\r\n        $notes = @($this._notesCache.Values | Where-Object {\r\n            $_.owner_type -eq $ownerType -and $_.owner_id -eq $ownerId\r\n        } | Sort-Object -Property modified -Descending)\r\n        return $notes\r\n    }\r\n\r\n    [object] GetNote([string]$noteId) {\r\n        if ($this._notesCache.ContainsKey($noteId)) {\r\n            return $this._notesCache[$noteId]\r\n        }\r\n        return $null\r\n    }\r\n\r\n    [object] CreateNote([string]$title) {\r\n        return $this.CreateNote($title, @())\r\n    }\r\n\r\n    [object] CreateNote([string]$title, [array]$tags) {\r\n        return $this.CreateNote($title, $tags, \"global\", $null)\r\n    }\r\n\r\n    [object] CreateNote([string]$title, [array]$tags, [string]$ownerType, [string]$ownerId) {\r\n        # Generate unique ID\r\n        $noteId = [guid]::NewGuid().ToString()\r\n\r\n        # Create note file\r\n        $fileName = \"$noteId.txt\"\r\n        $filePath = Join-Path $this._notesDir $fileName\r\n\r\n        # Create initial empty note\r\n        Set-Content -Path $filePath -Value \"\" -Encoding utf8\r\n\r\n        # Create metadata entry\r\n        $note = @{\r\n            id = $noteId\r\n            title = $title\r\n            file = $filePath\r\n            created = [datetime]::Now\r\n            modified = [datetime]::Now\r\n            tags = $tags\r\n            owner_type = $ownerType\r\n            owner_id = $ownerId\r\n            word_count = 0\r\n            line_count = 0\r\n        }\r\n\r\n        # Add to cache\r\n        $this._notesCache[$noteId] = $note\r\n\r\n        # Persist metadata\r\n        $this.SaveMetadata()\r\n\r\n        # Fire event\r\n        if ($this.OnNoteAdded) {\r\n            & $this.OnNoteAdded $note\r\n        }\r\n        if ($this.OnNotesChanged) {\r\n            & $this.OnNotesChanged\r\n        }\r\n\r\n        return $note\r\n    }\r\n\r\n    [void] UpdateNoteMetadata([string]$noteId, [hashtable]$changes) {\r\n        if (-not $this._notesCache.ContainsKey($noteId)) {\r\n            throw \"Note not found: $noteId\"\r\n        }\r\n\r\n        $note = $this._notesCache[$noteId]\r\n\r\n        # Apply changes\r\n        foreach ($key in $changes.Keys) {\r\n            if ($note.ContainsKey($key)) {\r\n                $note[$key] = $changes[$key]\r\n            }\r\n        }\r\n\r\n        # Update modified timestamp\r\n        $note.modified = [datetime]::Now\r\n\r\n        # Persist\r\n        $this.SaveMetadata()\r\n\r\n        # Fire event\r\n        if ($this.OnNoteUpdated) {\r\n            & $this.OnNoteUpdated $note\r\n        }\r\n        if ($this.OnNotesChanged) {\r\n            & $this.OnNotesChanged\r\n        }\r\n    }\r\n\r\n    [void] UpdateNoteStats([string]$noteId, [int]$wordCount, [int]$lineCount) {\r\n        $this.UpdateNoteMetadata($noteId, @{\r\n            word_count = $wordCount\r\n            line_count = $lineCount\r\n        })\r\n    }\r\n\r\n    [void] DeleteNote([string]$noteId) {\r\n        if (-not $this._notesCache.ContainsKey($noteId)) {\r\n            throw \"Note not found: $noteId\"\r\n        }\r\n\r\n        $note = $this._notesCache[$noteId]\r\n\r\n        # Delete file\r\n        if (Test-Path $note.file) {\r\n            try {\r\n                Remove-Item $note.file -Force -ErrorAction Stop\r\n            } catch {\r\n                # Write-PmcTuiLog \"Failed to delete note file $($note.file): $_\" \"ERROR\"\r\n                throw \"Failed to delete note file: $($_.Exception.Message)\"\r\n            }\r\n        }\r\n\r\n        # Remove from cache\r\n        $this._notesCache.Remove($noteId)\r\n\r\n        # Persist\r\n        $this.SaveMetadata()\r\n\r\n        # Fire event\r\n        if ($this.OnNoteDeleted) {\r\n            & $this.OnNoteDeleted $noteId\r\n        }\r\n        if ($this.OnNotesChanged) {\r\n            & $this.OnNotesChanged\r\n        }\r\n    }\r\n\r\n    [string] LoadNoteContent([string]$noteId) {\r\n        if (-not $this._notesCache.ContainsKey($noteId)) {\r\n            throw \"Note not found: $noteId\"\r\n        }\r\n\r\n        $note = $this._notesCache[$noteId]\r\n\r\n        if (Test-Path $note.file) {\r\n            return Get-Content -Path $note.file -Raw\r\n        }\r\n\r\n        return \"\"\r\n    }\r\n\r\n    [void] SaveNoteContent([string]$noteId, [string]$content) {\r\n        if (-not $this._notesCache.ContainsKey($noteId)) {\r\n            throw \"Note not found: $noteId\"\r\n        }\r\n\r\n        $note = $this._notesCache[$noteId]\r\n\r\n        # Atomic save: write to temp file, then rename\r\n        $tempFile = \"$($note.file).tmp\"\r\n\r\n        try {\r\n            # PowerShell 7+ requires lowercase encoding names\r\n            Set-Content -Path $tempFile -Value $content -Encoding utf8\r\n\r\n            # Backup existing file\r\n            if (Test-Path $note.file) {\r\n                Copy-Item $note.file \"$($note.file).bak\" -Force\r\n            }\r\n\r\n            # Rename temp to actual\r\n            Move-Item -Path $tempFile -Destination $note.file -Force\r\n\r\n            # Calculate stats\r\n            if ([string]::IsNullOrEmpty($content)) {\r\n                $lineCount = 0\r\n                $wordCount = 0\r\n            } else {\r\n                $lineArray = @($content -split \"`n\")\r\n                $lineCount = $lineArray.Count\r\n                $wordArray = @($content -split '\\s+' | Where-Object { -not [string]::IsNullOrWhiteSpace($_) })\r\n                $wordCount = $(if ($wordArray) { $wordArray.Count } else { 0 })\r\n            }\r\n\r\n            # Update metadata\r\n            $this.UpdateNoteStats($noteId, $wordCount, $lineCount)\r\n\r\n        } catch {\r\n            # Clean up temp file if it exists\r\n            if (Test-Path $tempFile) {\r\n                Remove-Item $tempFile -Force -ErrorAction SilentlyContinue\r\n            }\r\n            throw\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/services/PreferencesService.ps1", "content": "# PreferencesService.ps1 - User preferences persistence\r\n#\r\n# M-CFG-2: Preferences Persistence\r\n# Saves and loads user preferences like sort order, view modes, column widths,\r\n# theme settings, and other user-specific configuration.\r\n#\r\n# Usage:\r\n#   $prefs = [PreferencesService]::GetInstance()\r\n#   $prefs.SetPreference('defaultViewMode', 'active')\r\n#   $viewMode = $prefs.GetPreference('defaultViewMode', 'all')\r\n#   $prefs.SavePreferences()\r\n\r\nusing namespace System\r\nusing namespace System.IO\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nUser preferences persistence service\r\n\r\n.DESCRIPTION\r\nSingleton service that manages user preferences for PMC TUI.\r\nPreferences are stored in JSON format in the user's config directory.\r\n\r\nSupported preferences:\r\n- defaultViewMode: Default task list view (all, active, blocked, etc.)\r\n- defaultSortColumn: Default column to sort by\r\n- defaultSortAscending: Default sort direction\r\n- defaultPriority: Default priority for new tasks\r\n- showCompleted: Show completed tasks by default\r\n- columnWidths: Custom column widths\r\n- theme: Selected theme name\r\n- useSymbols: Use Unicode symbols vs text alternatives\r\n- dateFormat: Preferred date format\r\n- timeFormat: Preferred time format\r\n\r\n.EXAMPLE\r\n$prefs = [PreferencesService]::GetInstance()\r\n$prefs.SetPreference('defaultViewMode', 'active')\r\n$prefs.SavePreferences()\r\n##CLOSEBRACKET##\r\nclass PreferencesService {\r\n    # Singleton instance\r\n    static [PreferencesService]$_instance = $null\r\n\r\n    # Preferences storage\r\n    hidden [hashtable]$_preferences = @{}\r\n\r\n    # File path for preferences\r\n    hidden [string]$_preferencesPath = \"\"\r\n\r\n    # Dirty flag for unsaved changes\r\n    hidden [bool]$_isDirty = $false\r\n\r\n    # Default preferences\r\n    hidden [hashtable]$_defaults = @{\r\n        # View preferences\r\n        defaultViewMode = 'active'\r\n        defaultSortColumn = 'due'\r\n        defaultSortAscending = $true\r\n        showCompleted = $false\r\n\r\n        # Task defaults\r\n        defaultPriority = 'medium'\r\n        defaultStatus = 'pending'\r\n\r\n        # UI preferences\r\n        useSymbols = $true\r\n        dateFormat = 'yyyy-MM-dd'\r\n        timeFormat = 'HH:mm'\r\n        theme = 'default'\r\n\r\n        # Column widths (null means auto)\r\n        columnWidths = @{\r\n            title = $null\r\n            due = 10\r\n            priority = 10\r\n            status = 12\r\n            project = 20\r\n            tags = 15\r\n        }\r\n\r\n        # Performance preferences\r\n        enableVirtualScrolling = $true\r\n        maxVisibleRows = 1000\r\n        searchDebounceMs = 150\r\n        cacheRefreshIntervalMs = 500\r\n        showEditorStatistics = $false\r\n\r\n        # Accessibility\r\n        screenReaderMode = $false\r\n        highContrastMode = $false\r\n        largeFont = $false\r\n\r\n        # Auto-save preferences\r\n        autoSaveEnabled = $true\r\n        autoSaveIntervalSeconds = 300\r\n    }\r\n\r\n    # === Singleton Pattern ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get the singleton instance of PreferencesService\r\n\r\n    .OUTPUTS\r\n    PreferencesService singleton instance\r\n    ##CLOSEBRACKET##\r\n    static [PreferencesService] GetInstance() {\r\n        if ($null -eq [PreferencesService]::_instance) {\r\n            [PreferencesService]::_instance = [PreferencesService]::new()\r\n        }\r\n        return [PreferencesService]::_instance\r\n    }\r\n\r\n    # Private constructor for singleton\r\n    hidden PreferencesService() {\r\n        $this._InitializePreferencesPath()\r\n        $this._LoadPreferences()\r\n    }\r\n\r\n    # === Initialization ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Initialize preferences file path\r\n\r\n    .DESCRIPTION\r\n    Determines where to store preferences based on environment and platform\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _InitializePreferencesPath() {\r\n        # PORTABILITY: Use local directory for self-contained deployment\r\n        # Priority: ENV > Get-PmcConfigPath > Local .pmc-data directory\r\n        $configPath = $(if ($env:PMC_CONFIG_PATH) {\r\n            # Explicit override via environment variable\r\n            $env:PMC_CONFIG_PATH\r\n        } elseif (Get-Command Get-PmcConfigPath -ErrorAction SilentlyContinue) {\r\n            # Use PMC module's config path if available\r\n            Get-PmcConfigPath\r\n        } else {\r\n            # Default: Use .pmc-data directory relative to module root (self-contained)\r\n            $moduleRoot = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent\r\n            Join-Path $moduleRoot \".pmc-data\"\r\n        })\r\n\r\n        # Ensure directory exists\r\n        if (-not (Test-Path $configPath)) {\r\n            New-Item -ItemType Directory -Path $configPath -Force | Out-Null\r\n        }\r\n\r\n        $this._preferencesPath = Join-Path $configPath \"preferences.json\"\r\n\r\n        if ((Get-Variable -Name 'PmcTuiLogFile' -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcTuiLogFile) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] PreferencesService: Preferences path: $($this._preferencesPath)\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Load preferences from file\r\n\r\n    .DESCRIPTION\r\n    Loads preferences from JSON file, validates them, and merges with defaults\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _LoadPreferences() {\r\n        try {\r\n            if (Test-Path $this._preferencesPath) {\r\n                $json = Get-Content -Path $this._preferencesPath -Raw\r\n                $loaded = $json | ConvertFrom-Json -AsHashtable\r\n\r\n                if ((Get-Variable -Name 'PmcTuiLogFile' -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcTuiLogFile) {\r\n                    Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] PreferencesService: Loaded preferences from file\"\r\n                }\r\n\r\n                # M-CFG-6: Config Validation - validate loaded preferences\r\n                $validated = $this._ValidatePreferences($loaded)\r\n\r\n                # Merge with defaults (defaults for missing keys)\r\n                $this._preferences = $this._MergeWithDefaults($validated)\r\n                $this._isDirty = $false\r\n            } else {\r\n                if ((Get-Variable -Name 'PmcTuiLogFile' -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcTuiLogFile) {\r\n                    Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] PreferencesService: No preferences file found, using defaults\"\r\n                }\r\n\r\n                # Use defaults\r\n                $this._preferences = $this._defaults.Clone()\r\n                $this._isDirty = $true  # Mark dirty to save defaults\r\n            }\r\n        } catch {\r\n            if ((Get-Variable -Name 'PmcTuiLogFile' -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] PreferencesService: Error loading preferences: $_\"\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] PreferencesService: Using defaults\"\r\n            }\r\n\r\n            # On error, use defaults\r\n            $this._preferences = $this._defaults.Clone()\r\n            $this._isDirty = $true\r\n        }\r\n    }\r\n\r\n    # === Validation ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Validate preferences object\r\n\r\n    .PARAMETER prefs\r\n    Preferences hashtable to validate\r\n\r\n    .OUTPUTS\r\n    Validated preferences hashtable\r\n\r\n    .DESCRIPTION\r\n    M-CFG-6: Config Validation\r\n    Validates each preference value, removes invalid ones, uses defaults for invalid values\r\n    ##CLOSEBRACKET##\r\n    hidden [hashtable] _ValidatePreferences([hashtable]$prefs) {\r\n        $validated = @{}\r\n\r\n        # Validate each preference\r\n        foreach ($key in $prefs.Keys) {\r\n            $value = $prefs[$key]\r\n\r\n            switch ($key) {\r\n                'defaultViewMode' {\r\n                    $validModes = @('all', 'active', 'completed', 'blocked', 'overdue', 'today', 'tomorrow', 'week', 'nextactions', 'noduedate', 'month', 'agenda', 'upcoming')\r\n                    if ($value -in $validModes) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'defaultSortColumn' {\r\n                    $validColumns = @('title', 'due', 'priority', 'status', 'project', 'created', 'modified')\r\n                    if ($value -in $validColumns) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'defaultPriority' {\r\n                    $validPriorities = @('high', 'medium', 'low', 'none')\r\n                    if ($value -in $validPriorities) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'defaultStatus' {\r\n                    $validStatuses = @('pending', 'active', 'completed', 'blocked', 'cancelled', 'deferred')\r\n                    if ($value -in $validStatuses) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'defaultSortAscending' {\r\n                    if ($value -is [bool]) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'showCompleted' {\r\n                    if ($value -is [bool]) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'useSymbols' {\r\n                    if ($value -is [bool]) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'enableVirtualScrolling' {\r\n                    if ($value -is [bool]) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'maxVisibleRows' {\r\n                    if ($value -is [int] -and $value -gt 0 -and $value -le 10000) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'searchDebounceMs' {\r\n                    if ($value -is [int] -and $value -ge 0 -and $value -le 5000) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'cacheRefreshIntervalMs' {\r\n                    if ($value -is [int] -and $value -ge 0 -and $value -le 10000) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'showEditorStatistics' {\r\n                    if ($value -is [bool]) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                'autoSaveIntervalSeconds' {\r\n                    if ($value -is [int] -and $value -ge 30 -and $value -le 3600) {\r\n                        $validated[$key] = $value\r\n                    }\r\n                }\r\n                default {\r\n                    # For unknown keys or complex types (columnWidths, etc), just pass through\r\n                    $validated[$key] = $value\r\n                }\r\n            }\r\n        }\r\n\r\n        return $validated\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Merge preferences with defaults\r\n\r\n    .PARAMETER prefs\r\n    User preferences hashtable\r\n\r\n    .OUTPUTS\r\n    Merged hashtable with defaults filled in for missing keys\r\n    ##CLOSEBRACKET##\r\n    hidden [hashtable] _MergeWithDefaults([hashtable]$prefs) {\r\n        $merged = $this._defaults.Clone()\r\n\r\n        foreach ($key in $prefs.Keys) {\r\n            $merged[$key] = $prefs[$key]\r\n        }\r\n\r\n        return $merged\r\n    }\r\n\r\n    # === Public API ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get a preference value\r\n\r\n    .PARAMETER key\r\n    Preference key\r\n\r\n    .PARAMETER defaultValue\r\n    Default value if key doesn't exist (optional, uses system default if not provided)\r\n\r\n    .OUTPUTS\r\n    Preference value or default\r\n    ##CLOSEBRACKET##\r\n    [object] GetPreference([string]$key) {\r\n        if ($this._preferences.ContainsKey($key)) {\r\n            return $this._preferences[$key]\r\n        }\r\n\r\n        if ($this._defaults.ContainsKey($key)) {\r\n            return $this._defaults[$key]\r\n        }\r\n\r\n        return $null\r\n    }\r\n\r\n    [object] GetPreference([string]$key, [object]$defaultValue) {\r\n        if ($this._preferences.ContainsKey($key)) {\r\n            return $this._preferences[$key]\r\n        }\r\n\r\n        return $defaultValue\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set a preference value\r\n\r\n    .PARAMETER key\r\n    Preference key\r\n\r\n    .PARAMETER value\r\n    Preference value\r\n\r\n    .DESCRIPTION\r\n    Sets a preference and marks preferences as dirty (needing save)\r\n    ##CLOSEBRACKET##\r\n    [void] SetPreference([string]$key, [object]$value) {\r\n        $this._preferences[$key] = $value\r\n        $this._isDirty = $true\r\n\r\n        if ((Get-Variable -Name 'PmcTuiLogFile' -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcTuiLogFile) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] PreferencesService: Set preference '$key' = '$value'\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get all preferences\r\n\r\n    .OUTPUTS\r\n    Hashtable of all current preferences\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetAllPreferences() {\r\n        return $this._preferences.Clone()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Reset all preferences to defaults\r\n\r\n    .DESCRIPTION\r\n    M-CFG-4: Reset to Defaults functionality\r\n    ##CLOSEBRACKET##\r\n    [void] ResetToDefaults() {\r\n        $this._preferences = $this._defaults.Clone()\r\n        $this._isDirty = $true\r\n\r\n        if ((Get-Variable -Name 'PmcTuiLogFile' -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcTuiLogFile) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] PreferencesService: Reset all preferences to defaults\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Reset a specific preference to its default\r\n\r\n    .PARAMETER key\r\n    Preference key to reset\r\n\r\n    .DESCRIPTION\r\n    M-CFG-4: Reset to Defaults functionality\r\n    ##CLOSEBRACKET##\r\n    [void] ResetPreference([string]$key) {\r\n        if ($this._defaults.ContainsKey($key)) {\r\n            $this._preferences[$key] = $this._defaults[$key]\r\n            $this._isDirty = $true\r\n\r\n            if ((Get-Variable -Name 'PmcTuiLogFile' -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] PreferencesService: Reset preference '$key' to default\"\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Save preferences to file\r\n\r\n    .DESCRIPTION\r\n    Saves current preferences to JSON file\r\n    ##CLOSEBRACKET##\r\n    [void] SavePreferences() {\r\n        try {\r\n            # Convert to JSON with nice formatting\r\n            $json = $this._preferences | ConvertTo-Json -Depth 10\r\n\r\n            # Save to file\r\n            $json | Set-Content -Path $this._preferencesPath -Force\r\n\r\n            $this._isDirty = $false\r\n\r\n            if ((Get-Variable -Name 'PmcTuiLogFile' -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] PreferencesService: Saved preferences to $($this._preferencesPath)\"\r\n            }\r\n        } catch {\r\n            if ((Get-Variable -Name 'PmcTuiLogFile' -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcTuiLogFile) {\r\n                Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] PreferencesService: Error saving preferences: $_\"\r\n            }\r\n            throw\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Check if preferences have unsaved changes\r\n\r\n    .OUTPUTS\r\n    Boolean indicating if preferences are dirty\r\n    ##CLOSEBRACKET##\r\n    [bool] IsDirty() {\r\n        return $this._isDirty\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get the preferences file path\r\n\r\n    .OUTPUTS\r\n    String path to preferences file\r\n    ##CLOSEBRACKET##\r\n    [string] GetPreferencesPath() {\r\n        return $this._preferencesPath\r\n    }\r\n}\r\n\r\n# Export for module usage\r\nif ($MyInvocation.InvocationName -ne '.') {\r\n    try {\r\n        Export-ModuleMember -Variable PreferencesService\r\n    } catch {\r\n        # Ignore Export-ModuleMember errors when not in a module context\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/services/TaskStore.ps1", "content": "# TaskStore.ps1 - Centralized Observable Data Store for PMC TUI\n#\n# SINGLETON pattern - provides centralized data access with:\n# - Load data once from Get-PmcAllData\n# - In-memory caching (tasks, projects, time logs)\n# - CRUD operations (Add, Update, Delete, Get)\n# - Event-driven updates (OnTaskAdded, OnTaskUpdated, OnTaskDeleted, etc.)\n# - Auto-persistence via Set-PmcAllData\n# - Thread-safe operations\n# - Validation and error handling\n# - Rollback on save failure\n#\n# Usage:\n#   $store = [TaskStore]::GetInstance()\n#\n#   # CRUD operations\n#   $task = $store.GetTask($id)\n#   $allTasks = $store.GetAllTasks()\n#   $store.AddTask($task)        # Fires OnTaskAdded, persists\n#   $store.UpdateTask($id, $changes)  # Fires OnTaskUpdated, persists\n#   $store.DeleteTask($id)       # Fires OnTaskDeleted, persists\n#\n#   # Subscribe to changes\n#   $store.OnTaskAdded = { param($task) $this.RefreshUI() }\n#   $store.OnTaskUpdated = { param($task) $this.RefreshUI() }\n#   $store.OnTaskDeleted = { param($id) $this.RefreshUI() }\n#\n# The store automatically persists changes to disk and provides\n# rollback capabilities if persistence fails.\n\nusing namespace System\nusing namespace System.Collections.Generic\nusing namespace System.Threading\n\nSet-StrictMode -Version Latest\n\n<#\n.SYNOPSIS\nCentralized observable data store for PMC data with event-driven updates\n\n.DESCRIPTION\nTaskStore provides:\n- Singleton instance for centralized data access\n- In-memory caching of tasks, projects, time logs\n- CRUD operations with automatic persistence\n- Event callbacks for data changes (OnTaskAdded, OnTaskUpdated, etc.)\n- Validation before persistence\n- Rollback on save failure\n- Thread-safe operations with locking\n- Query methods (filtering, searching)\n- Batch operations for performance\n\n.EXAMPLE\n$store = [TaskStore]::GetInstance()\n$store.AddTask(@{ text='Buy milk'; project='personal'; priority=3 })\n##CLOSEBRACKET##\nclass TaskStore {\n    # === Singleton Instance ===\n    static hidden [TaskStore]$_instance = $null\n    static hidden [object]$_instanceLock = [object]::new()\n\n    # === Data Storage ===\n    hidden [hashtable]$_data = @{\n        tasks    = @()\n        projects = @()\n        timelogs = @()\n        settings = @{}\n        metadata = @{\n            lastLoaded = $null\n            lastSaved  = $null\n            version    = \"1.0\"\n        }\n    }\n\n    # === Backup for Rollback ===\n    hidden [hashtable]$_dataBackup = $null\n\n    # === Thread Safety ===\n    hidden [object]$_dataLock = [object]::new()\n\n    # === Event Callbacks - Tasks ===\n    [scriptblock]$OnTaskAdded = {}\n    [scriptblock]$OnTaskUpdated = {}\n    [scriptblock]$OnTaskDeleted = {}\n    [scriptblock]$OnTasksChanged = {}  # Fired after any task change\n\n    # === Event Callbacks - Projects ===\n    [scriptblock]$OnProjectAdded = {}\n    [scriptblock]$OnProjectUpdated = {}\n    [scriptblock]$OnProjectDeleted = {}\n    [scriptblock]$OnProjectsChanged = {}\n\n    # === Event Callbacks - Time Logs ===\n    [scriptblock]$OnTimeLogAdded = {}\n    [scriptblock]$OnTimeLogUpdated = {}\n    [scriptblock]$OnTimeLogDeleted = {}\n    [scriptblock]$OnTimeLogsChanged = {}\n\n    # === Event Callbacks - Global ===\n    [scriptblock]$OnDataChanged = {}   # Fired after any data change\n    [scriptblock]$OnLoadError = {}     # Fired when load fails\n    [scriptblock]$OnSaveError = {}     # Fired when save fails\n\n    # === State Flags ===\n    [bool]$IsLoaded = $false\n    [bool]$IsSaving = $false\n    [string]$LastError = \"\"\n    [bool]$AutoSave = $true  # CRITICAL: Enable by default to prevent data loss\n    [bool]$HasPendingChanges = $false  # True when changes need to be saved\n\n    # === Cached Statistics ===\n    hidden [hashtable]$_cachedStats = $null\n    hidden [bool]$_statsNeedUpdate = $true\n\n    # === Validation Rules ===\n    hidden [hashtable]$_validationRules = @{\n        task    = @{\n            required = @('text')\n            types    = @{\n                id        = 'string'\n                text      = 'string'\n                details   = 'string'\n                project   = 'string'\n                priority  = 'int'\n                status    = 'string'\n                due       = 'datetime'\n                tags      = 'array'\n                completed = 'bool'\n                created   = 'datetime'\n                parent_id = 'string'\n            }\n        }\n        project = @{\n            required = @('name')\n            types    = @{\n                id              = 'string'\n                name            = 'string'\n                description     = 'string'\n                created         = 'datetime'\n                status          = 'string'\n                tags            = 'array'\n                ID1             = 'string'\n                ID2             = 'string'\n                ProjFolder      = 'string'\n                CAAName         = 'string'\n                RequestName     = 'string'\n                T2020           = 'string'\n                AssignedDate    = 'datetime'\n                DueDate         = 'datetime'\n                BFDate          = 'datetime'\n                RequestDate     = 'datetime'\n                AuditType       = 'string'\n                AuditorName     = 'string'\n                AuditorPhone    = 'string'\n                AuditorTL       = 'string'\n                AuditorTLPhone  = 'string'\n                AuditCase       = 'string'\n                CASCase         = 'string'\n                AuditStartDate  = 'datetime'\n                TPName          = 'string'\n                TPNum           = 'string'\n                Address         = 'string'\n                City            = 'string'\n                Province        = 'string'\n                PostalCode      = 'string'\n                Country         = 'string'\n                AuditPeriodFrom = 'datetime'\n                AuditPeriodTo   = 'datetime'\n            }\n        }\n        timelog = @{\n            required = @('date', 'minutes')\n            types    = @{\n                date     = 'datetime'\n                task     = 'string'\n                project  = 'string'\n                timecode = 'string'\n                id1      = 'string'\n                id2      = 'string'\n                minutes  = 'int'\n                notes    = 'string'\n                created  = 'datetime'\n            }\n        }\n    }\n\n    # === Constructor (Private) ===\n    TaskStore() {\n        # Private constructor for singleton\n        $this._InitializeStore()\n    }\n\n    # === Singleton Pattern ===\n\n    <#\n    .SYNOPSIS\n    Get the singleton instance of TaskStore\n\n    .OUTPUTS\n    TaskStore singleton instance\n    ##CLOSEBRACKET##\n    static [TaskStore] GetInstance() {\n        if ($null -eq [TaskStore]::_instance) {\n            [Monitor]::Enter([TaskStore]::_instanceLock)\n            try {\n                if ($null -eq [TaskStore]::_instance) {\n                    [TaskStore]::_instance = [TaskStore]::new()\n                    if (-not [TaskStore]::_instance.LoadData()) {\n                        # FAIL FAST: Do not allow app to start with empty/corrupted state.\n                        $err = [TaskStore]::_instance.LastError\n                        [TaskStore]::_instance = $null # Reset instance so retry is possible\n                        throw \"CRITICAL: TaskStore failed to load data. Aborting to prevent data loss. Error: $err\"\n                    }\n                }\n            }\n            finally {\n                [Monitor]::Exit([TaskStore]::_instanceLock)\n            }\n        }\n\n        return [TaskStore]::_instance\n    }\n\n    <#\n    .SYNOPSIS\n    Reset the singleton instance (for testing)\n    ##CLOSEBRACKET##\n    static [void] ResetInstance() {\n        [Monitor]::Enter([TaskStore]::_instanceLock)\n        try {\n            [TaskStore]::_instance = $null\n        }\n        finally {\n            [Monitor]::Exit([TaskStore]::_instanceLock)\n        }\n    }\n\n    # === Data Loading ===\n\n    <#\n    .SYNOPSIS\n    Initialize the store\n    ##CLOSEBRACKET##\n    hidden [void] _InitializeStore() {\n        $this._data.tasks = [System.Collections.ArrayList]::new()\n        $this._data.projects = [System.Collections.ArrayList]::new()\n        $this._data.timelogs = [System.Collections.ArrayList]::new()\n        $this.IsLoaded = $false\n    }\n\n    <#\n    .SYNOPSIS\n    Load data from Get-PmcAllData\n\n    .OUTPUTS\n    True if load succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] LoadData() {\n        # Write-PmcTuiLog \"TaskStore.LoadData: Starting\" \"DEBUG\"\n        [Monitor]::Enter($this._dataLock)\n        try {\n            try {\n                # FIX: Call Get-PmcData via explicit module invocation\n                # Write-PmcTuiLog \"TaskStore.LoadData: Calling Get-PmcData\" \"DEBUG\"\n                $pmcModule = Get-Module -Name 'Pmc.Strict'\n                $pmcData = & $pmcModule { Get-PmcData }\n                # Write-PmcTuiLog \"TaskStore.LoadData: Get-PmcData returned - tasks=$($pmcData.tasks.Count) projects=$($pmcData.projects.Count) timelogs=$($pmcData.timelogs.Count)\" \"DEBUG\"\n\n                if ($null -eq $pmcData) {\n                    $this.LastError = \"Get-PmcData returned null\"\n                    # Write-PmcTuiLog \"TaskStore.LoadData: ERROR - Get-PmcData returned null\" \"ERROR\"\n                    $this._InvokeCallback($this.OnLoadError, $this.LastError)\n                    return $false\n                }\n\n                # Extract data sections\n                if ($pmcData.tasks) {\n                    $this._data.tasks = [System.Collections.ArrayList]::new()\n                    foreach ($task in $pmcData.tasks) {\n                        # Convert PSCustomObject to hashtable if needed\n                        if ($task -isnot [hashtable]) {\n                            $taskHash = @{}\n                            foreach ($prop in $task.PSObject.Properties) {\n                                $taskHash[$prop.Name] = $prop.Value\n                            }\n                            [void]$this._data.tasks.Add($taskHash)\n                        }\n                        else {\n                            [void]$this._data.tasks.Add($task)\n                        }\n                    }\n                    # Write-PmcTuiLog \"TaskStore.LoadData: Loaded $($this._data.tasks.Count) tasks\" \"DEBUG\"\n                }\n                else {\n                    $this._data.tasks = [System.Collections.ArrayList]::new()\n                    # Write-PmcTuiLog \"TaskStore.LoadData: No tasks in data, initialized empty list\" \"DEBUG\"\n                }\n\n                if ($pmcData.projects) {\n                    $this._data.projects = [System.Collections.ArrayList]::new()\n                    foreach ($project in $pmcData.projects) {\n                        # Convert PSCustomObject to hashtable if needed\n                        if ($project -isnot [hashtable]) {\n                            $projectHash = @{}\n                            foreach ($prop in $project.PSObject.Properties) {\n                                $projectHash[$prop.Name] = $prop.Value\n                            }\n                            [void]$this._data.projects.Add($projectHash)\n                        }\n                        else {\n                            [void]$this._data.projects.Add($project)\n                        }\n                    }\n                    # Write-PmcTuiLog \"TaskStore.LoadData: Loaded $($this._data.projects.Count) projects\" \"DEBUG\"\n                    if ($this._data.projects.Count -gt 0) {\n                        $firstProj = $this._data.projects[0]\n                        # Write-PmcTuiLog \"TaskStore.LoadData: First project name='$(Get-SafeProperty $firstProj 'name')' ID1='$(Get-SafeProperty $firstProj 'ID1')'\" \"DEBUG\"\n                    }\n                }\n                else {\n                    $this._data.projects = [System.Collections.ArrayList]::new()\n                    # Write-PmcTuiLog \"TaskStore.LoadData: No projects in data, initialized empty list\" \"DEBUG\"\n                }\n\n                if ($pmcData.timelogs) {\n                    $this._data.timelogs = [System.Collections.ArrayList]::new()\n                    foreach ($log in $pmcData.timelogs) {\n                        # Convert PSCustomObject to hashtable if needed\n                        if ($log -isnot [hashtable]) {\n                            $logHash = @{}\n                            foreach ($prop in $log.PSObject.Properties) {\n                                $logHash[$prop.Name] = $prop.Value\n                            }\n                            [void]$this._data.timelogs.Add($logHash)\n                        }\n                        else {\n                            [void]$this._data.timelogs.Add($log)\n                        }\n                    }\n                }\n                else {\n                    $this._data.timelogs = [System.Collections.ArrayList]::new()\n                }\n\n                if ($pmcData.settings) {\n                    $this._data.settings = $pmcData.settings\n                }\n                else {\n                    $this._data.settings = @{}\n                }\n\n                $this._data.metadata.lastLoaded = Get-Date\n                $this.IsLoaded = $true\n                $this.LastError = \"\"\n\n                return $true\n            }\n            catch {\n                $this.LastError = \"Failed to load data: $($_.Exception.Message)\"\n                # Write-PmcTuiLog \"TaskStore.LoadData: EXCEPTION: $($_.Exception.Message)\" \"ERROR\"\n                # Write-PmcTuiLog \"TaskStore.LoadData: Stack trace: $($_.ScriptStackTrace)\" \"ERROR\"\n                $this._InvokeCallback($this.OnLoadError, $this.LastError)\n                return $false\n            }\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Reload data from disk (discards in-memory changes)\n\n    .OUTPUTS\n    True if reload succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] ReloadData() {\n        return $this.LoadData()\n    }\n\n    # === Data Persistence ===\n\n    <#\n    .SYNOPSIS\n    Save all data to disk via Set-PmcAllData\n\n    .OUTPUTS\n    True if save succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] SaveData() {\n        # CRITICAL FIX #3: Acquire lock BEFORE checking IsSaving to prevent race condition\n        [Monitor]::Enter($this._dataLock)\n        try {\n            # Check IsSaving INSIDE the lock to ensure thread safety\n            if ($this.IsSaving) {\n                $this.LastError = \"Save already in progress\"\n                # Write-PmcTuiLog \"TaskStore.SaveData: Already saving, returning false\" \"ERROR\"\n                return $false\n            }\n\n            $this.IsSaving = $true\n            # Write-PmcTuiLog \"TaskStore.SaveData: START - tasks=$($this._data.tasks.Count) projects=$($this._data.projects.Count) timelogs=$($this._data.timelogs.Count)\" \"INFO\"\n\n            try {\n                # PHASE 1: Create in-memory backup for rollback\n                # Write-PmcTuiLog \"TaskStore.SaveData: Creating in-memory backup\" \"DEBUG\"\n                $this._CreateBackup()\n\n                # PHASE 2: Create persistent timestamped backup before destructive operation\n                # Write-PmcTuiLog \"TaskStore.SaveData: Creating persistent backup\" \"DEBUG\"\n                $this._CreatePersistentBackup()\n\n                # PHASE 3: Build data structure for Save-PmcData\n                # Write-PmcTuiLog \"TaskStore.SaveData: Building data structure\" \"DEBUG\"\n                $dataToSave = @{\n                    tasks    = $this._data.tasks.ToArray()\n                    projects = $this._data.projects.ToArray()\n                    timelogs = $this._data.timelogs.ToArray()\n                    settings = $this._data.settings\n                }\n\n                # Write-PmcTuiLog \"TaskStore.SaveData: Data structure built - tasks=$($dataToSave.tasks.Count) projects=$($dataToSave.projects.Count) timelogs=$($dataToSave.timelogs.Count)\" \"INFO\"\n                \n                # Log first task/project for verification\n                if ($dataToSave.tasks.Count -gt 0) {\n                    $firstTask = $dataToSave.tasks[0]\n                    # Write-PmcTuiLog \"TaskStore.SaveData: First task - text='$(Get-SafeProperty $firstTask 'text')' id='$(Get-SafeProperty $firstTask 'id')'\" \"DEBUG\"\n                }\n                if ($dataToSave.projects.Count -gt 0) {\n                    $firstProject = $dataToSave.projects[0]\n                    # Write-PmcTuiLog \"TaskStore.SaveData: First project - name='$(Get-SafeProperty $firstProject 'name')' ID1='$(Get-SafeProperty $firstProject 'ID1')'\" \"DEBUG\"\n                }\n\n                # PHASE 4: Call Save-PmcData via explicit module invocation\n                # Write-PmcTuiLog \"TaskStore.SaveData: Calling Save-PmcData\" \"INFO\"\n                $pmcModule = Get-Module -Name 'Pmc.Strict'\n                if ($null -eq $pmcModule) {\n                    $this.LastError = \"Pmc.Strict module not loaded - cannot save\"\n                    # Write-PmcTuiLog \"TaskStore.SaveData: FATAL - Pmc.Strict module not found\" \"ERROR\"\n                    return $false\n                }\n                \n                & $pmcModule { param($data) Save-PmcData -Data $data } $dataToSave\n                # Write-PmcTuiLog \"TaskStore.SaveData: Save-PmcData completed successfully\" \"INFO\"\n\n                # PHASE 5: Verify save success\n                # Write-PmcTuiLog \"TaskStore.SaveData: Verifying save\" \"DEBUG\"\n                $this._VerifySave($dataToSave)\n\n                # PHASE 6: Update metadata\n                $this._data.metadata.lastSaved = Get-Date\n                $this.LastError = \"\"\n                $this.HasPendingChanges = $false\n\n                # Clear in-memory backup on successful save\n                $this._dataBackup = $null\n\n                # Write-PmcTuiLog \"TaskStore.SaveData: SUCCESS - Data saved and verified\" \"INFO\"\n                return $true\n            }\n            catch {\n                $this.LastError = \"Failed to save data: $($_.Exception.Message)\"\n                # Write-PmcTuiLog \"TaskStore.SaveData: EXCEPTION: $($_.Exception.Message)\" \"ERROR\"\n                # Write-PmcTuiLog \"TaskStore.SaveData: Exception type: $($_.Exception.GetType().FullName)\" \"ERROR\"\n                # Write-PmcTuiLog \"TaskStore.SaveData: Stack trace: $($_.ScriptStackTrace)\" \"ERROR\"\n                \n                # Log actionable error guidance\n                # Write-PmcTuiLog \"TaskStore.SaveData: ERROR GUIDANCE:\" \"ERROR\"\n                # Write-PmcTuiLog \"  1. Check log for detailed error above\" \"ERROR\"\n                # Write-PmcTuiLog \"  2. Verify disk space available\" \"ERROR\"\n                # Write-PmcTuiLog \"  3. Check file permissions on tasks.json\" \"ERROR\"\n                # Write-PmcTuiLog \"  4. Look for backup files: tasks.json.backup.*\" \"ERROR\"\n\n                $this._InvokeCallback($this.OnSaveError, $this.LastError)\n\n                # Rollback to in-memory backup\n                # Write-PmcTuiLog \"TaskStore.SaveData: Rolling back to in-memory backup\" \"INFO\"\n                $this._Rollback()\n\n                return $false\n            }\n        }\n        finally {\n            $this.IsSaving = $false\n            [Monitor]::Exit($this._dataLock)\n            # Write-PmcTuiLog \"TaskStore.SaveData: END\" \"DEBUG\"\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Create backup of current data for rollback\n    ##CLOSEBRACKET##\n    hidden [void] _CreateBackup() {\n        # Create shallow copy of arrays - deep copy not needed for backup/rollback\n        $tasksCopy = [System.Collections.ArrayList]::new()\n        foreach ($task in $this._data.tasks) { $tasksCopy.Add($task) | Out-Null }\n\n        $projectsCopy = [System.Collections.ArrayList]::new()\n        foreach ($project in $this._data.projects) { $projectsCopy.Add($project) | Out-Null }\n\n        $timelogsCopy = [System.Collections.ArrayList]::new()\n        foreach ($log in $this._data.timelogs) { $timelogsCopy.Add($log) | Out-Null }\n\n        $this._dataBackup = @{\n            tasks    = $tasksCopy\n            projects = $projectsCopy\n            timelogs = $timelogsCopy\n            settings = $this._data.settings\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Rollback to backup data\n    ##CLOSEBRACKET##\n    hidden [void] _Rollback() {\n        if ($null -ne $this._dataBackup) {\n            $this._data.tasks = $this._dataBackup.tasks\n            $this._data.projects = $this._dataBackup.projects\n            $this._data.timelogs = $this._dataBackup.timelogs\n            $this._data.settings = $this._dataBackup.settings\n            $this._dataBackup = $null\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Create persistent timestamped backup before save (separate from in-memory backup)\n    \n    .DESCRIPTION\n    Creates a backup file like tasks.json.backup.20231215-143527\n    Keeps last 5 backups, deletes older ones\n    This protects against corruption from save failures\n    ##CLOSEBRACKET##\n    hidden [void] _CreatePersistentBackup() {\n        try {\n            # Get tasks.json path\n            $pmcModule = Get-Module -Name 'Pmc.Strict'\n            if ($null -eq $pmcModule) {\n                # Write-PmcTuiLog \"_CreatePersistentBackup: Pmc.Strict module not found, skipping backup\" \"WARNING\"\n                return\n            }\n\n            $tasksFile = & $pmcModule { Get-PmcTaskFilePath }\n            if (-not (Test-Path $tasksFile)) {\n                # Write-PmcTuiLog \"_CreatePersistentBackup: tasks.json does not exist yet, skipping backup\" \"DEBUG\"\n                return\n            }\n\n            # Create timestamped backup\n            $timestamp = Get-Date -Format 'yyyyMMdd-HHmmss'\n            $backupFile = \"$tasksFile.backup.$timestamp\"\n            \n            Copy-Item -Path $tasksFile -Destination $backupFile -Force\n            # Write-PmcTuiLog \"_CreatePersistentBackup: Created backup at $backupFile\" \"INFO\"\n\n            # Rotate backups - keep only last 5\n            $backupDir = Split-Path $tasksFile -Parent\n            $backupPattern = \"$(Split-Path $tasksFile -Leaf).backup.*\"\n            $backups = Get-ChildItem -Path $backupDir -Filter $backupPattern | \n                Sort-Object LastWriteTime -Descending\n\n            if ($backups.Count -gt 5) {\n                $toDelete = $backups | Select-Object -Skip 5\n                foreach ($old in $toDelete) {\n                    Remove-Item $old.FullName -Force\n                    # Write-PmcTuiLog \"_CreatePersistentBackup: Deleted old backup $($old.Name)\" \"DEBUG\"\n                }\n            }\n        }\n        catch {\n            # Backup creation is non-critical, log but continue\n            # Write-PmcTuiLog \"_CreatePersistentBackup: Failed to create backup: $_\" \"WARNING\"\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Verify save succeeded by re-loading data from disk\n    \n    .DESCRIPTION\n    Attempts to load tasks.json and verify task count matches\n    This catches save failures early\n    ##CLOSEBRACKET##\n    hidden [void] _VerifySave([hashtable]$savedData) {\n        try {\n            $pmcModule = Get-Module -Name 'Pmc.Strict'\n            if ($null -eq $pmcModule) {\n                # Write-PmcTuiLog \"_VerifySave: Pmc.Strict module not found, cannot verify\" \"WARNING\"\n                return\n            }\n\n            # Reload data from disk\n            $reloadedData = & $pmcModule { Get-PmcData }\n            \n            if ($null -eq $reloadedData) {\n                # Write-PmcTuiLog \"_VerifySave: Reloaded data is null!\" \"ERROR\"\n                throw \"Save verification failed - reloaded data is null\"\n            }\n\n            # Compare counts\n            $savedTasks = $savedData.tasks.Count\n            $reloadedTasks = if ($reloadedData.tasks) { @($reloadedData.tasks).Count } else { 0 }\n            \n            $savedProjects = $savedData.projects.Count  \n            $reloadedProjects = if ($reloadedData.projects) { @($reloadedData.projects).Count } else { 0 }\n\n            if ($savedTasks -ne $reloadedTasks) {\n                # Write-PmcTuiLog \"_VerifySave: Task count mismatch! Saved=$savedTasks Reloaded=$reloadedTasks\" \"ERROR\"\n                throw \"Save verification failed - task count mismatch (saved:$savedTasks vs reloaded:$reloadedTasks)\"\n            }\n\n            if ($savedProjects -ne $reloadedProjects) {\n                # Write-PmcTuiLog \"_VerifySave: Project count mismatch! Saved=$savedProjects Reloaded=$reloadedProjects\" \"ERROR\"\n                throw \"Save verification failed - project count mismatch (saved:$savedProjects vs reloaded:$reloadedProjects)\"\n            }\n\n            # Write-PmcTuiLog \"_VerifySave: Verification passed - tasks=$reloadedTasks projects=$reloadedProjects\" \"DEBUG\"\n        }\n        catch {\n            # Write-PmcTuiLog \"_VerifySave: Verification failed: $_\" \"ERROR\"\n            throw\n        }\n    }\n\n\n    # === Task CRUD Operations ===\n\n    <#\n    .SYNOPSIS\n    Get all tasks\n\n    .OUTPUTS\n    Array of task hashtables\n    ##CLOSEBRACKET##\n    [array] GetAllTasks() {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            # HIGH FIX #9: Always return array, never null\n            if ($null -eq $this._data.tasks) {\n                # Write-PmcTuiLog \"GetAllTasks: No tasks collection, returning empty array\" \"WARNING\"\n                return @()\n            }\n\n            $tasks = $this._data.tasks.ToArray()\n            # Write-PmcTuiLog \"GetAllTasks: Returning $($tasks.Count) tasks\" \"DEBUG\"\n            return $tasks\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Get task by ID\n\n    .PARAMETER id\n    Task ID\n\n    .OUTPUTS\n    Task hashtable or $null if not found\n\n    .NOTES\n    HIGH FIX #9: Consistent error handling pattern\n    - Collections (GetAllTasks, GetAllProjects) ALWAYS return arrays (never null)\n    - Single items (GetTask, GetProject) return object or $null\n    - Operations (Add, Update, Delete) return bool with LastError on failure\n    ##CLOSEBRACKET##\n    [hashtable] GetTask([string]$id) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            # HIGH FIX #9: Explicit null check with consistent behavior\n            if ([string]::IsNullOrWhiteSpace($id)) {\n                # Write-PmcTuiLog \"GetTask: Invalid ID (null or empty)\" \"WARNING\"\n                return $null\n            }\n\n            $task = $this._data.tasks | Where-Object { $_.id -eq $id } | Select-Object -First 1\n\n            if ($null -eq $task) {\n                # Write-PmcTuiLog \"GetTask: Task not found with ID '$id'\" \"DEBUG\"\n            }\n\n            return $task\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Add a new task\n\n    .PARAMETER task\n    Task hashtable (must include 'text' field minimum)\n\n    .OUTPUTS\n    True if add succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] AddTask([hashtable]$task) {\n        # Write-PmcTuiLog \"AddTask: Starting with task keys: $($task.Keys -join ', ')\" \"DEBUG\"\n        [Monitor]::Enter($this._dataLock)\n\n        $success = $false\n        $capturedTask = $null\n        $capturedTasks = $null\n\n        try {\n            # Validate task\n            $validationErrors = $this._ValidateEntity($task, 'task')\n            if ($validationErrors.Count -gt 0) {\n                $this.LastError = \"Task validation failed: $($validationErrors -join ', ')\"\n                # Write-PmcTuiLog \"AddTask: Validation FAILED: $($validationErrors -join ', ')\" \"ERROR\"\n                return $false\n            }\n            # Write-PmcTuiLog \"AddTask: Validation passed\" \"DEBUG\"\n\n            # Create backup BEFORE any modifications\n            $this._CreateBackup()\n\n            # Generate ID if not present\n            # LOW FIX ES-L5: Check for GUID collision (extremely rare but validate)\n            if (-not $task.ContainsKey('id') -or [string]::IsNullOrEmpty($task.id)) {\n                $maxRetries = 3\n                $retryCount = 0\n                $guidGenerated = $false\n                while (-not $guidGenerated -and $retryCount -lt $maxRetries) {\n                    $newGuid = [Guid]::NewGuid().ToString()\n                    # Check if this GUID already exists (collision check)\n                    $collision = $this._data.tasks | Where-Object { $_.id -eq $newGuid } | Select-Object -First 1\n                    if (-not $collision) {\n                        $task.id = $newGuid\n                        $guidGenerated = $true\n                    }\n                    else {\n                        # Write-PmcTuiLog \"GUID collision detected: $newGuid (retry $($retryCount + 1)/$maxRetries)\" \"WARNING\"\n                        $retryCount++\n                    }\n                }\n                if (-not $guidGenerated) {\n                    $this.LastError = \"Failed to generate unique GUID after $maxRetries attempts\"\n                    # Write-PmcTuiLog \"AddTask: GUID generation failed after $maxRetries retries\" \"ERROR\"\n                    return $false\n                }\n            }\n\n            # H-VAL-7: Check for duplicate ID before insert\n            $existingTask = $this._data.tasks | Where-Object { $_.id -eq $task.id } | Select-Object -First 1\n            if ($existingTask) {\n                $this.LastError = \"Task with ID '$($task.id)' already exists\"\n                # Write-PmcTuiLog \"AddTask: Duplicate ID detected: $($task.id)\" \"ERROR\"\n                return $false\n            }\n\n            # Add default status fields if not present\n            if (-not $task.ContainsKey('completed')) {\n                $task.completed = $false\n            }\n            if (-not $task.ContainsKey('status')) {\n                $task.status = 'pending'\n            }\n\n            # Add timestamps\n            $now = Get-Date\n            if (-not $task.ContainsKey('created')) {\n                $task.created = $now\n            }\n            $task.modified = $now\n\n            # Add to collection\n            $this._data.tasks.Add($task)\n            # Write-PmcTuiLog \"AddTask: Added to collection, total tasks=$($this._data.tasks.Count)\" \"DEBUG\"\n\n            # Mark pending changes and invalidate stats cache\n            $this.HasPendingChanges = $true\n            $this._statsNeedUpdate = $true\n\n            # Persist only if AutoSave is enabled\n            if ($this.AutoSave) {\n                if (-not $this.SaveData()) {\n                    # Write-PmcTuiLog \"AddTask: SaveData FAILED\" \"ERROR\"\n                    return $false\n                }\n                # Write-PmcTuiLog \"AddTask: SaveData succeeded\" \"DEBUG\"\n            }\n\n            # Capture data for callbacks BEFORE releasing lock\n            # Clone creates shallow copy - sufficient for callback isolation\n            $capturedTask = $(if ($task -is [hashtable]) { $task.Clone() } else { $task.PSObject.Copy() })\n            $capturedTasks = $this._data.tasks.ToArray()\n            $success = $true\n\n            # Write-PmcTuiLog \"AddTask: Success (lock held)\" \"DEBUG\"\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n\n        # Fire events AFTER releasing lock to avoid deadlock\n        if ($success) {\n            # Write-PmcTuiLog \"AddTask: Firing callbacks\" \"DEBUG\"\n            $this._InvokeCallback($this.OnTaskAdded, $capturedTask)\n            $this._InvokeCallback($this.OnTasksChanged, $capturedTasks)\n            $this._InvokeCallback($this.OnDataChanged, $null)\n        }\n\n        return $success\n    }\n\n    <#\n    .SYNOPSIS\n    Update an existing task\n\n    .PARAMETER id\n    Task ID\n\n    .PARAMETER changes\n    Hashtable of fields to update\n\n    .OUTPUTS\n    True if update succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] UpdateTask([string]$id, [hashtable]$changes) {\n        [Monitor]::Enter($this._dataLock)\n\n        $success = $false\n        $capturedTask = $null\n        $capturedTasks = $null\n\n        try {\n            # Find task\n            $task = $this._data.tasks | Where-Object { $_.id -eq $id } | Select-Object -First 1\n\n            if ($null -eq $task) {\n                $this.LastError = \"Task not found: $id\"\n                return $false\n            }\n\n            # Create backup BEFORE any modifications\n            $this._CreateBackup()\n\n            # CRITICAL FIX: Convert PSCustomObject to hashtable to prevent PowerShell's type coercion\n            # When assigning to PSCustomObject properties, PowerShell forces type conversion based on existing property type\n            if ($task -isnot [hashtable]) {\n                # Add-Content -Path \"$($env:TEMP)\\pmc-edit-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') TaskStore.UpdateTask: Converting PSCustomObject to hashtable\"\n                $taskHash = @{}\n                foreach ($prop in $task.PSObject.Properties) {\n                    $taskHash[$prop.Name] = $prop.Value\n                }\n                # Find and replace in the tasks list\n                $taskIndex = -1\n                for ($i = 0; $i -lt $this._data.tasks.Count; $i++) {\n                    if ((Get-SafeProperty $this._data.tasks[$i] 'id') -eq $id) {\n                        $taskIndex = $i\n                        break\n                    }\n                }\n                if ($taskIndex -ge 0) {\n                    $this._data.tasks[$taskIndex] = $taskHash\n                    $task = $taskHash\n                    # Add-Content -Path \"$($env:TEMP)\\pmc-edit-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') TaskStore.UpdateTask: Replaced task at index $taskIndex with hashtable\"\n                }\n            }\n\n            # Apply changes - now task is guaranteed to be hashtable\n            foreach ($key in $changes.Keys) {\n                if ($key -eq 'tags') {\n                    # Add-Content -Path \"$($env:TEMP)\\pmc-edit-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') TaskStore.UpdateTask: BEFORE setting tags - changes[$key] type=$($changes[$key].GetType().Name) isArray=$($changes[$key] -is [array]) value=$($changes[$key] -join ',')\"\n                }\n                $task[$key] = $changes[$key]\n                if ($key -eq 'tags') {\n                    # Add-Content -Path \"$($env:TEMP)\\pmc-edit-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') TaskStore.UpdateTask: AFTER setting tags - task.tags type=$($task[$key].GetType().Name) isArray=$($task[$key] -is [array]) value=$($task[$key] -join ',')\"\n                }\n            }\n\n            # Update modified timestamp\n            if ($task -is [hashtable]) {\n                $task['modified'] = Get-Date\n            }\n            elseif ($task.PSObject.Properties.Name -contains 'modified') {\n                $task.modified = Get-Date\n            }\n            else {\n                Add-Member -InputObject $task -MemberType NoteProperty -Name 'modified' -Value (Get-Date) -Force\n            }\n\n            # Validate updated task\n            # Add-Content -Path \"$($env:TEMP)\\pmc-edit-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') TaskStore.UpdateTask: BEFORE VALIDATION - task.tags type=$(if ($task.ContainsKey('tags')) { $task['tags'].GetType().FullName } else { 'MISSING' }) isArray=$(if ($task.ContainsKey('tags')) { $task['tags'] -is [array] } else { 'N/A' })\"\n            $validationErrors = $this._ValidateEntity($task, 'task')\n            # Add-Content -Path \"$($env:TEMP)\\pmc-edit-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') TaskStore.UpdateTask: AFTER VALIDATION - errors count=$($validationErrors.Count) errors=$($validationErrors -join '; ')\"\n            if ($validationErrors.Count -gt 0) {\n                $this.LastError = \"Task validation failed: $($validationErrors -join ', ')\"\n                $this._Rollback()\n                return $false\n            }\n\n            # Mark pending changes and invalidate stats cache\n            $this.HasPendingChanges = $true\n            $this._statsNeedUpdate = $true\n\n            # Persist only if AutoSave is enabled\n            if ($this.AutoSave) {\n                if (-not $this.SaveData()) {\n                    return $false\n                }\n            }\n\n            # Capture data for callbacks BEFORE releasing lock\n            # Clone creates shallow copy - sufficient for callback isolation\n            $capturedTask = $(if ($task -is [hashtable]) { $task.Clone() } else { $task.PSObject.Copy() })\n            $capturedTasks = $this._data.tasks.ToArray()\n            $success = $true\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n\n        # Fire events AFTER releasing lock to avoid deadlock\n        if ($success) {\n            $this._InvokeCallback($this.OnTaskUpdated, $capturedTask)\n            $this._InvokeCallback($this.OnTasksChanged, $capturedTasks)\n            $this._InvokeCallback($this.OnDataChanged, $null)\n        }\n\n        return $success\n    }\n\n    <#\n    .SYNOPSIS\n    Delete a task by ID\n\n    .PARAMETER id\n    Task ID\n\n    .OUTPUTS\n    True if delete succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] DeleteTask([string]$id) {\n        [Monitor]::Enter($this._dataLock)\n\n        $success = $false\n        $capturedId = $id\n        $capturedTasks = $null\n\n        try {\n            # Find task index\n            $index = -1\n            for ($i = 0; $i -lt $this._data.tasks.Count; $i++) {\n                if ($this._data.tasks[$i].id -eq $id) {\n                    $index = $i\n                    break\n                }\n            }\n\n            if ($index -eq -1) {\n                $this.LastError = \"Task not found: $id\"\n                return $false\n            }\n\n            # Create backup BEFORE any modifications\n            $this._CreateBackup()\n\n            # Remove task\n            $this._data.tasks.RemoveAt($index)\n\n            # Mark pending changes and invalidate stats cache\n            $this.HasPendingChanges = $true\n            $this._statsNeedUpdate = $true\n\n            # Persist only if AutoSave is enabled\n            if ($this.AutoSave) {\n                if (-not $this.SaveData()) {\n                    return $false\n                }\n            }\n\n            # Capture data for callbacks BEFORE releasing lock\n            $capturedTasks = $this._data.tasks.ToArray()\n            $success = $true\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n\n        # Fire events AFTER releasing lock to avoid deadlock\n        if ($success) {\n            $this._InvokeCallback($this.OnTaskDeleted, $capturedId)\n            $this._InvokeCallback($this.OnTasksChanged, $capturedTasks)\n            $this._InvokeCallback($this.OnDataChanged, $null)\n        }\n\n        return $success\n    }\n\n    # === Project CRUD Operations ===\n\n    <#\n    .SYNOPSIS\n    Get all projects\n\n    .OUTPUTS\n    Array of project hashtables\n    ##CLOSEBRACKET##\n    [array] GetAllProjects() {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            return $this._data.projects.ToArray()\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Get project by name\n\n    .PARAMETER name\n    Project name\n\n    .OUTPUTS\n    Project hashtable or $null if not found\n    ##CLOSEBRACKET##\n    [hashtable] GetProject([string]$name) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            $project = $this._data.projects | Where-Object { $_.name -eq $name } | Select-Object -First 1\n            return $project\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Add a new project\n\n    .PARAMETER project\n    Project hashtable (must include 'name' field minimum)\n\n    .OUTPUTS\n    True if add succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] AddProject([hashtable]$project) {\n        # Write-PmcTuiLog \"TaskStore.AddProject: START - name='$($project.name)'\" \"DEBUG\"\n        [Monitor]::Enter($this._dataLock)\n        try {\n            # Validate project\n            # Write-PmcTuiLog \"TaskStore.AddProject: Calling _ValidateEntity...\" \"DEBUG\"\n            $validationErrors = $this._ValidateEntity($project, 'project')\n            if ($validationErrors.Count -gt 0) {\n                $errorMsg = \"Project validation failed: $($validationErrors -join ', ')\"\n                $this.LastError = $errorMsg\n                # Write-PmcTuiLog \"TaskStore.AddProject: FAILED - $errorMsg\" \"ERROR\"\n                return $false\n            }\n            # Write-PmcTuiLog \"TaskStore.AddProject: Validation passed\" \"DEBUG\"\n\n            # Check for duplicate name\n            $existing = $this._data.projects | Where-Object { $_.name -eq $project.name }\n            if ($existing) {\n                $errorMsg = \"Project already exists: $($project.name)\"\n                $this.LastError = $errorMsg\n                # Write-PmcTuiLog \"TaskStore.AddProject: FAILED - $errorMsg\" \"ERROR\"\n                return $false\n            }\n            # Write-PmcTuiLog \"TaskStore.AddProject: No duplicate found\" \"DEBUG\"\n\n            # Create backup BEFORE any modifications\n            $this._CreateBackup()\n\n            # Add timestamps\n            $now = Get-Date\n            if (-not $project.ContainsKey('created')) {\n                $project.created = $now\n            }\n            $project.modified = $now\n\n            # Add to collection\n            # Write-PmcTuiLog \"TaskStore.AddProject: Adding to collection...\" \"DEBUG\"\n            $this._data.projects.Add($project)\n\n            # Mark pending changes\n            $this.HasPendingChanges = $true\n\n            # Persist only if AutoSave is enabled\n            if ($this.AutoSave) {\n                # Write-PmcTuiLog \"TaskStore.AddProject: AutoSave enabled, calling SaveData...\" \"DEBUG\"\n                if (-not $this.SaveData()) {\n                    # Write-PmcTuiLog \"TaskStore.AddProject: FAILED - SaveData returned false\" \"ERROR\"\n                    return $false\n                }\n                # Write-PmcTuiLog \"TaskStore.AddProject: SaveData succeeded\" \"DEBUG\"\n            }\n\n            # Fire events\n            $this._InvokeCallback($this.OnProjectAdded, $project)\n            $this._InvokeCallback($this.OnProjectsChanged, $this._data.projects.ToArray())\n            $this._InvokeCallback($this.OnDataChanged, $null)\n\n            # Write-PmcTuiLog \"TaskStore.AddProject: SUCCESS\" \"DEBUG\"\n            return $true\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Update an existing project\n\n    .PARAMETER name\n    Project name\n\n    .PARAMETER changes\n    Hashtable of fields to update\n\n    .OUTPUTS\n    True if update succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] UpdateProject([string]$name, [hashtable]$changes) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            # Write-PmcTuiLog \"UpdateProject: START - name='$name' changes=$($changes.Count)\" \"DEBUG\"\n\n            # Find project\n            $project = $this._data.projects | Where-Object { $_.name -eq $name } | Select-Object -First 1\n\n            if ($null -eq $project) {\n                $this.LastError = \"Project not found: $name\"\n                # Write-PmcTuiLog \"UpdateProject: Project not found: $name\" \"ERROR\"\n                return $false\n            }\n\n            # Write-PmcTuiLog \"UpdateProject: Found project, type=$($project.GetType().Name) BEFORE ID1='$(Get-SafeProperty $project 'ID1')'\" \"DEBUG\"\n\n            # Create backup BEFORE any modifications\n            $this._CreateBackup()\n\n            # Apply changes - handle both hashtable and PSCustomObject\n            foreach ($key in $changes.Keys) {\n                if ($key -eq 'ID1') {\n                    # Write-PmcTuiLog \"UpdateProject: Updating ID1 from '$(Get-SafeProperty $project 'ID1')' to '$($changes[$key])'\" \"DEBUG\"\n                }\n\n                # Check if hashtable or PSCustomObject\n                if ($project -is [hashtable]) {\n                    # Hashtable: direct assignment\n                    $project[$key] = $changes[$key]\n                    if ($key -eq 'ID1') {\n                        # Write-PmcTuiLog \"UpdateProject: Hashtable assignment - project['ID1']='$($project[$key])'\" \"DEBUG\"\n                    }\n                }\n                else {\n                    # PSCustomObject: use PSObject.Properties or Add-Member\n                    if ($project.PSObject.Properties.Name -contains $key) {\n                        $project.$key = $changes[$key]\n                    }\n                    else {\n                        Add-Member -InputObject $project -MemberType NoteProperty -Name $key -Value $changes[$key] -Force\n                    }\n                }\n            }\n\n            # Write-PmcTuiLog \"UpdateProject: AFTER applying changes - ID1='$(Get-SafeProperty $project 'ID1')'\" \"DEBUG\"\n\n            # Update modified timestamp\n            if ($project -is [hashtable]) {\n                $project['modified'] = Get-Date\n            }\n            else {\n                if ($project.PSObject.Properties.Name -contains 'modified') {\n                    $project.modified = Get-Date\n                }\n                else {\n                    Add-Member -InputObject $project -MemberType NoteProperty -Name 'modified' -Value (Get-Date) -Force\n                }\n            }\n\n            # Validate updated project\n            $validationErrors = $this._ValidateEntity($project, 'project')\n            if ($validationErrors.Count -gt 0) {\n                $this.LastError = \"Project validation failed: $($validationErrors -join ', ')\"\n                # Write-PmcTuiLog \"UpdateProject: Validation FAILED - $($validationErrors -join ', ')\" \"ERROR\"\n                $this._Rollback()\n                return $false\n            }\n\n            # Mark pending changes\n            $this.HasPendingChanges = $true\n\n            # Verify the change is in the projects array BEFORE SaveData\n            $verifyProject = $this._data.projects | Where-Object { $_.name -eq $name } | Select-Object -First 1\n            if ($verifyProject) {\n                # Write-PmcTuiLog \"UpdateProject: VERIFY before SaveData - project in array has ID1='$(Get-SafeProperty $verifyProject 'ID1')'\" \"DEBUG\"\n            }\n\n            # Persist only if AutoSave is enabled\n            if ($this.AutoSave) {\n                # Write-PmcTuiLog \"UpdateProject: AutoSave is enabled, calling SaveData\" \"DEBUG\"\n                if (-not $this.SaveData()) {\n                    # Write-PmcTuiLog \"UpdateProject: SaveData FAILED\" \"ERROR\"\n                    return $false\n                }\n                # Write-PmcTuiLog \"UpdateProject: SaveData succeeded\" \"DEBUG\"\n            }\n            else {\n                # Write-PmcTuiLog \"UpdateProject: AutoSave is DISABLED, skipping SaveData\" \"WARNING\"\n            }\n\n            # Fire events\n            $this._InvokeCallback($this.OnProjectUpdated, $project)\n            $this._InvokeCallback($this.OnProjectsChanged, $this._data.projects.ToArray())\n            $this._InvokeCallback($this.OnDataChanged, $null)\n\n            return $true\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Delete a project by name\n\n    .PARAMETER name\n    Project name\n\n    .OUTPUTS\n    True if delete succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] DeleteProject([string]$name) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            # Find project index\n            $index = -1\n            for ($i = 0; $i -lt $this._data.projects.Count; $i++) {\n                if ($this._data.projects[$i].name -eq $name) {\n                    $index = $i\n                    break\n                }\n            }\n\n            if ($index -eq -1) {\n                $this.LastError = \"Project not found: $name\"\n                return $false\n            }\n\n            # Create backup BEFORE any modifications\n            $this._CreateBackup()\n\n            # Remove project\n            $this._data.projects.RemoveAt($index)\n\n            # Mark pending changes\n            $this.HasPendingChanges = $true\n\n            # Persist only if AutoSave is enabled\n            if ($this.AutoSave) {\n                if (-not $this.SaveData()) {\n                    return $false\n                }\n            }\n\n            # Fire events\n            $this._InvokeCallback($this.OnProjectDeleted, $name)\n            $this._InvokeCallback($this.OnProjectsChanged, $this._data.projects.ToArray())\n            $this._InvokeCallback($this.OnDataChanged, $null)\n\n            return $true\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    # === Time Log CRUD Operations ===\n\n    <#\n    .SYNOPSIS\n    Get all time logs\n\n    .OUTPUTS\n    Array of time log hashtables\n    ##CLOSEBRACKET##\n    [array] GetAllTimeLogs() {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            return $this._data.timelogs.ToArray()\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Get time logs for a specific task\n\n    .PARAMETER taskId\n    Task ID\n\n    .OUTPUTS\n    Array of time log hashtables\n    ##CLOSEBRACKET##\n    [array] GetTimeLogsForTask([string]$taskId) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            $logs = $this._data.timelogs | Where-Object { $_.taskId -eq $taskId }\n            return $(if ($logs) { $logs } else { @() })\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Add a new time log\n\n    .PARAMETER timelog\n    Time log hashtable (must include 'taskId' and 'duration')\n\n    .OUTPUTS\n    True if add succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] AddTimeLog([hashtable]$timelog) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\n                # Write-PmcTuiLog \"TaskStore.AddTimeLog: CALLED with timelog keys: $($timelog.Keys -join ', ')\" \"DEBUG\"\n                foreach ($key in $timelog.Keys) {\n                    $val = $timelog[$key]\n                    $valType = if ($null -eq $val) { 'null' } else { $val.GetType().Name }\n                    # Write-PmcTuiLog \"TaskStore.AddTimeLog:   $key = $val (type: $valType)\" \"DEBUG\"\n                }\n            }\n            # Validate time log\n            $validationErrors = $this._ValidateEntity($timelog, 'timelog')\n            if ($validationErrors.Count -gt 0) {\n                $this.LastError = \"Time log validation failed: $($validationErrors -join ', ')\"\n                # Write-PmcTuiLog \"TaskStore.AddTimeLog: VALIDATION FAILED: $($validationErrors -join ', ')\" \"ERROR\"\n                return $false\n            }\n            # Write-PmcTuiLog \"TaskStore.AddTimeLog: Validation passed\" \"DEBUG\"\n\n            # Create backup BEFORE any modifications\n            $this._CreateBackup()\n\n            # Generate ID if not present\n            if (-not $timelog.ContainsKey('id') -or [string]::IsNullOrEmpty($timelog.id)) {\n                $timelog.id = [Guid]::NewGuid().ToString()\n            }\n\n            # Add timestamp if not present\n            if (-not $timelog.ContainsKey('timestamp')) {\n                $timelog.timestamp = Get-Date\n            }\n\n            # Add to collection\n            $this._data.timelogs.Add($timelog)\n\n            # Mark pending changes\n            $this.HasPendingChanges = $true\n\n            # Persist only if AutoSave is enabled\n            if ($this.AutoSave) {\n                if (-not $this.SaveData()) {\n                    return $false\n                }\n            }\n\n            # Fire events\n            $this._InvokeCallback($this.OnTimeLogAdded, $timelog)\n            $this._InvokeCallback($this.OnTimeLogsChanged, $this._data.timelogs.ToArray())\n            $this._InvokeCallback($this.OnDataChanged, $null)\n\n            return $true\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Delete a time log by ID\n\n    .PARAMETER id\n    Time log ID\n\n    .OUTPUTS\n    True if delete succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] DeleteTimeLog([string]$id) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            # Find time log index\n            $index = -1\n            for ($i = 0; $i -lt $this._data.timelogs.Count; $i++) {\n                if ($this._data.timelogs[$i].id -eq $id) {\n                    $index = $i\n                    break\n                }\n            }\n\n            if ($index -eq -1) {\n                $this.LastError = \"Time log not found: $id\"\n                return $false\n            }\n\n            # Create backup BEFORE any modifications\n            $this._CreateBackup()\n\n            # Remove time log\n            $this._data.timelogs.RemoveAt($index)\n\n            # Mark pending changes\n            $this.HasPendingChanges = $true\n\n            # Persist only if AutoSave is enabled\n            if ($this.AutoSave) {\n                if (-not $this.SaveData()) {\n                    return $false\n                }\n            }\n\n            # Fire events\n            $this._InvokeCallback($this.OnTimeLogDeleted, $id)\n            $this._InvokeCallback($this.OnTimeLogsChanged, $this._data.timelogs.ToArray())\n            $this._InvokeCallback($this.OnDataChanged, $null)\n\n            return $true\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Update a time log entry\n\n    .PARAMETER id\n    Time log ID\n\n    .PARAMETER changes\n    Hashtable of fields to update\n\n    .OUTPUTS\n    True if update succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] UpdateTimeLog([string]$id, [hashtable]$changes) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            # Find time log\n            $timelog = $null\n            foreach ($log in $this._data.timelogs) {\n                if ($log.id -eq $id) {\n                    $timelog = $log\n                    break\n                }\n            }\n\n            if (-not $timelog) {\n                $this.LastError = \"Time log not found: $id\"\n                return $false\n            }\n\n            # Create backup BEFORE any modifications\n            $this._CreateBackup()\n\n            # Apply changes\n            foreach ($key in $changes.Keys) {\n                if ($key -ne 'id') {\n                    # Don't allow ID changes\n                    $timelog[$key] = $changes[$key]\n                }\n            }\n\n            # Add modified timestamp\n            $timelog.modified = [DateTime]::Now\n\n            # Validate\n            $validationErrors = $this._ValidateEntity($timelog, 'timelog')\n            if ($validationErrors.Count -gt 0) {\n                $this.LastError = \"Validation failed: $($validationErrors -join ', ')\"\n                return $false\n            }\n\n            # Mark pending changes\n            $this.HasPendingChanges = $true\n\n            # Persist only if AutoSave is enabled\n            if ($this.AutoSave) {\n                if (-not $this.SaveData()) {\n                    return $false\n                }\n            }\n\n            # Fire events\n            $this._InvokeCallback($this.OnTimeLogUpdated, $timelog)\n            $this._InvokeCallback($this.OnTimeLogsChanged, $this._data.timelogs.ToArray())\n            $this._InvokeCallback($this.OnDataChanged, $null)\n\n            return $true\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    # === Query Methods ===\n\n    <#\n    .SYNOPSIS\n    Get tasks by project\n\n    .PARAMETER projectName\n    Project name\n\n    .OUTPUTS\n    Array of task hashtables\n    ##CLOSEBRACKET##\n    [array] GetTasksByProject([string]$projectName) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            $tasks = $this._data.tasks | Where-Object { $_.project -eq $projectName }\n            return $(if ($tasks) { $tasks } else { @() })\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Search tasks by text\n\n    .PARAMETER searchText\n    Search query\n\n    .OUTPUTS\n    Array of task hashtables\n    ##CLOSEBRACKET##\n    [array] SearchTasks([string]$searchText) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            $searchLower = $searchText.ToLower()\n            $tasks = $this._data.tasks | Where-Object {\n                $null -ne $_.text -and $_.text.ToLower().Contains($searchLower)\n            }\n            return $(if ($tasks) { $tasks } else { @() })\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Get tasks by priority range\n\n    .PARAMETER minPriority\n    Minimum priority (inclusive)\n\n    .PARAMETER maxPriority\n    Maximum priority (inclusive)\n\n    .OUTPUTS\n    Array of task hashtables\n    ##CLOSEBRACKET##\n    [array] GetTasksByPriority([int]$minPriority, [int]$maxPriority) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            $tasks = $this._data.tasks | Where-Object {\n                $_.priority -ge $minPriority -and $_.priority -le $maxPriority\n            }\n            return $(if ($tasks) { $tasks } else { @() })\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    # === Validation ===\n\n    <#\n    .SYNOPSIS\n    Validate an entity against rules\n\n    .PARAMETER entity\n    Entity hashtable to validate\n\n    .PARAMETER entityType\n    Entity type ('task', 'project', 'timelog')\n\n    .OUTPUTS\n    Array of validation error messages (empty if valid)\n    ##CLOSEBRACKET##\n    hidden [string[]] _ValidateEntity($entity, [string]$entityType) {\n        $errors = @()\n\n        if (-not $this._validationRules.ContainsKey($entityType)) {\n            $errors += \"Unknown entity type: $entityType\"\n            return $errors\n        }\n\n        $rules = $this._validationRules[$entityType]\n\n        # Check required fields\n        foreach ($field in $rules.required) {\n            $value = Get-SafeProperty $entity $field\n            if ([string]::IsNullOrEmpty($value)) {\n                $errors += \"Required field missing: $field\"\n            }\n        }\n\n        # Check field types\n        foreach ($field in $rules.types.Keys) {\n            $hasField = Test-SafeProperty $entity $field\n            if ($hasField) {\n                $value = Get-SafeProperty $entity $field\n                if ($field -eq 'tags') {\n                    # Add-Content -Path \"$($env:TEMP)\\pmc-edit-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') _ValidateEntity: Checking tags - value type=$($value.GetType().FullName) isArray=$($value -is [array]) value=$value\"\n                }\n                if ($null -ne $value) {\n                    $expectedType = $rules.types[$field]\n\n                    $isValid = switch ($expectedType) {\n                        'string' { $value -is [string] }\n                        'int' {\n                            # Accept both Int32 and Int64\n                            $result = ($value -is [int]) -or ($value -is [int64]) -or ($value -is [int32])\n                            if ($field -eq 'priority') {\n                                # Add-Content -Path \"$($env:TEMP)\\pmc-edit-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') TaskStore: Validating priority - value=$value type=$($value.GetType().FullName) isInt=$result\"\n                            }\n                            $result\n                        }\n                        'bool' { $value -is [bool] }\n                        'datetime' { $value -is [DateTime] }\n                        'array' { $value -is [array] }\n                        default { $true }\n                    }\n\n                    if (-not $isValid) {\n                        $errors += \"Field '$field' has invalid type (expected $expectedType, got $($value.GetType().FullName))\"\n                    }\n                }\n            }\n        }\n\n        return $errors\n    }\n\n    # === Helper Methods ===\n\n    <#\n    .SYNOPSIS\n    Invoke callback safely\n    ##CLOSEBRACKET##\n    hidden [void] _InvokeCallback([scriptblock]$callback, $arg) {\n        if ($null -ne $callback -and $callback -ne {}) {\n            try {\n                if ($null -ne $arg) {\n                    # Use Invoke-Command with -ArgumentList to pass single arg without array wrapping\n                    Invoke-Command -ScriptBlock $callback -ArgumentList (, $arg)\n                }\n                else {\n                    & $callback\n                }\n            }\n            catch {\n                # Log callback errors but DON'T rethrow - callbacks must never crash the app\n                $this.LastError = \"Callback failed: $($_.Exception.Message)\"\n                if (Get-Command Write-PmcTuiLog -ErrorAction SilentlyContinue) {\n                    # Write-PmcTuiLog \"TaskStore callback error: $($_.Exception.Message)\" \"ERROR\"\n                    # Write-PmcTuiLog \"Callback code: $($callback.ToString())\" \"ERROR\"\n                    # Write-PmcTuiLog \"Stack trace: $($_.ScriptStackTrace)\" \"ERROR\"\n                }\n                # DON'T rethrow - background operations must not crash\n            }\n        }\n    }\n\n    # === Batch Operations ===\n\n    <#\n    .SYNOPSIS\n    Add multiple tasks in a single transaction\n\n    .PARAMETER tasks\n    Array of task hashtables\n\n    .OUTPUTS\n    Number of tasks successfully added\n    ##CLOSEBRACKET##\n    [int] AddTasks([hashtable[]]$tasks) {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            $addedCount = 0\n            $this._CreateBackup()\n\n            foreach ($task in $tasks) {\n                # Validate task\n                $validationErrors = $this._ValidateEntity($task, 'task')\n                if ($validationErrors.Count -gt 0) {\n                    continue  # Skip invalid tasks\n                }\n\n                # Generate ID if not present\n                if (-not $task.ContainsKey('id') -or [string]::IsNullOrEmpty($task.id)) {\n                    $task.id = [Guid]::NewGuid().ToString()\n                }\n\n                # Add timestamps\n                $now = Get-Date\n                if (-not $task.ContainsKey('created')) {\n                    $task.created = $now\n                }\n                $task.modified = $now\n\n                # Add to collection\n                $this._data.tasks.Add($task)\n                $addedCount++\n            }\n\n            # Persist once for all tasks\n            if ($addedCount -gt 0) {\n                if ($this.SaveData()) {\n                    # Fire events once\n                    $this._InvokeCallback($this.OnTasksChanged, $this._data.tasks.ToArray())\n                    $this._InvokeCallback($this.OnDataChanged, $null)\n                }\n                else {\n                    return 0\n                }\n            }\n\n            return $addedCount\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Get data statistics\n\n    .OUTPUTS\n    Hashtable with data statistics\n    ##CLOSEBRACKET##\n    [hashtable] GetStatistics() {\n        [Monitor]::Enter($this._dataLock)\n        try {\n            # Return cached stats if available and not dirty\n            if (-not $this._statsNeedUpdate -and $null -ne $this._cachedStats) {\n                return $this._cachedStats\n            }\n\n            # Compute statistics (only when cache is dirty)\n            $completedCount = 0\n            $pendingCount = 0\n            foreach ($task in $this._data.tasks) {\n                if (Get-SafeProperty $task 'completed') {\n                    $completedCount++\n                }\n                else {\n                    $pendingCount++\n                }\n            }\n\n            $this._cachedStats = @{\n                taskCount          = $this._data.tasks.Count\n                projectCount       = $this._data.projects.Count\n                timeLogCount       = $this._data.timelogs.Count\n                completedTaskCount = $completedCount\n                pendingTaskCount   = $pendingCount\n                lastLoaded         = $this._data.metadata.lastLoaded\n                lastSaved          = $this._data.metadata.lastSaved\n            }\n\n            $this._statsNeedUpdate = $false\n            return $this._cachedStats\n        }\n        finally {\n            [Monitor]::Exit($this._dataLock)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Flush pending changes to disk\n\n    .DESCRIPTION\n    When AutoSave is disabled, changes accumulate in memory.\n    Call this method to persist all pending changes to disk.\n\n    .OUTPUTS\n    True if flush succeeded, False otherwise\n    ##CLOSEBRACKET##\n    [bool] Flush() {\n        if (-not $this.HasPendingChanges) {\n            return $true  # Nothing to save\n        }\n\n        if ($this.SaveData()) {\n            $this.HasPendingChanges = $false\n            return $true\n        }\n\n        return $false\n    }\n\n    <#\n    .SYNOPSIS\n    Enable automatic saving after each operation\n    ##CLOSEBRACKET##\n    [void] EnableAutoSave() {\n        $this.AutoSave = $true\n    }\n\n    <#\n    .SYNOPSIS\n    Disable automatic saving (batch mode)\n    ##CLOSEBRACKET##\n    [void] DisableAutoSave() {\n        $this.AutoSave = $false\n    }\n}"}, {"path": "module/Pmc.Strict/consoleui/src/PmcThemeEngine.ps1", "content": "# PmcThemeEngine.ps1 - Core theme system with gradient support\r\n#\r\n# Handles all color resolution for the TUI:\r\n# - Solid colors (single RGB value)\r\n# - Multi-stop gradients (horizontal/vertical transitions)\r\n# - Aggressive caching for performance\r\n# - JSON-based theme configuration\r\n\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nTheme engine singleton - handles all color/gradient computation and caching\r\n\r\n.DESCRIPTION\r\nProperties format in config.json:\r\n  Solid:    { \"Type\": \"Solid\", \"Color\": \"#ff8833\" }\r\n  Gradient: { \"Type\": \"Gradient\", \"Direction\": \"Horizontal\",\r\n              \"Stops\": [{\"Position\": 0.0, \"Color\": \"#ff8833\"}, ...] }\r\n\r\nProperty names: \"Background.Field\", \"Foreground.FieldFocused\", etc.\r\n##CLOSEBRACKET##\r\nclass PmcThemeEngine {\r\n    hidden static [PmcThemeEngine]$_instance = $null\r\n\r\n    # Loaded theme properties from config.json\r\n    hidden [hashtable]$_properties = @{}\r\n    hidden [hashtable]$_palette = @{}\r\n\r\n    # Cache: key = \"PropertyName_Width_Generation\", value = string[] of ANSI sequences\r\n    hidden [hashtable]$_gradientCache = @{}\r\n    hidden [hashtable]$_solidCache = @{}\r\n\r\n    # Int Caches\r\n    hidden [hashtable]$_solidIntCache = @{}\r\n    hidden [hashtable]$_gradientIntCache = @{}\r\n\r\n    hidden [int]$_cacheGeneration = 0\r\n\r\n    # Singleton access\r\n    static [PmcThemeEngine] GetInstance() {\r\n        if ($null -eq [PmcThemeEngine]::_instance) {\r\n            [PmcThemeEngine]::_instance = [PmcThemeEngine]::new()\r\n        }\r\n        return [PmcThemeEngine]::_instance\r\n    }\r\n\r\n    PmcThemeEngine() {\r\n        # Private constructor\r\n    }\r\n\r\n    # Configure engine with full state (called by PmcThemeManager)\r\n    [void] Configure([hashtable]$properties, [hashtable]$palette) {\r\n        $this._properties = $properties\r\n        $this._palette = $palette\r\n        $this.InvalidateCache()\r\n        \r\n        # Targeted diagnostic: log when Configure is called (only if debug enabled)\r\n        if ((Test-Path variable:global:PmcDebug) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\r\n            $propList = ($properties.Keys | Sort-Object) -join ', '\r\n            Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [PmcThemeEngine] Configure: $($properties.Count) properties: $propList\"\r\n        }\r\n    }\r\n\r\n    # Public Primitive: Get ANSI from Hex (for Manager)\r\n    [string] GetAnsiFromHex([string]$hex, [bool]$background) {\r\n        if ([string]::IsNullOrEmpty($hex)) { return '' }\r\n        return $this._GetSolidAnsiCached($hex, $background)\r\n    }\r\n\r\n    # Public Primitive: Get Int from Hex (for Manager)\r\n    [int] GetIntFromHex([string]$hex) {\r\n        if ([string]::IsNullOrEmpty($hex)) { return -1 }\r\n        return $this._GetSolidIntCached($hex)\r\n    }\r\n\r\n    # Get background ANSI - handles solid or gradient\r\n    [string] GetBackgroundAnsi([string]$propertyName, [int]$width, [int]$charIndex) {\r\n        if (-not $this._properties.ContainsKey($propertyName)) {\r\n            throw \"Theme Property Missing: '$propertyName'\"\r\n        }\r\n\r\n        $prop = $this._properties[$propertyName]\r\n\r\n        if ($prop.Type -eq 'Solid') {\r\n            return $this._GetSolidAnsiCached($prop.Color, $true)\r\n        }\r\n        elseif ($prop.Type -eq 'Gradient') {\r\n            $gradient = $this._GetGradientArrayCached($propertyName, $prop, $width, $true)\r\n            if ($charIndex -ge 0 -and $charIndex -lt $gradient.Count) {\r\n                return $gradient[$charIndex]\r\n            }\r\n            return ''\r\n        }\r\n\r\n        return ''\r\n    }\r\n\r\n    # Get foreground ANSI - usually solid\r\n    [string] GetForegroundAnsi([string]$propertyName) {\r\n        if (-not $this._properties.ContainsKey($propertyName)) {\r\n            throw \"Theme Property Missing: '$propertyName'\"\r\n        }\r\n\r\n        $prop = $this._properties[$propertyName]\r\n\r\n        if ($prop.Type -eq 'Solid') {\r\n            $ansi = $this._GetSolidAnsiCached($prop.Color, $false)\r\n            return $ansi\r\n        }\r\n\r\n        return ''\r\n    }\r\n\r\n    # Get integer color value (Generic - for Solid colors)\r\n    # Returns packed RGB int (0x00RRGGBB)\r\n    [int] GetThemeColorInt([string]$propertyName) {\r\n        if (-not $this._properties.ContainsKey($propertyName)) {\r\n            throw \"Theme Property Missing: '$propertyName'\"\r\n        }\r\n\r\n        $prop = $this._properties[$propertyName]\r\n        $hex = \"\"\r\n        \r\n        if ($prop.Type -eq 'Solid') {\r\n            $hex = $prop.Color\r\n        }\r\n        elseif ($prop.Type -eq 'Gradient') {\r\n            # Use first color for gradient fallback\r\n            # Use ContainsKey to avoid strict mode errors on missing keys\r\n            if ($prop.ContainsKey('Start') -and $prop.Start) {\r\n                $hex = $prop.Start\r\n            }\r\n            elseif ($prop.ContainsKey('Stops') -and $prop.Stops -and $prop.Stops.Count -gt 0) {\r\n                $hex = $prop.Stops[0].Color\r\n            }\r\n        }\r\n\r\n        if ([string]::IsNullOrEmpty($hex)) { return 0 }\r\n\r\n        return $this._ColorToInt($hex)\r\n    }\r\n\r\n    # Get gradient info for a property (returns null if solid)\r\n    # Returns @{ Start = [int]; End = [int] } for gradient, or $null for solid\r\n    [object] GetGradientInfo([string]$propertyName) {\r\n        if (-not $this._properties.ContainsKey($propertyName)) {\r\n            return $null\r\n        }\r\n\r\n        $prop = $this._properties[$propertyName]\r\n        \r\n        if ($prop.Type -eq 'Gradient') {\r\n            $startHex = $prop.Start\r\n            $endHex = $prop.End\r\n            if ($startHex -and $endHex) {\r\n                return @{\r\n                    Start = $this._ColorToInt($startHex)\r\n                    End = $this._ColorToInt($endHex)\r\n                }\r\n            }\r\n        }\r\n\r\n        return $null\r\n    }\r\n\r\n    # === INT API (For Hybrid Engine) ===\r\n\r\n    # Get foreground Packed Int - usually solid\r\n    [int] GetForegroundInt([string]$propertyName) {\r\n        if (-not $this._properties.ContainsKey($propertyName)) {\r\n            throw \"Theme Property Missing: '$propertyName'\"\r\n        }\r\n\r\n        $prop = $this._properties[$propertyName]\r\n\r\n        if ($prop.Type -eq 'Solid') {\r\n            return $this._GetSolidIntCached($prop.Color)\r\n        }\r\n        \r\n        # Fallback for gradients acting as foregrounds (use generic)\r\n        return $this.GetThemeColorInt($propertyName)\r\n    }\r\n\r\n    # Get background Packed Int\r\n    [int] GetBackgroundInt([string]$propertyName, [int]$width, [int]$charIndex) {\r\n        if (-not $this._properties.ContainsKey($propertyName)) {\r\n            throw \"Theme Property Missing: '$propertyName'\"\r\n        }\r\n\r\n        $prop = $this._properties[$propertyName]\r\n\r\n        if ($prop.Type -eq 'Solid') {\r\n            return $this._GetSolidIntCached($prop.Color)\r\n        }\r\n        elseif ($prop.Type -eq 'Gradient') {\r\n            # Gradient support for Ints\r\n            $gradient = $this._GetGradientIntArrayCached($propertyName, $prop, $width)\r\n            if ($charIndex -ge 0 -and $charIndex -lt $gradient.Count) {\r\n                return $gradient[$charIndex]\r\n            }\r\n            return -1\r\n        }\r\n\r\n        return -1\r\n    }\r\n\r\n    # Cached solid color ANSI\r\n    hidden [string] _GetSolidAnsiCached([string]$color, [bool]$background) {\r\n        $cacheKey = \"${color}_${background}_$($this._cacheGeneration)\"\r\n\r\n        if ($this._solidCache.ContainsKey($cacheKey)) {\r\n            return $this._solidCache[$cacheKey]\r\n        }\r\n\r\n        $ansi = $this._ColorToAnsi($color, $background)\r\n        $this._solidCache[$cacheKey] = $ansi\r\n        return $ansi\r\n    }\r\n\r\n    # Cached solid color Int\r\n    hidden [int] _GetSolidIntCached([string]$color) {\r\n        $cacheKey = \"${color}_$($this._cacheGeneration)\"\r\n\r\n        if ($this._solidIntCache.ContainsKey($cacheKey)) {\r\n            return $this._solidIntCache[$cacheKey]\r\n        }\r\n\r\n        $intColor = $this._ColorToInt($color)\r\n        $this._solidIntCache[$cacheKey] = $intColor\r\n        return $intColor\r\n    }\r\n\r\n    # Cached gradient array\r\n    hidden [string[]] _GetGradientArrayCached([string]$propertyName, [hashtable]$gradient, [int]$width, [bool]$background) {\r\n        $cacheKey = \"${propertyName}_${width}_${background}_$($this._cacheGeneration)\"\r\n\r\n        if ($this._gradientCache.ContainsKey($cacheKey)) {\r\n            return $this._gradientCache[$cacheKey]\r\n        }\r\n\r\n        $array = $this._ComputeGradient($gradient, $width, $background)\r\n        $this._gradientCache[$cacheKey] = $array\r\n        return $array\r\n    }\r\n\r\n    # Cached gradient Int array\r\n    hidden [int[]] _GetGradientIntArrayCached([string]$propertyName, [hashtable]$gradient, [int]$width) {\r\n        $cacheKey = \"${propertyName}_${width}_INT_$($this._cacheGeneration)\"\r\n\r\n        if ($this._gradientIntCache.ContainsKey($cacheKey)) {\r\n            return $this._gradientIntCache[$cacheKey]\r\n        }\r\n\r\n        $array = $this._ComputeGradientInt($gradient, $width)\r\n        $this._gradientIntCache[$cacheKey] = $array\r\n        return $array\r\n    }\r\n\r\n    # Compute gradient as array of ANSI sequences\r\n    hidden [string[]] _ComputeGradient([hashtable]$gradient, [int]$length, [bool]$background) {\r\n        $result = [List[string]]::new($length)\r\n        \r\n        # Support both Stops array and simple Start/End\r\n        $stops = $null\r\n        if ($gradient.Stops) {\r\n            $stops = $gradient.Stops | Sort-Object Position\r\n        }\r\n        elseif ($gradient.Start -and $gradient.End) {\r\n            $stops = @(\r\n                @{ Position = 0.0; Color = $gradient.Start }\r\n                @{ Position = 1.0; Color = $gradient.End }\r\n            )\r\n        }\r\n        else {\r\n            # Fallback - return empty\r\n            return @()\r\n        }\r\n\r\n        for ($i = 0; $i -lt $length; $i++) {\r\n            $ratio = $(if ($length -eq 1) { 0.0 } else { $i / ($length - 1) })\r\n            $color = $this._GetColorAtRatio($stops, $ratio)\r\n            $result.Add($this._ColorToAnsi($color, $background))\r\n        }\r\n\r\n        return $result.ToArray()\r\n    }\r\n\r\n    # Compute gradient as array of Ints\r\n    hidden [int[]] _ComputeGradientInt([hashtable]$gradient, [int]$length) {\r\n        $result = [List[int]]::new($length)\r\n        \r\n        # Support both Stops array and simple Start/End\r\n        $stops = $null\r\n        if ($gradient.Stops) {\r\n            $stops = $gradient.Stops | Sort-Object Position\r\n        }\r\n        elseif ($gradient.Start -and $gradient.End) {\r\n            $stops = @(\r\n                @{ Position = 0.0; Color = $gradient.Start }\r\n                @{ Position = 1.0; Color = $gradient.End }\r\n            )\r\n        }\r\n        else {\r\n            # Fallback - return empty\r\n            return @()\r\n        }\r\n\r\n        for ($i = 0; $i -lt $length; $i++) {\r\n            $ratio = $(if ($length -eq 1) { 0.0 } else { $i / ($length - 1) })\r\n            $color = $this._GetColorAtRatio($stops, $ratio)\r\n            $result.Add($this._ColorToInt($color))\r\n        }\r\n\r\n        return $result.ToArray()\r\n    }\r\n\r\n    hidden [string] _GetColorAtRatio([array]$stops, [double]$ratio) {\r\n        # Find surrounding stops\r\n        $beforeStop = $stops[0]\r\n        $afterStop = $stops[-1]\r\n\r\n        for ($s = 0; $s -lt $stops.Count - 1; $s++) {\r\n            if ($ratio -ge $stops[$s].Position -and $ratio -le $stops[$s + 1].Position) {\r\n                $beforeStop = $stops[$s]\r\n                $afterStop = $stops[$s + 1]\r\n                break\r\n            }\r\n        }\r\n\r\n        # Local interpolation between the two stops\r\n        $localRatio = $(if ($afterStop.Position -eq $beforeStop.Position) {\r\n                0.0\r\n            }\r\n            else {\r\n                ($ratio - $beforeStop.Position) / ($afterStop.Position - $beforeStop.Position)\r\n            })\r\n\r\n        return $this._InterpolateColor($beforeStop.Color, $afterStop.Color, $localRatio)\r\n    }\r\n\r\n    # Linear color interpolation\r\n    hidden [string] _InterpolateColor([string]$start, [string]$end, [double]$ratio) {\r\n        $startHex = $start.TrimStart('#')\r\n        $endHex = $end.TrimStart('#')\r\n\r\n        $startR = [Convert]::ToInt32($startHex.Substring(0, 2), 16)\r\n        $startG = [Convert]::ToInt32($startHex.Substring(2, 2), 16)\r\n        $startB = [Convert]::ToInt32($startHex.Substring(4, 2), 16)\r\n\r\n        $endR = [Convert]::ToInt32($endHex.Substring(0, 2), 16)\r\n        $endG = [Convert]::ToInt32($endHex.Substring(2, 2), 16)\r\n        $endB = [Convert]::ToInt32($endHex.Substring(4, 2), 16)\r\n\r\n        $r = [int]($startR + ($endR - $startR) * $ratio)\r\n        $g = [int]($startG + ($endG - $startG) * $ratio)\r\n        $b = [int]($startB + ($endB - $startB) * $ratio)\r\n\r\n        return \"#{0:X2}{1:X2}{2:X2}\" -f $r, $g, $b\r\n    }\r\n\r\n    # Convert hex color to ANSI escape sequence\r\n    hidden [string] _ColorToAnsi([string]$hex, [bool]$background) {\r\n        $hex = $hex.TrimStart('#')\r\n\r\n        if ($hex.Length -ne 6) {\r\n            return ''\r\n        }\r\n\r\n        try {\r\n            $r = [Convert]::ToInt32($hex.Substring(0, 2), 16)\r\n            $g = [Convert]::ToInt32($hex.Substring(2, 2), 16)\r\n            $b = [Convert]::ToInt32($hex.Substring(4, 2), 16)\r\n\r\n            if ($background) {\r\n                return \"`e[48;2;${r};${g};${b}m\"\r\n            }\r\n            else {\r\n                return \"`e[38;2;${r};${g};${b}m\"\r\n            }\r\n        }\r\n        catch {\r\n            # DEBUG\r\n            # Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcThemeEngine] ANSI CONVERSION FAILED: '$hex' - $_\"\r\n            return ''\r\n        }\r\n    }\r\n\r\n    # Convert hex color to Packed Int\r\n    hidden [int] _ColorToInt([string]$hex) {\r\n        $hex = $hex.TrimStart('#')\r\n        if ($hex.Length -ne 6) { return -1 }\r\n\r\n        try {\r\n            $r = [Convert]::ToInt32($hex.Substring(0, 2), 16)\r\n            $g = [Convert]::ToInt32($hex.Substring(2, 2), 16)\r\n            $b = [Convert]::ToInt32($hex.Substring(4, 2), 16)\r\n\r\n            # Pack RGB: (R << 16) | (G << 8) | B\r\n            return ($r -shl 16) -bor ($g -shl 8) -bor $b\r\n        }\r\n        catch {\r\n            return -1\r\n        }\r\n    }\r\n\r\n    # Clear all caches (call on theme reload)\r\n    [void] InvalidateCache() {\r\n        $this._cacheGeneration++\r\n        $this._gradientCache.Clear()\r\n        $this._solidCache.Clear()\r\n        $this._solidIntCache.Clear()\r\n        $this._gradientIntCache.Clear()\r\n    }\r\n}\r\n"}, {"path": "module/Pmc.Strict/consoleui/theme/PmcThemeManager.ps1", "content": "# PmcThemeManager - Unified theme system bridging PMC and SpeedTUI\r\n# Handles PMC's sophisticated palette derivation + SpeedTUI's theme manager\r\n\r\nusing namespace System.Collections.Generic\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nUnified theme manager bridging PMC's theme system with SpeedTUI\r\n\r\n.DESCRIPTION\r\nPmcThemeManager provides a single interface for theme management:\r\n- Wraps PMC's existing theme system (single hex → full palette)\r\n- Integrates with SpeedTUI's theme manager (if available)\r\n- Provides unified color role API\r\n- Handles theme switching and synchronization\r\n- Singleton pattern for global access\r\n\r\n.EXAMPLE\r\n$theme = [PmcThemeManager]::GetInstance()\r\n$color = $theme.GetColor('Primary')\r\n$ansi = $theme.GetAnsiSequence('Primary', $false)\r\n##CLOSEBRACKET##\r\nclass PmcThemeManager {\r\n    # === Singleton Instance ===\r\n    hidden static [PmcThemeManager]$_instance = $null\r\n\r\n    # === PMC Theme Data ===\r\n    [hashtable]$PmcTheme           # From Get-PmcState -Section 'Display' -Key 'Theme'\r\n    [hashtable]$StyleTokens        # From Get-PmcState -Section 'Display' -Key 'Styles'\r\n    [hashtable]$ColorPalette       # From Get-PmcColorPalette()\r\n\r\n    # === SpeedTUI Integration ===\r\n    [object]$SpeedTUITheme = $null # SpeedTUI ThemeManager (if available)\r\n\r\n    # === Cached Data ===\r\n    hidden [hashtable]$_colorCache = @{}\r\n    hidden [hashtable]$_ansiCache = @{}\r\n\r\n    # === Singleton Constructor ===\r\n    hidden PmcThemeManager() {\r\n        $this._Initialize()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get singleton instance of PmcThemeManager\r\n    ##CLOSEBRACKET##\r\n    static [PmcThemeManager] GetInstance() {\r\n        if ($null -eq [PmcThemeManager]::_instance) {\r\n            [PmcThemeManager]::_instance = [PmcThemeManager]::new()\r\n        }\r\n        return [PmcThemeManager]::_instance\r\n    }\r\n\r\n    # === Initialization ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Initialize theme system by loading PMC theme state\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _Initialize() {\r\n        try {\r\n            if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\r\n                Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [PmcThemeManager] _Initialize started\"\r\n            }\r\n\r\n            # Load PMC theme from state (for StyleTokens)\r\n            $displayState = Get-PmcState -Section 'Display'\r\n            if ($displayState) {\r\n                $this.PmcTheme = $displayState.Theme\r\n                $this.StyleTokens = $displayState.Styles\r\n            }\r\n\r\n            # Load color palette\r\n            $this.ColorPalette = Get-PmcColorPalette\r\n\r\n            # Initialize caches\r\n            $this._colorCache = @{}\r\n            $this._ansiCache = @{}\r\n\r\n            # ONE PATH: Load theme from file\r\n            $theme = Get-ActiveTheme\r\n            if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\r\n                Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [PmcThemeManager] Active theme name: '$($theme.Name)' Hex: '$($theme.Hex)' Props: $($theme.Properties.Count)\"\r\n            }\r\n\r\n            if ($theme -and $theme.Properties) {\r\n                [PmcThemeEngine]::GetInstance().Configure($theme.Properties, $this.ColorPalette)\r\n            } else {\r\n                # No theme file found - this should not happen\r\n                if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\r\n                    Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [PmcThemeManager] ERROR: No theme loaded\"\r\n                }\r\n            }\r\n        } catch {\r\n            if ($null -ne (Get-Variable -Name PmcDebug -Scope Global -ErrorAction SilentlyContinue) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\r\n                Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [PmcThemeManager] _Initialize ERROR: $_\"\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Try to initialize SpeedTUI theme manager if available\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _InitializeSpeedTUITheme() {\r\n        # SpeedTUI integration would go here if needed\r\n        # For now, PMC theme is primary source of truth\r\n        $this.SpeedTUITheme = $null\r\n    }\r\n\r\n\r\n    # === Public API ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get hex color string for a specific role\r\n\r\n    .PARAMETER role\r\n    Color role: Primary, Border, Text, Muted, Error, Warning, Success, Bright, Header, etc.\r\n\r\n    .OUTPUTS\r\n    Hex color string (e.g., \"#33aaff\") or empty string if not found\r\n\r\n    .EXAMPLE\r\n    $color = $theme.GetColor('Primary')  # Returns \"#33aaff\"\r\n    ##CLOSEBRACKET##\r\n    [string] GetColor([string]$role) {\r\n        # Check cache first\r\n        if ($this._colorCache.ContainsKey($role)) {\r\n            return $this._colorCache[$role]\r\n        }\r\n\r\n        $color = $this._ResolveColor($role)\r\n        $this._colorCache[$role] = $color\r\n        return $color\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Resolve color from theme system\r\n    ##CLOSEBRACKET##\r\n    hidden [string] _ResolveColor([string]$role) {\r\n        # Try style tokens first (includes Fg property)\r\n        if ($this.StyleTokens -and $this.StyleTokens.ContainsKey($role)) {\r\n            $style = $this.StyleTokens[$role]\r\n            if ($style.Fg) {\r\n                return $style.Fg\r\n            }\r\n        }\r\n\r\n        # Try color palette (RGB object → hex)\r\n        if ($this.ColorPalette -and $this.ColorPalette.ContainsKey($role)) {\r\n            $rgb = $this.ColorPalette[$role]\r\n            if ($rgb.R -ne $null -and $rgb.G -ne $null -and $rgb.B -ne $null) {\r\n                return (\"#{0:X2}{1:X2}{2:X2}\" -f $rgb.R, $rgb.G, $rgb.B)\r\n            }\r\n        }\r\n\r\n        # STRICT THEME ENFORCEMENT: No fallbacks.\r\n        throw \"Theme Property Missing: '$role'\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get ANSI escape sequence for a color role\r\n\r\n    .PARAMETER role\r\n    Color role\r\n\r\n    .PARAMETER background\r\n    If true, returns background color sequence; otherwise foreground\r\n\r\n    .OUTPUTS\r\n    ANSI escape sequence (e.g., \"`e[38;2;51;170;255m\")\r\n\r\n    .EXAMPLE\r\n    $ansi = $theme.GetAnsiSequence('Primary', $false)  # Foreground\r\n    $ansiBg = $theme.GetAnsiSequence('Primary', $true)  # Background\r\n    ##CLOSEBRACKET##\r\n    [string] GetAnsiSequence([string]$role, [bool]$background = $false) {\r\n        $cacheKey = \"${role}_${background}\"\r\n\r\n        # Check cache\r\n        if ($this._ansiCache.ContainsKey($cacheKey)) {\r\n            return $this._ansiCache[$cacheKey]\r\n        }\r\n\r\n        # Get hex color\r\n        $hex = $this.GetColor($role)\r\n        if ([string]::IsNullOrEmpty($hex)) {\r\n            return ''\r\n        }\r\n\r\n        # Convert to ANSI\r\n        $ansi = $this._HexToAnsi($hex, $background)\r\n        $this._ansiCache[$cacheKey] = $ansi\r\n        return $ansi\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Convert hex color to ANSI sequence\r\n    ##CLOSEBRACKET##\r\n    hidden [string] _HexToAnsi([string]$hex, [bool]$background) {\r\n        # Parse hex\r\n        $hex = $hex.TrimStart('#')\r\n        if ($hex.Length -ne 6) { return '' }\r\n\r\n        try {\r\n            $r = [Convert]::ToInt32($hex.Substring(0, 2), 16)\r\n            $g = [Convert]::ToInt32($hex.Substring(2, 2), 16)\r\n            $b = [Convert]::ToInt32($hex.Substring(4, 2), 16)\r\n\r\n            if ($background) {\r\n                return \"`e[48;2;${r};${g};${b}m\"\r\n            } else {\r\n                return \"`e[38;2;${r};${g};${b}m\"\r\n            }\r\n        } catch {\r\n            return ''\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get style object with foreground, background, and formatting\r\n\r\n    .PARAMETER role\r\n    Style role from StyleTokens (Title, Header, Body, Editing, Selected, etc.)\r\n\r\n    .OUTPUTS\r\n    Hashtable with Fg, Bg, Bold properties\r\n\r\n    .EXAMPLE\r\n    $style = $theme.GetStyle('Selected')\r\n    # Returns @{ Bg = '#33aaff'; Fg = 'White' }\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetStyle([string]$role) {\r\n        if ($this.StyleTokens -and $this.StyleTokens.ContainsKey($role)) {\r\n            return $this.StyleTokens[$role]\r\n        }\r\n\r\n        # Fallback: construct basic style from color\r\n        return @{\r\n            Fg = $this.GetColor($role)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get complete theme hashtable with ANSI sequences for dialogs/widgets\r\n\r\n    .DESCRIPTION\r\n    Returns a standard hashtable with common theme elements as ANSI sequences.\r\n    Useful for passing to dialogs, widgets, and other components that need\r\n    multiple theme colors.\r\n\r\n    .OUTPUTS\r\n    Hashtable with ANSI sequences for common theme roles\r\n\r\n    .EXAMPLE\r\n    $theme = $themeManager.GetTheme()\r\n    # Returns @{\r\n    #   Primary = \"`e[38;2;51;170;255m\"\r\n    #   PrimaryBg = \"`e[48;2;51;170;255m\"\r\n    #   Text = \"`e[38;2;204;204;204m\"\r\n    #   ...\r\n    # }\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetTheme() {\r\n        return @{\r\n            # Primary colors\r\n            Primary = $this.GetAnsiSequence('Primary', $false)\r\n            PrimaryBg = $this.GetAnsiSequence('Primary', $true)\r\n\r\n            # Dialog colors (common pattern from TimeListScreen)\r\n            DialogBg = $this.GetAnsiSequence('Surface', $true)\r\n            DialogFg = $this.GetAnsiSequence('OnSurface', $false)\r\n            DialogBorder = $this.GetAnsiSequence('Outline', $false)\r\n\r\n            # Text hierarchy\r\n            Header = $this.GetAnsiSequence('Header', $false)\r\n            Title = $this.GetAnsiSequence('Title', $false)\r\n            Text = $this.GetAnsiSequence('Text', $false)\r\n            Body = $this.GetAnsiSequence('Body', $false)\r\n            Muted = $this.GetAnsiSequence('Muted', $false)\r\n            Label = $this.GetAnsiSequence('Label', $false)\r\n\r\n            # Semantic colors\r\n            Highlight = $this.GetAnsiSequence('Highlight', $false)\r\n            Error = $this.GetAnsiSequence('Error', $false)\r\n            Warning = $this.GetAnsiSequence('Warning', $false)\r\n            Success = $this.GetAnsiSequence('Success', $false)\r\n            Info = $this.GetAnsiSequence('Info', $false)\r\n\r\n            # UI elements\r\n            Border = $this.GetAnsiSequence('Border', $false)\r\n            Status = $this.GetAnsiSequence('Status', $false)\r\n\r\n            # Special\r\n            Bright = $this.GetAnsiSequence('Bright', $false)\r\n            Reset = \"`e[0m\"\r\n        }\r\n    }\r\n\r\n    # === Theme Management ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Reload theme from PMC state system\r\n\r\n    .DESCRIPTION\r\n    Call this after theme changes to refresh cached data\r\n    ##CLOSEBRACKET##\r\n    [void] Reload() {\r\n        # Clear caches\r\n        $this._colorCache.Clear()\r\n        $this._ansiCache.Clear()\r\n\r\n        # Reload from state\r\n        $this._Initialize()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set theme hex color and regenerate palette\r\n\r\n    .PARAMETER hex\r\n    New theme hex color (e.g., \"#33aaff\")\r\n\r\n    .DESCRIPTION\r\n    Updates PMC theme, saves config, and regenerates palette\r\n    ##CLOSEBRACKET##\r\n    [void] SetTheme([string]$hex) {\r\n        if ([string]::IsNullOrWhiteSpace($hex)) {\r\n            throw \"Theme hex cannot be empty\"\r\n        }\r\n\r\n        # Normalize hex format\r\n        if (-not $hex.StartsWith('#')) {\r\n            $hex = '#' + $hex\r\n        }\r\n\r\n        try {\r\n            # Update config\r\n            $cfg = Get-PmcConfig\r\n            if (-not $cfg.Display) { $cfg.Display = @{} }\r\n            if (-not $cfg.Display.Theme) { $cfg.Display.Theme = @{} }\r\n            $cfg.Display.Theme.Hex = $hex\r\n            Save-PmcConfig $cfg\r\n\r\n            # Force theme re-initialization\r\n            Initialize-PmcThemeSystem -Force\r\n\r\n            # Reload this manager\r\n            $this.Reload()\r\n\r\n            # CRITICAL FIX: Notify PmcThemeEngine of theme change\r\n            # The engine caches theme properties and needs to reload\r\n            try {\r\n                $engine = [PmcThemeEngine]::GetInstance()\r\n                if ($engine) {\r\n                    $engine.InvalidateCache()\r\n                }\r\n            } catch {\r\n                # PmcThemeEngine may not be available in all contexts\r\n            }\r\n        } catch {\r\n            throw \"Failed to set theme: $_\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get current theme hex color\r\n\r\n    .OUTPUTS\r\n    Hex color string (e.g., \"#33aaff\")\r\n    ##CLOSEBRACKET##\r\n    [string] GetCurrentThemeHex() {\r\n        if ($this.PmcTheme -and $this.PmcTheme.Hex) {\r\n            return $this.PmcTheme.Hex\r\n        }\r\n        return '#33aaff'\r\n    }\r\n\r\n    # === Utility Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get RGB components from hex color\r\n\r\n    .PARAMETER hex\r\n    Hex color string (with or without #)\r\n\r\n    .OUTPUTS\r\n    Hashtable with R, G, B properties (0-255)\r\n    ##CLOSEBRACKET##\r\n    [hashtable] HexToRgb([string]$hex) {\r\n        $hex = $hex.TrimStart('#')\r\n        if ($hex.Length -ne 6) {\r\n            return @{ R = 0; G = 0; B = 0 }\r\n        }\r\n\r\n        try {\r\n            return @{\r\n                R = [Convert]::ToInt32($hex.Substring(0, 2), 16)\r\n                G = [Convert]::ToInt32($hex.Substring(2, 2), 16)\r\n                B = [Convert]::ToInt32($hex.Substring(4, 2), 16)\r\n            }\r\n        } catch {\r\n            return @{ R = 0; G = 0; B = 0 }\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/widgets/DatePicker.ps1", "content": "using namespace System\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\nusing namespace System.Globalization\r\n\r\n# DatePicker.ps1 - Production-ready date picker widget for PMC TUI\r\n# Supports both text input (smart date parsing) and calendar mode (visual month grid)\r\n#\r\n# Usage:\r\n#   $picker = [DatePicker]::new()\r\n#   $picker.SetPosition(10, 5)\r\n#   $picker.SetSize(35, 14)\r\n#   $picker.SetDate([DateTime]::Today)\r\n#\r\n#   # Render\r\n#   $ansiOutput = $picker.Render()\r\n#\r\n#   # Handle input\r\n#   $key = [Console]::ReadKey($true)\r\n#   $handled = $picker.HandleInput($key)\r\n#\r\n#   # Get result\r\n#   if ($picker.IsConfirmed) {\r\n#       $selected = $picker.GetSelectedDate()\r\n#   }\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Load PmcWidget base class if not already loaded\r\nif (-not ([System.Management.Automation.PSTypeName]'PmcWidget').Type) {\r\n    . \"$PSScriptRoot/PmcWidget.ps1\"\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nProduction-ready DatePicker widget with text and calendar modes\r\n\r\n.DESCRIPTION\r\nFeatures:\r\n- Text mode: Smart date parsing (today, tomorrow, next friday, +7, eom, ISO dates)\r\n- Calendar mode: Visual month grid with arrow navigation\r\n- Full keyboard navigation\r\n- Theme integration\r\n- Event callbacks for date changes, confirmation, cancellation\r\n- Automatic bounds clamping and validation\r\n\r\n.EXAMPLE\r\n$picker = [DatePicker]::new()\r\n$picker.SetPosition(10, 5)\r\n$picker.SetSize(35, 14)\r\n$picker.SetDate([DateTime]::Today)\r\n$ansiOutput = $picker.Render()\r\n##CLOSEBRACKET##\r\nclass DatePicker : PmcWidget {\r\n    # === Public Properties ===\r\n    [bool]$IsConfirmed = $false      # True when user presses Enter\r\n    [bool]$IsCancelled = $false      # True when user presses Esc\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnDateChanged = {}  # Called when date changes: param($newDate)\r\n    [scriptblock]$OnConfirmed = {}    # Called when Enter pressed: param($finalDate)\r\n    [scriptblock]$OnCancelled = {}    # Called when Esc pressed\r\n\r\n    # === Private State ===\r\n    hidden [DateTime]$_selectedDate = [DateTime]::Today\r\n    hidden [DateTime]$_calendarMonth = [DateTime]::Today  # Month being displayed in calendar\r\n    hidden [bool]$_isCalendarMode = $false                # False = text mode, True = calendar mode\r\n    hidden [string]$_textInput = \"\"                       # Text mode input buffer\r\n    hidden [string]$_errorMessage = \"\"                    # Error message to display\r\n    hidden [int]$_cursorPosition = 0                      # Text cursor position\r\n\r\n    # === Constructor ===\r\n    DatePicker() : base(\"DatePicker\") {\r\n        $this.Width = 35\r\n        $this.Height = 14\r\n        $this._selectedDate = [DateTime]::Today\r\n        $this._calendarMonth = [DateTime]::Today\r\n        $this._textInput = $this._selectedDate.ToString(\"yyyy-MM-dd\")\r\n        $this.CanFocus = $true\r\n        $this._isCalendarMode = $true  # ALWAYS start in calendar mode\r\n    }\r\n\r\n    # === Public API Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set the currently selected date\r\n\r\n    .PARAMETER date\r\n    DateTime to set as selected\r\n    ##CLOSEBRACKET##\r\n    [void] SetDate([DateTime]$date) {\r\n        $this._selectedDate = $date\r\n        $this._calendarMonth = $date\r\n        $this._textInput = $date.ToString(\"yyyy-MM-dd\")\r\n        $this._errorMessage = \"\"\r\n        $this._InvokeCallback($this.OnDateChanged, $date)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get the currently selected date\r\n\r\n    .OUTPUTS\r\n    DateTime object\r\n    ##CLOSEBRACKET##\r\n    [DateTime] GetSelectedDate() {\r\n        return $this._selectedDate\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle keyboard input\r\n\r\n    .PARAMETER keyInfo\r\n    ConsoleKeyInfo from [Console]::ReadKey($true)\r\n\r\n    .OUTPUTS\r\n    True if input was handled, False otherwise\r\n    ##CLOSEBRACKET##\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        # Global keys\r\n        if ($keyInfo.Key -eq 'Enter') {\r\n            $this.IsConfirmed = $true\r\n            $this._InvokeCallback($this.OnConfirmed, $this._selectedDate)\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'Escape') {\r\n            $this.IsCancelled = $true\r\n            $this._InvokeCallback($this.OnCancelled, $null)\r\n            return $true\r\n        }\r\n\r\n        # Always handle as calendar mode\r\n        return $this._HandleCalendarInput($keyInfo)\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n        # Regions removed - using direct WriteAt in RenderToEngine for reliability\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render date picker to engine\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        # DEBUG: Conditional logging for rendering issues\r\n        if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [DatePicker.RenderToEngine] CALLED X=$($this.X) Y=$($this.Y) W=$($this.Width) H=$($this.Height)\"\r\n        }\r\n\r\n        # Clamp to bounds\r\n        $this._ClampToBounds($engine)\r\n\r\n        # Get background color first (needed for Fill and DrawBox)\r\n        $bg = $this.GetThemedBgInt('Background.Row', $this.Width, 0)\r\n\r\n        # Ensure Popup is drawn ABOVE everything else\r\n        if ($engine.PSObject.Methods['BeginLayer']) {\r\n            $engine.BeginLayer(100)\r\n        }\r\n\r\n        $fg = $this.GetThemedInt('Foreground.Row')\r\n        $borderFg = $this.GetThemedInt('Border.Widget')\r\n        $primaryFg = $this.GetThemedInt('Foreground.Title')\r\n        $mutedFg = $this.GetThemedInt('Foreground.Muted')\r\n        $errorFg = $this.GetThemedInt('Foreground.Error')\r\n        $successFg = $this.GetThemedInt('Foreground.Success')\r\n        $highlightBg = $this.GetThemedBgInt('Background.RowSelected', 1, 0)\r\n        $highlightFg = $this.GetThemedInt('Foreground.RowSelected')\r\n\r\n        # DEBUG: Log colors\r\n        if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [DatePicker.RenderToEngine] Colors: bg=$bg borderFg=$borderFg\"\r\n        }\r\n\r\n        # Draw Box (Panel Background)\r\n        $engine.Fill($this.X, $this.Y, $this.Width, $this.Height, ' ', $fg, $bg)\r\n        $engine.DrawBox($this.X, $this.Y, $this.Width, $this.Height, $borderFg, $bg)\r\n        \r\n        # Title\r\n        $title = \"Select Date\"\r\n        $pad = [Math]::Max(0, [Math]::Floor(($this.Width - 4 - $title.Length) / 2))\r\n        $engine.WriteAt($this.X + 2 + $pad, $this.Y + 1, $title, $primaryFg, $bg)\r\n        \r\n        # Status\r\n        $currentValue = \"Current: \" + $this._selectedDate.ToString(\"yyyy-MM-dd ddd\")\r\n        $engine.WriteAt($this.X + 2, $this.Y + 2, $this.PadText($currentValue, $this.Width - 4, 'left'), $fg, $bg)\r\n        \r\n        # Calendar Header\r\n        $monthYear = $this._calendarMonth.ToString(\"MMMM yyyy\")\r\n        $pad = [Math]::Max(0, [Math]::Floor(($this.Width - 4 - $monthYear.Length) / 2))\r\n        $engine.WriteAt($this.X + 2 + $pad, $this.Y + 4, $monthYear, $primaryFg, $bg)\r\n        \r\n        # Day Names\r\n        $dayNames = \"Su Mo Tu We Th Fr Sa\"\r\n        $pad = [Math]::Max(0, [Math]::Floor(($this.Width - 4 - $dayNames.Length) / 2))\r\n        $engine.WriteAt($this.X + 2 + $pad, $this.Y + 5, $dayNames, $primaryFg, $bg)\r\n        \r\n        # Grid\r\n        $firstDay = [DateTime]::new($this._calendarMonth.Year, $this._calendarMonth.Month, 1)\r\n        $daysInMonth = [DateTime]::DaysInMonth($this._calendarMonth.Year, $this._calendarMonth.Month)\r\n        $startDayOfWeek = [int]$firstDay.DayOfWeek\r\n        $today = [DateTime]::Today\r\n        \r\n        for ($week = 0; $week -lt 6; $week++) {\r\n            $rowY = $this.Y + 6 + $week\r\n            $padGrid = [Math]::Max(0, [Math]::Floor(($this.Width - 4 - 20) / 2))\r\n            $startX = $this.X + 2 + $padGrid\r\n            \r\n            for ($dow = 0; $dow -lt 7; $dow++) {\r\n                $dayNum = ($week * 7 + $dow) - $startDayOfWeek + 1\r\n                $cellX = $startX + ($dow * 3)\r\n                \r\n                if ($dayNum -ge 1 -and $dayNum -le $daysInMonth) {\r\n                    $thisDate = [DateTime]::new($this._calendarMonth.Year, $this._calendarMonth.Month, $dayNum)\r\n                    $dayStr = $dayNum.ToString().PadLeft(2)\r\n                    \r\n                    $isSelected = ($thisDate.Date -eq $this._selectedDate.Date)\r\n                    $isToday = ($thisDate.Date -eq $today)\r\n                    \r\n                    $cBg = $bg\r\n                    $cFg = $fg\r\n                    \r\n                    if ($isSelected) {\r\n                        $cBg = $highlightBg\r\n                        $cFg = $highlightFg\r\n                    }\r\n                    elseif ($isToday) {\r\n                        $cFg = $primaryFg\r\n                    }\r\n                    \r\n                    $engine.WriteAt($cellX, $rowY, $dayStr, $cFg, $cBg)\r\n                }\r\n            }\r\n        }\r\n        \r\n        # Help\r\n        $helpText = \"Enter: Select\"\r\n        $engine.WriteAt($this.X + 2, $this.Y + $this.Height - 3, $this.PadText($helpText, $this.Width - 4, 'left'), $mutedFg, $bg)\r\n        \r\n        # Error\r\n        if ($this._errorMessage) {\r\n            $engine.WriteAt($this.X + 2, $this.Y + $this.Height - 1, $this.PadText($this._errorMessage, $this.Width - 4, 'left'), $errorFg, $bg)\r\n        }\r\n        \r\n        # End layer elevation\r\n        if ($engine.PSObject.Methods['EndLayer']) {\r\n            $engine.EndLayer()\r\n        }\r\n\r\n        # DEBUG: Log completion\r\n        if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\r\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [DatePicker.RenderToEngine] COMPLETE\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Ensure widget stays within screen bounds (Engine Viewport)\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _ClampToBounds([object]$engine) {\r\n        # Check Engine bounds first (Authoritative Viewport)\r\n        if ($engine -and $engine.PSObject.Properties['Width']) {\r\n            $termWidth = $engine.Width\r\n            $termHeight = $engine.Height\r\n        }\r\n        else {\r\n            # Fallback to console (but verify console availability)\r\n            try {\r\n                $termWidth = [Console]::WindowWidth\r\n                $termHeight = [Console]::WindowHeight\r\n            }\r\n            catch {\r\n                $termWidth = 80\r\n                $termHeight = 24\r\n            }\r\n        }\r\n        \r\n        # Clamp X\r\n        if ($this.X + $this.Width -ge $termWidth) {\r\n            $this.X = [Math]::Max(0, $termWidth - $this.Width)\r\n        }\r\n        \r\n        # Clamp Y\r\n        if ($this.Y + $this.Height -ge $termHeight) {\r\n            $this.Y = [Math]::Max(0, $termHeight - $this.Height)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render the date picker widget (Legacy)\r\n    ##CLOSEBRACKET##\r\n    [string] Render() {\r\n        return \"\"\r\n    }\r\n\r\n    # === Private Helper Methods ===\r\n\r\n    hidden [void] _ToggleMode() {\r\n        $this._isCalendarMode = -not $this._isCalendarMode\r\n        $this._errorMessage = \"\"\r\n\r\n        if ($this._isCalendarMode) {\r\n            $parsed = $this._ParseTextInput()\r\n            if ($parsed) {\r\n                $this._selectedDate = $parsed\r\n                $this._calendarMonth = $parsed\r\n            }\r\n        }\r\n        else {\r\n            $this._textInput = $this._selectedDate.ToString(\"yyyy-MM-dd\")\r\n            $this._cursorPosition = $this._textInput.Length\r\n        }\r\n    }\r\n\r\n    hidden [bool] _HandleCalendarInput([ConsoleKeyInfo]$keyInfo) {\r\n        $changed = $false\r\n\r\n        switch ($keyInfo.Key) {\r\n            'LeftArrow' {\r\n                $this._selectedDate = $this._selectedDate.AddDays(-1)\r\n                $changed = $true\r\n            }\r\n            'RightArrow' {\r\n                $this._selectedDate = $this._selectedDate.AddDays(1)\r\n                $changed = $true\r\n            }\r\n            'UpArrow' {\r\n                $this._selectedDate = $this._selectedDate.AddDays(-7)\r\n                $changed = $true\r\n            }\r\n            'DownArrow' {\r\n                $this._selectedDate = $this._selectedDate.AddDays(7)\r\n                $changed = $true\r\n            }\r\n            'PageUp' {\r\n                $this._selectedDate = $this._selectedDate.AddMonths(-1)\r\n                $this._calendarMonth = $this._selectedDate\r\n                $changed = $true\r\n            }\r\n            'PageDown' {\r\n                $this._selectedDate = $this._selectedDate.AddMonths(1)\r\n                $this._calendarMonth = $this._selectedDate\r\n                $changed = $true\r\n            }\r\n            'Home' {\r\n                $this._selectedDate = [DateTime]::new($this._selectedDate.Year, $this._selectedDate.Month, 1)\r\n                $changed = $true\r\n            }\r\n            'End' {\r\n                $daysInMonth = [DateTime]::DaysInMonth($this._selectedDate.Year, $this._selectedDate.Month)\r\n                $this._selectedDate = [DateTime]::new($this._selectedDate.Year, $this._selectedDate.Month, $daysInMonth)\r\n                $changed = $true\r\n            }\r\n        }\r\n\r\n        if ($changed) {\r\n            if ($this._selectedDate.Month -ne $this._calendarMonth.Month -or\r\n                $this._selectedDate.Year -ne $this._calendarMonth.Year) {\r\n                $this._calendarMonth = $this._selectedDate\r\n            }\r\n            $this._InvokeCallback($this.OnDateChanged, $this._selectedDate)\r\n        }\r\n\r\n        return $changed\r\n    }\r\n\r\n    hidden [object] _ParseTextInput() {\r\n        $input = $this._textInput.Trim().ToLower()\r\n\r\n        if ([string]::IsNullOrWhiteSpace($input)) {\r\n            $this._errorMessage = \"Empty input\"\r\n            return $null\r\n        }\r\n\r\n        try {\r\n            if ($input -eq 'today') { return [DateTime]::Today }\r\n            if ($input -eq 'tomorrow') { return [DateTime]::Today.AddDays(1) }\r\n\r\n            if ($input -match '^([+-]?\\d+)$') {\r\n                $days = [int]$Matches[1]\r\n                return [DateTime]::Today.AddDays($days)\r\n            }\r\n\r\n            if ($input -eq 'eom') {\r\n                $today = [DateTime]::Today\r\n                $daysInMonth = [DateTime]::DaysInMonth($today.Year, $today.Month)\r\n                return [DateTime]::new($today.Year, $today.Month, $daysInMonth)\r\n            }\r\n\r\n            if ($input -match '^next\\s+(\\w+)') {\r\n                $dayName = $Matches[1]\r\n                $targetDay = $this._ParseDayOfWeek($dayName)\r\n                if ($targetDay -ne $null) {\r\n                    $today = [DateTime]::Today\r\n                    $daysUntil = (([int]$targetDay - [int]$today.DayOfWeek + 7) % 7)\r\n                    if ($daysUntil -eq 0) { $daysUntil = 7 }\r\n                    return $today.AddDays($daysUntil)\r\n                }\r\n            }\r\n\r\n            $targetDay = $this._ParseDayOfWeek($input)\r\n            if ($targetDay -ne $null) {\r\n                $today = [DateTime]::Today\r\n                $daysUntil = (([int]$targetDay - [int]$today.DayOfWeek + 7) % 7)\r\n                if ($daysUntil -eq 0) { $daysUntil = 7 }\r\n                return $today.AddDays($daysUntil)\r\n            }\r\n\r\n            if ($input -match '^\\d{4}-\\d{2}-\\d{2}$') {\r\n                $parsed = [DateTime]::ParseExact($input, 'yyyy-MM-dd', [CultureInfo]::InvariantCulture)\r\n                return $parsed\r\n            }\r\n\r\n            $parsed = [DateTime]::Parse($input, [CultureInfo]::InvariantCulture)\r\n            return $parsed\r\n        }\r\n        catch {\r\n            $this._errorMessage = \"Invalid date: $input\"\r\n            return $null\r\n        }\r\n\r\n        $this._errorMessage = \"Unrecognized format: $input\"\r\n        return $null\r\n    }\r\n\r\n    hidden [object] _ParseDayOfWeek([string]$name) {\r\n        $name = $name.ToLower()\r\n        switch -Regex ($name) {\r\n            '^su(n|nday)?$' { return [DayOfWeek]::Sunday }\r\n            '^mo(n|nday)?$' { return [DayOfWeek]::Monday }\r\n            '^tu(e|es|esday)?$' { return [DayOfWeek]::Tuesday }\r\n            '^we(d|dnesday)?$' { return [DayOfWeek]::Wednesday }\r\n            '^th(u|ursday)?$' { return [DayOfWeek]::Thursday }\r\n            '^fr(i|iday)?$' { return [DayOfWeek]::Friday }\r\n            '^sa(t|turday)?$' { return [DayOfWeek]::Saturday }\r\n        }\r\n        return $null\r\n    }\r\n\r\n    hidden [void] _InvokeCallback([scriptblock]$callback, $arg) {\r\n        if ($callback -and $callback -ne {}) {\r\n            try {\r\n                if ($arg -ne $null) {\r\n                    & $callback $arg\r\n                }\r\n                else {\r\n                    & $callback\r\n                }\r\n            }\r\n            catch {\r\n                # Silently ignore callback errors\r\n            }\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/widgets/FilterPanel.ps1", "content": "using namespace System\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# FilterPanel.ps1 - Dynamic filter builder UI\r\n# Builds complex filters with visual chips and dropdown configuration\r\n#\r\n# Usage:\r\n#   $panel = [FilterPanel]::new()\r\n#   $panel.SetPosition(5, 5)\r\n#   $panel.SetSize(80, 12)\r\n#   $panel.OnFiltersChanged = { param($filters) $this.ReloadData() }\r\n#\r\n#   # Apply filters to data\r\n#   $filteredTasks = $panel.ApplyFilters($allTasks)\r\n#\r\n#   # Export/import filter presets\r\n#   $preset = $panel.GetFilterPreset()\r\n#   $panel.LoadFilterPreset($preset)\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Load PmcWidget base class\r\nif (-not ([System.Management.Automation.PSTypeName]'PmcWidget').Type) {\r\n    . \"$PSScriptRoot/PmcWidget.ps1\"\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nDynamic filter builder widget with visual filter chips\r\n\r\n.DESCRIPTION\r\nFeatures:\r\n- Add/remove filters dynamically\r\n- Filter types: Project, Priority, DueDate, Tags, Status, Text\r\n- Visual filter chips: [Project: work] [Priority >= 3] [Due: This Week]\r\n- Alt+A to add filter (shows dropdown of filter types)\r\n- Alt+R to remove selected filter\r\n- Alt+C to clear all filters\r\n- Apply filters to data arrays\r\n- OnFiltersChanged event\r\n- Export/import filter presets\r\n- Smart filter matching with multiple operators\r\n- Preset filters (common filter combinations)\r\n\r\nFilter Types:\r\n- Project: Filter by project name (equals, contains)\r\n- Priority: Filter by priority number (=, !=, <, <=, >, >=)\r\n- DueDate: Filter by due date (today, this week, this month, before, after, between)\r\n- Tags: Filter by tags (has, has all, has any)\r\n- Status: Filter by status (pending, completed, archived)\r\n- Text: Full-text search in task text\r\n\r\n.EXAMPLE\r\n$panel = [FilterPanel]::new()\r\n$panel.SetPosition(5, 5)\r\n$allTasks = Get-PmcData | Select-Object -ExpandProperty tasks\r\n$filteredTasks = $panel.ApplyFilters($allTasks)\r\n##CLOSEBRACKET##\r\nclass FilterPanel : PmcWidget {\r\n    # === Public Properties ===\r\n    [string]$Title = \"Filters\"                 # Panel title\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnFiltersChanged = {}        # Called when filters change: param($filters)\r\n    [scriptblock]$OnFilterAdded = {}           # Called when filter added: param($filter)\r\n    [scriptblock]$OnFilterRemoved = {}         # Called when filter removed: param($index)\r\n    [scriptblock]$OnFiltersCleared = {}        # Called when all filters cleared\r\n\r\n    # === State Flags ===\r\n    [bool]$IsEditing = $false                  # True when editing filters\r\n\r\n    # === Private State ===\r\n    hidden [List[hashtable]]$_filters = [List[hashtable]]::new()     # Active filters\r\n    hidden [int]$_selectedFilterIndex = 0                             # Selected filter index\r\n    hidden [bool]$_showAddMenu = $false                               # Show add filter menu\r\n    hidden [int]$_addMenuSelectedIndex = 0                            # Selected item in add menu\r\n    hidden [string[]]$_availableFilterTypes = @(\r\n        'Project', 'Priority', 'DueDate', 'Tags', 'Status', 'Text'\r\n    )\r\n\r\n    # Filter presets (common filter combinations)\r\n    hidden [hashtable]$_presets = @{\r\n        'Today'         = @(\r\n            @{ Type = 'DueDate'; Op = 'equals'; Value = [DateTime]::Today }\r\n        )\r\n        'This Week'     = @(\r\n            @{ Type = 'DueDate'; Op = 'between'; Value = @([DateTime]::Today, [DateTime]::Today.AddDays(7)) }\r\n        )\r\n        'High Priority' = @(\r\n            @{ Type = 'Priority'; Op = '>='; Value = 4 }\r\n        )\r\n        'Work Project'  = @(\r\n            @{ Type = 'Project'; Op = 'equals'; Value = 'work' }\r\n        )\r\n    }\r\n\r\n    # === Constructor ===\r\n    FilterPanel() : base(\"FilterPanel\") {\r\n        $this.Width = 80\r\n        $this.Height = 12\r\n        $this.CanFocus = $true\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] Resize([int]$width, [int]$height) {\r\n        $this.Width = $width\r\n        $this.Height = $height\r\n    }\r\n\r\n    # === Public API Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set active filters\r\n\r\n    .PARAMETER filters\r\n    Array of filter hashtables\r\n    ##CLOSEBRACKET##\r\n    [void] SetFilters([hashtable[]]$filters) {\r\n        $this._filters.Clear()\r\n\r\n        if ($null -ne $filters -and $filters.Count -gt 0) {\r\n            foreach ($filter in $filters) {\r\n                $this._filters.Add($filter)\r\n            }\r\n        }\r\n\r\n        $this._InvokeCallback($this.OnFiltersChanged, $this.GetFilters())\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get current filters\r\n\r\n    .OUTPUTS\r\n    Array of filter hashtables\r\n    ##CLOSEBRACKET##\r\n    [hashtable[]] GetFilters() {\r\n        return $this._filters.ToArray()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Add a new filter\r\n\r\n    .PARAMETER filter\r\n    Filter hashtable with Type, Op, Value properties\r\n    ##CLOSEBRACKET##\r\n    [void] AddDoFilter([hashtable]$filter) {\r\n        $this._filters.Add($filter)\r\n        $this._InvokeCallback($this.OnFilterAdded, $filter)\r\n        $this._InvokeCallback($this.OnFiltersChanged, $this.GetFilters())\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Remove filter by index\r\n\r\n    .PARAMETER index\r\n    Zero-based filter index\r\n    ##CLOSEBRACKET##\r\n    [void] RemoveDoFilter([int]$index) {\r\n        if ($index -ge 0 -and $index -lt $this._filters.Count) {\r\n            $this._filters.RemoveAt($index)\r\n            $this._InvokeCallback($this.OnFilterRemoved, $index)\r\n            $this._InvokeCallback($this.OnFiltersChanged, $this.GetFilters())\r\n\r\n            # Adjust selected index\r\n            if ($this._selectedFilterIndex -ge $this._filters.Count) {\r\n                $this._selectedFilterIndex = [Math]::Max(0, $this._filters.Count - 1)\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Clear all filters\r\n    ##CLOSEBRACKET##\r\n    [void] ClearFilters() {\r\n        $this._filters.Clear()\r\n        $this._selectedFilterIndex = 0\r\n        $this._InvokeCallback($this.OnFiltersCleared, $null)\r\n        $this._InvokeCallback($this.OnFiltersChanged, $this.GetFilters())\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Apply filters to data array\r\n\r\n    .PARAMETER dataArray\r\n    Array of objects to filter\r\n\r\n    .OUTPUTS\r\n    Filtered array\r\n    ##CLOSEBRACKET##\r\n    [array] ApplyFilters([array]$dataArray) {\r\n        if ($null -eq $dataArray -or $dataArray.Count -eq 0) {\r\n            return @()\r\n        }\r\n\r\n        if ($this._filters.Count -eq 0) {\r\n            return $dataArray\r\n        }\r\n\r\n        $filtered = $dataArray\r\n\r\n        foreach ($filter in $this._filters) {\r\n            $filtered = $this._ApplySingleDoFilter($filtered, $filter)\r\n        }\r\n\r\n        return $filtered\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get human-readable filter string\r\n\r\n    .OUTPUTS\r\n    String describing all active filters\r\n    ##CLOSEBRACKET##\r\n    [string] GetFilterString() {\r\n        if ($this._filters.Count -eq 0) {\r\n            return \"No filters\"\r\n        }\r\n\r\n        $sb = [StringBuilder]::new()\r\n\r\n        foreach ($filter in $this._filters) {\r\n            if ($sb.Length -gt 0) {\r\n                $sb.Append(\" AND \")\r\n            }\r\n\r\n            $sb.Append($this._FormatFilterChip($filter))\r\n        }\r\n\r\n        return $sb.ToString()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get filter preset\r\n\r\n    .OUTPUTS\r\n    Hashtable with filter configuration\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetFilterPreset() {\r\n        return @{\r\n            Filters   = $this.GetFilters()\r\n            Timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Load filter preset\r\n\r\n    .PARAMETER preset\r\n    Preset hashtable from GetFilterPreset()\r\n    ##CLOSEBRACKET##\r\n    [void] LoadFilterPreset([hashtable]$preset) {\r\n        if ($preset.ContainsKey('Filters')) {\r\n            $this.SetFilters($preset.Filters)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle keyboard input\r\n\r\n    .PARAMETER keyInfo\r\n    ConsoleKeyInfo from [Console]::ReadKey($true)\r\n\r\n    .OUTPUTS\r\n    True if input was handled, False otherwise\r\n    ##CLOSEBRACKET##\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        # Add menu navigation\r\n        if ($this._showAddMenu) {\r\n            return $this._HandleAddMenuInput($keyInfo)\r\n        }\r\n\r\n        # Alt+A - add filter\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt -and $keyInfo.Key -eq 'A') {\r\n            $this._showAddMenu = $true\r\n            $this._addMenuSelectedIndex = 0\r\n            return $true\r\n        }\r\n\r\n        # Alt+R - remove selected filter\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt -and $keyInfo.Key -eq 'R') {\r\n            if ($this._filters.Count -gt 0) {\r\n                $this.RemoveDoFilter($this._selectedFilterIndex)\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Alt+C - clear all filters\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt -and $keyInfo.Key -eq 'C') {\r\n            $this.ClearFilters()\r\n            return $true\r\n        }\r\n\r\n        # Navigate filters\r\n        if ($keyInfo.Key -eq 'LeftArrow') {\r\n            if ($this._selectedFilterIndex -gt 0) {\r\n                $this._selectedFilterIndex--\r\n            }\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'RightArrow') {\r\n            if ($this._selectedFilterIndex -lt ($this._filters.Count - 1)) {\r\n                $this._selectedFilterIndex++\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Delete - remove selected filter\r\n        if ($keyInfo.Key -eq 'Delete') {\r\n            if ($this._filters.Count -gt 0) {\r\n                $this.RemoveDoFilter($this._selectedFilterIndex)\r\n            }\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n        \r\n        $engine.DefineRegion(\"$($this.RegionID)_Title\", $this.X + 2, $this.Y + 1, $this.Width - 4, 1)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Count\", $this.X + $this.Width - 10, $this.Y + 1, 8, 1)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Filters\", $this.X + 2, $this.Y + 2, $this.Width - 4, $this.Height - 4)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Help\", $this.X + 2, $this.Y + $this.Height - 2, $this.Width - 4, 1)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render directly to engine (new high-performance path)\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        $this.RegisterLayout($engine)\r\n\r\n        # Colors (Ints)\r\n        [int]$fg = 0; [int]$bg = 0; [int]$borderFg = 0; [int]$primaryFg = 0; [int]$mutedFg = 0; [int]$highlightBg = 0; [int]$highlightFg = 0\r\n\r\n        $fg = $this.GetThemedInt('Foreground.Row')\r\n        $bg = $this.GetThemedBgInt('Background.MenuBar', 1, 0)\r\n        $borderFg = $this.GetThemedInt('Border.Widget')\r\n        $primaryFg = $this.GetThemedInt('Foreground.Title')\r\n        $mutedFg = $this.GetThemedInt('Foreground.Muted')\r\n        $highlightBg = $this.GetThemedBgInt('Background.RowSelected', 1, 0)\r\n        $highlightFg = $this.GetThemedInt('Foreground.RowSelected')\r\n        # Title\r\n        $titleText = \" $($this.Title) \"\r\n        $engine.WriteToRegion(\"$($this.RegionID)_Title\", $titleText, $primaryFg, $bg)\r\n        \r\n        # Count\r\n        $countText = \"($($this._filters.Count) active)\"\r\n        $engine.WriteToRegion(\"$($this.RegionID)_Count\", $countText, $mutedFg, $bg)\r\n        \r\n        # Filters (Chips)\r\n        $filtersRegion = \"$($this.RegionID)_Filters\"\r\n        $bounds = $engine.GetRegionBounds($filtersRegion)\r\n        \r\n        if ($bounds) {\r\n            $currentX = $bounds.X\r\n            $currentY = $bounds.Y\r\n            $maxX = $bounds.X + $bounds.Width\r\n            $maxY = $bounds.Y + $bounds.Height\r\n            \r\n            if ($this._filters.Count -eq 0) {\r\n                # No filters\r\n                $msg = \"No filters active\"\r\n                $pad = [Math]::Max(0, [Math]::Floor(($bounds.Width - $msg.Length) / 2))\r\n                $engine.WriteAt($bounds.X, $currentY + 1, (\" \" * $pad) + $msg, $mutedFg, $bg)\r\n            }\r\n            else {\r\n                for ($i = 0; $i -lt $this._filters.Count; $i++) {\r\n                    $filter = $this._filters[$i]\r\n                    $chipText = \"[\" + $this._FormatFilterChip($filter) + \"]\"\r\n                    $chipLen = $chipText.Length + 1\r\n                    \r\n                    if ($currentX + $chipLen -gt $maxX) {\r\n                        $currentX = $bounds.X\r\n                        $currentY++\r\n                    }\r\n                    \r\n                    if ($currentY -ge $maxY) { break }\r\n                    \r\n                    $isSelected = ($i -eq $this._selectedFilterIndex)\r\n                    $chipBg = if ($isSelected) { $highlightBg } else { $bg }\r\n                    \r\n                    # Color based on type\r\n                    $ansiColor = $this._GetFilterColor($filter.Type)\r\n                    $chipFg = [HybridRenderEngine]::AnsiColorToInt($ansiColor)\r\n                    \r\n                    $engine.WriteAt($currentX, $currentY, $chipText, $chipFg, $chipBg)\r\n                    $currentX += $chipLen\r\n                }\r\n            }\r\n        }\r\n        \r\n        # Add Menu (Overlay)\r\n        if ($this._showAddMenu) {\r\n            $menuWidth = 30\r\n            $menuHeight = $this._availableFilterTypes.Count + 4\r\n            $menuX = $this.X + [Math]::Floor(($this.Width - $menuWidth) / 2)\r\n            $menuY = $this.Y + 2\r\n            \r\n            $menuRegionId = \"$($this.RegionID)_AddMenu\"\r\n            $engine.DefineRegion($menuRegionId, $menuX, $menuY, $menuWidth, $menuHeight, 100)\r\n            \r\n            $engine.Fill($menuX, $menuY, $menuWidth, $menuHeight, ' ', $fg, $bg)\r\n            $engine.DrawBox($menuX, $menuY, $menuWidth, $menuHeight, $borderFg, $bg)\r\n            \r\n            # Menu Title\r\n            $engine.WriteAt($menuX + 2, $menuY, \" Add Filter \", $primaryFg, $bg)\r\n            \r\n            # Items\r\n            for ($i = 0; $i -lt $this._availableFilterTypes.Count; $i++) {\r\n                $type = $this._availableFilterTypes[$i]\r\n                $isSel = ($i -eq $this._addMenuSelectedIndex)\r\n                $iBg = if ($isSel) { $highlightBg } else { $bg }\r\n                \r\n                $engine.Fill($menuX + 1, $menuY + 1 + $i, $menuWidth - 2, 1, ' ', $fg, $iBg)\r\n                $engine.WriteAt($menuX + 2, $menuY + 1 + $i, $type, $fg, $iBg)\r\n            }\r\n            \r\n            # Help\r\n            $engine.WriteAt($menuX + 2, $menuY + $menuHeight - 2, \"Enter=Add | Esc=Cancel\", $mutedFg, $bg)\r\n        }\r\n        \r\n        # Help\r\n        $helpText = \"Alt+A: Add | Alt+R: Remove | Alt+C: Clear | Arrows: Navigate\"\r\n        $engine.WriteToRegion(\"$($this.RegionID)_Help\", $helpText, $mutedFg, $bg)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render the filter panel\r\n\r\n    .OUTPUTS\r\n    ANSI string ready for display\r\n    ##CLOSEBRACKET##\r\n    [string] Render() {\r\n        $sb = [StringBuilder]::new(2048)\r\n\r\n        # Colors from new theme system\r\n        $borderColor = $this.GetThemedFg('Border.Widget')\r\n        $textColor = $this.GetThemedFg('Foreground.Row')\r\n        $primaryColor = $this.GetThemedFg('Foreground.Title')\r\n        $mutedColor = $this.GetThemedFg('Foreground.Muted')\r\n        $errorColor = $this.GetThemedFg('Foreground.Error')\r\n        $successColor = $this.GetThemedFg('Foreground.Success')\r\n        $highlightBg = $this.GetThemedBg('Background.RowSelected', 1, 0)\r\n        $highlightFg = $this.GetThemedFg('Foreground.RowSelected')\r\n        $reset = \"`e[0m\"\r\n\r\n        # Draw top border\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.BuildBoxBorder($this.Width, 'top', 'single'))\r\n\r\n        # Title\r\n        $titleText = \" $($this.Title) \"\r\n        $titlePos = 2\r\n        $sb.Append($this.BuildMoveTo($this.X + $titlePos, $this.Y))\r\n        $sb.Append($primaryColor)\r\n        $sb.Append($titleText)\r\n\r\n        # Filter count\r\n        $countText = \"($($this._filters.Count) active)\"\r\n        $sb.Append($this.BuildMoveTo($this.X + $this.Width - $countText.Length - 2, $this.Y))\r\n        $sb.Append($mutedColor)\r\n        $sb.Append($countText)\r\n\r\n        # Active filters display (rows 1-8)\r\n        $filterDisplayRows = 7\r\n        $currentRow = 1\r\n\r\n        if ($this._filters.Count -eq 0) {\r\n            # No filters message\r\n            $noFiltersY = $this.Y + $currentRow + 2\r\n            $sb.Append($this.BuildMoveTo($this.X, $noFiltersY))\r\n            $sb.Append($borderColor)\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n            $sb.Append($this.BuildMoveTo($this.X + 2, $noFiltersY))\r\n            $sb.Append($mutedColor)\r\n            $sb.Append($this.PadText(\"No filters active\", $this.Width - 4, 'center'))\r\n\r\n            $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $noFiltersY))\r\n            $sb.Append($borderColor)\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n        }\r\n        else {\r\n            # Render filter chips\r\n            $this._RenderFilterChips($sb, $currentRow, $borderColor, $textColor, $primaryColor, $highlightBg, $reset)\r\n        }\r\n\r\n        # Fill remaining rows\r\n        for ($row = $currentRow; $row -lt $filterDisplayRows + 1; $row++) {\r\n            $rowY = $this.Y + $row\r\n            $sb.Append($this.BuildMoveTo($this.X, $rowY))\r\n            $sb.Append($borderColor)\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n            $sb.Append(\" \" * ($this.Width - 2))\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n        }\r\n\r\n        # Add menu overlay (if shown)\r\n        if ($this._showAddMenu) {\r\n            $this._RenderAddMenu($sb, $borderColor, $textColor, $primaryColor, $mutedColor, $highlightBg, $reset)\r\n        }\r\n\r\n        # Help text row\r\n        $helpRowY = $this.Y + $this.Height - 2\r\n        $sb.Append($this.BuildMoveTo($this.X, $helpRowY))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        $sb.Append($this.BuildMoveTo($this.X + 2, $helpRowY))\r\n        $sb.Append($mutedColor)\r\n        $helpText = \"Alt+A: Add | Alt+R: Remove | Alt+C: Clear | Arrows: Navigate\"\r\n        $sb.Append($this.TruncateText($helpText, $this.Width - 4))\r\n\r\n        $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $helpRowY))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        # Bottom border\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y + $this.Height - 1))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.BuildBoxBorder($this.Width, 'bottom', 'single'))\r\n\r\n        $sb.Append($reset)\r\n        return $sb.ToString()\r\n    }\r\n\r\n    # === Private Helper Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render filter chips\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _RenderFilterChips([StringBuilder]$sb, [ref]$currentRow, [string]$borderColor, [string]$textColor, [string]$primaryColor, [string]$highlightBg, [string]$reset) {\r\n        $innerWidth = $this.Width - 4\r\n        $currentX = 0\r\n        $currentY = $currentRow.Value\r\n\r\n        for ($i = 0; $i -lt $this._filters.Count; $i++) {\r\n            $filter = $this._filters[$i]\r\n            $chipText = $this._FormatFilterChip($filter)\r\n            $chipLen = $chipText.Length + 2  # Add padding\r\n\r\n            # Check if we need to wrap to next row\r\n            if ($currentX + $chipLen -gt $innerWidth) {\r\n                # Fill rest of current row\r\n                $padding = $innerWidth - $currentX\r\n                $sb.Append(\" \" * $padding)\r\n\r\n                # Right border\r\n                $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $this.Y + $currentY))\r\n                $sb.Append($borderColor)\r\n                $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n                # Move to next row\r\n                $currentY++\r\n                $currentX = 0\r\n\r\n                # Start new row\r\n                $sb.Append($this.BuildMoveTo($this.X, $this.Y + $currentY))\r\n                $sb.Append($borderColor)\r\n                $sb.Append($this.GetBoxChar('single_vertical'))\r\n            }\r\n\r\n            # Position for chip\r\n            if ($currentX -eq 0) {\r\n                $sb.Append($this.BuildMoveTo($this.X + 2, $this.Y + $currentY))\r\n            }\r\n\r\n            # Render chip\r\n            $isSelected = ($i -eq $this._selectedFilterIndex)\r\n\r\n            if ($isSelected) {\r\n                $sb.Append($highlightBg)\r\n                $sb.Append(\"`e[30m\")\r\n            }\r\n            else {\r\n                $chipColor = $this._GetFilterColor($filter.Type)\r\n                $sb.Append($chipColor)\r\n            }\r\n\r\n            $sb.Append(\"[\")\r\n            $sb.Append($chipText)\r\n            $sb.Append(\"]\")\r\n            $sb.Append($reset)\r\n            $sb.Append(\" \")\r\n\r\n            $currentX += $chipLen + 1\r\n        }\r\n\r\n        # Fill rest of current row\r\n        if ($currentX -lt $innerWidth) {\r\n            $padding = $innerWidth - $currentX\r\n            $sb.Append(\" \" * $padding)\r\n        }\r\n\r\n        # Right border for last row\r\n        $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $this.Y + $currentY))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        $currentRow.Value = $currentY + 1\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render add filter menu overlay\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _RenderAddMenu([StringBuilder]$sb, [string]$borderColor, [string]$textColor, [string]$primaryColor, [string]$mutedColor, [string]$highlightBg, [string]$reset) {\r\n        $menuWidth = 30\r\n        $menuHeight = $this._availableFilterTypes.Count + 4\r\n        $menuX = $this.X + [Math]::Floor(($this.Width - $menuWidth) / 2)\r\n        $menuY = $this.Y + 2\r\n\r\n        # Draw menu border\r\n        $sb.Append($this.BuildMoveTo($menuX, $menuY))\r\n        $sb.Append($primaryColor)\r\n        $sb.Append($this.BuildBoxBorder($menuWidth, 'top', 'single'))\r\n\r\n        # Title\r\n        $sb.Append($this.BuildMoveTo($menuX + 2, $menuY))\r\n        $sb.Append(\" Add Filter \")\r\n\r\n        # Filter types\r\n        for ($i = 0; $i -lt $this._availableFilterTypes.Count; $i++) {\r\n            $itemY = $menuY + $i + 1\r\n            $filterType = $this._availableFilterTypes[$i]\r\n            $isSelected = ($i -eq $this._addMenuSelectedIndex)\r\n\r\n            $sb.Append($this.BuildMoveTo($menuX, $itemY))\r\n            $sb.Append($borderColor)\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n            $sb.Append($this.BuildMoveTo($menuX + 2, $itemY))\r\n\r\n            if ($isSelected) {\r\n                $sb.Append($highlightBg)\r\n                $sb.Append(\"`e[30m\")\r\n            }\r\n            else {\r\n                $sb.Append($textColor)\r\n            }\r\n\r\n            $sb.Append($this.PadText($filterType, $menuWidth - 4, 'left'))\r\n            $sb.Append($reset)\r\n\r\n            $sb.Append($this.BuildMoveTo($menuX + $menuWidth - 1, $itemY))\r\n            $sb.Append($borderColor)\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n        }\r\n\r\n        # Help row\r\n        $helpY = $menuY + $this._availableFilterTypes.Count + 1\r\n        $sb.Append($this.BuildMoveTo($menuX, $helpY))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        $sb.Append($this.BuildMoveTo($menuX + 2, $helpY))\r\n        $sb.Append($mutedColor)\r\n        $sb.Append($this.TruncateText(\"Enter=Add | Esc=Cancel\", $menuWidth - 4))\r\n\r\n        $sb.Append($this.BuildMoveTo($menuX + $menuWidth - 1, $helpY))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        # Bottom border\r\n        $sb.Append($this.BuildMoveTo($menuX, $menuY + $menuHeight - 1))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.BuildBoxBorder($menuWidth, 'bottom', 'single'))\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle add menu input\r\n    ##CLOSEBRACKET##\r\n    hidden [bool] _HandleAddMenuInput([ConsoleKeyInfo]$keyInfo) {\r\n        if ($keyInfo.Key -eq 'Escape') {\r\n            $this._showAddMenu = $false\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'Enter') {\r\n            # Add filter of selected type\r\n            $filterType = $this._availableFilterTypes[$this._addMenuSelectedIndex]\r\n            $newFilter = $this._CreateDefaultDoFilter($filterType)\r\n            $this.AddDoFilter($newFilter)\r\n            $this._showAddMenu = $false\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'UpArrow') {\r\n            if ($this._addMenuSelectedIndex -gt 0) {\r\n                $this._addMenuSelectedIndex--\r\n            }\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'DownArrow') {\r\n            if ($this._addMenuSelectedIndex -lt ($this._availableFilterTypes.Count - 1)) {\r\n                $this._addMenuSelectedIndex++\r\n            }\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Create default filter for a type\r\n    ##CLOSEBRACKET##\r\n    hidden [hashtable] _CreateDefaultDoFilter([string]$filterType) {\r\n        switch ($filterType) {\r\n            'Project' {\r\n                return @{ Type = 'Project'; Op = 'equals'; Value = 'work' }\r\n            }\r\n            'Priority' {\r\n                return @{ Type = 'Priority'; Op = '>='; Value = 3 }\r\n            }\r\n            'DueDate' {\r\n                return @{ Type = 'DueDate'; Op = 'equals'; Value = [DateTime]::Today }\r\n            }\r\n            'Tags' {\r\n                return @{ Type = 'Tags'; Op = 'has'; Value = 'urgent' }\r\n            }\r\n            'Status' {\r\n                return @{ Type = 'Status'; Op = 'equals'; Value = 'pending' }\r\n            }\r\n            'Text' {\r\n                return @{ Type = 'Text'; Op = 'contains'; Value = '' }\r\n            }\r\n            default {\r\n                return @{ Type = 'Unknown'; Op = 'equals'; Value = $null }\r\n            }\r\n        }\r\n        # Fallback (should never reach here)\r\n        return @{ Type = 'Unknown'; Op = 'equals'; Value = $null }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Format filter as chip text\r\n    ##CLOSEBRACKET##\r\n    hidden [string] _FormatFilterChip([hashtable]$filter) {\r\n        $type = $filter.Type\r\n        $op = $filter.Op\r\n        $value = $filter.Value\r\n\r\n        $opSymbol = switch ($op) {\r\n            'equals' { '=' }\r\n            'notequals' { '!=' }\r\n            'contains' { '~' }\r\n            'startswith' { '^' }\r\n            'lt' { '<' }\r\n            'lte' { '<=' }\r\n            'gt' { '>' }\r\n            'gte' { '>=' }\r\n            'has' { 'has' }\r\n            'hasall' { 'has all' }\r\n            'hasany' { 'has any' }\r\n            'between' { 'between' }\r\n            default { $op }\r\n        }\r\n\r\n        # Format value based on type\r\n        $valueStr = \"\"\r\n        if ($value -is [DateTime]) {\r\n            $valueStr = $value.ToString(\"MM/dd\")\r\n        }\r\n        elseif ($value -is [array]) {\r\n            $valueStr = $value -join ', '\r\n        }\r\n        else {\r\n            $valueStr = $value.ToString()\r\n        }\r\n\r\n        return \"$type $opSymbol $valueStr\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get color for filter type\r\n    ##CLOSEBRACKET##\r\n    hidden [string] _GetFilterColor([string]$filterType) {\r\n        $colorMap = @{\r\n            'Project'  = '#3498db'\r\n            'Priority' = '#e74c3c'\r\n            'DueDate'  = '#2ecc71'\r\n            'Tags'     = '#9b59b6'\r\n            'Status'   = '#f39c12'\r\n            'Text'     = '#1abc9c'\r\n        }\r\n\r\n        $hex = $(if ($colorMap.ContainsKey($filterType)) { $colorMap[$filterType] } else { '#CCCCCC' })\r\n\r\n        # Convert hex to RGB\r\n        $hex = $hex.TrimStart('#')\r\n        $r = [Convert]::ToInt32($hex.Substring(0, 2), 16)\r\n        $g = [Convert]::ToInt32($hex.Substring(2, 2), 16)\r\n        $b = [Convert]::ToInt32($hex.Substring(4, 2), 16)\r\n\r\n        return \"`e[38;2;${r};${g};${b}m\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Apply a single filter to data array\r\n    ##CLOSEBRACKET##\r\n    hidden [array] _ApplySingleDoFilter([array]$dataArray, [hashtable]$filter) {\r\n        $type = $filter.Type\r\n        $op = $filter.Op\r\n        $value = $filter.Value\r\n\r\n        $filtered = [System.Collections.ArrayList]::new()\r\n\r\n        foreach ($item in $dataArray) {\r\n            $match = $false\r\n\r\n            switch ($type) {\r\n                'Project' {\r\n                    $itemValue = $(if ($item.project) { $item.project } else { \"\" })\r\n                    $match = $this._CompareValues($itemValue, $op, $value)\r\n                }\r\n\r\n                'Priority' {\r\n                    $itemValue = $(if ($null -ne $item.priority) { $item.priority } else { 0 })\r\n                    $match = $this._CompareValues($itemValue, $op, $value)\r\n                }\r\n\r\n                'DueDate' {\r\n                    if ($null -ne $item.due) {\r\n                        try {\r\n                            $itemDate = $(if ($item.due -is [DateTime]) { $item.due } else { [DateTime]::Parse($item.due) })\r\n                            $match = $this._CompareDates($itemDate, $op, $value)\r\n                        }\r\n                        catch {\r\n                            # Invalid date format - treat as non-matching\r\n                            $match = $false\r\n                        }\r\n                    }\r\n                }\r\n\r\n                'Tags' {\r\n                    $itemTags = $(if ($item.tags) { $item.tags } else { @() })\r\n                    $match = $this._CompareTags($itemTags, $op, $value)\r\n                }\r\n\r\n                'Status' {\r\n                    $itemValue = $(if ($item.status) { $item.status } else { \"pending\" })\r\n                    $match = $this._CompareValues($itemValue, $op, $value)\r\n                }\r\n\r\n                'Text' {\r\n                    $itemValue = $(if ($item.text) { $item.text } else { \"\" })\r\n                    $match = $this._CompareValues($itemValue, $op, $value)\r\n                }\r\n            }\r\n\r\n            if ($match) {\r\n                [void]$filtered.Add($item)\r\n            }\r\n        }\r\n\r\n        # Force array type - prevent PowerShell from unwrapping single-item arrays to scalars\r\n        return @($filtered)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Compare two values based on operator\r\n    ##CLOSEBRACKET##\r\n    hidden [bool] _CompareValues($itemValue, [string]$op, $filterValue) {\r\n        switch ($op) {\r\n            'equals' { return $itemValue -eq $filterValue }\r\n            'notequals' { return $itemValue -ne $filterValue }\r\n            'contains' { return $itemValue -like \"*$filterValue*\" }\r\n            'startswith' { return $itemValue -like \"$filterValue*\" }\r\n            'lt' { return $itemValue -lt $filterValue }\r\n            'lte' { return $itemValue -le $filterValue }\r\n            'gt' { return $itemValue -gt $filterValue }\r\n            'gte' { return $itemValue -ge $filterValue }\r\n            '>=' { return $itemValue -ge $filterValue }\r\n            '<=' { return $itemValue -le $filterValue }\r\n            '>' { return $itemValue -gt $filterValue }\r\n            '<' { return $itemValue -lt $filterValue }\r\n            '=' { return $itemValue -eq $filterValue }\r\n            '!=' { return $itemValue -ne $filterValue }\r\n            default { return $false }\r\n        }\r\n        # Fallback (should never reach here)\r\n        return $false\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Compare dates with operator\r\n    ##CLOSEBRACKET##\r\n    hidden [bool] _CompareDates([DateTime]$itemDate, [string]$op, $filterValue) {\r\n        if ($op -eq 'between' -and $filterValue -is [array] -and $filterValue.Count -ge 2) {\r\n            $start = $filterValue[0]\r\n            $end = $filterValue[1]\r\n            return $itemDate -ge $start -and $itemDate -le $end\r\n        }\r\n\r\n        if ($filterValue -is [DateTime]) {\r\n            return $this._CompareValues($itemDate, $op, $filterValue)\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Compare tags with operator\r\n    ##CLOSEBRACKET##\r\n    hidden [bool] _CompareTags([array]$itemTags, [string]$op, $filterValue) {\r\n        if ($null -eq $itemTags) {\r\n            $itemTags = @()\r\n        }\r\n\r\n        switch ($op) {\r\n            'has' {\r\n                return $itemTags -contains $filterValue\r\n            }\r\n            'hasall' {\r\n                if ($filterValue -is [array]) {\r\n                    foreach ($tag in $filterValue) {\r\n                        if ($itemTags -notcontains $tag) {\r\n                            return $false\r\n                        }\r\n                    }\r\n                    return $true\r\n                }\r\n                return $itemTags -contains $filterValue\r\n            }\r\n            'hasany' {\r\n                if ($filterValue -is [array]) {\r\n                    foreach ($tag in $filterValue) {\r\n                        if ($itemTags -contains $tag) {\r\n                            return $true\r\n                        }\r\n                    }\r\n                    return $false\r\n                }\r\n                return $itemTags -contains $filterValue\r\n            }\r\n            default {\r\n                return $false\r\n            }\r\n        }\r\n        # Fallback (should never reach here)\r\n        return $false\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Invoke callback safely\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _InvokeCallback([scriptblock]$callback, $args) {\r\n        if ($null -ne $callback -and $callback -ne {}) {\r\n            try {\r\n                if ($null -ne $args) {\r\n                    & $callback $args\r\n                }\r\n                else {\r\n                    & $callback\r\n                }\r\n            }\r\n            catch {\r\n                # Silently ignore callback errors\r\n            }\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/widgets/InlineEditor.ps1", "content": "using namespace System\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# InlineEditor.ps1 - Multi-field composer widget for inline editing\r\n# THE KEY WIDGET - Composes multiple input types into a single editor\r\n#\r\n# Usage:\r\n#   $fields = @(\r\n#       @{ Name='text'; Label='Task'; Type='text'; Value='Buy milk'; Required=$true }\r\n#       @{ Name='due'; Label='Due Date'; Type='date'; Value=[DateTime]::Today }\r\n#       @{ Name='project'; Label='Project'; Type='project'; Value='personal' }\r\n#       @{ Name='priority'; Label='Priority'; Type='number'; Value=3; Min=0; Max=5 }\r\n#       @{ Name='tags'; Label='Tags'; Type='tags'; Value=@('urgent') }\r\n#   )\r\n#\r\n#   $editor = [InlineEditor]::new()\r\n#   $editor.SetFields($fields)\r\n#   $editor.SetPosition(5, 5)\r\n#   $editor.OnConfirmed = { param($values) Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [InlineEditor] Saved: $($values | ConvertTo-Json)\" }\r\n#\r\n#   # Render loop\r\n#   while (-not $editor.IsConfirmed -and -not $editor.IsCancelled) {\r\n#       $ansiOutput = $editor.Render()\r\n#       Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [InlineEditor] Rendering editor\"\r\n#       $key = [Console]::ReadKey($true)\r\n#       $editor.HandleInput($key)\r\n#   }\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Load PmcWidget base class and field widgets\r\nif (-not ([System.Management.Automation.PSTypeName]'PmcWidget').Type) {\r\n    . \"$PSScriptRoot/PmcWidget.ps1\"\r\n}\r\n\r\n# Load field widgets\r\n. \"$PSScriptRoot/TextInput.ps1\"\r\n. \"$PSScriptRoot/DatePicker.ps1\"\r\n. \"$PSScriptRoot/ProjectPicker.ps1\"\r\n. \"$PSScriptRoot/TagEditor.ps1\"\r\n\r\n<#\r\n.SYNOPSIS\r\nMulti-field inline editor that composes existing widgets into a unified editor\r\n\r\n.DESCRIPTION\r\nFeatures:\r\n- Compose multiple field types: text, date, project, number, tags\r\n- Tab/Shift+Tab to cycle between fields\r\n- Enter to confirm all changes (validates all fields)\r\n- Esc to cancel\r\n- Visual field list with labels\r\n- Field validation with error display\r\n- OnFieldChanged event for each field change\r\n- OnConfirmed event with all field values\r\n- Smart layout - fields stack vertically\r\n- Focus indicators for active field\r\n- Required field validation\r\n\r\nField Types:\r\n- text: Single-line text input (uses TextInput widget)\r\n- date: Date picker (uses DatePicker widget)\r\n- project: Project picker (uses ProjectPicker widget)\r\n- tags: Tag editor (uses TagEditor widget)\r\n- number: Number input with visual slider (custom inline widget)\r\n\r\n.EXAMPLE\r\n$fields = @(\r\n    @{ Name='text'; Label='Task'; Type='text'; Value='Buy milk'; Required=$true }\r\n    @{ Name='due'; Label='Due Date'; Type='date'; Value=[DateTime]::Today }\r\n    @{ Name='project'; Label='Project'; Type='project'; Value='personal' }\r\n    @{ Name='priority'; Label='Priority'; Type='number'; Value=3; Min=0; Max=5 }\r\n    @{ Name='tags'; Label='Tags'; Type='tags'; Value=@('urgent') }\r\n)\r\n$editor = [InlineEditor]::new()\r\n$editor.SetFields($fields)\r\n$values = $editor.GetValues()\r\n##CLOSEBRACKET##\r\nclass InlineEditor : PmcWidget {\r\n    # === Public Properties ===\r\n    [string]$Title = \"Edit\"                    # Editor title\r\n    [string]$LayoutMode = \"vertical\"           # \"vertical\" (default) or \"horizontal\" (compact inline mode)\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnFieldChanged = {}          # Called when field changes: param($fieldName, $value)\r\n    [scriptblock]$OnConfirmed = {}             # Called when Enter pressed: param($allValues)\r\n    [scriptblock]$OnCancelled = {}             # Called when Esc pressed\r\n    [scriptblock]$OnValidationFailed = {}      # Called when validation fails: param($errors)\r\n\r\n    # === State Flags ===\r\n    [bool]$IsConfirmed = $false                # True when Enter pressed and validated\r\n    [bool]$IsCancelled = $false                # True when Esc pressed\r\n    [bool]$NeedsClear = $false                 # True when field widget was closed and screen needs clear\r\n    [string]$TargetRegionID = \"\"               # Engine Layout Region to target (if any)\r\n\r\n    # === Private State ===\r\n    hidden [List[hashtable]]$_fields = [List[hashtable]]::new()      # Field definition\r\n    hidden [hashtable]$_fieldWidgets = @{}                           # Widget instances keyed by field name\r\n    hidden [hashtable]$_datePickerWidgets = @{}                      # DatePicker instances for date fields (kept separate from TextInput)\r\n    hidden [int]$_currentFieldIndex = 0                              # Currently focused field\r\n    hidden [string[]]$_validationErrors = @()                        # Current validation errors\r\n    hidden [hashtable]$_fieldErrors = @{}                            # H-UI-3: Per-field validation errors for real-time display\r\n    hidden [bool]$_showFieldWidgets = $false                         # Whether to show expanded field widget\r\n    hidden [string]$_expandedFieldName = \"\"                          # Name of currently expanded field\r\n    hidden [bool]$_datePickerMode = $false                           # True when DatePicker is active (not TextInput)\r\n\r\n    # Validation debouncing\r\n    hidden [DateTime]$_lastKeystroke = [DateTime]::MinValue\r\n    hidden [int]$_validationDelayMs = 300                            # Wait 300ms after last keystroke before validating\r\n    hidden [string]$_pendingValidationField = \"\"                     # Field pending validation\r\n\r\n    # === Constructor ===\r\n    InlineEditor() : base(\"InlineEditor\") {\r\n        $this.Width = 70\r\n        $this.Height = 25\r\n        $this.CanFocus = $true\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] Resize([int]$width, [int]$height) {\r\n        $this.Width = $width\r\n        $this.Height = $height\r\n        # Re-calculate layout if needed\r\n    }\r\n\r\n    # === Public API Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Configure the fields for this editor\r\n\r\n    .PARAMETER fields\r\n    Array of hashtables with field definitions:\r\n    - Name: Field identifier (required)\r\n    - Label: Display label (required)\r\n    - Type: Field type: text, date, project, number, tags (required)\r\n    - Value: Initial value (optional)\r\n    - Required: Whether field is required (optional, default $false)\r\n    - Min/Max: For number type (optional)\r\n    - MaxLength: For text type (optional)\r\n    - Placeholder: For text type (optional)\r\n    ##CLOSEBRACKET##\r\n    [void] SetFields([hashtable[]]$fields) {\r\n        # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.SetFields] START with $($fields.Count) fields, LayoutMode=$($this.LayoutMode) X=$($this.X) Y=$($this.Y) Width=$($this.Width) Height=$($this.Height) Visible=$($this.Visible)\"\r\n        $this._fields.Clear()\r\n        # Note: Old widget references cleared from dictionaries\r\n        # PowerShell GC will clean up. Widgets don't register external event handlers.\r\n        $this._fieldWidgets.Clear()\r\n        $this._datePickerWidgets.Clear()\r\n        $this._currentFieldIndex = 0\r\n        # Add-Content -Path \"$($env:TEMP)/pmc-flow-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.SetFields] Cleared existing fields/widgets\"\r\n        $this._validationErrors = @()\r\n        $this._datePickerMode = $false\r\n\r\n        # Reset state flags\r\n        $this.IsConfirmed = $false\r\n        $this.IsCancelled = $false\r\n\r\n        if ($null -eq $fields -or $fields.Count -eq 0) {\r\n            return\r\n        }\r\n\r\n        foreach ($fieldDef in $fields) {\r\n            # Validate field definition\r\n            if (-not $fieldDef.ContainsKey('Name')) {\r\n                throw \"Field definition missing 'Name' property\"\r\n            }\r\n            if (-not $fieldDef.ContainsKey('Label')) {\r\n                throw \"Field definition missing 'Label' property\"\r\n            }\r\n            if (-not $fieldDef.ContainsKey('Type')) {\r\n                throw \"Field definition missing 'Type' property\"\r\n            }\r\n\r\n            # Add to fields list\r\n            $this._fields.Add($fieldDef)\r\n            # Write-PmcTuiLog \"InlineEditor.SetFields: Added field '$($fieldDef.Name)' type=$($fieldDef.Type)\" \"DEBUG\"\r\n\r\n            # Create widget instance for this field\r\n            try {\r\n                $this._CreateFieldWidget($fieldDef)\r\n                # Write-PmcTuiLog \"InlineEditor.SetFields: Created widget for field '$($fieldDef.Name)'\" \"DEBUG\"\r\n            }\r\n            catch {\r\n                # Write-PmcTuiLog \"InlineEditor.SetFields: ERROR creating widget for field '$($fieldDef.Name)': $_\" \"ERROR\"\r\n                throw\r\n            }\r\n        }\r\n\r\n        # Add Save button as last field ONLY in vertical mode\r\n        # In horizontal mode, Enter key saves directly, no button needed\r\n        if ($this.LayoutMode -eq 'vertical') {\r\n            $saveButton = @{\r\n                Name       = '__save_button__'\r\n                Label      = ''\r\n                Type       = 'button'\r\n                ButtonText = 'Save'\r\n            }\r\n            $this._fields.Add($saveButton)\r\n        }\r\n\r\n        # Calculate required height based on field count\r\n        $this.Height = 6 + ($this._fields.Count * 3) + 3  # Header + fields + footer + padding\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get all field values as hashtable\r\n\r\n    .OUTPUTS\r\n    Hashtable with field names as keys and current values as values\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetValues() {\r\n        # Write-PmcTuiLog \"GetValues: Starting, _fields count=$($this._fields.Count)\" \"DEBUG\"\r\n        $values = @{}\r\n\r\n        foreach ($field in $this._fields) {\r\n            $fieldName = $field.Name\r\n            $fieldType = $field.Type\r\n\r\n            # Write-PmcTuiLog \"GetValues: Processing field=$fieldName type=$fieldType\" \"DEBUG\"\r\n\r\n            # Skip button fields\r\n            if ($fieldType -eq 'button') {\r\n                continue\r\n            }\r\n\r\n            $value = $this._GetFieldValue($fieldName, $fieldType)\r\n            # Write-PmcTuiLog \"GetValues: Field $fieldName value=$value\" \"DEBUG\"\r\n            $values[$fieldName] = $value\r\n        }\r\n\r\n        # Write-PmcTuiLog \"GetValues: Returning hashtable with $($values.Keys.Count) keys: $($values.Keys -join ', ')\" \"DEBUG\"\r\n        return $values\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get value of a specific field\r\n\r\n    .PARAMETER name\r\n    Field name\r\n\r\n    .OUTPUTS\r\n    Field value or $null if field not found\r\n    ##CLOSEBRACKET##\r\n    [object] GetField([string]$name) {\r\n        $field = $this._fields | Where-Object { $_.Name -eq $name } | Select-Object -First 1\r\n\r\n        if ($null -eq $field) {\r\n            return $null\r\n        }\r\n\r\n        return $this._GetFieldValue($name, $field.Type)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set focus to a specific field by index\r\n\r\n    .PARAMETER fieldIndex\r\n    Zero-based field index\r\n    ##CLOSEBRACKET##\r\n    [void] SetFocus([int]$fieldIndex) {\r\n        if ($fieldIndex -ge 0 -and $fieldIndex -lt $this._fields.Count) {\r\n            $this._currentFieldIndex = $fieldIndex\r\n            $this._showFieldWidgets = $false\r\n            $this._expandedFieldName = \"\"\r\n            $this._datePickerMode = $false\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle keyboard input\r\n\r\n    .PARAMETER keyInfo\r\n    ConsoleKeyInfo from [Console]::ReadKey($true)\r\n\r\n    .OUTPUTS\r\n    True if input was handled, False otherwise\r\n    ##CLOSEBRACKET##\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        # Write-PmcTuiLog \"InlineEditor.HandleInput: Key=$($keyInfo.Key) Expanded=$($this._expandedFieldName)\" \"DEBUG\"\r\n        # Add-Content -Path \"$($env:TEMP)\\pmc-widget-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.HandleInput] START Key=$($keyInfo.Key) Expanded=$($this._expandedFieldName) ShowFieldWidgets=$($this._showFieldWidgets) CurrentFieldIndex=$($this._currentFieldIndex) FieldsCount=$($this._fields.Count) LayoutMode=$($this.LayoutMode)\"\r\n\r\n        # If a field widget is expanded, route input to it\r\n        if ($this._showFieldWidgets -and -not [string]::IsNullOrWhiteSpace($this._expandedFieldName)) {\r\n            # Add-Content -Path \"$($env:TEMP)\\pmc-widget-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.HandleInput] Widget is expanded, routing input to field widget\"\r\n            # Safety: Allow Escape to force-close expanded widget even if widget doesn't handle it\r\n            if ($keyInfo.Key -eq 'Escape') {\r\n                # Add-Content -Path \"$($env:TEMP)\\pmc-widget-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.HandleInput] ESC pressed on expanded widget, collapsing\"\r\n                $this._showFieldWidgets = $false\r\n                $this._expandedFieldName = \"\"\r\n                $this._datePickerMode = $false\r\n                return $true\r\n            }\r\n\r\n            # Get the appropriate widget based on mode\r\n            $widget = $null\r\n            $field = $this._fields | Where-Object { $_.Name -eq $this._expandedFieldName } | Select-Object -First 1\r\n\r\n            # Add-Content -Path \"$($env:TEMP)\\pmc-widget-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.HandleInput] Field type: $($field.Type) Mode: $($this._datePickerMode)\"\r\n            if ($field.Type -eq 'date' -and $this._datePickerMode) {\r\n                # Use DatePicker when in DatePicker mode\r\n                $widget = $this._datePickerWidgets[$this._expandedFieldName]\r\n            }\r\n            else {\r\n                # Use normal widget\r\n                $widget = $this._fieldWidgets[$this._expandedFieldName]\r\n            }\r\n\r\n            # Check for widget-specific completion\r\n            # Add-Content -Path \"$($env:TEMP)\\pmc-widget-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.HandleInput] Calling widget.HandleInput() for field $($this._expandedFieldName)\"\r\n            $handled = $widget.HandleInput($keyInfo)\r\n            # Add-Content -Path \"$($env:TEMP)\\pmc-widget-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.HandleInput] widget.HandleInput() returned: $handled\"\r\n\r\n            # Check if widget confirmed or cancelled\r\n            # PmcFilePicker uses IsComplete instead of IsConfirmed/IsCancelled\r\n            $isComplete = $false\r\n            if ($widget.PSObject.Properties['IsComplete']) {\r\n                $isComplete = $widget.IsComplete\r\n                # Add-Content -Path \"$($env:TEMP)\\pmc-widget-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.HandleInput] Widget has IsComplete property: $isComplete\"\r\n            }\r\n            elseif ($widget.PSObject.Properties['IsConfirmed']) {\r\n                $isComplete = $widget.IsConfirmed -or $widget.IsCancelled\r\n                # Add-Content -Path \"$($env:TEMP)\\pmc-widget-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.HandleInput] Widget has IsConfirmed property: IsConfirmed=$($widget.IsConfirmed) IsCancelled=$($widget.IsCancelled) isComplete=$isComplete\"\r\n            }\r\n\r\n            if ($isComplete) {\r\n                # Add-Content -Path \"$($env:TEMP)\\pmc-widget-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.HandleInput] Widget marked complete, collapsing\"\r\n                # For date fields in DatePicker mode, update TextInput with selected date\r\n                if ($field.Type -eq 'date' -and $this._datePickerMode) {\r\n                    # Get selected date from DatePicker\r\n                    $selectedDate = $(if ($widget.IsConfirmed) { $widget.GetSelectedDate() } else { $null })\r\n\r\n                    if ($selectedDate) {\r\n                        # Update the TextInput widget (which is still stored in _fieldWidgets)\r\n                        $textWidget = $this._fieldWidgets[$this._expandedFieldName]\r\n                        $textWidget.SetText($selectedDate.ToString('yyyy-MM-dd'))\r\n                        # Update field value\r\n                        $field.Value = $selectedDate\r\n                    }\r\n                }\r\n\r\n                # For folder fields, update TextInput with selected path\r\n                if ($field.Type -eq 'folder' -and $widget.PSObject.Properties['IsComplete'] -and $widget.IsComplete) {\r\n                    # Write-PmcTuiLog \"InlineEditor: Folder picker complete - Result=$($widget.Result) SelectedPath='$($widget.SelectedPath)'\" \"DEBUG\"\r\n                    # Add-Content -Path \"$($env:TEMP)\\pmc-widget-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.HandleInput] Folder picker complete\"\r\n\r\n                    # Get selected path from FilePicker\r\n                    $selectedPath = $(if ($widget.Result) { $widget.SelectedPath } else { '' })\r\n\r\n                    # Write-PmcTuiLog \"InlineEditor: Setting folder field value to '$selectedPath'\" \"DEBUG\"\r\n\r\n                    # Recreate TextInput and restore it\r\n                    $textWidget = [TextInput]::new()\r\n                    $textWidget.MaxLength = 255\r\n                    $textWidget.Placeholder = 'Press Enter to browse...'\r\n                    $textWidget.SetText($selectedPath)\r\n\r\n                    # Restore TextInput in place of FilePicker\r\n                    $this._fieldWidgets[$this._expandedFieldName] = $textWidget\r\n\r\n                    # Update field value\r\n                    $field.Value = $selectedPath\r\n\r\n                    # Write-PmcTuiLog \"InlineEditor: Folder field updated - field.Value='$($field.Value)'\" \"DEBUG\"\r\n                }\r\n\r\n                # Collapse widget\r\n                # Add-Content -Path \"$($env:TEMP)\\pmc-widget-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [InlineEditor.HandleInput] Collapsing widget, setting _showFieldWidgets=false and NeedsClear=true\"\r\n                $this._showFieldWidgets = $false\r\n                $this._datePickerMode = $false\r\n                # DO NOT set NeedsClear - widget will be hidden naturally on next render\r\n\r\n                # Get value from widget and update field BEFORE collapsing\r\n                # Only for widgets that have IsConfirmed property (not PmcFilePicker which uses Result)\r\n                if ($widget.PSObject.Properties['IsConfirmed'] -and $widget.IsConfirmed) {\r\n                    # For tags, get tags directly from TagEditor\r\n                    if ($field.Type -eq 'tags') {\r\n                        $field.Value = $widget.GetTags()\r\n                    }\r\n                    # For project, get selected project and update field value\r\n                    elseif ($field.Type -eq 'project') {\r\n                        $selectedProject = $widget.GetSelectedProject()\r\n                        $field.Value = $selectedProject\r\n\r\n                        # CRITICAL: Restore the original TextInput widget with selected value\r\n                        # In horizontal mode, project field uses TextInput (which was temporarily replaced by ProjectPicker)\r\n                        $textWidget = [TextInput]::new()\r\n                        $textWidget.MaxLength = 100\r\n                        $textWidget.Placeholder = 'Project name'\r\n                        $textWidget.SetText([string]$selectedProject)\r\n                        $this._fieldWidgets[$this._expandedFieldName] = $textWidget\r\n                    }\r\n\r\n                    $this._InvokeCallback($this.OnFieldChanged, @($this._expandedFieldName, $field.Value))\r\n                }\r\n\r\n                # For PmcFilePicker, trigger callback if Result is true\r\n                if ($field.Type -eq 'folder' -and $widget.PSObject.Properties['Result'] -and $widget.Result) {\r\n                    $this._InvokeCallback($this.OnFieldChanged, @($this._expandedFieldName, $field.Value))\r\n                }\r\n\r\n                $this._expandedFieldName = \"\"\r\n                return $true\r\n            }\r\n\r\n            return $handled\r\n        }\r\n\r\n        # Enter key behavior depends on current field\r\n        if ($keyInfo.Key -eq 'Enter') {\r\n            # Write-PmcTuiLog \"InlineEditor.HandleKeyPress: Enter key pressed - currentFieldIndex=$($this._currentFieldIndex)\" \"DEBUG\"\r\n            # Check current field type\r\n            if ($this._currentFieldIndex -ge 0 -and $this._currentFieldIndex -lt $this._fields.Count) {\r\n                $currentField = $this._fields[$this._currentFieldIndex]\r\n                # Write-PmcTuiLog \"InlineEditor.HandleKeyPress: Current field type: $($currentField.Type)\" \"DEBUG\"\r\n\r\n                # For Button type - validate and save\r\n                if ($currentField.Type -eq 'button') {\r\n                    if ($this._ValidateAllFields()) {\r\n                        # Write-PmcTuiLog \"InlineEditor: Save button pressed - Saving form\" \"DEBUG\"\r\n                        $this.IsConfirmed = $true\r\n                        $values = $this.GetValues()\r\n                        $this._InvokeCallback($this.OnConfirmed, $values)\r\n                        return $true\r\n                    }\r\n                    else {\r\n                        # Write-PmcTuiLog \"InlineEditor: Validation FAILED - Errors: $($this._validationErrors -join ', ')\" \"ERROR\"\r\n                        $this._InvokeCallback($this.OnValidationFailed, $this._validationErrors)\r\n                        return $true\r\n                    }\r\n                }\r\n\r\n                # For Date/Project/Folder fields - Enter expands the widget\r\n                if ($currentField.Type -eq 'date' -or $currentField.Type -eq 'project' -or $currentField.Type -eq 'folder') {\r\n                    # Write-PmcTuiLog \"InlineEditor: Enter on $($currentField.Type) field - expanding widget\" \"DEBUG\"\r\n                    $this._ExpandCurrentField()\r\n                    return $true\r\n                }\r\n\r\n                # For all fields (in horizontal mode) or other field types - Enter ALWAYS validates and saves\r\n                if ($this._ValidateAllFields()) {\r\n                    # Write-PmcTuiLog \"InlineEditor: Validation passed, confirming\" \"DEBUG\"\r\n                    $this.IsConfirmed = $true\r\n                    $values = $this.GetValues()\r\n                    $this._InvokeCallback($this.OnConfirmed, $values)\r\n                    return $true\r\n                }\r\n                else {\r\n                    # Validation failed - show errors and stay open\r\n                    # Write-PmcTuiLog \"InlineEditor: Validation FAILED - Errors: $($this._validationErrors -join ', ')\" \"ERROR\"\r\n                    $this._InvokeCallback($this.OnValidationFailed, $this._validationErrors)\r\n                    return $true\r\n                }\r\n            }\r\n\r\n            # No field selected - validate and confirm\r\n            if ($this._ValidateAllFields()) {\r\n                $this.IsConfirmed = $true\r\n                $values = $this.GetValues()\r\n                $this._InvokeCallback($this.OnConfirmed, $values)\r\n                return $true\r\n            }\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'Escape') {\r\n            $this.IsCancelled = $true\r\n            $this.NeedsClear = $true  # Request full screen clear to remove partial entry\r\n            $this._InvokeCallback($this.OnCancelled, $null)\r\n            return $true\r\n        }\r\n\r\n        # Tab - navigate between fields\r\n        if ($keyInfo.Key -eq 'Tab') {\r\n            if ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift) {\r\n                # Shift+Tab - navigate to previous field\r\n                $this._MoveToPreviousField()\r\n            }\r\n            else {\r\n                # Tab - navigate to next field (in horizontal mode, Tab ALWAYS navigates, never expands)\r\n                # In vertical mode, Tab could expand widgets, but in horizontal mode we keep it simple\r\n                $this._MoveToNextField()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Up/Down arrows - navigate fields\r\n        if ($keyInfo.Key -eq 'UpArrow') {\r\n            $this._MoveToPreviousField()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'DownArrow') {\r\n            $this._MoveToNextField()\r\n            return $true\r\n        }\r\n\r\n        # Left/Right arrows - adjust number fields inline\r\n        if ($this._currentFieldIndex -ge 0 -and $this._currentFieldIndex -lt $this._fields.Count) {\r\n            $currentField = $this._fields[$this._currentFieldIndex]\r\n\r\n            if ($currentField.Type -eq 'number') {\r\n                $min = $(if ($currentField.ContainsKey('Min')) { $currentField.Min } else { 0 })\r\n                $max = $(if ($currentField.ContainsKey('Max')) { $currentField.Max } else { 10 })\r\n                $step = $(if ($currentField.ContainsKey('Step')) { $currentField.Step } else { 1 })\r\n                $currentValue = $this._GetFieldValue($currentField.Name, 'number')\r\n                if ($null -eq $currentValue) { $currentValue = $min }\r\n\r\n                if ($keyInfo.Key -eq 'LeftArrow' -and $currentValue -gt $min) {\r\n                    $this._SetFieldValue($currentField.Name, $currentValue - $step)\r\n                    return $true\r\n                }\r\n\r\n                if ($keyInfo.Key -eq 'RightArrow' -and $currentValue -lt $max) {\r\n                    $this._SetFieldValue($currentField.Name, $currentValue + $step)\r\n                    return $true\r\n                }\r\n            }\r\n        }\r\n\r\n        # F2 - expand current field widget (DatePicker, ProjectPicker, etc.)\r\n        # Note: Spacebar is handled below for non-text fields to allow typing spaces\r\n        if ($keyInfo.Key -eq 'F2') {\r\n            $this._ExpandCurrentField()\r\n            return $true\r\n        }\r\n\r\n        # For all fields with widgets, allow direct typing (inline editing)\r\n        if ($this._currentFieldIndex -ge 0 -and $this._currentFieldIndex -lt $this._fields.Count) {\r\n            $currentField = $this._fields[$this._currentFieldIndex]\r\n            # Write-PmcTuiLog \"InlineEditor.HandleInput: Current field index=$($this._currentFieldIndex) name=$($currentField.Name) type=$($currentField.Type)\" \"DEBUG\"\r\n\r\n            # Text, Textarea, Date, Tags, Project AND Number fields - pass input to widget\r\n            if ($currentField.Type -eq 'text' -or $currentField.Type -eq 'textarea' -or $currentField.Type -eq 'date' -or $currentField.Type -eq 'tags' -or $currentField.Type -eq 'project' -or $currentField.Type -eq 'number') {\r\n                # Don't pass navigation keys to widget - let InlineEditor handle them\r\n                # NOTE: Enter is NOT in this list - it's already handled above at line 383\r\n                if ($keyInfo.Key -eq 'Tab' -or $keyInfo.Key -eq 'UpArrow' -or $keyInfo.Key -eq 'DownArrow') {\r\n                    return $false  # Let InlineEditor handle navigation\r\n                }\r\n\r\n                # Clear validation errors when user starts editing a field\r\n                # This prevents stale error messages from appearing while the user is actively typing\r\n                # Skip for navigation and submission keys\r\n                if ($keyInfo.Key -ne 'Enter') {\r\n                    $this._validationErrors = @()\r\n                }\r\n\r\n                if (-not $this._fieldWidgets.ContainsKey($currentField.Name)) {\r\n                    # Write-PmcTuiLog \"InlineEditor.HandleInput: ERROR - Widget not found for field '$($currentField.Name)'. Available widgets: $($this._fieldWidgets.Keys -join ', ')\" \"ERROR\"\r\n                    return $false\r\n                }\r\n\r\n                $widget = $this._fieldWidgets[$currentField.Name]\r\n                # Write-PmcTuiLog \"InlineEditor.HandleInput: Routing input to widget type=$($widget.GetType().Name)\" \"DEBUG\"\r\n                # Handle input for TextInput\r\n                if ($widget.GetType().Name -eq 'TextInput') {\r\n                    # DEBUG: Detailed trace\r\n                    # Add-Content -Path \"/tmp/pmc-input-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] InlineEditor: Before TextInput.HandleInput - Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' Text='$($widget.Text)'\"\r\n                    # Write-PmcTuiLog \"InlineEditor.HandleInput: Calling TextInput.HandleInput() with key=$($keyInfo.Key) char=$($keyInfo.KeyChar)\" \"DEBUG\"\r\n                    $textBefore = $widget.Text\r\n                    $handled = $widget.HandleInput($keyInfo)\r\n                    $textAfter = $widget.Text\r\n                    # Add-Content -Path \"/tmp/pmc-input-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] InlineEditor: After TextInput.HandleInput - handled=$handled Text before='$textBefore' after='$textAfter'\"\r\n                    # Write-PmcTuiLog \"InlineEditor.HandleInput: TextInput.HandleInput() returned - Text before='$textBefore' after='$textAfter' handled=$handled\" \"DEBUG\"\r\n\r\n                    # CRITICAL FIX: If TextInput confirmed (Enter pressed), validate and confirm ENTIRE form\r\n                    if ($widget.PSObject.Properties['IsConfirmed'] -and $widget.IsConfirmed) {\r\n                        if ($this._ValidateAllFields()) {\r\n                            $this.IsConfirmed = $true\r\n                            $values = $this.GetValues()\r\n                            $this._InvokeCallback($this.OnConfirmed, $values)\r\n                            return $true\r\n                        }\r\n                        else {\r\n                            # Validation failed - show errors, reset TextInput confirmation, stay open\r\n                            $widget.IsConfirmed = $false\r\n                            $this._InvokeCallback($this.OnValidationFailed, $this._validationErrors)\r\n                            return $true\r\n                        }\r\n                    }\r\n\r\n                    # H-UI-3: Real-time validation with debouncing\r\n                    # Instead of validating immediately, queue validation for later\r\n                    if ($handled -and $keyInfo.Key -ne 'Enter' -and $keyInfo.Key -ne 'Escape') {\r\n                        $this._lastKeystroke = [DateTime]::Now\r\n                        $this._pendingValidationField = $currentField.Name\r\n                        # Validation will happen in Update() method after delay\r\n                    }\r\n\r\n                    return $handled\r\n                }\r\n                return $false\r\n            }\r\n\r\n            # For non-text fields (Folder, File, etc.) allow Spacebar to expand\r\n            if ($keyInfo.Key -eq 'Spacebar') {\r\n                $this._ExpandCurrentField()\r\n                return $true\r\n            }\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    # === Rendering ===\r\n\r\n    [void] RenderToEngine([object]$engine) {\r\n        # Process debounced validation first\r\n        $this._ProcessDebouncedValidation()\r\n\r\n\r\n        # Use Z-layer for popup effect (Editor is always on top)\r\n        # CRITICAL FIX: Base panels render at Z=20. We must be higher.\r\n        # using 100 (Dropdown/Overlay level) ensures we are visible.\r\n        if ($engine.PSObject.Methods['BeginLayer']) {\r\n            $engine.BeginLayer(100)\r\n        }\r\n\r\n        # CRITICAL FIX: Lock rendering coordinates to prevent column misalignment\r\n        # Some rendering systems modify X/Width during render, causing 1-pixel shifts\r\n        # Cache values at render start and use these locked values throughout\r\n        $lockedX = $this.X\r\n        $lockedWidth = $this.Width\r\n        $lockedY = $this.Y\r\n\r\n        # LAYOUT SYSTEM: Render fields horizontally\r\n\r\n        $currentX = $lockedX\r\n\r\n        # Colors (Int)\r\n        $focusBg = $this.GetThemedColorInt('Background.FieldFocused')\r\n        $focusFg = $this.GetThemedColorInt('Foreground.FieldFocused')\r\n        $normalBg = $this.GetThemedColorInt('Background.Field')\r\n        $normalFg = $this.GetThemedColorInt('Foreground.Field')\r\n\r\n\r\n        for ($i = 0; $i -lt $this._fields.Count; $i++) {\r\n            $field = $this._fields[$i]\r\n            $isFocused = ($i -eq $this._currentFieldIndex)\r\n            $fieldWidth = $(if ($field.ContainsKey('Width')) { $field.Width } else { 20 })\r\n\r\n            # Determine colors\r\n            $fg = $(if ($isFocused) { $focusFg } else { $normalFg })\r\n            $bg = $(if ($isFocused) { $focusBg } else { $normalBg })\r\n\r\n            # Get display value\r\n            $val = $this._GetFieldValuePreview($field)\r\n            $displayText = $val\r\n\r\n\r\n            # PREVENT DOUBLE BORDER ARTIFACTS:\r\n            # If this field is currently expanded with a \"Replacement\" widget (Project/Tags),\r\n            # we must BLANK OUT the underlying area to erase the List Grid lines.\r\n            # But we skip drawing the text content to avoid \"text bleeding\" at the edges.\r\n            if ($isFocused -and $this._showFieldWidgets -and $this._expandedFieldName -eq $field.Name) {\r\n                if ($field.Type -eq 'project' -or $field.Type -eq 'tags') {\r\n                    # Erase the entire field area with opaque background\r\n                    # This hides the underlying List Grid / Separators\r\n                    $engine.Fill($currentX, $lockedY, $fieldWidth, 1, ' ', $fg, $bg)\r\n                    \r\n                    # Advance X and skip drawing text/cursor (replaced by widget)\r\n                    $currentX += $fieldWidth\r\n                    continue\r\n                }\r\n            }\r\n            \r\n            # Text Input Handling (Cursor logic)\r\n            $isEditableType = ($field.Type -eq 'text' -or $field.Type -eq 'textarea' -or $field.Type -eq 'date' -or $field.Type -eq 'tags' -or $field.Type -eq 'project')\r\n            $hasWidget = $this._fieldWidgets.ContainsKey($field.Name)\r\n            if ($isFocused -and $isEditableType -and $hasWidget) {\r\n                $widget = $this._fieldWidgets[$field.Name]\r\n                if ($widget.GetType().Name -eq 'TextInput') {\r\n                    $text = $widget.GetText()\r\n\r\n                    # Ensure widget width logic\r\n                    $widget.Width = $fieldWidth + 4\r\n                    \r\n                    $cursorPos = $widget._cursorPosition\r\n                    $scrollOffset = $widget._scrollOffset\r\n                     \r\n                    # Scroll logic \r\n                    if ($cursorPos -lt $scrollOffset) { $scrollOffset = $cursorPos }\r\n                    if ($cursorPos -gt ($scrollOffset + $fieldWidth - 1)) { $scrollOffset = $cursorPos - $fieldWidth + 1 }\r\n                    if ($scrollOffset -lt 0) { $scrollOffset = 0 }\r\n                    $widget._scrollOffset = $scrollOffset # Update widget state\r\n                    \r\n                    $visibleText = \"\"\r\n                    if ($scrollOffset -lt $text.Length) {\r\n                        $visibleText = $text.Substring($scrollOffset)\r\n                    }\r\n                    if ($visibleText.Length -gt $fieldWidth) {\r\n                        $visibleText = $visibleText.Substring(0, $fieldWidth)\r\n                    }\r\n                    $displayText = $visibleText\r\n                    \r\n                    # Render Field Background & Text\r\n                    $engine.Fill($currentX, $lockedY, $fieldWidth, 1, ' ', $fg, $bg)\r\n                    $engine.WriteAt($currentX, $lockedY, $displayText, $fg, $bg)\r\n\r\n                    # Render Cursor\r\n                    $relCursor = $cursorPos - $scrollOffset\r\n                    if ($relCursor -ge 0 -and $relCursor -le $fieldWidth) {\r\n                        # Draw cursor (Inverted BG/FG usually)\r\n                        $cursorChar = \" \"\r\n                        if ($relCursor -lt $displayText.Length) {\r\n                            $cursorChar = $displayText[$relCursor]\r\n                        }\r\n                        # Swap FG/BG for cursor\r\n                        $engine.WriteAt($currentX + $relCursor, $lockedY, $cursorChar, $bg, $fg)\r\n                    }\r\n                }\r\n                else {\r\n                    # Non-TextInput widget focused\r\n                    $engine.Fill($currentX, $lockedY, $fieldWidth, 1, ' ', $fg, $bg)\r\n                    $engine.WriteAt($currentX, $lockedY, $displayText, $fg, $bg)\r\n                }\r\n            }\r\n            else {\r\n                # Normal Field\r\n                $engine.Fill($currentX, $lockedY, $fieldWidth, 1, ' ', $fg, $bg)\r\n                $engine.WriteAt($currentX, $lockedY, $displayText, $fg, $bg)\r\n            }\r\n            \r\n            # Advance X position\r\n            $currentX += $fieldWidth\r\n        }\r\n        \r\n        # Handle Expanded Widget Mode (Overlay)\r\n        if ($this._showFieldWidgets -and -not [string]::IsNullOrWhiteSpace($this._expandedFieldName)) {\r\n            $field = $this._fields | Where-Object { $_.Name -eq $this._expandedFieldName } | Select-Object -First 1\r\n            if ($null -ne $field) {\r\n                $widget = $null\r\n                if ($field.Type -eq 'date' -and $this._datePickerMode -and $this._datePickerWidgets.ContainsKey($field.Name)) {\r\n                    $widget = $this._datePickerWidgets[$field.Name]\r\n                }\r\n                elseif ($this._fieldWidgets.ContainsKey($field.Name)) {\r\n                    $widget = $this._fieldWidgets[$field.Name]\r\n                }\r\n\r\n                if ($null -ne $widget) {\r\n                    $fieldXOffset = 0\r\n                    foreach ($f in $this._fields) {\r\n                        if ($f.Name -eq $field.Name) { break }\r\n                        $w = $(if ($f.ContainsKey('Width')) { $f.Width } else { 20 })\r\n                        $fieldXOffset += $w\r\n                    }\r\n                    \r\n                    $widget.X = $this.X + $fieldXOffset\r\n                    $widget.Y = $this.Y\r\n                    if ($widget.PSObject.Properties['Width']) {\r\n                        if ($field.Type -eq 'date') { $widget.Width = 26 }\r\n                        else { \r\n                            # Cap width at 60 to prevent massive dropdowns on wide screens\r\n                            $calcWidth = [Math]::Max(20, $this.Width - 4)\r\n                            $widget.Width = [Math]::Min(60, $calcWidth)\r\n                        }\r\n                    }\r\n                    \r\n                    if ($widget.PSObject.Methods['RenderToEngine']) {\r\n                        $widget.RenderToEngine($engine)\r\n                    }\r\n                    else {\r\n                        $out = $widget.Render()\r\n                        if ($out) { $engine.WriteAt($widget.X, $widget.Y, $out) }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if ($engine.PSObject.Methods['EndLayer']) {\r\n            $engine.EndLayer()\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render the inline editor\r\n\r\n    .OUTPUTS\r\n    ANSI string ready for display\r\n    ##CLOSEBRACKET##\r\n    [string] Render() {\r\n        # Process debounced validation\r\n        $this._ProcessDebouncedValidation()\r\n\r\n        # Dispatch based on layout mode\r\n        # Write-PmcTuiLog \"InlineEditor.Render: LayoutMode='$($this.LayoutMode)'\" \"DEBUG\"\r\n        if ($this.LayoutMode -eq 'horizontal') {\r\n            return $this._RenderHorizontal()\r\n        }\r\n        else {\r\n            # Write-PmcTuiLog \"InlineEditor.Render: Calling _RenderVertical because LayoutMode is not 'horizontal'\" \"ERROR\"\r\n            return $this._RenderVertical()\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Process debounced validation - called every frame\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _ProcessDebouncedValidation() {\r\n        # Check if validation is pending and enough time has passed\r\n        if (-not [string]::IsNullOrEmpty($this._pendingValidationField) -and\r\n            $this._lastKeystroke -ne [DateTime]::MinValue) {\r\n\r\n            $elapsed = ([DateTime]::Now - $this._lastKeystroke).TotalMilliseconds\r\n\r\n            if ($elapsed -ge $this._validationDelayMs) {\r\n                # Time to validate\r\n                $field = $this._fields | Where-Object { $_.Name -eq $this._pendingValidationField } | Select-Object -First 1\r\n\r\n                if ($null -ne $field) {\r\n                    $this._ValidateFieldRealtime($field)\r\n                }\r\n\r\n                # Clear pending state\r\n                $this._pendingValidationField = \"\"\r\n                $this._lastKeystroke = [DateTime]::MinValue\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render fields horizontally (inline mode)\r\n    ##CLOSEBRACKET##\r\n    hidden [string] _RenderHorizontal() {\r\n        $sb = [StringBuilder]::new(2048)\r\n\r\n        # NEW THEME API - delegate to theme engine\r\n        $reset = \"`e[0m\"\r\n\r\n        # DEBUG: Always render SOMETHING visible\r\n        if ($this._fields.Count -eq 0) {\r\n            $sb.Append($this.BuildMoveTo($this.X, $this.Y))\r\n            $sb.Append(\"`e[41m NO FIELDS CONFIGURED `e[0m\")\r\n            return $sb.ToString()\r\n        }\r\n\r\n        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [EDIT] InlineEditor._RenderHorizontal() called\"\r\n        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [EDIT] _showFieldWidgets=$($this._showFieldWidgets) _expandedFieldName='$($this._expandedFieldName)'\"\r\n        # }\r\n\r\n        # If a widget is expanded, render it instead\r\n        if ($this._showFieldWidgets -and -not [string]::IsNullOrWhiteSpace($this._expandedFieldName)) {\r\n            # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [EDIT] WIDGET EXPANDED - field='$($this._expandedFieldName)'\"\r\n            # }\r\n            $field = $this._fields | Where-Object { $_.Name -eq $this._expandedFieldName } | Select-Object -First 1\r\n            if ($null -ne $field) {\r\n                # CRITICAL FIX: For date fields in DatePicker mode, use DatePicker NOT TextInput\r\n                $widget = $null\r\n                if ($field.Type -eq 'date' -and $this._datePickerMode -and $this._datePickerWidgets.ContainsKey($field.Name)) {\r\n                    $widget = $this._datePickerWidgets[$field.Name]\r\n                    # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [EDIT] Found DatePicker in _datePickerWidgets: $($widget.GetType().Name)\"\r\n                    # }\r\n                }\r\n                elseif ($this._fieldWidgets.ContainsKey($field.Name)) {\r\n                    $widget = $this._fieldWidgets[$field.Name]\r\n                    # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [EDIT] Found widget in _fieldWidgets: $($widget.GetType().Name)\"\r\n                    # }\r\n                }\r\n\r\n                if ($null -ne $widget) {\r\n                    # Widget types that render themselves\r\n                    if ($widget.GetType().Name -in @('DatePicker', 'ProjectPicker', 'TagEditor')) {\r\n                        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [EDIT] Rendering expanded widget: $($widget.GetType().Name)\"\r\n                        # }\r\n                        # NOTE: NeedsClear NOT set - widgets render as overlays without clearing screen\r\n                        $widgetOutput = $widget.Render()\r\n                        # Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')] [EDIT] Widget rendered, output length=$($widgetOutput.Length)\"\r\n                        # }\r\n                        return $widgetOutput\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        # CRITICAL: NO row background in edit mode - only focused field gets background\r\n        # This keeps the row clean and highlights only the active field\r\n        $reset = \"`e[0m\"\r\n\r\n        # Move to start of row (no background color applied)\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y))\r\n\r\n        # DEBUG: Show that we're rendering\r\n        # $sb.Append(\"`e[42m[EDIT]`e[0m \")\r\n\r\n        # Render fields side-by-side with absolute positioning\r\n        $currentX = $this.X\r\n\r\n        for ($i = 0; $i -lt $this._fields.Count; $i++) {\r\n            $field = $this._fields[$i]\r\n            $isFocused = ($i -eq $this._currentFieldIndex)\r\n\r\n            # Calculate field width (use Width from field definition or default)\r\n            $fieldWidth = $(if ($field.ContainsKey('Width')) { $field.Width } else { 20 })\r\n\r\n            # CRITICAL: Position each field explicitly at its X coordinate\r\n            # This prevents wrapping and ensures precise alignment\r\n            $sb.Append($this.BuildMoveTo($currentX, $this.Y))\r\n\r\n            # Get field value\r\n            $value = $this._GetFieldValuePreview($field)\r\n\r\n            # For focused text fields with TextInput widget, show with cursor\r\n            if ($isFocused -and ($field.Type -eq 'text' -or $field.Type -eq 'textarea' -or $field.Type -eq 'date' -or $field.Type -eq 'tags' -or $field.Type -eq 'project') -and $this._fieldWidgets.ContainsKey($field.Name)) {\r\n                $widget = $this._fieldWidgets[$field.Name]\r\n                if ($widget.GetType().Name -eq 'TextInput') {\r\n                    # FIX: Update widget width to match field width for correct scroll calculation in HandleInput\r\n                    $widget.Width = $fieldWidth + 4\r\n\r\n                    $text = $widget.GetText()\r\n                    $cursorPos = $widget._cursorPosition\r\n\r\n                    # Calculate scroll offset locally to ensure immediate responsiveness to width changes\r\n                    # Use existing offset as starting point if possible, but clamp to new width\r\n                    $scrollOffset = $widget._scrollOffset\r\n\r\n                    # Recalculate scroll offset to ensure cursor is visible within fieldWidth\r\n                    if ($cursorPos -lt $scrollOffset) {\r\n                        $scrollOffset = $cursorPos\r\n                    }\r\n                    if ($cursorPos -gt ($scrollOffset + $fieldWidth - 1)) {\r\n                        $scrollOffset = $cursorPos - $fieldWidth + 1\r\n                    }\r\n                    if ($scrollOffset -lt 0) {\r\n                        $scrollOffset = 0\r\n                    }\r\n\r\n                    # Get visible text\r\n                    $visibleText = \"\"\r\n                    if ($scrollOffset -lt $text.Length) {\r\n                        $visibleText = $text.Substring($scrollOffset)\r\n                    }\r\n                    if ($visibleText.Length -gt $fieldWidth) {\r\n                        $visibleText = $visibleText.Substring(0, $fieldWidth)\r\n                    }\r\n\r\n                    # Pad to field width + 2 to match column padding\r\n                    $paddedText = $visibleText.PadRight($fieldWidth + 2)\r\n\r\n                    # Calculate cursor position relative to visible text\r\n                    $relCursorPos = $cursorPos - $scrollOffset\r\n\r\n                    # CRITICAL FIX: Use theme colors for focused field\r\n                    $focusBg = $this.GetThemedBg('Background.FieldFocused', $fieldWidth, 0)\r\n                    $focusFg = $this.GetThemedFg('Foreground.FieldFocused')\r\n\r\n                    # Render with highlighting and blinking cursor\r\n                    $renderWidth = $fieldWidth + 2\r\n                    for ($charIdx = 0; $charIdx -lt $renderWidth; $charIdx++) {\r\n                        if ($charIdx -eq $relCursorPos) {\r\n                            # Cursor position - invert colors and blink\r\n                            $sb.Append(\"`e[7m`e[5m\" + $focusBg + $focusFg + $paddedText[$charIdx] + \"`e[25m`e[27m\")\r\n                            # Restore focus colors after cursor\r\n                            if ($charIdx -lt ($renderWidth - 1)) {\r\n                                $sb.Append($focusBg + $focusFg)\r\n                            }\r\n                        }\r\n                        else {\r\n                            $sb.Append($focusBg + $focusFg + $paddedText[$charIdx])\r\n                        }\r\n                    }\r\n\r\n                    # Reset after focused field\r\n                    $sb.Append($reset)\r\n                }\r\n                else {\r\n                    # Widget field (date/project/tags) that isn't TextInput - show preview with focus\r\n                    $renderWidth = $fieldWidth + 2\r\n                    $displayValue = $value.PadRight($renderWidth)\r\n                    if ($displayValue.Length -gt $renderWidth) {\r\n                        $displayValue = $displayValue.Substring(0, $renderWidth)\r\n                    }\r\n\r\n                    # Use theme colors for focused widget fields\r\n                    $focusBg = $this.GetThemedBg('Background.FieldFocused', $renderWidth, 0)\r\n                    $focusFg = $this.GetThemedFg('Foreground.FieldFocused')\r\n                    $sb.Append($focusBg + $focusFg + $displayValue)\r\n                    # Reset after focused field\r\n                    $sb.Append($reset)\r\n                }\r\n            }\r\n            else {\r\n                # Non-focused field - show value without special highlighting\r\n                # For date/project fields, show TextInput content if available\r\n                $displayValue = $value\r\n                if (($field.Type -eq 'date' -or $field.Type -eq 'project') -and $this._fieldWidgets.ContainsKey($field.Name)) {\r\n                    $widget = $this._fieldWidgets[$field.Name]\r\n                    if ($widget.GetType().Name -eq 'TextInput') {\r\n                        $displayValue = $widget.GetText()\r\n                    }\r\n                }\r\n\r\n                $renderWidth = $fieldWidth + 2\r\n                $displayValue = $displayValue.PadRight($renderWidth)\r\n                if ($displayValue.Length -gt $renderWidth) {\r\n                    $displayValue = $displayValue.Substring(0, $renderWidth)\r\n                }\r\n                # CRITICAL: Non-focused fields ALSO get background highlighting in edit mode\r\n                $unfocusedBg = $this.GetThemedBg('Background.Field', $renderWidth, 0)\r\n                $unfocusedFg = $this.GetThemedFg('Foreground.Field')\r\n                $sb.Append($unfocusedBg + $unfocusedFg + $displayValue)\r\n                # Reset after non-focused field\r\n                $sb.Append($reset)\r\n            }\r\n\r\n            # CRITICAL FIX: Match UniversalList column spacing exactly\r\n            # UniversalList uses: currentX += colWidth (no extra padding)\r\n            # We must match to avoid cumulative column misalignment in Edit mode\r\n            $currentX += $fieldWidth\r\n        }\r\n\r\n        # CRITICAL FIX: Reset colors THEN clear to EOL (ensures no background bleeds into padding)\r\n        $sb.Append($reset)  # Reset colors first\r\n        $sb.Append(\"`e[K\")  # Then clear to end of line\r\n\r\n        # DO NOT clear line below in horizontal mode - InlineEditor is rendering WITHIN the grid\r\n        # Clearing the line below would erase grid content\r\n\r\n        return $sb.ToString()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render fields vertically (popup mode)\r\n    ##CLOSEBRACKET##\r\n    hidden [string] _RenderVertical() {\r\n        $sb = [StringBuilder]::new(4096)\r\n\r\n        # Colors from theme (NEW API)\r\n        $borderColor = $this.GetThemedFg('Border.Widget')\r\n        $textColor = $this.GetThemedFg('Foreground.Field')\r\n        $primaryColor = $this.GetThemedFg('Foreground.FieldFocused')\r\n        $mutedColor = $this.GetThemedFg('Foreground.Muted')\r\n        $errorColor = $this.GetThemedFg('Foreground.Error')\r\n        $successColor = $this.GetThemedFg('Foreground.Success')\r\n        $highlightBg = $this.GetThemedBg('Background.RowSelected', 80, 0)\r\n        $reset = \"`e[0m\"\r\n\r\n        # If a field widget is expanded, render it instead of the form\r\n        if ($this._showFieldWidgets -and -not [string]::IsNullOrWhiteSpace($this._expandedFieldName)) {\r\n            # Get the appropriate widget based on mode\r\n            $field = $this._fields | Where-Object { $_.Name -eq $this._expandedFieldName } | Select-Object -First 1\r\n\r\n            $widget = $null\r\n            if ($field.Type -eq 'date' -and $this._datePickerMode) {\r\n                # Render DatePicker when in DatePicker mode\r\n                if ($this._datePickerWidgets.ContainsKey($this._expandedFieldName)) {\r\n                    $widget = $this._datePickerWidgets[$this._expandedFieldName]\r\n                }\r\n            }\r\n            else {\r\n                # Render normal widget\r\n                if ($this._fieldWidgets.ContainsKey($this._expandedFieldName)) {\r\n                    $widget = $this._fieldWidgets[$this._expandedFieldName]\r\n                }\r\n            }\r\n\r\n            if ($null -ne $widget) {\r\n                # Check if widget is PmcFilePicker (needs terminal dimensions)\r\n                if ($widget.GetType().Name -eq 'PmcFilePicker') {\r\n                    # Get terminal size\r\n                    try {\r\n                        $termWidth = [Console]::WindowWidth\r\n                        $termHeight = [Console]::WindowHeight\r\n                    }\r\n                    catch {\r\n                        $termWidth = 120\r\n                        $termHeight = 40\r\n                    }\r\n\r\n\r\n                    # }\r\n\r\n                    # NOTE: NeedsClear NOT set - FilePicker renders as overlay without clearing screen\r\n                    $output = $widget.Render($termWidth, $termHeight)\r\n\r\n\r\n                    # }\r\n\r\n                    return $output\r\n                }\r\n                else {\r\n                    return $widget.Render()\r\n                }\r\n            }\r\n\r\n            # Widget doesn't exist - fall through to render normal form\r\n            $this._showFieldWidgets = $false\r\n            $this._expandedFieldName = \"\"\r\n        }\r\n\r\n        # Draw top border\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.BuildBoxBorder($this.Width, 'top', 'single'))\r\n\r\n        # Title\r\n        $titleText = \" $($this.Title) \"\r\n        $titlePos = 2\r\n        $sb.Append($this.BuildMoveTo($this.X + $titlePos, $this.Y))\r\n        $sb.Append($primaryColor)\r\n        $sb.Append($titleText)\r\n\r\n        # Field count\r\n        $countText = \"($($this._fields.Count) fields)\"\r\n        $sb.Append($this.BuildMoveTo($this.X + $this.Width - $countText.Length - 2, $this.Y))\r\n        $sb.Append($mutedColor)\r\n        $sb.Append($countText)\r\n\r\n        $currentRow = 1\r\n\r\n        # Render each field\r\n        for ($i = 0; $i -lt $this._fields.Count; $i++) {\r\n            $field = $this._fields[$i]\r\n            $isFocused = ($i -eq $this._currentFieldIndex)\r\n\r\n            # Field row\r\n            $rowY = $this.Y + $currentRow\r\n\r\n            # Label row\r\n            $sb.Append($this.BuildMoveTo($this.X, $rowY))\r\n            # H-UI-3: Show red border if field has validation error\r\n            $hasError = $this._fieldErrors.ContainsKey($field.Name)\r\n            if ($hasError) {\r\n                $sb.Append($errorColor)\r\n            }\r\n            else {\r\n                $sb.Append($borderColor)\r\n            }\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n            # Label\r\n            $label = $field.Label\r\n            $isRequired = $(if ($field.ContainsKey('Required')) { $field.Required } else { $false })\r\n            if ($isRequired) {\r\n                $label += \" *\"\r\n            }\r\n\r\n            $sb.Append($this.BuildMoveTo($this.X + 2, $rowY))\r\n            if ($hasError) {\r\n                # H-UI-3: Red text for invalid field label\r\n                $sb.Append($errorColor)\r\n            }\r\n            elseif ($isFocused) {\r\n                $sb.Append($primaryColor)\r\n            }\r\n            else {\r\n                $sb.Append($mutedColor)\r\n            }\r\n            $sb.Append($this.PadText($label + \":\", 20, 'left'))\r\n\r\n            # Value display - for text/date fields, render the TextInput widget inline\r\n            $sb.Append($this.BuildMoveTo($this.X + 22, $rowY))\r\n\r\n            if (($field.Type -eq 'text' -or $field.Type -eq 'textarea' -or $field.Type -eq 'date' -or $field.Type -eq 'tags') -and $isFocused -and $this._fieldWidgets.ContainsKey($field.Name)) {\r\n                # Render TextInput widget inline for focused text/textarea/date/tags fields\r\n                $widget = $this._fieldWidgets[$field.Name]\r\n                if ($widget.GetType().Name -eq 'TextInput') {\r\n                    $sb.Append($textColor)\r\n                    $text = $widget.GetText()\r\n                    $cursorPos = $widget._cursorPosition\r\n\r\n                    # Show text with cursor\r\n                    if ($cursorPos -le $text.Length) {\r\n                        $beforeCursor = $text.Substring(0, $cursorPos)\r\n                        $atCursor = $(if ($cursorPos -lt $text.Length) { $text.Substring($cursorPos, 1) } else { \" \" })\r\n                        $afterCursor = $(if ($cursorPos -lt $text.Length - 1) { $text.Substring($cursorPos + 1) } else { \"\" })\r\n\r\n                        $sb.Append($beforeCursor)\r\n                        $sb.Append($highlightBg)\r\n                        $sb.Append($textColor)  # Use Body text color, not hardcoded black\r\n                        $sb.Append($atCursor)\r\n                        $sb.Append($reset)\r\n                        $sb.Append($textColor)\r\n                        $sb.Append($afterCursor)\r\n                    }\r\n                    else {\r\n                        $sb.Append($text)\r\n                    }\r\n                    $sb.Append($reset)\r\n                }\r\n                else {\r\n                    # Not a TextInput, show preview\r\n                    if ($isFocused) {\r\n                        $sb.Append($highlightBg)\r\n                        $sb.Append($textColor)  # Use Body text color, not hardcoded black\r\n                    }\r\n                    else {\r\n                        $sb.Append($textColor)\r\n                    }\r\n                    $valuePreview = $this._GetFieldValuePreview($field)\r\n                    $sb.Append($this.PadText($valuePreview, $this.Width - 24, 'left'))\r\n                    if ($isFocused) {\r\n                        $sb.Append($reset)\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                # Not focused or not text/date field - show preview\r\n                if ($isFocused) {\r\n                    $sb.Append($highlightBg)\r\n                    $sb.Append($textColor)  # Use Body text color, not hardcoded black\r\n                }\r\n                else {\r\n                    $sb.Append($textColor)\r\n                }\r\n\r\n                $valuePreview = $this._GetFieldValuePreview($field)\r\n                $sb.Append($this.PadText($valuePreview, $this.Width - 24, 'left'))\r\n\r\n                if ($isFocused) {\r\n                    $sb.Append($reset)\r\n                }\r\n            }\r\n\r\n            # Right border\r\n            $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $rowY))\r\n            if ($hasError) {\r\n                $sb.Append($errorColor)\r\n            }\r\n            else {\r\n                $sb.Append($borderColor)\r\n            }\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n            $currentRow++\r\n\r\n            # Spacing row (H-UI-3: show error message below field if invalid)\r\n            $sb.Append($this.BuildMoveTo($this.X, $this.Y + $currentRow))\r\n            if ($hasError) {\r\n                $sb.Append($errorColor)\r\n            }\r\n            else {\r\n                $sb.Append($borderColor)\r\n            }\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n            # H-UI-3: Display per-field error message\r\n            if ($hasError) {\r\n                $errorMsg = $this._fieldErrors[$field.Name]\r\n                $sb.Append($this.BuildMoveTo($this.X + 2, $this.Y + $currentRow))\r\n                $sb.Append($errorColor)\r\n                $sb.Append($this.TruncateText($errorMsg, $this.Width - 4))\r\n            }\r\n            else {\r\n                $sb.Append(\" \" * ($this.Width - 2))\r\n            }\r\n\r\n            $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $this.Y + $currentRow))\r\n            if ($hasError) {\r\n                $sb.Append($errorColor)\r\n            }\r\n            else {\r\n                $sb.Append($borderColor)\r\n            }\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n            $currentRow++\r\n        }\r\n\r\n        # Help text row\r\n        $helpRowY = $this.Y + $currentRow\r\n        $sb.Append($this.BuildMoveTo($this.X, $helpRowY))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        $sb.Append($this.BuildMoveTo($this.X + 2, $helpRowY))\r\n        $sb.Append($mutedColor)\r\n        $helpText = \"Tab: Next | Enter on Save button | Esc: Cancel\"\r\n        $sb.Append($this.TruncateText($helpText, $this.Width - 4))\r\n\r\n        $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $helpRowY))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        $currentRow++\r\n\r\n        # Validation errors row\r\n        $errorRowY = $this.Y + $currentRow\r\n        $sb.Append($this.BuildMoveTo($this.X, $errorRowY))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        if ($this._validationErrors.Count -gt 0) {\r\n            $sb.Append($this.BuildMoveTo($this.X + 2, $errorRowY))\r\n            $sb.Append($errorColor)\r\n            $errorMsg = $this._validationErrors[0]  # Show first error\r\n            $sb.Append($this.TruncateText($errorMsg, $this.Width - 4))\r\n        }\r\n        else {\r\n            $sb.Append(\" \" * ($this.Width - 2))\r\n        }\r\n\r\n        $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $errorRowY))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        $currentRow++\r\n\r\n        # Bottom border\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y + $currentRow))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.BuildBoxBorder($this.Width, 'bottom', 'single'))\r\n\r\n        $sb.Append($reset)\r\n        return $sb.ToString()\r\n    }\r\n\r\n    # === Private Helper Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Create widget instance for a field\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _CreateFieldWidget([hashtable]$fieldDef) {\r\n        $fieldName = $fieldDef.Name\r\n        $fieldType = $fieldDef.Type\r\n        $value = $(if ($fieldDef.ContainsKey('Value')) { $fieldDef.Value } else { $null })\r\n\r\n        $widget = $null\r\n\r\n        switch ($fieldType) {\r\n            'text' {\r\n                $widget = [TextInput]::new()\r\n                # Use properties, not methods\r\n                $widget.X = $this.X + 5\r\n                $widget.Y = $this.Y + 5\r\n                $widget.Width = 60\r\n                $widget.Height = 3\r\n                $widget.Label = $fieldDef.Label\r\n\r\n                if ($value) {\r\n                    $widget.SetText($value)\r\n                }\r\n\r\n                if ($fieldDef.ContainsKey('MaxLength')) {\r\n                    $widget.MaxLength = $fieldDef.MaxLength\r\n                }\r\n\r\n                if ($fieldDef.ContainsKey('Placeholder')) {\r\n                    $widget.Placeholder = $fieldDef.Placeholder\r\n                }\r\n            }\r\n\r\n            'textarea' {\r\n                # Use TextInput with larger size for multi-line text (inline editing)\r\n                # For full-featured editing, users can open dedicated TextAreaEditor screen\r\n                # Future enhancement: Add modal TextAreaEditor dialog for complex text editing\r\n                $widget = [TextInput]::new()\r\n                # Use properties, not methods\r\n                $widget.X = $this.X + 5\r\n                $widget.Y = $this.Y + 5\r\n                $widget.Width = 60\r\n                $widget.Height = 5  # Taller than regular text input\r\n                $widget.Label = $fieldDef.Label\r\n\r\n                if ($value) {\r\n                    # Replace newlines with a visible separator for single-line display\r\n                    $displayValue = $value.ToString() -replace \"`n\", \" | \"\r\n                    $widget.SetText($displayValue)\r\n                }\r\n\r\n                if ($fieldDef.ContainsKey('MaxLength')) {\r\n                    $widget.MaxLength = $fieldDef.MaxLength\r\n                }\r\n                else {\r\n                    $widget.MaxLength = 5000  # Default larger limit for textarea\r\n                }\r\n\r\n                $widget.Placeholder = 'Separate items with  | '\r\n            }\r\n\r\n            'date' {\r\n                # For inline editing, use TextInput (user can type dates like \"2025-11-15\" or \"+3\")\r\n                # DatePicker is created on-demand when user presses Enter\r\n                $widget = [TextInput]::new()\r\n                $widget.MaxLength = 20\r\n\r\n                if ($value) {\r\n                    if ($value -is [DateTime]) {\r\n                        $widget.SetText($value.ToString('yyyy-MM-dd'))\r\n                    }\r\n                    else {\r\n                        $widget.SetText($value.ToString())\r\n                    }\r\n                }\r\n                else {\r\n                    $widget.SetText('')\r\n                }\r\n\r\n                $widget.Placeholder = 'yyyy-MM-dd or +days'\r\n\r\n                # Wire up text change callback to update field value\r\n                $editor = $this\r\n                $field = $fieldDef\r\n                $widget.OnTextChanged = {\r\n                    param($newText)\r\n                    # Update the field value when text changes\r\n                    $editor._SetFieldValue($field.Name, $newText)\r\n                }\r\n            }\r\n\r\n            'project' {\r\n                # In horizontal mode, use TextInput for inline typing\r\n                # In vertical mode, use ProjectPicker for full selection UI\r\n                if ($this.LayoutMode -eq 'horizontal') {\r\n                    $widget = [TextInput]::new()\r\n                    $widget.MaxLength = 100\r\n                    $widget.Placeholder = 'Project name'\r\n                    if ($value) {\r\n                        $widget.SetText($value.ToString())\r\n                    }\r\n                    else {\r\n                        $widget.SetText('')\r\n                    }\r\n                }\r\n                else {\r\n                    $widget = [ProjectPicker]::new()\r\n                    # Use properties, not methods\r\n                    $widget.X = $this.X + 5\r\n                    $widget.Y = $this.Y + 5\r\n                    $widget.Width = 35\r\n                    $widget.Height = 12\r\n                    $widget.Label = $fieldDef.Label\r\n                    if ($value) {\r\n                        $widget.SetSearchText($value)\r\n                    }\r\n                }\r\n            }\r\n\r\n            'tags' {\r\n                # Tags use simple text input with comma-separated values\r\n                $widget = [TextInput]::new()\r\n                $widget.MaxLength = 100\r\n                $widget.Placeholder = 'tag1, tag2, tag3'\r\n\r\n                if ($value -and $value -is [array]) {\r\n                    # Convert array to comma-separated string\r\n                    $widget.SetText($value -join ', ')\r\n                }\r\n                elseif ($value) {\r\n                    $widget.SetText($value.ToString())\r\n                }\r\n                else {\r\n                    $widget.SetText('')\r\n                }\r\n\r\n                # Wire up callback to save changes\r\n                $editor = $this\r\n                $field = $fieldDef\r\n                $widget.OnTextChanged = {\r\n                    param($newText)\r\n                    $editor._SetFieldValue($field.Name, $newText)\r\n                }\r\n            }\r\n\r\n            'folder' {\r\n                # Folder picker - use TextInput for inline display\r\n                $widget = [TextInput]::new()\r\n                $widget.MaxLength = 255\r\n                $widget.Placeholder = 'Press Enter to browse...'\r\n\r\n                if ($value) {\r\n                    $widget.SetText($value.ToString())\r\n                }\r\n                else {\r\n                    $widget.SetText('')\r\n                }\r\n\r\n                # Wire up callback\r\n                $editor = $this\r\n                $field = $fieldDef\r\n                $widget.OnTextChanged = {\r\n                    param($newText)\r\n                    $editor._SetFieldValue($field.Name, $newText)\r\n                }\r\n            }\r\n\r\n            'file' {\r\n                # File picker - use TextInput for inline display\r\n                $widget = [TextInput]::new()\r\n                $widget.MaxLength = 255\r\n                $widget.Placeholder = 'Press Enter to browse...'\r\n\r\n                if ($value) {\r\n                    $widget.SetText($value.ToString())\r\n                }\r\n                else {\r\n                    $widget.SetText('')\r\n                }\r\n\r\n                # Wire up callback\r\n                $editor = $this\r\n                $field = $fieldDef\r\n                $widget.OnTextChanged = {\r\n                    param($newText)\r\n                    $editor._SetFieldValue($field.Name, $newText)\r\n                }\r\n            }\r\n\r\n            'number' {\r\n                # Number fields use TextInput for direct entry AND arrow keys for increment/decrement\r\n                $widget = [TextInput]::new()\r\n                $widget.X = $this.X + 5\r\n                $widget.Y = $this.Y + 5\r\n                $widget.Width = 20\r\n                $widget.Height = 3\r\n                $widget.Label = $fieldDef.Label\r\n                \r\n                # Set initial value\r\n                if ($value) {\r\n                    $widget.SetText($value.ToString())\r\n                } else {\r\n                    $min = $(if ($fieldDef.ContainsKey('Min')) { $fieldDef.Min } else { 0 })\r\n                    $widget.SetText($min.ToString())\r\n                }\r\n                \r\n                # Validate input is numeric\r\n                $widget.OnTextChanged = {\r\n                    param($newText)\r\n                    if ([string]::IsNullOrWhiteSpace($newText)) { return }\r\n                    if ($newText -notmatch '^-?\\d*\\.?\\d*$') {\r\n                        # Revert invalid char? (TextInput doesn't support revert easily, rely on validation)\r\n                    }\r\n                }\r\n            }\r\n\r\n            'button' {\r\n                # Button is handled inline (no separate widget)\r\n            }\r\n\r\n            default {\r\n                throw \"Unsupported field type: $fieldType\"\r\n            }\r\n        }\r\n\r\n        if ($widget) {\r\n            $this._fieldWidgets[$fieldName] = $widget\r\n            # Write-PmcTuiLog \"InlineEditor._CreateFieldWidget: Stored widget for field '$fieldName' (type=$fieldType) - widget.Text='$(if ($widget.GetType().Name -eq 'TextInput') { $widget.Text } else { 'N/A' })'\" \"DEBUG\"\r\n        }\r\n        else {\r\n            # Write-PmcTuiLog \"InlineEditor._CreateFieldWidget: WARNING - widget is null for field '$fieldName' (type=$fieldType)\" \"WARNING\"\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get current value of a field\r\n    ##CLOSEBRACKET##\r\n    hidden [object] _GetFieldValue([string]$fieldName, [string]$fieldType) {\r\n        switch ($fieldType) {\r\n            'text' {\r\n                if (-not $this._fieldWidgets.ContainsKey($fieldName)) {\r\n                    # Write-PmcTuiLog \"ERROR: No widget for text field '$fieldName'\" \"ERROR\"\r\n                    return \"\"\r\n                }\r\n                $widget = $this._fieldWidgets[$fieldName]\r\n                if (-not $widget) {\r\n                    # Write-PmcTuiLog \"ERROR: Widget is null for text field '$fieldName'\" \"ERROR\"\r\n                    return \"\"\r\n                }\r\n                $value = $widget.GetText()\r\n                # Write-PmcTuiLog \"InlineEditor._GetFieldValue: text field '$fieldName' -> value='$value' (widget.Text='$($widget.Text)')\" \"DEBUG\"\r\n                return $value\r\n            }\r\n\r\n            'textarea' {\r\n                $widget = $this._fieldWidgets[$fieldName]\r\n                # Convert pipe-separated items back to newline-separated\r\n                $text = $widget.GetText()\r\n                return $text -replace '\\s*\\|\\s*', \"`n\"\r\n            }\r\n\r\n            'date' {\r\n                $widget = $this._fieldWidgets[$fieldName]\r\n                # Date fields use TextInput for inline editing\r\n                if ($widget.GetType().Name -eq 'TextInput') {\r\n                    $dateText = $widget.GetText().Trim().ToLower()\r\n                    if ([string]::IsNullOrWhiteSpace($dateText)) {\r\n                        return $null\r\n                    }\r\n\r\n                    # Parse relative dates like \"+7\" or \"-3\"\r\n                    if ($dateText -match '^([+-])(\\d+)$') {\r\n                        $sign = $matches[1]\r\n                        $days = [int]$matches[2]\r\n                        if ($sign -eq '+') {\r\n                            return [DateTime]::Now.AddDays($days)\r\n                        }\r\n                        else {\r\n                            return [DateTime]::Now.AddDays(-$days)\r\n                        }\r\n                    }\r\n\r\n                    # Special keywords\r\n                    if ($dateText -eq 'today' -or $dateText -eq 't') {\r\n                        return [DateTime]::Today\r\n                    }\r\n                    if ($dateText -eq 'tomorrow' -or $dateText -eq 'tom') {\r\n                        return [DateTime]::Today.AddDays(1)\r\n                    }\r\n                    if ($dateText -eq 'yesterday') {\r\n                        return [DateTime]::Today.AddDays(-1)\r\n                    }\r\n                    if ($dateText -eq 'eom') {\r\n                        # End of current month\r\n                        $now = [DateTime]::Now\r\n                        return [DateTime]::new($now.Year, $now.Month, [DateTime]::DaysInMonth($now.Year, $now.Month))\r\n                    }\r\n                    if ($dateText -eq 'eoy') {\r\n                        # End of current year\r\n                        return [DateTime]::new([DateTime]::Now.Year, 12, 31)\r\n                    }\r\n                    if ($dateText -eq 'som') {\r\n                        # Start of current month\r\n                        $now = [DateTime]::Now\r\n                        return [DateTime]::new($now.Year, $now.Month, 1)\r\n                    }\r\n\r\n                    # Parse YYYYMMDD format (20251125)\r\n                    if ($dateText -match '^\\d{8}$') {\r\n                        try {\r\n                            $year = [int]$dateText.Substring(0, 4)\r\n                            $month = [int]$dateText.Substring(4, 2)\r\n                            $day = [int]$dateText.Substring(6, 2)\r\n                            return [DateTime]::new($year, $month, $day)\r\n                        }\r\n                        catch {\r\n                            # Invalid date, fall through\r\n                        }\r\n                    }\r\n\r\n                    # Parse YYMMDD format (251125)\r\n                    if ($dateText -match '^\\d{6}$') {\r\n                        try {\r\n                            $year = 2000 + [int]$dateText.Substring(0, 2)\r\n                            $month = [int]$dateText.Substring(2, 2)\r\n                            $day = [int]$dateText.Substring(4, 2)\r\n                            return [DateTime]::new($year, $month, $day)\r\n                        }\r\n                        catch {\r\n                            # Invalid date, fall through\r\n                        }\r\n                    }\r\n\r\n                    # Parse absolute dates (standard formats)\r\n                    try {\r\n                        return [DateTime]::Parse($dateText)\r\n                    }\r\n                    catch {\r\n                        return $null\r\n                    }\r\n                }\r\n                else {\r\n                    # DatePicker (if still using old approach)\r\n                    return $widget.GetSelectedDate()\r\n                }\r\n            }\r\n\r\n            'project' {\r\n                $widget = $this._fieldWidgets[$fieldName]\r\n                # In horizontal mode, project uses TextInput for inline typing\r\n                if ($widget.GetType().Name -eq 'TextInput') {\r\n                    return $widget.GetText()\r\n                }\r\n                else {\r\n                    return $widget.GetSelectedProject()\r\n                }\r\n            }\r\n\r\n            'tags' {\r\n                # Tags are stored as comma-separated text in TextInput\r\n                $widget = $this._fieldWidgets[$fieldName]\r\n                $tagsText = $widget.GetText()\r\n\r\n                if ([string]::IsNullOrWhiteSpace($tagsText)) {\r\n                    return @()\r\n                }\r\n\r\n                # Split by comma and trim\r\n                $tags = $tagsText -split ',' | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }\r\n\r\n                # H-VAL-5: Validate tags match pattern ^[a-zA-Z0-9_-]+$\r\n                $validTags = @()\r\n                foreach ($tag in $tags) {\r\n                    if ($tag -match '^[a-zA-Z0-9_-]+$') {\r\n                        $validTags += $tag\r\n                    }\r\n                    else {\r\n                        # Write-PmcTuiLog \"InlineEditor: Invalid tag '$tag' - must contain only letters, numbers, underscore, or hyphen\" \"WARNING\"\r\n                    }\r\n                }\r\n\r\n                return @($validTags)\r\n            }\r\n\r\n            'folder' {\r\n                # Folder path stored as text in TextInput (or PmcFilePicker if still expanded)\r\n                $widget = $this._fieldWidgets[$fieldName]\r\n                if ($widget.GetType().Name -eq 'PmcFilePicker') {\r\n                    # Still showing picker - return current path\r\n                    return $widget.CurrentPath\r\n                }\r\n                else {\r\n                    # TextInput - return text\r\n                    return $widget.GetText()\r\n                }\r\n            }\r\n\r\n            'file' {\r\n                # File path stored as text in TextInput (or PmcFilePicker if still expanded)\r\n                $widget = $this._fieldWidgets[$fieldName]\r\n                if ($widget.GetType().Name -eq 'PmcFilePicker') {\r\n                    # Still showing picker - return current path\r\n                    return $widget.CurrentPath\r\n                }\r\n                else {\r\n                    # TextInput - return text\r\n                    return $widget.GetText()\r\n                }\r\n            }\r\n\r\n            'number' {\r\n                if ($this._fieldWidgets.ContainsKey($fieldName)) {\r\n                    $widget = $this._fieldWidgets[$fieldName]\r\n                    $textVal = $widget.GetText()\r\n                    if ([string]::IsNullOrWhiteSpace($textVal)) {\r\n                        return 0\r\n                    }\r\n                    try {\r\n                        return [double]$textVal\r\n                    } catch {\r\n                        return 0\r\n                    }\r\n                }\r\n                \r\n                $field = $this._fields | Where-Object { $_.Name -eq $fieldName } | Select-Object -First 1\r\n                if ($field.ContainsKey('Value')) {\r\n                    return $field.Value\r\n                }\r\n                else {\r\n                    return 0\r\n                }\r\n            }\r\n\r\n            'button' {\r\n                return $null\r\n            }\r\n\r\n            default {\r\n                return $null\r\n            }\r\n        }\r\n        # Fallback (should never reach here)\r\n        return $null\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set field value (for inline editing)\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _SetFieldValue([string]$fieldName, [object]$value) {\r\n        # Find the field\r\n        $field = $this._fields | Where-Object { $_.Name -eq $fieldName } | Select-Object -First 1\r\n        if ($null -eq $field) {\r\n            return\r\n        }\r\n\r\n        # Update the field's Value property\r\n        $field.Value = $value\r\n\r\n        # CRITICAL FIX: Also update the widget if it exists\r\n        # This is required for \"number\" fields where arrow keys update the value via this method,\r\n        # but the UI (TextInput) wouldn't update because _GetFieldValue prioritizes reading from the widget.\r\n        if ($this._fieldWidgets.ContainsKey($fieldName)) {\r\n            $widget = $this._fieldWidgets[$fieldName]\r\n            \r\n            # Handle TextInput (used for text, number, date, project-inline)\r\n            if ($widget.GetType().Name -eq 'TextInput') {\r\n                $newText = if ($null -ne $value) { $value.ToString() } else { \"\" }\r\n                $currentText = $widget.GetText()\r\n                \r\n                # Only update if different to avoid infinite loops with OnTextChanged\r\n                # and to preserve cursor position when typing\r\n                if ($newText -ne $currentText) {\r\n                    $widget.SetText($newText)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get preview string for a field (for list view)\r\n    ##CLOSEBRACKET##\r\n    hidden [string] _GetFieldValuePreview([hashtable]$field) {\r\n        $fieldName = $field.Name\r\n        $fieldType = $field.Type\r\n        $value = $this._GetFieldValue($fieldName, $fieldType)\r\n\r\n        switch ($fieldType) {\r\n            'text' {\r\n                if ([string]::IsNullOrWhiteSpace($value)) {\r\n                    return \"(empty)\"\r\n                }\r\n                return $value\r\n            }\r\n\r\n            'date' {\r\n                if ($value -is [DateTime]) {\r\n                    return $value.ToString(\"yyyy-MM-dd (ddd)\")\r\n                }\r\n                # Show raw text from TextInput if it exists\r\n                if ($this._fieldWidgets.ContainsKey($fieldName)) {\r\n                    $widget = $this._fieldWidgets[$fieldName]\r\n                    if ($widget.GetType().Name -eq 'TextInput') {\r\n                        $text = $widget.GetText()\r\n                        if (-not [string]::IsNullOrWhiteSpace($text)) {\r\n                            return $text\r\n                        }\r\n                    }\r\n                }\r\n                return \"(no date)\"\r\n            }\r\n\r\n            'project' {\r\n                if ([string]::IsNullOrWhiteSpace($value)) {\r\n                    return \"(no project)\"\r\n                }\r\n                return $value\r\n            }\r\n\r\n            'tags' {\r\n                if ($null -eq $value -or $value.Count -eq 0) {\r\n                    return \"(no tags)\"\r\n                }\r\n                return \"[\" + ($value -join \"] [\") + \"]\"\r\n            }\r\n\r\n            'number' {\r\n                $min = $(if ($field.ContainsKey('Min')) { $field.Min } else { 0 })\r\n                $max = $(if ($field.ContainsKey('Max')) { $field.Max } else { 10 })\r\n                $val = $(if ($null -ne $value) { $value } else { $min })\r\n\r\n                # Build visual slider\r\n                $range = $max - $min\r\n                $position = $(if ($range -gt 0) { [Math]::Floor(($val - $min) / $range * 10) } else { 0 })\r\n                $slider = \"[\" + (\"-\" * $position) + \"●\" + (\"-\" * (10 - $position)) + \"] $val\"\r\n                return $slider\r\n            }\r\n\r\n            'button' {\r\n                $buttonText = $(if ($field.ContainsKey('ButtonText')) { $field.ButtonText } else { 'Button' })\r\n                return \"[ $buttonText ]\"\r\n            }\r\n\r\n            'folder' {\r\n                if ([string]::IsNullOrWhiteSpace($value)) {\r\n                    return \"(no folder)\"\r\n                }\r\n                return $value\r\n            }\r\n\r\n            default {\r\n                return \"(unknown)\"\r\n            }\r\n        }\r\n        # Fallback (should never reach here)\r\n        return \"(unknown)\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move to next field\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _MoveToNextField() {\r\n        if ($this._currentFieldIndex -lt ($this._fields.Count - 1)) {\r\n            $this._currentFieldIndex++\r\n            $this._validationErrors = @()\r\n        }\r\n        else {\r\n            # Wrap to first field\r\n            $this._currentFieldIndex = 0\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move to previous field\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _MoveToPreviousField() {\r\n        if ($this._currentFieldIndex -gt 0) {\r\n            $this._currentFieldIndex--\r\n            $this._validationErrors = @()\r\n        }\r\n        else {\r\n            # Wrap to last field\r\n            $this._currentFieldIndex = $this._fields.Count - 1\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Expand current field's widget\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _ExpandCurrentField() {\r\n        if ($this._currentFieldIndex -ge 0 -and $this._currentFieldIndex -lt $this._fields.Count) {\r\n            $field = $this._fields[$this._currentFieldIndex]\r\n\r\n            # Text, Textarea, Tags, Number, and Button fields are handled inline (no expansion)\r\n            # Tags are comma-separated text input, no widget needed\r\n            if ($field.Type -eq 'text' -or $field.Type -eq 'textarea' -or $field.Type -eq 'tags' -or $field.Type -eq 'number' -or $field.Type -eq 'button') {\r\n                return\r\n            }\r\n\r\n            # For folder fields, create PmcFilePicker on demand\r\n            if ($field.Type -eq 'folder') {\r\n                # Load PmcFilePicker if not already loaded\r\n                . \"$PSScriptRoot/PmcFilePicker.ps1\"\r\n\r\n                # Get current value from TextInput widget\r\n                $textWidget = $this._fieldWidgets[$field.Name]\r\n                $currentPath = $textWidget.GetText()\r\n\r\n                # Create FilePicker using Add-Type to avoid parse-time type dependency\r\n                $filePickerType = 'PmcFilePicker' -as [Type]\r\n                $filePicker = $filePickerType::new($currentPath, $true)  # true = directories only\r\n                $filePicker.Width = 70\r\n                $filePicker.Height = 20\r\n\r\n                # Replace the TextInput with FilePicker temporarily\r\n                $this._fieldWidgets[$field.Name] = $filePicker\r\n\r\n                $this._expandedFieldName = $field.Name\r\n                $this._showFieldWidgets = $true\r\n                # NOTE: NeedsClear NOT set - widget renders as overlay without clearing screen\r\n\r\n                $filePicker.IsComplete = $false\r\n                $filePicker.Result = $false\r\n                return\r\n            }\r\n\r\n            # For date fields, create fresh DatePicker each time\r\n            if ($field.Type -eq 'date') {\r\n                # Get current value from TextInput widget (which stays in _fieldWidgets)\r\n                $textWidget = $this._fieldWidgets[$field.Name]\r\n                $currentText = $textWidget.GetText()\r\n\r\n                # ALWAYS create a fresh DatePicker (don't reuse old instances)\r\n                $datePicker = [DatePicker]::new()\r\n                $datePicker.SetPosition($this.X + 5, $this.Y + 5)\r\n                $datePicker.SetSize(35, 14)\r\n\r\n                # Force calendar mode (not text input mode)\r\n                $datePicker._isCalendarMode = $true\r\n\r\n                # Parse current text value to DateTime if possible\r\n                if (-not [string]::IsNullOrWhiteSpace($currentText)) {\r\n                    try {\r\n                        $parsedDate = [DateTime]::Parse($currentText)\r\n                        $datePicker.SetDate($parsedDate)\r\n                    }\r\n                    catch {\r\n                        # Invalid date, use today\r\n                        $datePicker.SetDate([DateTime]::Now)\r\n                    }\r\n                }\r\n                else {\r\n                    # No text, use today\r\n                    $datePicker.SetDate([DateTime]::Now)\r\n                }\r\n\r\n                # Store fresh DatePicker\r\n                $this._datePickerWidgets[$field.Name] = $datePicker\r\n\r\n                # Set mode to DatePicker\r\n                $this._datePickerMode = $true\r\n\r\n                # Fresh picker has IsConfirmed/IsCancelled already false\r\n                $this._expandedFieldName = $field.Name\r\n                $this._showFieldWidgets = $true\r\n                # NOTE: NeedsClear NOT set - widget renders as overlay without clearing screen\r\n                return\r\n            }\r\n\r\n            # For project fields, create fresh ProjectPicker each time\r\n            if ($field.Type -eq 'project') {\r\n                # Load ProjectPicker if not already loaded\r\n                if (-not ([System.Management.Automation.PSTypeName]'ProjectPicker').Type) {\r\n                    . \"$PSScriptRoot/ProjectPicker.ps1\"\r\n                }\r\n\r\n                # ALWAYS create a fresh ProjectPicker (don't reuse old instances)\r\n                $projectPicker = [ProjectPicker]::new()\r\n                $projectPicker.SetPosition($this.X + 5, $this.Y + 3)\r\n                $projectPicker.SetSize(40, 15)\r\n\r\n                # Get current value from TextInput widget\r\n                $textWidget = $this._fieldWidgets[$field.Name]\r\n                $currentProject = $textWidget.GetText()\r\n                if (-not [string]::IsNullOrWhiteSpace($currentProject)) {\r\n                    $projectPicker._searchText = $currentProject\r\n                }\r\n\r\n                # Store fresh ProjectPicker\r\n                $this._fieldWidgets[$field.Name] = $projectPicker\r\n\r\n                $this._expandedFieldName = $field.Name\r\n                $this._showFieldWidgets = $true\r\n                # NOTE: NeedsClear NOT set - widget renders as overlay without clearing screen\r\n                return\r\n            }\r\n\r\n            $this._expandedFieldName = $field.Name\r\n            $this._showFieldWidgets = $true\r\n\r\n            # Reset widget state for non-date/project fields\r\n            if ($field.Type -ne 'date' -and $field.Type -ne 'project') {\r\n                $widget = $this._fieldWidgets[$field.Name]\r\n                $widget.IsConfirmed = $false\r\n                $widget.IsCancelled = $false\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Validate all fields\r\n\r\n    .OUTPUTS\r\n    True if all fields valid, False otherwise\r\n    ##CLOSEBRACKET##\r\n    hidden [bool] _ValidateAllFields() {\r\n        # Write-PmcTuiLog \"InlineEditor._ValidateAllFields CALLED - field count: $($this._fields.Count)\" \"DEBUG\"\r\n        $this._validationErrors = @()\r\n\r\n        foreach ($field in $this._fields) {\r\n            $fieldName = $field.Name\r\n            $fieldType = $field.Type\r\n            $isRequired = $(if ($field.ContainsKey('Required')) { $field.Required } else { $false })\r\n\r\n            $value = $this._GetFieldValue($fieldName, $fieldType)\r\n            # Write-PmcTuiLog \"InlineEditor._ValidateAllFields - Field: $fieldName, Type: $fieldType, Required: $isRequired, Value: '$value'\" \"DEBUG\"\r\n\r\n            # Check required fields\r\n            if ($isRequired) {\r\n                $isEmpty = $false\r\n\r\n                switch ($fieldType) {\r\n                    'text' {\r\n                        $isEmpty = [string]::IsNullOrWhiteSpace($value)\r\n                    }\r\n                    'date' {\r\n                        $isEmpty = ($null -eq $value)\r\n                    }\r\n                    'project' {\r\n                        $isEmpty = [string]::IsNullOrWhiteSpace($value)\r\n                    }\r\n                    'tags' {\r\n                        $isEmpty = ($null -eq $value -or $value.Count -eq 0)\r\n                    }\r\n                    'number' {\r\n                        $isEmpty = ($null -eq $value)\r\n                    }\r\n                }\r\n\r\n                if ($isEmpty) {\r\n                    $err = \"$($field.Label) is required\"\r\n                    # Write-PmcTuiLog \"InlineEditor._ValidateAllFields - VALIDATION ERROR: $err\" \"ERROR\"\r\n                    $this._validationErrors += $err\r\n                }\r\n            }\r\n\r\n            # Type-specific validation\r\n            if ($fieldType -eq 'number' -and $null -ne $value) {\r\n                $min = $(if ($field.ContainsKey('Min')) { $field.Min } else { [int]::MinValue })\r\n                $max = $(if ($field.ContainsKey('Max')) { $field.Max } else { [int]::MaxValue })\r\n\r\n                if ($value -lt $min) {\r\n                    $err = \"$($field.Label) must be >= $min\"\r\n                    # Write-PmcTuiLog \"InlineEditor._ValidateAllFields - VALIDATION ERROR: $err\" \"ERROR\"\r\n                    $this._validationErrors += $err\r\n                }\r\n\r\n                if ($value -gt $max) {\r\n                    $err = \"$($field.Label) must be <= $max\"\r\n                    # Write-PmcTuiLog \"InlineEditor._ValidateAllFields - VALIDATION ERROR: $err\" \"ERROR\"\r\n                    $this._validationErrors += $err\r\n                }\r\n            }\r\n        }\r\n\r\n        $isValid = $this._validationErrors.Count -eq 0\r\n        # Write-PmcTuiLog \"InlineEditor._ValidateAllFields RESULT: isValid=$isValid, errorCount=$($this._validationErrors.Count)\" \"DEBUG\"\r\n        return $isValid\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    H-UI-3: Validate a single field in real-time (as user types)\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _ValidateFieldRealtime([hashtable]$field) {\r\n        $fieldName = $field.Name\r\n        $fieldType = $field.Type\r\n        $isRequired = $(if ($field.ContainsKey('Required')) { $field.Required } else { $false })\r\n\r\n        # Get current value\r\n        $value = $this._GetFieldValue($fieldName, $fieldType)\r\n\r\n        # Check required fields\r\n        if ($isRequired) {\r\n            $isEmpty = $false\r\n\r\n            switch ($fieldType) {\r\n                'text' {\r\n                    $isEmpty = [string]::IsNullOrWhiteSpace($value)\r\n                }\r\n                'date' {\r\n                    $isEmpty = ($null -eq $value)\r\n                }\r\n                'project' {\r\n                    $isEmpty = [string]::IsNullOrWhiteSpace($value)\r\n                }\r\n                'tags' {\r\n                    $isEmpty = ($null -eq $value -or $value.Count -eq 0)\r\n                }\r\n                'number' {\r\n                    $isEmpty = ($null -eq $value)\r\n                }\r\n            }\r\n\r\n            if ($isEmpty) {\r\n                $this._fieldErrors[$fieldName] = \"$($field.Label) is required\"\r\n                return\r\n            }\r\n        }\r\n\r\n        # Type-specific validation\r\n        if ($fieldType -eq 'number' -and $null -ne $value) {\r\n            $min = $(if ($field.ContainsKey('Min')) { $field.Min } else { [int]::MinValue })\r\n            $max = $(if ($field.ContainsKey('Max')) { $field.Max } else { [int]::MaxValue })\r\n\r\n            if ($value -lt $min) {\r\n                $this._fieldErrors[$fieldName] = \"$($field.Label) must be >= $min\"\r\n                return\r\n            }\r\n\r\n            if ($value -gt $max) {\r\n                $this._fieldErrors[$fieldName] = \"$($field.Label) must be <= $max\"\r\n                return\r\n            }\r\n        }\r\n\r\n        # Field is valid - remove error\r\n        $this._fieldErrors.Remove($fieldName)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Invoke callback safely\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _InvokeCallback([scriptblock]$callback, $arg) {\r\n        if ($null -ne $callback) {\r\n            # Check if callback has actual code (not just empty braces)\r\n            $callbackText = $callback.ToString().Trim()\r\n            # Match {} or { } or {  } etc (braces with only whitespace inside)\r\n            if ([string]::IsNullOrWhiteSpace($callbackText) -or $callbackText -match '^\\{\\s*\\}$') {\r\n                # Write-PmcTuiLog \"InlineEditor._InvokeCallback: Callback is null/empty, skipping\" \"DEBUG\"\r\n                return\r\n            }\r\n\r\n            # if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\r\n            #     Write-PmcTuiLog \"InlineEditor._InvokeCallback: Invoking callback with arg type=$($arg.GetType().Name)\" \"DEBUG\"\r\n            # }\r\n            try {\r\n                if ($null -ne $arg) {\r\n                    # Use Invoke-Command with -ArgumentList to pass single arg without array wrapping\r\n                    Invoke-Command -ScriptBlock $callback -ArgumentList (, $arg)\r\n                }\r\n                else {\r\n                    & $callback\r\n                }\r\n                # if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\r\n                #     Write-PmcTuiLog \"InlineEditor._InvokeCallback: Callback completed successfully\" \"DEBUG\"\r\n                # }\r\n            }\r\n            catch {\r\n                # Log callback errors but DON'T rethrow - callbacks must never crash the app\r\n                if (Get-Command Write-PmcTuiLog -ErrorAction SilentlyContinue) {\r\n                    # Write-PmcTuiLog \"InlineEditor callback error: $($_.Exception.Message)\" \"ERROR\"\r\n                    # Write-PmcTuiLog \"Callback code: $($callback.ToString())\" \"ERROR\"\r\n                    # Write-PmcTuiLog \"Stack trace: $($_.ScriptStackTrace)\" \"ERROR\"\r\n                }\r\n                # DON'T rethrow - form submission callbacks must not crash\r\n            }\r\n        }\r\n    }\r\n}\r\n"}, {"path": "module/Pmc.Strict/consoleui/widgets/PmcDialog.ps1", "content": "using namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nDialog system for PMC TUI\r\n\r\n.DESCRIPTION\r\nProvides reusable dialog components:\r\n- ConfirmDialog: Yes/No confirmation\r\n- TextInputDialog: Single line text input\r\n- MessageDialog: Display message with OK button\r\n##CLOSEBRACKET##\r\n\r\nclass PmcDialog {\r\n    [string]$Title\r\n    [string]$Message\r\n    [int]$Width\r\n    [int]$Height\r\n    [bool]$IsComplete = $false\r\n    [bool]$Result = $false\r\n    [string]$TextResult = ''\r\n\r\n    PmcDialog([string]$title, [string]$message) {\r\n        $this.Title = $title\r\n        $this.Message = $message\r\n        $this.Width = [Math]::Max(60, [Math]::Max($title.Length + 10, $message.Length + 10))\r\n        $this.Height = 10\r\n    }\r\n\r\n    [string] Render([int]$termWidth, [int]$termHeight, [hashtable]$theme) {\r\n        # Legacy render stub\r\n        return \"\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render directly to engine (new high-performance path)\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        # Calculate centered position if not set (or if we want to force center)\r\n        # But Widgets usually have X/Y set. \r\n        # Dialogs often need re-centering on resize.\r\n        # Let's assume layout manager or caller sets X/Y.\r\n        \r\n        # Colors (Ints)\r\n        # Colors (Themed)\r\n        $bg = $this.GetThemedColorInt('Background.Widget')\r\n        $fg = $this.GetThemedColorInt('Foreground.Primary')\r\n        $borderFg = $this.GetThemedColorInt('Border.Widget')\r\n        $highlightFg = $this.GetThemedColorInt('Foreground.Title')\r\n        \r\n        # Shadow (Offset 2,1)\r\n        $shadowBg = [HybridRenderEngine]::_PackRGB(0, 0, 0)\r\n        $engine.Fill($this.X + 2, $this.Y + 1, $this.Width, $this.Height, ' ', -1, $shadowBg)\r\n        \r\n        # Main Box\r\n        $engine.Fill($this.X, $this.Y, $this.Width, $this.Height, ' ', $fg, $bg)\r\n        $engine.DrawBox($this.X, $this.Y, $this.Width, $this.Height, $borderFg, $bg)\r\n        \r\n        # Title\r\n        $titleX = $this.X + [Math]::Floor(($this.Width - $this.Title.Length) / 2)\r\n        $engine.WriteAt($titleX, $this.Y + 1, $this.Title, $highlightFg, $bg)\r\n        \r\n        # Message\r\n        if ($this.Message) {\r\n            $msgX = $this.X + [Math]::Floor(($this.Width - $this.Message.Length) / 2)\r\n            $engine.WriteAt($msgX, $this.Y + 3, $this.Message, $fg, $bg)\r\n        }\r\n    }\r\n\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        # Override in derived classes\r\n        return $false\r\n    }\r\n}\r\n\r\nclass ConfirmDialog : PmcDialog {\r\n    [int]$SelectedButton = 0  # 0 = Yes, 1 = No\r\n\r\n    ConfirmDialog([string]$title, [string]$message) : base($title, $message) {\r\n    }\r\n\r\n    [void] RenderToEngine([object]$engine) {\r\n        ([PmcDialog]$this).RenderToEngine($engine)\r\n        \r\n        $bg = $this.GetThemedColorInt('Background.Widget')\r\n        $fg = $this.GetThemedColorInt('Foreground.Primary')\r\n        $highlightBg = $this.GetThemedColorInt('Background.RowSelected')\r\n        \r\n        # Buttons\r\n        $yesText = \" Yes \"\r\n        $noText = \" No \"\r\n        $gap = 4\r\n        $totalW = $yesText.Length + $noText.Length + $gap\r\n        \r\n        $btnX = $this.X + [Math]::Floor(($this.Width - $totalW) / 2)\r\n        $btnY = $this.Y + 6\r\n        \r\n        # Yes\r\n        $yesBg = if ($this.SelectedButton -eq 0) { $highlightBg } else { $bg }\r\n        $engine.WriteAt($btnX, $btnY, $yesText, $fg, $yesBg)\r\n        \r\n        # No\r\n        $noBg = if ($this.SelectedButton -eq 1) { $highlightBg } else { $bg }\r\n        $engine.WriteAt($btnX + $yesText.Length + $gap, $btnY, $noText, $fg, $noBg)\r\n    }\r\n\r\n    [string] Render([int]$termWidth, [int]$termHeight, [hashtable]$theme) { return \"\" }\r\n\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        switch ($keyInfo.Key) {\r\n            'LeftArrow' {\r\n                $this.SelectedButton = 0\r\n                return $true\r\n            }\r\n            'RightArrow' {\r\n                $this.SelectedButton = 1\r\n                return $true\r\n            }\r\n            'Tab' {\r\n                $this.SelectedButton = 1 - $this.SelectedButton\r\n                return $true\r\n            }\r\n            'Enter' {\r\n                $this.Result = ($this.SelectedButton -eq 0)\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n            'Escape' {\r\n                $this.Result = $false\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n            'Y' {\r\n                $this.Result = $true\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n            'N' {\r\n                $this.Result = $false\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n        }\r\n        return $false\r\n    }\r\n}\r\n\r\nclass TextInputDialog : PmcDialog {\r\n    [string]$InputBuffer = ''\r\n    [string]$Prompt\r\n\r\n    TextInputDialog([string]$title, [string]$prompt, [string]$defaultValue) : base($title, $prompt) {\r\n        $this.Prompt = $prompt\r\n        $this.InputBuffer = $defaultValue\r\n    }\r\n\r\n    [void] RenderToEngine([object]$engine) {\r\n        ([PmcDialog]$this).RenderToEngine($engine)\r\n        \r\n        $bg = $this.GetThemedColorInt('Background.Widget')\r\n        $fg = $this.GetThemedColorInt('Foreground.Primary')\r\n        $inputBg = $this.GetThemedColorInt('Background.Field')\r\n        $cursorFg = $this.GetThemedColorInt('Foreground.Muted')\r\n        \r\n        $inputWidth = $this.Width - 8\r\n        $inputX = $this.X + 4\r\n        $inputY = $this.Y + 5\r\n        \r\n        $display = $this.InputBuffer\r\n        if ($display.Length -gt $inputWidth - 2) {\r\n            $display = $display.Substring($display.Length - $inputWidth + 2)\r\n        }\r\n        \r\n        $engine.Fill($inputX, $inputY, $inputWidth, 1, ' ', $fg, $inputBg)\r\n        $engine.WriteAt($inputX + 1, $inputY, $display, $fg, $inputBg)\r\n        $engine.WriteAt($inputX + 1 + $display.Length, $inputY, \"_\", $cursorFg, $inputBg)\r\n        \r\n        # Hint\r\n        $hint = \"Enter: OK | Esc: Cancel\"\r\n        $hintX = $this.X + [Math]::Floor(($this.Width - $hint.Length) / 2)\r\n        $engine.WriteAt($hintX, $this.Y + 7, $hint, $cursorFg, $bg)\r\n    }\r\n\r\n    [string] Render([int]$termWidth, [int]$termHeight, [hashtable]$theme) { return \"\" }\r\n\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        switch ($keyInfo.Key) {\r\n            'Enter' {\r\n                $this.TextResult = $this.InputBuffer\r\n                $this.Result = $true\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n            'Escape' {\r\n                $this.Result = $false\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n            'Backspace' {\r\n                if ($this.InputBuffer.Length > 0) {\r\n                    $this.InputBuffer = $this.InputBuffer.Substring(0, $this.InputBuffer.Length - 1)\r\n                }\r\n                return $true\r\n            }\r\n            default {\r\n                if ($keyInfo.KeyChar -ge 32 -and $keyInfo.KeyChar -le 126) {\r\n                    $this.InputBuffer += $keyInfo.KeyChar\r\n                }\r\n                return $true\r\n            }\r\n        }\r\n        return $false\r\n    }\r\n}\r\n\r\nclass MessageDialog : PmcDialog {\r\n    MessageDialog([string]$title, [string]$message) : base($title, $message) {\r\n    }\r\n\r\n    [void] RenderToEngine([object]$engine) {\r\n        ([PmcDialog]$this).RenderToEngine($engine)\r\n        \r\n        $bg = $this.GetThemedColorInt('Background.Widget')\r\n        $fg = $this.GetThemedColorInt('Foreground.Primary')\r\n        $highlightBg = $this.GetThemedColorInt('Background.RowSelected')\r\n        \r\n        $ok = \" OK \"\r\n        $okX = $this.X + [Math]::Floor(($this.Width - $ok.Length) / 2)\r\n        \r\n        $engine.WriteAt($okX, $this.Y + 6, $ok, $fg, $highlightBg)\r\n    }\r\n\r\n    [string] Render([int]$termWidth, [int]$termHeight, [hashtable]$theme) { return \"\" }\r\n\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        switch ($keyInfo.Key) {\r\n            'Enter' {\r\n                $this.Result = $true\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n            'Escape' {\r\n                $this.Result = $true\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n        }\r\n        return $false\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nMulti-field project form dialog\r\n##CLOSEBRACKET##\r\nclass ProjectFormDialog : PmcDialog {\r\n    [hashtable]$Fields = @{\r\n        name        = ''\r\n        description = ''\r\n        path        = ''\r\n        aliases     = ''\r\n    }\r\n    [string]$CurrentField = 'name'\r\n    [array]$FieldOrder = @('name', 'description', 'path', 'aliases')\r\n    [hashtable]$FieldLabels = @{\r\n        name        = 'Name'\r\n        description = 'Description'\r\n        path        = 'Path'\r\n        aliases     = 'Aliases'\r\n    }\r\n    [bool]$IsEditMode = $false\r\n    [string]$OriginalName = ''\r\n\r\n    # Constructor for new project\r\n    ProjectFormDialog() : base(\"Add Project\", \"Enter project details\") {\r\n        $this.Width = 70\r\n        $this.Height = 16\r\n        $this.IsEditMode = $false\r\n    }\r\n\r\n    # Constructor for editing existing project\r\n    ProjectFormDialog([hashtable]$existingProject) : base(\"Edit Project\", \"Modify project details\") {\r\n        $this.Width = 70\r\n        $this.Height = 16\r\n        $this.IsEditMode = $true\r\n        $this.OriginalName = $existingProject.name\r\n\r\n        # Populate fields from existing project\r\n        $this.Fields.name = $existingProject.name\r\n        $this.Fields.description = $(if ($existingProject.description) { $existingProject.description } else { '' })\r\n        $this.Fields.path = $(if ($existingProject.path) { $existingProject.path } else { '' })\r\n        $this.Fields.aliases = $(if ($existingProject.aliases -and $existingProject.aliases.Count -gt 0) {\r\n                $existingProject.aliases -join ', '\r\n            }\r\n            else {\r\n                ''\r\n            })\r\n    }\r\n\r\n    [void] RenderToEngine([object]$engine) {\r\n        # Base renders Frame + Title\r\n        ([PmcDialog]$this).RenderToEngine($engine)\r\n        \r\n        $bg = $this.GetThemedColorInt('Background.Widget')\r\n        $fg = $this.GetThemedColorInt('Foreground.Primary')\r\n        $highlight = $this.GetThemedColorInt('Foreground.RowSelected')\r\n        $accentBg = $this.GetThemedColorInt('Background.RowSelected')\r\n        $muted = $this.GetThemedColorInt('Foreground.Muted')\r\n        \r\n        # Override base BG for form? Or match it. Base uses 45,55,72. \r\n        # This form used 30,30,30. Let's use Base colors for consistency if possible, \r\n        # or stick to its own palette. \r\n        # Let's stick to its own palette for now to minimize visual change risk.\r\n        # But we need to redraw base box with these colors if we want consistency.\r\n        # Let's re-draw background/border using Form colors.\r\n        $engine.Fill($this.X, $this.Y, $this.Width, $this.Height, ' ', $fg, $bg)\r\n        $engine.DrawBox($this.X, $this.Y, $this.Width, $this.Height, $fg, $bg)\r\n        $engine.WriteAt($this.X + 2, $this.Y + 1, $this.Title, $highlight, $bg)\r\n        \r\n        $fieldY = $this.Y + 3\r\n        $labelX = $this.X + 4\r\n        $inputX = $this.X + 18\r\n        $inputWidth = $this.Width - 22\r\n        \r\n        foreach ($fieldName in $this.FieldOrder) {\r\n            $isCurrent = ($fieldName -eq $this.CurrentField)\r\n            $label = $this.FieldLabels[$fieldName]\r\n            $value = $this.Fields[$fieldName]\r\n            \r\n            # Label\r\n            $lFg = if ($isCurrent) { $highlight } else { $muted }\r\n            $engine.WriteAt($labelX, $fieldY, $label.PadRight(12), $lFg, $bg)\r\n            \r\n            # Input\r\n            $iBg = if ($isCurrent) { $accentBg } else { $bg }\r\n            $iFg = $fg\r\n            \r\n            $disp = $value\r\n            if ($disp.Length -gt $inputWidth) { $disp = $disp.Substring(0, $inputWidth - 3) + \"...\" }\r\n            \r\n            $engine.Fill($inputX, $fieldY, $inputWidth, 1, ' ', $iFg, $iBg)\r\n            $engine.WriteAt($inputX, $fieldY, $disp, $iFg, $iBg)\r\n            \r\n            if ($isCurrent) {\r\n                $cursorX = $inputX + [Math]::Min($value.Length, $inputWidth - 1)\r\n                $engine.WriteAt($cursorX, $fieldY, \"_\", $highlight, $accentBg)\r\n            }\r\n            \r\n            $fieldY += 2\r\n        }\r\n        \r\n        # Instructions\r\n        $inst = \"Tab: Next | Enter: Save | Esc: Cancel\"\r\n        $instX = $this.X + [Math]::Floor(($this.Width - $inst.Length) / 2)\r\n        $engine.WriteAt($instX, $this.Y + $this.Height - 3, $inst, $muted, $bg)\r\n    }\r\n\r\n    [string] Render([int]$termWidth, [int]$termHeight, [hashtable]$theme) { return \"\" }\r\n\r\n    # REMOVED: UpdateFieldDisplay() - Dead code that was never called\r\n    # This method used [Console]::Write() which bypassed the render engine layer system.\r\n    # If field-by-field updates are needed in the future, they should use the render engine\r\n    # with BeginLayer([ZIndex]::Dialog) instead of direct console writes.\r\n\r\n    # File picker integration\r\n    [string]$FilePicker = ''  # Signal to caller to show file picker\r\n\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        switch ($keyInfo.Key) {\r\n            'Enter' {\r\n                # Check if we're on path field - open file picker\r\n                if ($this.CurrentField -eq 'path') {\r\n                    $this.FilePicker = 'show'\r\n                    return $true\r\n                }\r\n\r\n                # Otherwise validate and save\r\n                if ([string]::IsNullOrWhiteSpace($this.Fields.name)) {\r\n                    # Name is required - don't close\r\n                    return $true\r\n                }\r\n                $this.Result = $true\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n            'Escape' {\r\n                $this.Result = $false\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n            'Tab' {\r\n                # Move to next field - NEEDS FULL REDRAW\r\n                $currentIndex = $this.FieldOrder.IndexOf($this.CurrentField)\r\n                if ($keyInfo.Modifiers -eq [ConsoleModifiers]::Shift) {\r\n                    # Shift+Tab: previous field\r\n                    $currentIndex--\r\n                    if ($currentIndex -lt 0) {\r\n                        $currentIndex = $this.FieldOrder.Count - 1\r\n                    }\r\n                }\r\n                else {\r\n                    # Tab: next field\r\n                    $currentIndex++\r\n                    if ($currentIndex -ge $this.FieldOrder.Count) {\r\n                        $currentIndex = 0\r\n                    }\r\n                }\r\n                $this.CurrentField = $this.FieldOrder[$currentIndex]\r\n                return $true  # Caller must re-render\r\n            }\r\n            'UpArrow' {\r\n                # Move to previous field - NEEDS FULL REDRAW\r\n                $currentIndex = $this.FieldOrder.IndexOf($this.CurrentField)\r\n                $currentIndex--\r\n                if ($currentIndex -lt 0) {\r\n                    $currentIndex = $this.FieldOrder.Count - 1\r\n                }\r\n                $this.CurrentField = $this.FieldOrder[$currentIndex]\r\n                return $true  # Caller must re-render\r\n            }\r\n            'DownArrow' {\r\n                # Move to next field - NEEDS FULL REDRAW\r\n                $currentIndex = $this.FieldOrder.IndexOf($this.CurrentField)\r\n                $currentIndex++\r\n                if ($currentIndex -ge $this.FieldOrder.Count) {\r\n                    $currentIndex = 0\r\n                }\r\n                $this.CurrentField = $this.FieldOrder[$currentIndex]\r\n                return $true  # Caller must re-render\r\n            }\r\n            'Backspace' {\r\n                # Delete character from current field - UPDATE CURRENT FIELD ONLY\r\n                if ($this.Fields[$this.CurrentField].Length -gt 0) {\r\n                    $this.Fields[$this.CurrentField] = $this.Fields[$this.CurrentField].Substring(0, $this.Fields[$this.CurrentField].Length - 1)\r\n                }\r\n                return $false  # No full redraw needed\r\n            }\r\n            default {\r\n                # Add character to current field - UPDATE CURRENT FIELD ONLY\r\n                if ($keyInfo.KeyChar -ge 32 -and $keyInfo.KeyChar -le 126) {\r\n                    $this.Fields[$this.CurrentField] += $keyInfo.KeyChar\r\n                }\r\n                return $false  # No full redraw needed\r\n            }\r\n        }\r\n        return $false\r\n    }\r\n\r\n    # Get the project hashtable result\r\n    [hashtable] GetProject() {\r\n        # Parse aliases from comma-separated string\r\n        $aliasesArray = @()\r\n        if (-not [string]::IsNullOrWhiteSpace($this.Fields.aliases)) {\r\n            $aliasesArray = @($this.Fields.aliases -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ })\r\n        }\r\n\r\n        return @{\r\n            name        = $this.Fields.name\r\n            description = $this.Fields.description\r\n            path        = $this.Fields.path\r\n            aliases     = $aliasesArray\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/widgets/PmcFilePicker.ps1", "content": "using namespace System\r\nusing namespace System.Collections.Generic\r\n\r\n<#\r\n.SYNOPSIS\r\nModern File/Directory Picker Widget for PmcTUI\r\nFully integrated with SpeedTUI render engine, proper Z-layering, theme support\r\n##CLOSEBRACKET##\r\n\r\nif (-not ([System.Management.Automation.PSTypeName]'PmcWidget').Type) {\r\n    . \"$PSScriptRoot/PmcWidget.ps1\"\r\n}\r\n\r\nclass PmcFilePicker : PmcWidget {\r\n    # === Public Properties ===\r\n    [string]$CurrentPath = ''\r\n    [array]$Items = @()\r\n    [int]$SelectedIndex = 0\r\n    [int]$ScrollOffset = 0\r\n    [bool]$DirectoriesOnly = $true\r\n    [string]$SelectedPath = ''\r\n    [bool]$IsComplete = $false\r\n    [bool]$Result = $false\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnConfirmed = {}       # Called when selection confirmed: param($path)\r\n    [scriptblock]$OnCancelled = {}       # Called when cancelled\r\n\r\n    # === Private State ===\r\n    hidden [int]$_minWidth = 50\r\n    hidden [int]$_minHeight = 15\r\n    hidden [int]$_contentPadding = 2\r\n    hidden [int]$_headerHeight = 3      # Title + separator + blank\r\n    hidden [int]$_footerHeight = 2      # Blank + footer text\r\n\r\n    PmcFilePicker([string]$startPath, [bool]$directoriesOnly) {\r\n        $this.DirectoriesOnly = $directoriesOnly\r\n        $this.Width = 70\r\n        $this.Height = 22\r\n\r\n        # Set start path\r\n        if ([string]::IsNullOrWhiteSpace($startPath) -or -not (Test-Path $startPath)) {\r\n            $this.CurrentPath = [Environment]::GetFolderPath('UserProfile')\r\n        } else {\r\n            $this.CurrentPath = $startPath\r\n        }\r\n\r\n        $this._LoadItems()\r\n    }\r\n\r\n    # === Item Management ===\r\n\r\n    hidden [void] _LoadItems() {\r\n        $this.Items = @()\r\n        $this.SelectedIndex = 0\r\n        $this.ScrollOffset = 0\r\n\r\n        try {\r\n            # Add parent directory (..)\r\n            $parent = Split-Path -Parent $this.CurrentPath\r\n            if ($parent -and $parent -ne $this.CurrentPath) {\r\n                $this.Items += @{ Name = '..'; Path = $parent; IsDirectory = $true }\r\n            }\r\n\r\n            # Get directories\r\n            $dirs = @(Get-ChildItem -Path $this.CurrentPath -Directory -ErrorAction SilentlyContinue | Sort-Object Name)\r\n            foreach ($dir in $dirs) {\r\n                $this.Items += @{ Name = $dir.Name; Path = $dir.FullName; IsDirectory = $true }\r\n            }\r\n\r\n            # Get files if not DirectoriesOnly\r\n            if (-not $this.DirectoriesOnly) {\r\n                $files = @(Get-ChildItem -Path $this.CurrentPath -File -ErrorAction SilentlyContinue | Sort-Object Name)\r\n                foreach ($file in $files) {\r\n                    $this.Items += @{ Name = $file.Name; Path = $file.FullName; IsDirectory = $false }\r\n                }\r\n            }\r\n        } catch {\r\n            # Fall back to home directory\r\n            $this.CurrentPath = [Environment]::GetFolderPath('UserProfile')\r\n            $this._LoadItems()\r\n        }\r\n    }\r\n\r\n    # === Layout ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n\r\n        # Ensure minimum dimensions\r\n        if ($this.Width -lt $this._minWidth) { $this.Width = $this._minWidth }\r\n        if ($this.Height -lt $this._minHeight) { $this.Height = $this._minHeight }\r\n\r\n        # Center on screen if not positioned\r\n        if ($this.X -le 0) {\r\n            $this.X = [Math]::Max(1, [Math]::Floor(($engine.Width - $this.Width) / 2))\r\n        }\r\n        if ($this.Y -le 0) {\r\n            $this.Y = [Math]::Max(1, [Math]::Floor(($engine.Height - $this.Height) / 2))\r\n        }\r\n\r\n        # Define regions\r\n        $contentHeight = $this.Height - $this._headerHeight - $this._footerHeight\r\n        $engine.DefineRegion(\"$($this.RegionID)_Header\", $this.X + 1, $this.Y + 1, $this.Width - 2, 1)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Path\", $this.X + 1, $this.Y + 2, $this.Width - 2, 1)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Items\", $this.X + 1, $this.Y + 3, $this.Width - 2, $contentHeight)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Footer\", $this.X + 1, $this.Y + $this.Height - 1, $this.Width - 2, 1)\r\n    }\r\n\r\n    # === Rendering ===\r\n\r\n    [void] RenderToEngine([object]$engine) {\r\n        $this.RegisterLayout($engine)\r\n\r\n        # Add-Content -Path \"/tmp/pmc-filepicker-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] === FilePicker.RenderToEngine START === X=$($this.X) Y=$($this.Y) Width=$($this.Width) Height=$($this.Height) engineWidth=$($engine.Width) engineHeight=$($engine.Height)\"\r\n\r\n        # Begin Z-layer (above content, below dialogs)\r\n        if ($engine.PSObject.Methods['BeginLayer']) {\r\n            # Add-Content -Path \"/tmp/pmc-filepicker-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] BeginLayer(20) called\"\r\n            $engine.BeginLayer(20)\r\n        }\r\n        else {\r\n            # Add-Content -Path \"/tmp/pmc-filepicker-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] WARNING: BeginLayer method not available\"\r\n        }\r\n\r\n        # Theme colors\r\n        $primaryBg = $this.GetThemedColorInt('Background.Primary')\r\n        $primaryFg = $this.GetThemedColorInt('Foreground.Field')\r\n        $borderFg = $this.GetThemedColorInt('Border.Widget')\r\n        $titleFg = $this.GetThemedColorInt('Foreground.Title')\r\n        $selectedBg = $this.GetThemedColorInt('Background.RowSelected')\r\n        $selectedFg = $this.GetThemedColorInt('Foreground.RowSelected')\r\n        $mutedFg = $this.GetThemedColorInt('Foreground.Muted')\r\n\r\n        # Draw background and border\r\n        $engine.Fill($this.X, $this.Y, $this.Width, $this.Height, ' ', $primaryFg, $primaryBg)\r\n\r\n        # Draw top and bottom border\r\n        $engine.Fill($this.X, $this.Y, $this.Width, 1, '─', $borderFg, $primaryBg)\r\n        $engine.Fill($this.X, $this.Y + $this.Height - 1, $this.Width, 1, '─', $borderFg, $primaryBg)\r\n\r\n        # Draw left and right borders\r\n        for ($i = $this.Y; $i -lt ($this.Y + $this.Height); $i++) {\r\n            $engine.WriteAt($this.X, $i, '│', $borderFg, $primaryBg)\r\n            $engine.WriteAt($this.X + $this.Width - 1, $i, '│', $borderFg, $primaryBg)\r\n        }\r\n\r\n        # Draw corners\r\n        $engine.WriteAt($this.X, $this.Y, '┌', $borderFg, $primaryBg)\r\n        $engine.WriteAt($this.X + $this.Width - 1, $this.Y, '┐', $borderFg, $primaryBg)\r\n        $engine.WriteAt($this.X, $this.Y + $this.Height - 1, '└', $borderFg, $primaryBg)\r\n        $engine.WriteAt($this.X + $this.Width - 1, $this.Y + $this.Height - 1, '┘', $borderFg, $primaryBg)\r\n\r\n        # Draw header\r\n        $headerText = \"📁 Select Directory\"\r\n        $headerPadded = $headerText.PadRight($this.Width - 2)\r\n        $engine.WriteAt($this.X + 1, $this.Y + 1, $headerPadded.Substring(0, $this.Width - 2), $titleFg, $primaryBg)\r\n\r\n        # Draw path\r\n        $pathDisplay = $this.CurrentPath\r\n        if ($pathDisplay.Length -gt ($this.Width - 4)) {\r\n            $pathDisplay = \"...\" + $pathDisplay.Substring($pathDisplay.Length - ($this.Width - 7))\r\n        }\r\n        $pathPadded = $pathDisplay.PadRight($this.Width - 2)\r\n        $engine.WriteAt($this.X + 1, $this.Y + 2, $pathPadded.Substring(0, $this.Width - 2), $mutedFg, $primaryBg)\r\n\r\n        # Draw items\r\n        $listY = $this.Y + 3\r\n        $contentHeight = $this.Height - $this._headerHeight - $this._footerHeight\r\n\r\n        # Ensure selection is visible\r\n        if ($this.SelectedIndex -lt $this.ScrollOffset) {\r\n            $this.ScrollOffset = $this.SelectedIndex\r\n        }\r\n        if ($this.SelectedIndex -ge ($this.ScrollOffset + $contentHeight)) {\r\n            $this.ScrollOffset = $this.SelectedIndex - $contentHeight + 1\r\n        }\r\n\r\n        # Render items\r\n        $row = 0\r\n        $itemCount = $this.Items.Count\r\n        for ($i = $this.ScrollOffset; $i -lt [Math]::Min($this.ScrollOffset + $contentHeight, $itemCount); $i++) {\r\n            $item = $this.Items[$i]\r\n            $isSelected = ($i -eq $this.SelectedIndex)\r\n            $itemBg = if ($isSelected) { $selectedBg } else { $primaryBg }\r\n            $itemFg = if ($isSelected) { $selectedFg } else { if ($item.IsDirectory) { $titleFg } else { $primaryFg } }\r\n\r\n            # Item text\r\n            $icon = if ($item.IsDirectory) { \"📁\" } else { \"📄\" }\r\n            $displayName = $item.Name\r\n            $maxNameLen = $this.Width - 6\r\n            if ($displayName.Length -gt $maxNameLen) {\r\n                $displayName = $displayName.Substring(0, $maxNameLen - 3) + \"...\"\r\n            }\r\n\r\n            $itemText = \" $icon $displayName\"\r\n            $itemTextPadded = $itemText.PadRight($this.Width - 2)\r\n\r\n            $engine.Fill($this.X + 1, $listY + $row, $this.Width - 2, 1, ' ', $itemFg, $itemBg)\r\n            $engine.WriteAt($this.X + 1, $listY + $row, $itemTextPadded.Substring(0, $this.Width - 2), $itemFg, $itemBg)\r\n\r\n            $row++\r\n        }\r\n\r\n        # Fill remaining rows\r\n        while ($row -lt $contentHeight) {\r\n            $engine.Fill($this.X + 1, $listY + $row, $this.Width - 2, 1, ' ', $primaryFg, $primaryBg)\r\n            $row++\r\n        }\r\n\r\n        # Draw scroll indicators\r\n        if ($this.ScrollOffset -gt 0) {\r\n            $engine.WriteAt($this.X + $this.Width - 2, $listY, \"▲\", $mutedFg, $primaryBg)\r\n        }\r\n        if (($this.ScrollOffset + $contentHeight) -lt $itemCount) {\r\n            $engine.WriteAt($this.X + $this.Width - 2, $listY + $contentHeight - 1, \"▼\", $mutedFg, $primaryBg)\r\n        }\r\n\r\n        # Draw footer\r\n        $footerText = \"↑↓: Navigate | Enter: Select | Space: Use Path | Esc: Cancel\"\r\n        if ($footerText.Length -gt ($this.Width - 2)) {\r\n            $footerText = $footerText.Substring(0, $this.Width - 5) + \"...\"\r\n        }\r\n        $footerPadded = $footerText.PadRight($this.Width - 2)\r\n        $engine.WriteAt($this.X + 1, $this.Y + $this.Height - 1, $footerPadded.Substring(0, $this.Width - 2), $mutedFg, $primaryBg)\r\n\r\n        # End Z-layer\r\n        if ($engine.PSObject.Methods['EndLayer']) {\r\n            # Add-Content -Path \"/tmp/pmc-filepicker-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] EndLayer() called\"\r\n            $engine.EndLayer()\r\n        }\r\n        # Add-Content -Path \"/tmp/pmc-filepicker-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] === FilePicker.RenderToEngine END ===\"\r\n    }\r\n\r\n    # === Input Handling ===\r\n\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        switch ($keyInfo.Key) {\r\n            'UpArrow' {\r\n                if ($this.SelectedIndex -gt 0) {\r\n                    $this.SelectedIndex--\r\n                }\r\n                return $true\r\n            }\r\n            'DownArrow' {\r\n                if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {\r\n                    $this.SelectedIndex++\r\n                }\r\n                return $true\r\n            }\r\n            'PageUp' {\r\n                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - 10)\r\n                return $true\r\n            }\r\n            'PageDown' {\r\n                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + 10)\r\n                return $true\r\n            }\r\n            'Home' {\r\n                $this.SelectedIndex = 0\r\n                return $true\r\n            }\r\n            'End' {\r\n                if ($this.Items.Count -gt 0) {\r\n                    $this.SelectedIndex = $this.Items.Count - 1\r\n                }\r\n                return $true\r\n            }\r\n            'Enter' {\r\n                if ($this.Items.Count -eq 0) {\r\n                    return $true\r\n                }\r\n                $selected = $this.Items[$this.SelectedIndex]\r\n                if ($selected.IsDirectory) {\r\n                    $this.CurrentPath = $selected.Path\r\n                    $this._LoadItems()\r\n                } else {\r\n                    $this.SelectedPath = $selected.Path\r\n                    $this.Result = $true\r\n                    $this.IsComplete = $true\r\n                    $this._InvokeCallback($this.OnConfirmed, $this.SelectedPath)\r\n                }\r\n                return $true\r\n            }\r\n            'Spacebar' {\r\n                # Select current path\r\n                $this.SelectedPath = $this.CurrentPath\r\n                $this.Result = $true\r\n                $this.IsComplete = $true\r\n                $this._InvokeCallback($this.OnConfirmed, $this.SelectedPath)\r\n                return $true\r\n            }\r\n            'Escape' {\r\n                $this.Result = $false\r\n                $this.IsComplete = $true\r\n                $this._InvokeCallback($this.OnCancelled, $null)\r\n                return $true\r\n            }\r\n        }\r\n        return $false\r\n    }\r\n\r\n    # === Callbacks ===\r\n\r\n    hidden [void] _InvokeCallback([scriptblock]$callback, [object]$arg) {\r\n        if ($callback -and $callback -ne $null) {\r\n            try {\r\n                & $callback $arg\r\n            } catch {\r\n                # Callback error - log but don't crash\r\n            }\r\n        }\r\n    }\r\n\r\n    # === Legacy Render method (for compatibility) ===\r\n\r\n    [string] Render() {\r\n        return \"\"\r\n    }\r\n}\r\n"}, {"path": "module/Pmc.Strict/consoleui/widgets/PmcFooter.ps1", "content": "using namespace System.Text\r\nusing namespace System.Collections.Generic\r\n\r\n# PmcFooter - Keyboard shortcuts display\r\n# Shows available keyboard shortcuts for current screen\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nFooter widget displaying keyboard shortcuts\r\n\r\n.DESCRIPTION\r\nPmcFooter shows available keyboard shortcuts in a consistent format:\r\n- Left-aligned shortcuts\r\n- Separator characters\r\n- Color-coded key labels\r\n\r\n.EXAMPLE\r\n$footer = [PmcFooter]::new()\r\n$footer.AddShortcut(\"Esc\", \"Back\")\r\n$footer.AddShortcut(\"F10\", \"Menu\")\r\n$footer.AddShortcut(\"Enter\", \"Select\")\r\n##CLOSEBRACKET##\r\nclass PmcFooter : PmcWidget {\r\n    # === Properties ===\r\n    [List[hashtable]]$Shortcuts\r\n\r\n    # === Constructor ===\r\n    PmcFooter() : base(\"Footer\") {\r\n        $this.Shortcuts = [List[hashtable]]::new()\r\n        $this.Height = 1\r\n        $this.Width = 80\r\n    }\r\n\r\n    # === Shortcut Management ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Add a keyboard shortcut to display\r\n\r\n    .PARAMETER key\r\n    Key name (e.g., \"Esc\", \"F10\", \"Ctrl+S\")\r\n\r\n    .PARAMETER description\r\n    Action description (e.g., \"Back\", \"Save\", \"Exit\")\r\n\r\n    .EXAMPLE\r\n    $footer.AddShortcut(\"Esc\", \"Back\")\r\n    ##CLOSEBRACKET##\r\n    [void] AddShortcut([string]$key, [string]$description) {\r\n        $this.Shortcuts.Add(@{\r\n            Key = $key\r\n            Description = $description\r\n        })\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Clear all shortcuts\r\n\r\n    .DESCRIPTION\r\n    Removes all shortcuts from the footer\r\n    ##CLOSEBRACKET##\r\n    [void] ClearShortcuts() {\r\n        $this.Shortcuts.Clear()\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set shortcuts from array\r\n\r\n    .PARAMETER shortcuts\r\n    Array of key-description pairs\r\n\r\n    .EXAMPLE\r\n    $footer.SetShortcuts(@(\r\n        @{ Key = \"Esc\"; Description = \"Back\" }\r\n        @{ Key = \"Enter\"; Description = \"Select\" }\r\n    ))\r\n    ##CLOSEBRACKET##\r\n    [void] SetShortcuts([array]$shortcuts) {\r\n        $this.Shortcuts.Clear()\r\n        foreach ($shortcut in $shortcuts) {\r\n            $this.Shortcuts.Add($shortcut)\r\n        }\r\n        $this.Invalidate()\r\n    }\r\n\r\n    # === Rendering ===\r\n\r\n    [string] OnRender() {\r\n        if ($this.Shortcuts.Count -eq 0) {\r\n            return \"\"\r\n        }\r\n\r\n        $sb = [System.Text.StringBuilder]::new(512)\r\n\r\n        # Colors\r\n        $keyColor = $this.GetThemedFg('Foreground.Title')\r\n        $textColor = $this.GetThemedFg('Foreground.Muted')\r\n        $separatorColor = $this.GetThemedFg('Border.Widget')\r\n        $reset = \"`e[0m\"\r\n\r\n        # Position\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y))\r\n        # CRITICAL: Clear the entire line first to prevent text corruption\r\n        $sb.Append(\"`e[K\")\r\n\r\n        # Build shortcut string\r\n        $shortcutParts = [List[string]]::new()\r\n        foreach ($shortcut in $this.Shortcuts) {\r\n            $key = $shortcut.Key\r\n            $desc = $shortcut.Description\r\n\r\n            $part = \"${keyColor}${key}${reset}${textColor}: ${desc}${reset}\"\r\n            $shortcutParts.Add($part)\r\n        }\r\n\r\n        # Join with separator\r\n        $separator = \" ${separatorColor}|${reset} \"\r\n        $footerText = $shortcutParts -join $separator\r\n\r\n        # Note: This includes ANSI codes, so actual display width will be shorter\r\n        # For now, just output it (proper width calculation would need ANSI stripping)\r\n        $sb.Append($footerText)\r\n        $sb.Append($reset)\r\n\r\n        $result = $sb.ToString()\r\n\r\n        return $result\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Main\", $this.X, $this.Y, $this.Width, $this.Height)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render directly to engine (new high-performance path)\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        if ($this.Shortcuts.Count -eq 0) {\r\n            return\r\n        }\r\n\r\n        $this.RegisterLayout($engine)\r\n\r\n        # Build the footer text as a single string with inline formatting\r\n        # This allows gradient themes to work properly across the entire footer\r\n        $parts = @()\r\n        for ($i = 0; $i -lt $this.Shortcuts.Count; $i++) {\r\n            $shortcut = $this.Shortcuts[$i]\r\n            $key = $shortcut.Key\r\n            $desc = $shortcut.Description\r\n\r\n            # Format: \"Key: Description\"\r\n            $part = \"${key}: ${desc}\"\r\n            $parts += $part\r\n        }\r\n\r\n        # Join with separator\r\n        $footerText = $parts -join \" | \"\r\n\r\n        # Use WriteThemedToRegion for automatic gradient support\r\n        # Use Foreground.Primary which supports gradient rendering from theme config\r\n        $this.WriteThemedToRegion($engine, \"$($this.RegionID)_Main\", $footerText, 'Foreground.Primary', 'Background.Footer')\r\n    }\r\n\r\n    # === Helper Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Create footer with standard shortcuts\r\n\r\n    .PARAMETER shortcuts\r\n    Array of @{ Key = \"...\"; Description = \"...\" }\r\n\r\n    .OUTPUTS\r\n    Configured PmcFooter instance\r\n\r\n    .EXAMPLE\r\n    $footer = [PmcFooter]::CreateStandard(@(\r\n        @{ Key = \"Esc\"; Description = \"Back\" }\r\n        @{ Key = \"F10\"; Description = \"Menu\" }\r\n    ))\r\n    ##CLOSEBRACKET##\r\n    static [PmcFooter] CreateStandard([array]$shortcuts) {\r\n        $footer = [PmcFooter]::new()\r\n        $footer.SetShortcuts($shortcuts)\r\n        return $footer\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Create footer with common navigation shortcuts\r\n\r\n    .OUTPUTS\r\n    PmcFooter with standard navigation shortcuts\r\n    ##CLOSEBRACKET##\r\n    static [PmcFooter] CreateNavigationFooter() {\r\n        $footer = [PmcFooter]::new()\r\n        $footer.AddShortcut(\"↑↓\", \"Navigate\")\r\n        $footer.AddShortcut(\"Enter\", \"Select\")\r\n        $footer.AddShortcut(\"Esc\", \"Back\")\r\n        $footer.AddShortcut(\"F10\", \"Menu\")\r\n        return $footer\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Create footer with common edit shortcuts\r\n\r\n    .OUTPUTS\r\n    PmcFooter with standard edit shortcuts\r\n    ##CLOSEBRACKET##\r\n    static [PmcFooter] CreateEditFooter() {\r\n        $footer = [PmcFooter]::new()\r\n        $footer.AddShortcut(\"Enter\", \"Save\")\r\n        $footer.AddShortcut(\"Esc\", \"Cancel\")\r\n        $footer.AddShortcut(\"Tab\", \"Next Field\")\r\n        return $footer\r\n    }\r\n}\r\n\r\n# Classes exported automatically in PowerShell 5.1+\r\n# Classes exported automatically in PowerShell 5.1+"}, {"path": "module/Pmc.Strict/consoleui/widgets/PmcHeader.ps1", "content": "using namespace System.Text\r\n\r\n# PmcHeader - Screen header widget with title, breadcrumb, and context info\r\n# Provides consistent header appearance across all PMC screens\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nHeader widget for screen titles and navigation context\r\n\r\n.DESCRIPTION\r\nPmcHeader displays:\r\n- Screen title (large, themed)\r\n- Optional icon\r\n- Optional breadcrumb trail\r\n- Optional context information\r\n- Horizontal separator line\r\n\r\n.EXAMPLE\r\n$header = [PmcHeader]::new(\"Tasks\")\r\n$header.SetBreadcrumb(@(\"Home\", \"Projects\", \"Tasks\"))\r\n$header.SetContext(\"15 active tasks\")\r\n##CLOSEBRACKET##\r\nclass PmcHeader : PmcWidget {\r\n    # === Properties ===\r\n    [string]$Title = \"\"\r\n    [string]$Icon = \"\"\r\n    [string[]]$Breadcrumb = @()\r\n    [string]$ContextInfo = \"\"\r\n    [bool]$ShowSeparator = $true\r\n    [string]$BorderStyle = 'single'  # 'single', 'double', 'heavy'\r\n\r\n    # === Constructor ===\r\n    PmcHeader() : base(\"Header\") {\r\n        $this.Height = 5  # Title + blank + breadcrumb + blank + separator (max height with breadcrumb)\r\n        $this.Width = 80\r\n    }\r\n\r\n    PmcHeader([string]$title) : base(\"Header\") {\r\n        $this.Title = $title\r\n        $this.Height = 5  # Title + blank + breadcrumb + blank + separator (max height with breadcrumb)\r\n        $this.Width = 80\r\n    }\r\n\r\n    # === Configuration ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set the title text\r\n\r\n    .PARAMETER title\r\n    Title to display\r\n    ##CLOSEBRACKET##\r\n    [void] SetTitle([string]$title) {\r\n        $this.Title = $title\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set the icon character\r\n\r\n    .PARAMETER icon\r\n    Icon character or emoji\r\n    ##CLOSEBRACKET##\r\n    [void] SetIcon([string]$icon) {\r\n        $this.Icon = $icon\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set breadcrumb trail\r\n\r\n    .PARAMETER breadcrumb\r\n    Array of breadcrumb segments (e.g., @(\"Home\", \"Projects\", \"My Project\"))\r\n    ##CLOSEBRACKET##\r\n    [void] SetBreadcrumb([string[]]$breadcrumb) {\r\n        $this.Breadcrumb = $breadcrumb\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set context information (right-aligned)\r\n\r\n    .PARAMETER contextInfo\r\n    Context text (e.g., \"15 items\", \"Last updated: 2024-01-15\")\r\n    ##CLOSEBRACKET##\r\n    [void] SetContext([string]$contextInfo) {\r\n        $this.ContextInfo = $contextInfo\r\n        $this.Invalidate()\r\n    }\r\n\r\n    # === Rendering ===\r\n\r\n    [string] OnRender() {\r\n        $sb = [System.Text.StringBuilder]::new(512)\r\n\r\n        # Colors\r\n        $titleColor = $this.GetThemedFg('Foreground.Title')\r\n        $mutedColor = $this.GetThemedFg('Foreground.Muted')\r\n        $borderColor = $this.GetThemedFg('Border.Widget')\r\n        $reset = \"`e[0m\"\r\n\r\n        # Line 1: Title (with optional icon and context)\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y))\r\n        $sb.Append($titleColor)\r\n\r\n        $titleText = \"\"\r\n        if ($this.Icon) {\r\n            $titleText = \"$($this.Icon) \"\r\n        }\r\n        $titleText += $this.Title\r\n\r\n        # If context info exists, show it right-aligned\r\n        if ($this.ContextInfo) {\r\n            $contextText = \" [$($this.ContextInfo)]\"\r\n            $availableWidth = $this.Width - $titleText.Length - $contextText.Length\r\n            if ($availableWidth -gt 0) {\r\n                $sb.Append($titleText)\r\n                $sb.Append($this.GetSpaces($availableWidth))\r\n                $sb.Append($mutedColor)\r\n                $sb.Append($contextText)\r\n                $sb.Append($reset)\r\n            } else {\r\n                # Not enough room, just show title\r\n                $sb.Append($this.TruncateText($titleText, $this.Width))\r\n                $sb.Append($reset)\r\n            }\r\n        } else {\r\n            $sb.Append($titleText)\r\n            $sb.Append($reset)\r\n        }\r\n\r\n        # Line 2: Blank line for visual space\r\n        # (intentionally blank)\r\n\r\n        # Line 3: Breadcrumb (if present)\r\n        if ($this.Breadcrumb -and $this.Breadcrumb.Count -gt 0) {\r\n            $sb.Append($this.BuildMoveTo($this.X, $this.Y + 2))\r\n            $sb.Append($mutedColor)\r\n\r\n            $breadcrumbText = $this.Breadcrumb -join \" → \"\r\n            $sb.Append($this.TruncateText($breadcrumbText, $this.Width))\r\n            $sb.Append($reset)\r\n        }\r\n\r\n        # Line 4: Column headers will be rendered by TaskListScreen here\r\n        # Line 5: Separator (if enabled)\r\n        if ($this.ShowSeparator) {\r\n            $separatorY = $(if ($this.Breadcrumb -and $this.Breadcrumb.Count -gt 0) { $this.Y + 4 } else { $this.Y + 2 })\r\n            $sb.Append($this.BuildMoveTo($this.X, $separatorY))\r\n            $sb.Append($borderColor)\r\n            $sb.Append($this.BuildHorizontalLine($this.Width, $this.BorderStyle))\r\n            $sb.Append($reset)\r\n        }\r\n\r\n        $result = $sb.ToString()\r\n\r\n        return $result\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n\r\n        # Region for Title (Left side)\r\n        $contextWidth = [Math]::Min(30, [Math]::Max(10, $this.Width - 20))  # Clamp between 10-30\r\n        $titleWidth = [Math]::Max(10, $this.Width - $contextWidth)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Title\", $this.X, $this.Y, $titleWidth, 1)\r\n\r\n        # Region for Context (Right side) - ensure it doesn't extend past widget bounds\r\n        $engine.DefineRegion(\"$($this.RegionID)_Context\", $this.X + $titleWidth, $this.Y, $contextWidth, 1)\r\n        \r\n        # Region for Breadcrumb (Line 3, Y+2)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Breadcrumb\", $this.X, $this.Y + 2, $this.Width, 1)\r\n        \r\n        # Region for Separator (Line 5 or 3 depending on breadcrumb)\r\n        # We calculate Y dynamically based on state during render, but regions are static.\r\n        # So we define TWO separator regions and use the right one? Or just one flexible one?\r\n        # Better: Define potential regions.\r\n        $engine.DefineRegion(\"$($this.RegionID)_Separator_Breadcrumb\", $this.X, $this.Y + 4, $this.Width, 1)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Separator_Simple\", $this.X, $this.Y + 2, $this.Width, 1)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render directly to engine (new high-performance path)\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        $this.RegisterLayout($engine)\r\n\r\n        # Colors (Ints for solid colors)\r\n        $borderFg = $this.GetThemedInt('Border.Widget')\r\n\r\n        # Calculate region widths (must match RegisterLayout)\r\n        $contextWidth = [Math]::Min(30, [Math]::Max(10, $this.Width - 20))\r\n        $titleWidth = [Math]::Max(10, $this.Width - $contextWidth)\r\n\r\n        # Title - Use WriteThemedToRegion for automatic gradient support\r\n        $titleText = if ($this.Icon) { \"$($this.Icon) $($this.Title)\" } else { $this.Title }\r\n        $this.WriteThemedToRegion($engine, \"$($this.RegionID)_Title\", $titleText, 'Foreground.Title', 'Background.Header')\r\n\r\n        # Context Info (Right-aligned within its region)\r\n        if ($this.ContextInfo) {\r\n             $ctxText = \"[$($this.ContextInfo)]\"\r\n             $padCount = [Math]::Max(0, $contextWidth - $ctxText.Length)\r\n             $paddedCtx = (\" \" * $padCount) + $ctxText\r\n             $this.WriteThemedToRegion($engine, \"$($this.RegionID)_Context\", $paddedCtx, 'Foreground.Muted', 'Background.Header')\r\n        }\r\n\r\n        # Breadcrumb - Use WriteThemedToRegion for gradient support\r\n        $hasBreadcrumb = ($this.Breadcrumb -and $this.Breadcrumb.Count -gt 0)\r\n        if ($hasBreadcrumb) {\r\n            $crumbText = $this.Breadcrumb -join \" → \"\r\n            $this.WriteThemedToRegion($engine, \"$($this.RegionID)_Breadcrumb\", $crumbText, 'Foreground.Muted', 'Background.Header')\r\n        }\r\n\r\n        # Separator\r\n        if ($this.ShowSeparator) {\r\n            $sepRegion = if ($hasBreadcrumb) { \"$($this.RegionID)_Separator_Breadcrumb\" } else { \"$($this.RegionID)_Separator_Simple\" }\r\n\r\n            # Fill with line char\r\n            # We need bounds for Fill.\r\n            $bounds = $engine.GetRegionBounds($sepRegion)\r\n            if ($bounds) {\r\n                # Determine char based on style\r\n                $char = $this.GetBoxChar('single_horizontal')\r\n                if ($this.BorderStyle -eq 'double') { $char = $this.GetBoxChar('double_horizontal') }\r\n\r\n                # Get background color for separator\r\n                $headerBg = $this.GetThemedBgInt('Background.Header', 1, 0)\r\n                $engine.Fill($bounds.X, $bounds.Y, $bounds.Width, 1, $char, $borderFg, $headerBg)\r\n            }\r\n        }\r\n    }\r\n\r\n    # === Pre-computation ===\r\n\r\n    [void] PrecomputeRenderData() {\r\n        # Pre-compute layout based on current size\r\n        # Called by base class when bounds change\r\n    }\r\n}\r\n\r\n# Classes exported automatically in PowerShell 5.1+\r\n# Classes exported automatically in PowerShell 5.1+"}, {"path": "module/Pmc.Strict/consoleui/widgets/PmcMenuBar.ps1", "content": "using namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# PmcMenuBar - Top-level navigation menu with dropdown support\r\n# Full keyboard navigation, hotkeys, and dropdown menus\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nMenu item within a dropdown menu\r\n\r\n.DESCRIPTION\r\nRepresents a single item in a dropdown menu with:\r\n- Display label\r\n- Hotkey character\r\n- Action scriptblock\r\n- Enabled/disabled state\r\n- Separator flag\r\n##CLOSEBRACKET##\r\nclass PmcMenuItem {\r\n    [string]$Label = \"\"\r\n    [char]$Hotkey = [char]0\r\n    [scriptblock]$Action = $null\r\n    [bool]$Enabled = $true\r\n    [bool]$IsSeparator = $false\r\n    [string]$Description = \"\"  # Optional hint text\r\n\r\n    PmcMenuItem([string]$label, [char]$hotkey, [scriptblock]$action) {\r\n        $this.Label = $label\r\n        $this.Hotkey = $hotkey\r\n        $this.Action = $action\r\n    }\r\n\r\n    # Constructor for separator\r\n    static [PmcMenuItem] Separator() {\r\n        $item = [PmcMenuItem]::new(\"\", [char]0, $null)\r\n        $item.IsSeparator = $true\r\n        return $item\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nTop-level menu containing dropdown items\r\n\r\n.DESCRIPTION\r\nRepresents a menu in the menu bar (e.g., \"File\", \"Edit\", \"View\")\r\n##CLOSEBRACKET##\r\nclass PmcMenu {\r\n    [string]$Title = \"\"\r\n    [char]$Hotkey = [char]0\r\n    [List[PmcMenuItem]]$Items\r\n\r\n    PmcMenu([string]$title, [char]$hotkey) {\r\n        $this.Title = $title\r\n        $this.Hotkey = $hotkey\r\n        $this.Items = [List[PmcMenuItem]]::new()\r\n    }\r\n\r\n    [PmcMenu] AddItem([string]$label, [char]$hotkey, [scriptblock]$action) {\r\n        $this.Items.Add([PmcMenuItem]::new($label, $hotkey, $action))\r\n        return $this\r\n    }\r\n\r\n    [PmcMenu] AddSeparator() {\r\n        $this.Items.Add([PmcMenuItem]::Separator())\r\n        return $this\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nMenu bar widget with dropdown menus\r\n\r\n.DESCRIPTION\r\nPmcMenuBar provides:\r\n- Top-level horizontal menu bar\r\n- Dropdown menus on activation\r\n- Full keyboard navigation (arrows, hotkeys)\r\n- Themed rendering\r\n- Event callbacks\r\n\r\n.EXAMPLE\r\n$menuBar = [PmcMenuBar]::new()\r\n$menuBar.AddMenu('File', 'F', @(\r\n    [PmcMenuItem]::new('New', 'N', { Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcMenuBar] New!\" })\r\n    [PmcMenuItem]::new('Open', 'O', { Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcMenuBar] Open!\" })\r\n    [PmcMenuItem]::Separator()\r\n    [PmcMenuItem]::new('Exit', 'X', { exit })\r\n))\r\n##CLOSEBRACKET##\r\nclass PmcMenuBar : PmcWidget {\r\n    # === Properties ===\r\n    [List[PmcMenu]]$Menus\r\n    [int]$SelectedMenuIndex = -1        # Which menu is selected (hover)\r\n    [int]$SelectedItemIndex = -1        # Which item in dropdown is selected\r\n    [bool]$IsActive = $false            # Menu bar has focus\r\n    [bool]$DropdownVisible = $false     # Dropdown is showing\r\n\r\n    # === Events ===\r\n    [scriptblock]$OnMenuItemSelected = $null\r\n\r\n    # === Cached Render Data ===\r\n    hidden [List[int]]$_menuXPositions = [List[int]]::new()  # X position of each menu\r\n    \r\n    # === Constructor ===\r\n    PmcMenuBar() : base(\"MenuBar\") {\r\n        $this.Menus = [List[PmcMenu]]::new()\r\n        $this.CanFocus = $true\r\n\r\n        # Default size (will be set by layout manager)\r\n        $this.Width = 80\r\n        $this.Height = 1\r\n    }\r\n\r\n    # === Menu Management ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Add a menu to the menu bar\r\n    ##CLOSEBRACKET##\r\n    [PmcMenuBar] AddMenu([string]$title, [char]$hotkey, [array]$items) {\r\n        $menu = [PmcMenu]::new($title, $hotkey)\r\n        foreach ($item in $items) {\r\n            $menu.Items.Add($item)\r\n        }\r\n        $this.Menus.Add($menu)\r\n        return $this\r\n    }\r\n\r\n    # === Navigation ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Activate the menu bar (show first menu or highlight bar)\r\n    ##CLOSEBRACKET##\r\n    [void] Activate() {\r\n        $this.IsActive = $true\r\n        if ($this.Menus.Count -gt 0) {\r\n            $this.SelectedMenuIndex = 0\r\n        }\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Deactivate the menu bar\r\n    ##CLOSEBRACKET##\r\n    [void] Deactivate() {\r\n        $this.IsActive = $false\r\n        $this.DropdownVisible = $false\r\n        $this.SelectedMenuIndex = -1\r\n        $this.SelectedItemIndex = -1\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Show dropdown for currently selected menu\r\n    ##CLOSEBRACKET##\r\n    [void] ShowDropdown() {\r\n        if ($this.SelectedMenuIndex -ge 0 -and $this.SelectedMenuIndex -lt $this.Menus.Count) {\r\n            $menu = $this.Menus[$this.SelectedMenuIndex]\r\n\r\n            # Don't show dropdown if menu has no items\r\n            if ($null -eq $menu.Items -or $menu.Items.Count -eq 0) {\r\n                return\r\n            }\r\n\r\n            $this.DropdownVisible = $true\r\n            $this.SelectedItemIndex = 0\r\n            # Skip separators\r\n            $this._SelectNextEnabledItem()\r\n            $this.Invalidate()\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Hide dropdown\r\n    ##CLOSEBRACKET##\r\n    [void] HideDropdown() {\r\n        $this.DropdownVisible = $false\r\n        $this.SelectedItemIndex = -1\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move selection to next menu\r\n    ##CLOSEBRACKET##\r\n    [void] SelectNextMenu() {\r\n        if ($this.Menus.Count -eq 0) { return }\r\n        $this.SelectedMenuIndex = ($this.SelectedMenuIndex + 1) % $this.Menus.Count\r\n        $this.SelectedItemIndex = -1\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move selection to previous menu\r\n    ##CLOSEBRACKET##\r\n    [void] SelectPreviousMenu() {\r\n        if ($this.Menus.Count -eq 0) { return }\r\n        $this.SelectedMenuIndex--\r\n        if ($this.SelectedMenuIndex -lt 0) {\r\n            $this.SelectedMenuIndex = $this.Menus.Count - 1\r\n        }\r\n        $this.SelectedItemIndex = -1\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move selection to next item in dropdown\r\n    ##CLOSEBRACKET##\r\n    [void] SelectNextItem() {\r\n        if (-not $this.DropdownVisible -or $this.SelectedMenuIndex -lt 0) { return }\r\n        $menu = $this.Menus[$this.SelectedMenuIndex]\r\n        if ($menu.Items.Count -eq 0) { return }\r\n\r\n        $this.SelectedItemIndex = ($this.SelectedItemIndex + 1) % $menu.Items.Count\r\n        $this._SelectNextEnabledItem()\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move selection to previous item in dropdown\r\n    ##CLOSEBRACKET##\r\n    [void] SelectPreviousItem() {\r\n        if (-not $this.DropdownVisible -or $this.SelectedMenuIndex -lt 0) { return }\r\n        $menu = $this.Menus[$this.SelectedMenuIndex]\r\n        if ($menu.Items.Count -eq 0) { return }\r\n\r\n        $this.SelectedItemIndex--\r\n        if ($this.SelectedItemIndex -lt 0) {\r\n            $this.SelectedItemIndex = $menu.Items.Count - 1\r\n        }\r\n        $this._SelectPreviousEnabledItem()\r\n        $this.Invalidate()\r\n    }\r\n\r\n    # Skip separators and disabled items\r\n    hidden [void] _SelectNextEnabledItem() {\r\n        if ($this.SelectedMenuIndex -lt 0) { return }\r\n        $menu = $this.Menus[$this.SelectedMenuIndex]\r\n        $attempts = 0\r\n        while ($attempts -lt $menu.Items.Count) {\r\n            $item = $menu.Items[$this.SelectedItemIndex]\r\n            if (-not $item.IsSeparator -and $item.Enabled) { break }\r\n            $this.SelectedItemIndex = ($this.SelectedItemIndex + 1) % $menu.Items.Count\r\n            $attempts++\r\n        }\r\n    }\r\n\r\n    hidden [void] _SelectPreviousEnabledItem() {\r\n        if ($this.SelectedMenuIndex -lt 0) { return }\r\n        $menu = $this.Menus[$this.SelectedMenuIndex]\r\n        $attempts = 0\r\n        while ($attempts -lt $menu.Items.Count) {\r\n            $item = $menu.Items[$this.SelectedItemIndex]\r\n            if (-not $item.IsSeparator -and $item.Enabled) { break }\r\n            $this.SelectedItemIndex--\r\n            if ($this.SelectedItemIndex -lt 0) {\r\n                $this.SelectedItemIndex = $menu.Items.Count - 1\r\n            }\r\n            $attempts++\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Execute currently selected menu item\r\n    ##CLOSEBRACKET##\r\n    [bool] ExecuteSelectedItem() {\r\n        if (-not $this.DropdownVisible -or $this.SelectedMenuIndex -lt 0 -or $this.SelectedItemIndex -lt 0) {\r\n            return $false\r\n        }\r\n\r\n        $menu = $this.Menus[$this.SelectedMenuIndex]\r\n        if ($this.SelectedItemIndex -ge $menu.Items.Count) {\r\n            return $false\r\n        }\r\n\r\n        $item = $menu.Items[$this.SelectedItemIndex]\r\n        if ($item.IsSeparator -or -not $item.Enabled) {\r\n            return $false\r\n        }\r\n\r\n        # Close dropdown BEFORE executing action\r\n        $this.HideDropdown()\r\n        $this.Deactivate()\r\n\r\n        # Execute action\r\n        if ($item.Action) {\r\n            try {\r\n                & $item.Action\r\n            } catch {\r\n                # Log error so menu action failures are visible (only if debug enabled)\r\n                if ((Test-Path variable:global:PmcDebug) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\r\n                    Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [MenuBar] Action failed for '$($item.Label)': $_\"\r\n                    Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [MenuBar] Stack: $($_.ScriptStackTrace)\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Fire event\r\n        if ($this.OnMenuItemSelected) {\r\n            & $this.OnMenuItemSelected $this $menu $item\r\n        }\r\n\r\n        return $true\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Main\", $this.X, $this.Y, $this.Width, $this.Height)\r\n    }\r\n\r\n    # === Rendering ===\r\n\r\n    [string] OnRender() {\r\n        # Legacy support if needed, but we prefer RenderToEngine\r\n        return \"\" \r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render directly to engine (new high-performance path)\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        $this.RegisterLayout($engine)\r\n\r\n        # Colors (Ints)\r\n        $bg = $this.GetThemedBgInt('Background.MenuBar', 1, 0)\r\n        $fg = $this.GetThemedInt('Foreground.Row')\r\n        $highlightBg = $this.GetThemedBgInt('Background.RowSelected', 1, 0)\r\n        $highlightFg = $this.GetThemedInt('Foreground.RowSelected')\r\n        \r\n        # Fallback removed - strict theme enforcement\r\n\r\n        # 1. Draw Main Bar Background\r\n        $engine.Fill($this.X, $this.Y, $this.Width, 1, ' ', $fg, $bg)\r\n        \r\n        # 2. Draw Menu Titles\r\n        $currentX = $this.X + 1\r\n        $this._menuXPositions.Clear()\r\n        \r\n        for ($i = 0; $i -lt $this.Menus.Count; $i++) {\r\n            $menu = $this.Menus[$i]\r\n            $this._menuXPositions.Add($currentX - $this.X)\r\n            \r\n            $text = \" $($menu.Title)\"\r\n            if ($menu.Hotkey -ne 0) { $text += \"($($menu.Hotkey))\" }\r\n            $text += \" \"\r\n            \r\n            $itemBg = $bg\r\n            $itemFg = $fg\r\n            if ($i -eq $this.SelectedMenuIndex -and $this.IsActive) {\r\n                $itemBg = $highlightBg\r\n                $itemFg = $highlightFg\r\n            }\r\n            \r\n            $engine.WriteAt($currentX, $this.Y, $text, $itemFg, $itemBg)\r\n            $currentX += $text.Length\r\n        }\r\n\r\n        # 3. Draw Dropdown (if visible)\r\n        if ($this.DropdownVisible -and $this.SelectedMenuIndex -ge 0) {\r\n             $this._RenderDropdownToEngine($engine)\r\n        }\r\n    }\r\n\r\n    hidden [void] _RenderDropdownToEngine([object]$engine) {\r\n        if ($this.SelectedMenuIndex -lt 0 -or $this.SelectedMenuIndex -ge $this.Menus.Count) { return }\r\n        $menu = $this.Menus[$this.SelectedMenuIndex]\r\n        if ($menu.Items.Count -eq 0) { return }\r\n\r\n        # Calculate width\r\n        $maxWidth = 10\r\n        foreach ($item in $menu.Items) {\r\n            if (-not $item.IsSeparator) {\r\n                $itemWidth = $item.Label.Length + 5\r\n                if ($item.Hotkey -eq 0) { $itemWidth = $item.Label.Length + 1 }\r\n                if ($itemWidth -gt $maxWidth) { $maxWidth = $itemWidth }\r\n            }\r\n        }\r\n        $width = $maxWidth + 2\r\n        $height = $menu.Items.Count + 2 # Borders\r\n        \r\n        $x = $this.X + $this._menuXPositions[$this.SelectedMenuIndex]\r\n        $y = $this.Y + 1\r\n        \r\n        # Define Popup Region\r\n        $regionId = \"$($this.RegionID)_Dropdown\"\r\n        $engine.DefineRegion($regionId, $x, $y, $width, $height, 100) # Z=100\r\n        \r\n        # Colors\r\n        $bg = $this.GetThemedBgInt('Background.MenuBar', 1, 0)\r\n        $fg = $this.GetThemedInt('Foreground.Row')\r\n        $borderFg = $this.GetThemedInt('Border.Widget')\r\n        $highlightBg = $this.GetThemedBgInt('Background.RowSelected', 1, 0)\r\n        $highlightFg = $this.GetThemedInt('Foreground.RowSelected')\r\n        $mutedFg = $this.GetThemedInt('Foreground.Muted')\r\n        \r\n        # Fallback removed - strict theme enforcement\r\n\r\n        # Draw Box in Region\r\n        # We can use Fill/WriteToRegion\r\n        $engine.Fill($x, $y, $width, $height, ' ', $fg, $bg)\r\n        \r\n        # Borders\r\n        $engine.WriteToRegion($regionId, $this.BuildBoxBorder($width, 'top', 'single'), $borderFg, $bg)\r\n        \r\n        # Items\r\n        for ($i = 0; $i -lt $menu.Items.Count; $i++) {\r\n            $item = $menu.Items[$i]\r\n            $itemY = $y + 1 + $i\r\n            \r\n            # Left/Right Border\r\n            $engine.WriteAt($x, $itemY, $this.GetBoxChar('single_vertical'), $borderFg, $bg)\r\n            $engine.WriteAt($x + $width - 1, $itemY, $this.GetBoxChar('single_vertical'), $borderFg, $bg)\r\n            \r\n            if ($item.IsSeparator) {\r\n                # Separator\r\n                $sep = $this.GetBoxChar('single_vertical') + ($this.GetBoxChar('single_horizontal') * ($width - 2)) + $this.GetBoxChar('single_vertical')\r\n                $engine.WriteAt($x, $itemY, $sep, $borderFg, $bg)\r\n            } else {\r\n                $isSelected = ($i -eq $this.SelectedItemIndex)\r\n                $iBg = $(if ($isSelected) { $highlightBg } else { $bg })\r\n                $iFg = $(if ($isSelected) { $highlightFg } else { $fg })\r\n                if (-not $item.Enabled) { $iFg = $mutedFg }\r\n                \r\n                $text = \" $($item.Label)\"\r\n                if ($item.Hotkey -ne 0) { $text += \" ($($item.Hotkey))\" }\r\n                \r\n                # Pad\r\n                $padLen = $width - 2 - $text.Length\r\n                if ($padLen -gt 0) { $text += (\" \" * $padLen) }\r\n                \r\n                $engine.WriteAt($x + 1, $itemY, $text, $iFg, $iBg)\r\n            }\r\n        }\r\n        \r\n        # Bottom Border\r\n        $engine.WriteAt($x, $y + $height - 1, $this.BuildBoxBorder($width, 'bottom', 'single'), $borderFg, $bg)\r\n    }\r\n\r\n    # === Input Handling ===\r\n\r\n    [bool] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo) {\r\n        $key = $keyInfo.Key\r\n        $char = $keyInfo.KeyChar\r\n\r\n\r\n        # }\r\n\r\n        # Handle Alt+hotkey even when not active (to activate menu)\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt) {\r\n            # }\r\n            if ($this._HandleMenuHotkey($char)) {\r\n                # Menu hotkey handler already set SelectedMenuIndex and showed dropdown\r\n                # Just ensure IsActive is set (don't call Activate() which resets index to 0)\r\n                $this.IsActive = $true\r\n                # }\r\n                return $true\r\n            }\r\n            # }\r\n        }\r\n\r\n        # Normal menu operations require IsActive\r\n        if (-not $this.IsActive) {\r\n            return $false\r\n        }\r\n\r\n        # Dropdown navigation\r\n        if ($this.DropdownVisible) {\r\n            switch ($key) {\r\n                'UpArrow' {\r\n                    $this.SelectPreviousItem()\r\n                    return $true\r\n                }\r\n                'DownArrow' {\r\n                    $this.SelectNextItem()\r\n                    return $true\r\n                }\r\n                'LeftArrow' {\r\n                    $this.HideDropdown()\r\n                    $this.SelectPreviousMenu()\r\n                    $this.ShowDropdown()\r\n                    return $true\r\n                }\r\n                'RightArrow' {\r\n                    $this.HideDropdown()\r\n                    $this.SelectNextMenu()\r\n                    $this.ShowDropdown()\r\n                    return $true\r\n                }\r\n                'Enter' {\r\n                    $this.ExecuteSelectedItem()\r\n                    # Always return true - we handled the key (even if no action executed)\r\n                    return $true\r\n                }\r\n                'Escape' {\r\n                    # }\r\n                    $this.HideDropdown()\r\n                    $this.Deactivate()\r\n                    return $true\r\n                }\r\n                default {\r\n                    # Check hotkeys\r\n                    if ($this._HandleItemHotkey($char)) {\r\n                        return $true\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            # Menu bar navigation\r\n            switch ($key) {\r\n                'LeftArrow' {\r\n                    $this.SelectPreviousMenu()\r\n                    return $true\r\n                }\r\n                'RightArrow' {\r\n                    $this.SelectNextMenu()\r\n                    return $true\r\n                }\r\n                'DownArrow' {\r\n                    $this.ShowDropdown()\r\n                    return $true\r\n                }\r\n                'Enter' {\r\n                    $this.ShowDropdown()\r\n                    return $true\r\n                }\r\n                'Escape' {\r\n                    # }\r\n                    $this.Deactivate()\r\n                    return $true\r\n                }\r\n                default {\r\n                    # Check menu hotkeys\r\n                    if ($this._HandleMenuHotkey($char)) {\r\n                        return $true\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    hidden [bool] _HandleMenuHotkey([char]$char) {\r\n        if ($char -eq [char]0) { return $false }\r\n        $charUpper = [char]::ToUpper($char)\r\n\r\n        for ($i = 0; $i -lt $this.Menus.Count; $i++) {\r\n            $menu = $this.Menus[$i]\r\n            if ([char]::ToUpper($menu.Hotkey) -eq $charUpper) {\r\n                $this.SelectedMenuIndex = $i\r\n                $this.ShowDropdown()\r\n                return $true\r\n            }\r\n        }\r\n        return $false\r\n    }\r\n\r\n    hidden [bool] _HandleItemHotkey([char]$char) {\r\n        if ($char -eq [char]0 -or $this.SelectedMenuIndex -lt 0) { return $false }\r\n        $charUpper = [char]::ToUpper($char)\r\n\r\n        $menu = $this.Menus[$this.SelectedMenuIndex]\r\n        for ($i = 0; $i -lt $menu.Items.Count; $i++) {\r\n            $item = $menu.Items[$i]\r\n            if (-not $item.IsSeparator -and $item.Enabled -and [char]::ToUpper($item.Hotkey) -eq $charUpper) {\r\n                $this.SelectedItemIndex = $i\r\n                return $this.ExecuteSelectedItem()\r\n            }\r\n        }\r\n        return $false\r\n    }\r\n}\r\n\r\n# Classes exported automatically in PowerShell 5.1+\r\n"}, {"path": "module/Pmc.Strict/consoleui/widgets/PmcPanel.ps1", "content": "using namespace System.Text\r\nusing namespace System.Collections.Generic\r\n\r\n# PmcPanel - Container widget with border and title\r\n# Provides grouped content areas with visual boundaries\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nPanel widget - container with border, title, and optional scrolling\r\n\r\n.DESCRIPTION\r\nPmcPanel provides:\r\n- Border with customizable style (single, double, heavy, rounded)\r\n- Optional title in border\r\n- Content area with automatic padding\r\n- Optional scroll support\r\n- Child widget container\r\n\r\n.EXAMPLE\r\n$panel = [PmcPanel]::new(\"Settings\")\r\n$panel.SetBorderStyle('rounded')\r\n$panel.SetPadding(2)\r\n##CLOSEBRACKET##\r\nclass PmcPanel : PmcWidget {\r\n    # === Properties ===\r\n    [string]$PanelTitle = \"\"\r\n    [string]$BorderStyle = 'single'  # 'single', 'double', 'heavy', 'rounded'\r\n    [int]$PaddingLeft = 1\r\n    [int]$PaddingTop = 1\r\n    [int]$PaddingRight = 1\r\n    [int]$PaddingBottom = 1\r\n    [bool]$ShowTitle = $true\r\n    [bool]$ShowBorder = $true\r\n\r\n    # Content\r\n    [string]$ContentText = \"\"        # Simple text content (alternative to children)\r\n    [string]$ContentAlign = 'left'   # 'left', 'center', 'right'\r\n\r\n    # === Constructor ===\r\n    PmcPanel() : base(\"Panel\") {\r\n        $this.Width = 40\r\n        $this.Height = 10\r\n    }\r\n\r\n    PmcPanel([string]$title) : base(\"Panel\") {\r\n        $this.PanelTitle = $title\r\n        $this.Width = 40\r\n        $this.Height = 10\r\n    }\r\n\r\n    PmcPanel([string]$title, [int]$width, [int]$height) : base(\"Panel\") {\r\n        $this.PanelTitle = $title\r\n        $this.Width = $width\r\n        $this.Height = $height\r\n    }\r\n\r\n    # === Configuration ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set border style\r\n\r\n    .PARAMETER style\r\n    Border style: 'single', 'double', 'heavy', 'rounded'\r\n    ##CLOSEBRACKET##\r\n    [void] SetBorderStyle([string]$style) {\r\n        $this.BorderStyle = $style\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set padding (all sides)\r\n\r\n    .PARAMETER padding\r\n    Padding in characters\r\n    ##CLOSEBRACKET##\r\n    [void] SetPadding([int]$padding) {\r\n        $this.PaddingLeft = $padding\r\n        $this.PaddingTop = $padding\r\n        $this.PaddingRight = $padding\r\n        $this.PaddingBottom = $padding\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set padding (individual sides)\r\n    ##CLOSEBRACKET##\r\n    [void] SetPadding([int]$left, [int]$top, [int]$right, [int]$bottom) {\r\n        $this.PaddingLeft = $left\r\n        $this.PaddingTop = $top\r\n        $this.PaddingRight = $right\r\n        $this.PaddingBottom = $bottom\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set simple text content\r\n\r\n    .PARAMETER text\r\n    Text to display in panel\r\n\r\n    .PARAMETER align\r\n    Alignment: 'left', 'center', 'right'\r\n    ##CLOSEBRACKET##\r\n    [void] SetContent([string]$text, [string]$align = 'left') {\r\n        $this.ContentText = $text\r\n        $this.ContentAlign = $align\r\n        $this.Invalidate()\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n        \r\n        $borderOffset = if ($this.ShowBorder) { 1 } else { 0 }\r\n        \r\n        $contentX = $this.X + $borderOffset + $this.PaddingLeft\r\n        $contentY = $this.Y + $borderOffset + $this.PaddingTop\r\n        $contentW = $this.Width - (2 * $borderOffset) - $this.PaddingLeft - $this.PaddingRight\r\n        $contentH = $this.Height - (2 * $borderOffset) - $this.PaddingTop - $this.PaddingBottom\r\n        \r\n        $engine.DefineRegion(\"$($this.RegionID)_Content\", $contentX, $contentY, $contentW, $contentH)\r\n        \r\n        if ($this.ShowTitle -and $this.PanelTitle) {\r\n            $engine.DefineRegion(\"$($this.RegionID)_Title\", $this.X + 2, $this.Y, $this.Width - 4, 1)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render directly to engine (new high-performance path)\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\n        # DEBUG: Conditional logging\n        if ($global:PmcTuiLogFile -and $global:PmcTuiLogLevel -ge 3) {\n            Add-Content -Path $global:PmcTuiLogFile -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [PmcPanel.RenderToEngine] CALLED X=$($this.X) Y=$($this.Y) W=$($this.Width) H=$($this.Height) ShowBorder=$($this.ShowBorder)\"\n        }\r\n        $this.RegisterLayout($engine)\r\n\r\n        # Colors (Ints) - Match UniversalList color methods for consistency\r\n        $borderColor = $this.GetThemedColorInt('Border.Widget')\r\n        $titleColor = $this.GetThemedColorInt('Foreground.Title')\r\n        $textColor = $this.GetThemedColorInt('Foreground.Row')\r\n        $bg = $this.GetThemedColorInt('Background.Row')\r\n        \r\n        # Draw Border\r\n        if ($this.ShowBorder) {\r\n            $engine.DrawBox($this.X, $this.Y, $this.Width, $this.Height, $borderColor, $bg, $this.BorderStyle)\r\n            \r\n            # Draw Title\r\n            if ($this.ShowTitle -and $this.PanelTitle) {\r\n                $titleText = \" $($this.PanelTitle) \"\r\n                # DrawBox draws lines. We overwrite with title.\r\n                # Use region logic or manual write.\r\n                # Title region defined at X+2.\r\n                $engine.WriteToRegion(\"$($this.RegionID)_Title\", $titleText, $titleColor, $bg)\r\n            }\r\n        }\r\n        \r\n        # Content Text\r\n        if ($this.ContentText) {\r\n            $regionId = \"$($this.RegionID)_Content\"\r\n            $bounds = $engine.GetRegionBounds($regionId)\r\n            \r\n            if ($bounds) {\r\n                # Simple text wrapping or direct write?\r\n                # ContentText might be multiline.\r\n                $lines = $this.ContentText -split \"`n\"\r\n                for ($i = 0; $i -lt $lines.Count; $i++) {\r\n                    if ($i -ge $bounds.Height) { break }\r\n                    \r\n                    $line = $lines[$i]\r\n                    # Alignment\r\n                    if ($this.ContentAlign -eq 'center') {\r\n                        $pad = [Math]::Max(0, [Math]::Floor(($bounds.Width - $line.Length) / 2))\r\n                        $line = (\" \" * $pad) + $line\r\n                    }\r\n                    elseif ($this.ContentAlign -eq 'right') {\r\n                        $pad = [Math]::Max(0, $bounds.Width - $line.Length)\r\n                        $line = (\" \" * $pad) + $line\r\n                    }\r\n                    \r\n                    $engine.WriteAt($bounds.X, $bounds.Y + $i, $line, $textColor, $bg)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    # === Rendering ===\r\n\r\n    [string] OnRender() {\r\n        # Legacy render stub\r\n        return \"\"\r\n    }\r\n\r\n\r\n\r\n    # === Helper Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get content area bounds (excluding border and padding)\r\n\r\n    .OUTPUTS\r\n    Hashtable with X, Y, Width, Height of usable content area\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetContentBounds() {\r\n        $borderOffset = $(if ($this.ShowBorder) { 1 } else { 0 })\r\n\r\n        return @{\r\n            X      = $this.X + $borderOffset + $this.PaddingLeft\r\n            Y      = $this.Y + $borderOffset + $this.PaddingTop\r\n            Width  = $this.Width - (2 * $borderOffset) - $this.PaddingLeft - $this.PaddingRight\r\n            Height = $this.Height - (2 * $borderOffset) - $this.PaddingTop - $this.PaddingBottom\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Create simple info panel\r\n\r\n    .PARAMETER title\r\n    Panel title\r\n\r\n    .PARAMETER content\r\n    Panel content text\r\n\r\n    .OUTPUTS\r\n    Configured PmcPanel\r\n    ##CLOSEBRACKET##\r\n    static [PmcPanel] CreateInfoPanel([string]$title, [string]$content) {\r\n        $panel = [PmcPanel]::new($title)\r\n        $panel.SetContent($content, 'left')\r\n        $panel.SetBorderStyle('single')\r\n        return $panel\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Create emphasized panel with double border\r\n\r\n    .PARAMETER title\r\n    Panel title\r\n\r\n    .OUTPUTS\r\n    Configured PmcPanel\r\n    ##CLOSEBRACKET##\r\n    static [PmcPanel] CreateEmphasisPanel([string]$title) {\r\n        $panel = [PmcPanel]::new($title)\r\n        $panel.SetBorderStyle('double')\r\n        return $panel\r\n    }\r\n}\r\n\r\n# Classes exported automatically in PowerShell 5.1+\r\n# Classes exported automatically in PowerShell 5.1+"}, {"path": "module/Pmc.Strict/consoleui/widgets/PmcStatusBar.ps1", "content": "using namespace System.Text\r\n\r\n# PmcStatusBar - Status information display at bottom of screen\r\n# Shows current status, mode, notifications, and system info\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n<#\r\n.SYNOPSIS\r\nStatus bar widget for bottom-of-screen status display\r\n\r\n.DESCRIPTION\r\nPmcStatusBar displays:\r\n- Left section: Primary status message\r\n- Center section: Mode or context\r\n- Right section: System info (time, notifications, etc.)\r\n\r\n.EXAMPLE\r\n$statusBar = [PmcStatusBar]::new()\r\n$statusBar.SetLeftText(\"15 tasks loaded\")\r\n$statusBar.SetCenterText(\"VIEW MODE\")\r\n$statusBar.SetRightText(\"10:30 AM\")\r\n##CLOSEBRACKET##\r\nclass PmcStatusBar : PmcWidget {\r\n    # === Properties ===\r\n    [string]$LeftText = \"\"\r\n    [string]$CenterText = \"\"\r\n    [string]$RightText = \"\"\r\n    [bool]$UseBackground = $true  # Fill with background color\r\n\r\n    # === Constructor ===\r\n    PmcStatusBar() : base(\"StatusBar\") {\r\n        $this.Height = 1\r\n        $this.Width = 80\r\n    }\r\n\r\n    # === Configuration ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set left section text\r\n\r\n    .PARAMETER text\r\n    Text to display on left side\r\n    ##CLOSEBRACKET##\r\n    [void] SetLeftText([string]$text) {\r\n        $this.LeftText = $text\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set center section text\r\n\r\n    .PARAMETER text\r\n    Text to display in center\r\n    ##CLOSEBRACKET##\r\n    [void] SetCenterText([string]$text) {\r\n        $this.CenterText = $text\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set right section text\r\n\r\n    .PARAMETER text\r\n    Text to display on right side\r\n    ##CLOSEBRACKET##\r\n    [void] SetRightText([string]$text) {\r\n        $this.RightText = $text\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set all three sections at once\r\n\r\n    .PARAMETER left\r\n    Left text\r\n\r\n    .PARAMETER center\r\n    Center text\r\n\r\n    .PARAMETER right\r\n    Right text\r\n    ##CLOSEBRACKET##\r\n    [void] SetStatus([string]$left, [string]$center, [string]$right) {\r\n        $this.LeftText = $left\r\n        $this.CenterText = $center\r\n        $this.RightText = $right\r\n        $this.Invalidate()\r\n    }\r\n\r\n    # === Rendering ===\r\n\r\n    [string] OnRender() {\r\n        $sb = [System.Text.StringBuilder]::new(256)\r\n\r\n        # Colors\r\n        $bgColor = $this.GetThemedBg('Background.MenuBar', 1, 0)\r\n        $fgColor = $this.GetThemedFg('Foreground.Row')\r\n        $mutedColor = $this.GetThemedFg('Foreground.Muted')\r\n        $reset = \"`e[0m\"\r\n\r\n        # Position\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y))\r\n\r\n        # Background\r\n        if ($this.UseBackground) {\r\n            $sb.Append($bgColor)\r\n            $sb.Append($fgColor)\r\n        }\r\n\r\n        # Calculate section widths\r\n        $leftWidth = [Math]::Floor($this.Width * 0.4)\r\n        $centerWidth = [Math]::Floor($this.Width * 0.2)\r\n        $rightWidth = $this.Width - $leftWidth - $centerWidth\r\n\r\n        # Left section\r\n        $leftDisplay = $this.PadText($this.LeftText, $leftWidth, 'left')\r\n        $sb.Append($leftDisplay)\r\n\r\n        # Center section\r\n        $centerDisplay = $this.PadText($this.CenterText, $centerWidth, 'center')\r\n        $sb.Append($mutedColor)\r\n        $sb.Append($centerDisplay)\r\n        $sb.Append($fgColor)\r\n\r\n        # Right section\r\n        $rightDisplay = $this.PadText($this.RightText, $rightWidth, 'right')\r\n        $sb.Append($rightDisplay)\r\n\r\n        $sb.Append($reset)\r\n\r\n        $result = $sb.ToString()\r\n\r\n        return $result\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n\r\n        $leftWidth = [Math]::Floor($this.Width * 0.4)\r\n        $centerWidth = [Math]::Floor($this.Width * 0.2)\r\n        $rightWidth = $this.Width - $leftWidth - $centerWidth\r\n\r\n        $engine.DefineRegion(\"$($this.RegionID)_Left\", $this.X, $this.Y, $leftWidth, 1)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Center\", $this.X + $leftWidth, $this.Y, $centerWidth, 1)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Right\", $this.X + $leftWidth + $centerWidth, $this.Y, $rightWidth, 1)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render directly to engine (new high-performance path)\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        $this.RegisterLayout($engine)\r\n\r\n        $bg = $this.GetThemedBgInt('Background.MenuBar', 1, 0)\r\n        $fg = $this.GetThemedInt('Foreground.Row')\r\n        $muted = $this.GetThemedInt('Foreground.Muted')\r\n        \r\n        # FAIL FAST\r\n        # if ($bg -eq -1) { $bg = [HybridRenderEngine]::_PackRGB(30, 30, 30) } # Dark grey fallback\r\n\r\n        # Fill background\r\n        $engine.Fill($this.X, $this.Y, $this.Width, 1, ' ', $fg, $bg)\r\n\r\n        # Left section\r\n        $engine.WriteToRegion(\"$($this.RegionID)_Left\", $this.LeftText, $fg, $bg)\r\n\r\n        # Center section (Centered)\r\n        $boundsC = $engine.GetRegionBounds(\"$($this.RegionID)_Center\")\r\n        if ($boundsC) {\r\n            $pad = [Math]::Max(0, [Math]::Floor(($boundsC.Width - $this.CenterText.Length) / 2))\r\n            $cText = (\" \" * $pad) + $this.CenterText\r\n            $engine.WriteToRegion(\"$($this.RegionID)_Center\", $cText, $muted, $bg)\r\n        }\r\n\r\n        # Right section (Right-aligned)\r\n        $boundsR = $engine.GetRegionBounds(\"$($this.RegionID)_Right\")\r\n        if ($boundsR) {\r\n            $pad = [Math]::Max(0, $boundsR.Width - $this.RightText.Length)\r\n            $rText = (\" \" * $pad) + $this.RightText\r\n            $engine.WriteToRegion(\"$($this.RegionID)_Right\", $rText, $fg, $bg)\r\n        }\r\n    }\r\n\r\n    # === Helper Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set status with timestamp\r\n\r\n    .PARAMETER message\r\n    Status message\r\n\r\n    .DESCRIPTION\r\n    Sets left text to message and right text to current time\r\n    ##CLOSEBRACKET##\r\n    [void] SetStatusWithTime([string]$message) {\r\n        $this.LeftText = $message\r\n        $this.RightText = (Get-Date).ToString(\"HH:mm:ss\")\r\n        $this.Invalidate()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Show loading status\r\n\r\n    .PARAMETER message\r\n    Loading message\r\n    ##CLOSEBRACKET##\r\n    [void] ShowLoading([string]$message) {\r\n        $this.SetLeftText(\"⏳ $message\")\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Show success status\r\n\r\n    .PARAMETER message\r\n    Success message\r\n    ##CLOSEBRACKET##\r\n    [void] ShowSuccess([string]$message) {\r\n        $this.SetLeftText(\"[OK] $message\")\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Show error status\r\n\r\n    .PARAMETER message\r\n    Error message\r\n    ##CLOSEBRACKET##\r\n    [void] ShowError([string]$message) {\r\n        $this.SetLeftText(\"[ERROR] $message\")\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Clear status bar\r\n\r\n    .DESCRIPTION\r\n    Clears all text sections\r\n    ##CLOSEBRACKET##\r\n    [void] Clear() {\r\n        $this.LeftText = \"\"\r\n        $this.CenterText = \"\"\r\n        $this.RightText = \"\"\r\n        $this.Invalidate()\r\n    }\r\n}\r\n\r\n# Classes exported automatically in PowerShell 5.1+\r\n# Classes exported automatically in PowerShell 5.1+"}, {"path": "module/Pmc.Strict/consoleui/widgets/PmcWidget.ps1", "content": "# PmcWidget - Base class for all PMC widgets\n# Extends SpeedTUI Component with PMC-specific theme and layout integration\n\nusing namespace System.Collections.Generic\nusing namespace System.Text\n\nSet-StrictMode -Version Latest\n\n# SpeedTUI framework must be loaded before this file\n# (loaded by PmcApplication.ps1 or Start-PmcTUI.ps1)\n# This check ensures Component class is available\nif (-not ([System.Management.Automation.PSTypeName]'Component').Type) {\n    throw \"SpeedTUI Component class not found. Ensure SpeedTUILoader.ps1 is loaded before PmcWidget.ps1\"\n}\n\n# PmcThemeEngine must be loaded before this file\n# (loaded by SpeedTUILoader.ps1)\nif (-not ([System.Management.Automation.PSTypeName]'PmcThemeEngine').Type) {\n    throw \"PmcThemeEngine class not found. Ensure PmcThemeEngine.ps1 is loaded before PmcWidget.ps1\"\n}\n\n# Ensure ZIndex is loaded (needed by most widgets)\nif (-not ([System.Management.Automation.PSTypeName]'ZIndex').Type) {\n    $zIndexPath = Join-Path $PSScriptRoot '../ZIndex.ps1'\n    if (Test-Path $zIndexPath) {\n        . $zIndexPath\n    }\n}\n\n<#\n.SYNOPSIS\nBase class for all PMC widgets extending SpeedTUI Component\n\n.DESCRIPTION\nPmcWidget provides the foundation for all PMC UI components:\n- Integration with PMC's theme system (single hex → full palette derivation)\n- Layout constraint support (named regions, percentage-based positioning)\n- Box drawing with full Unicode character set\n- Performance optimizations (string caching, pre-computation)\n- Unified event handling\n- State management hooks\n\n.EXAMPLE\n# Example: Custom widget implementation\n# class MyCustomWidget : PmcWidget {\n#     [void] RenderToEngine([object]$engine) {\n#         $this.DrawBox($this.X, $this.Y, 20, 5, $this.GetThemedInt('Border'), $this.GetThemedBgInt('Background', 20, 0))\n#     }\n# }\n##CLOSEBRACKET##\nclass PmcWidget : Component {\n    # === PMC-Specific Properties ===\n    [string]$Name = \"\"                    # Widget name for debugging\n    [bool]$Visible = $true                # Widget visibility (default: true)\n    [hashtable]$LayoutConstraints = @{}   # Named region constraints\n    [string]$RegionID = \"\"                # Engine Layout Region ID\n\n    # === Theme Integration ===\n    hidden [hashtable]$_pmcTheme = $null        # Cached PMC theme\n    hidden [hashtable]$_pmcStyleTokens = $null  # Cached style tokens\n    hidden [bool]$_themeInitialized = $false\n\n    # === Box Drawing Characters ===\n    hidden [hashtable]$_boxChars = @{\n        # Single line\n        'single_horizontal'   = '─'\n        'single_vertical'     = '│'\n        'single_topleft'      = '┌'\n        'single_topright'     = '┐'\n        'single_bottomleft'   = '└'\n        'single_bottomright'  = '┘'\n        'single_cross'        = '┼'\n        'single_t_down'       = '┬'\n        'single_t_up'         = '┴'\n        'single_t_right'      = '├'\n        'single_t_left'       = '┤'\n\n        # Double line\n        'double_horizontal'   = '═'\n        'double_vertical'     = '║'\n        'double_topleft'      = '╔'\n        'double_topright'     = '╗'\n        'double_bottomleft'   = '╚'\n        'double_bottomright'  = '╝'\n        'double_cross'        = '╬'\n        'double_t_down'       = '╦'\n        'double_t_up'         = '╩'\n        'double_t_right'      = '╠'\n        'double_t_left'       = '╣'\n\n        # Heavy line\n        'heavy_horizontal'    = '━'\n        'heavy_vertical'      = '┃'\n        'heavy_topleft'       = '┏'\n        'heavy_topright'      = '┓'\n        'heavy_bottomleft'    = '┗'\n        'heavy_bottomright'   = '┛'\n\n        # Rounded\n        'rounded_topleft'     = '╭'\n        'rounded_topright'    = '╮'\n        'rounded_bottomleft'  = '╰'\n        'rounded_bottomright' = '╯'\n    }\n\n    # === Constructor ===\n    PmcWidget() : base() {\n        $this.Name = $this.GetType().Name\n        $this._EnsureThemeInitialized()\n    }\n\n    PmcWidget([string]$name) : base() {\n        $this.Name = $name\n        $this._EnsureThemeInitialized()\n    }\n\n    # === Layout System ===\n\n    <#\n    .SYNOPSIS\n    Register layout regions with the engine.\n    Override this to define complex grids or sub-regions.\n    ##CLOSEBRACKET##\n    [void] RegisterLayout([object]$engine) {\n        if ([string]::IsNullOrEmpty($this.RegionID)) {\n            $this.RegionID = $this.Name + \"_\" + [Guid]::NewGuid().ToString().Substring(0, 8)\n        }\n        \n        # Define base region for this widget\n        # Z-Index default 0, parent relative if supported later\n        if ($engine.PSObject.Methods['DefineRegion']) {\n            $engine.DefineRegion($this.RegionID, $this.X, $this.Y, $this.Width, $this.Height)\n        }\n    }\n\n    # === Rendering ===\n\n    <#\n    .SYNOPSIS\n    Ensure PMC theme system is loaded\n    ##CLOSEBRACKET##\n    hidden [void] _EnsureThemeInitialized() {\n        if ($this._themeInitialized) { return }\n\n        try {\n            # Get PMC theme state\n            $displayState = Get-PmcState -Section 'Display'\n            if ($displayState) {\n                $this._pmcTheme = $displayState.Theme\n                $this._pmcStyleTokens = $displayState.Styles\n            }\n\n            # Fallback to defaults if state not available\n            # FAIL FAST\n            # if (-not $this._pmcTheme) {\n            #    $this._pmcTheme = @{\n            #        PaletteName = 'default'\n            #        Hex = '#33aaff'\n            #        TrueColor = $true\n            #    }\n            # }\n\n            # FAIL FAST\n            # if (-not $this._pmcStyleTokens) {\n            #    $this._pmcStyleTokens = @{\n            #        Title = @{ Fg = '#33aaff' }\n            #        Body = @{ Fg = '#CCCCCC' }\n            #        Border = @{ Fg = '#666666' }\n            #    }\n            # }\n\n            $this._themeInitialized = $true\n        }\n        catch {\n            # FAIL FAST\n            throw\n            \n            # Fallback - widget still functional with defaults\n            # if (Get-Command Write-PmcTuiLog -ErrorAction SilentlyContinue) {\n            #     Write-PmcTuiLog \"Theme initialization failed: $($_.Exception.Message)\" \"ERROR\"\n            #     Write-PmcTuiLog \"Stack: $($_.ScriptStackTrace)\"\n            # }\n            # $this._themeInitialized = $true\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Get color for a specific role from PMC theme system\n\n    .PARAMETER role\n    Color role: Primary, Border, Text, Muted, Error, Warning, Success, Bright, Header, etc.\n\n    .OUTPUTS\n    String - background ANSI escape sequence\n\n    .NOTES\n    NEW THEME API - Replaces GetThemedAnsi()\n    Delegates to PmcThemeEngine singleton for all color resolution\n    Supports both solid colors and gradients automatically\n\n    Property name format: \"Background.Field\", \"Background.FieldFocused\", etc.\n    For solid colors: width/charIndex ignored, same ANSI for all positions\n    For gradients: returns interpolated ANSI for specific character position\n    ##CLOSEBRACKET##\n    [string] GetThemedBg([string]$propertyName, [int]$width, [int]$charIndex) {\n        $engine = [PmcThemeEngine]::GetInstance()\n        $result = $engine.GetBackgroundAnsi($propertyName, $width, $charIndex)\n        # CRITICAL DEBUG: Log what theme engine returns\n        return $result\n    }\n\n    <#\n    .SYNOPSIS\n    Get foreground ANSI color sequence from theme engine\n\n    .PARAMETER propertyName\n    Theme property name (e.g., \"Foreground.Field\", \"Foreground.FieldFocused\")\n\n    .OUTPUTS\n    String - foreground ANSI escape sequence\n\n    .NOTES\n    NEW THEME API - Replaces GetThemedAnsi()\n    Foregrounds are typically solid colors\n    ##CLOSEBRACKET##\n    [string] GetThemedFg([string]$propertyName) {\n        $engine = [PmcThemeEngine]::GetInstance()\n        $result = $engine.GetForegroundAnsi($propertyName)\n        # CRITICAL DEBUG: Log what theme engine returns\n        return $result\n    }\n\n    <#\n    .SYNOPSIS\n    Get integer color value for HybridRenderEngine\n    ##CLOSEBRACKET##\n    [int] GetThemedColorInt([string]$propertyName) {\n        $engine = [PmcThemeEngine]::GetInstance()\n        return $engine.GetThemeColorInt($propertyName)\n    }\n\n    <#\n    .SYNOPSIS\n    Get packed RGB integer for a specific role (Hybrid Engine optimized)\n\n    .PARAMETER role\n    Color role or property name\n\n    .PARAMETER background\n    If true, gets background color (supports gradient/position if index provided)\n\n    .OUTPUTS\n    Int - Packed RGB integer or -1\n    ##CLOSEBRACKET##\n    [int] GetThemedInt([string]$role) {\n        $engine = [PmcThemeEngine]::GetInstance()\n        return $engine.GetForegroundInt($role)\n    }\n\n    [int] GetThemedBgInt([string]$role, [int]$width, [int]$charIndex) {\n        $engine = [PmcThemeEngine]::GetInstance()\n        return $engine.GetBackgroundInt($role, $width, $charIndex)\n    }\n\n    <#\n    .SYNOPSIS\n    Get gradient info for a property (returns null if solid)\n    ##CLOSEBRACKET##\n    [object] GetGradientInfo([string]$propertyName) {\n        $engine = [PmcThemeEngine]::GetInstance()\n        return $engine.GetGradientInfo($propertyName)\n    }\n\n    <#\n    .SYNOPSIS\n    Write themed text that automatically uses gradient if theme defines it\n\n    .PARAMETER renderEngine\n    The render engine (HybridRenderEngine)\n\n    .PARAMETER x\n    X coordinate\n\n    .PARAMETER y\n    Y coordinate\n\n    .PARAMETER text\n    Text to render\n\n    .PARAMETER fgProp\n    Foreground theme property (e.g., 'Foreground.Row')\n\n    .PARAMETER bgProp\n    Background theme property (e.g., 'Background.Row')\n    ##CLOSEBRACKET##\n    [void] WriteThemedAt([object]$renderEngine, [int]$x, [int]$y, [string]$text, [string]$fgProp, [string]$bgProp) {\n        $themeEngine = [PmcThemeEngine]::GetInstance()\n        \n        # Check if foreground is gradient\n        $gradientInfo = $themeEngine.GetGradientInfo($fgProp)\n        \n        # DEBUG: Log to file\n        # Add-Content -Path \"/tmp/pmc-gradient-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] WriteThemedAt: fgProp=$fgProp gradientInfo=$(if($gradientInfo){'GRADIENT'}else{'null'})\"\n        \n        # Get background color (always solid for now)\n        $bg = $themeEngine.GetThemeColorInt($bgProp)\n        \n        if ($gradientInfo) {\n            # Use gradient overload\n            # Add-Content -Path \"/tmp/pmc-gradient-debug.log\" -Value \"  -> GRADIENT WriteAt: Start=$($gradientInfo.Start) End=$($gradientInfo.End)\"\n            $renderEngine.WriteAt($x, $y, $text, $gradientInfo.Start, $gradientInfo.End, $bg)\n        }\n        else {\n            # Use solid color\n            $fg = $themeEngine.GetThemeColorInt($fgProp)\n            $renderEngine.WriteAt($x, $y, $text, $fg, $bg)\n        }\n    }\n\n    <#\n    .SYNOPSIS\n    Write themed text to a specific region, automatically handling gradients\n    \n    .PARAMETER renderEngine\n    The render engine (HybridRenderEngine)\n    \n    .PARAMETER regionId\n    Target region ID\n    \n    .PARAMETER text\n    Text to render\n    \n    .PARAMETER fgProp\n    Foreground theme property\n    \n    .PARAMETER bgProp\n    Background theme property\n    ##CLOSEBRACKET##\n    [void] WriteThemedToRegion([object]$renderEngine, [string]$regionId, [string]$text, [string]$fgProp, [string]$bgProp) {\n        $themeEngine = [PmcThemeEngine]::GetInstance()\n        \n        # Check if foreground is gradient\n        $gradientInfo = $themeEngine.GetGradientInfo($fgProp)\n        \n        # Get background color (always solid for now)\n        $bg = $themeEngine.GetThemeColorInt($bgProp)\n        \n        if ($gradientInfo) {\n            # Use gradient overload\n            $renderEngine.WriteToRegion($regionId, $text, $gradientInfo.Start, $gradientInfo.End, $bg)\n        }\n        else {\n            # Use solid color\n            $fg = $themeEngine.GetThemeColorInt($fgProp)\n            $renderEngine.WriteToRegion($regionId, $text, $fg, $bg)\n        }\n    }\n\n\n    # === Box Drawing Methods ===\n\n    <#\n    .SYNOPSIS\n    Get box-drawing character by name\n\n    .PARAMETER charName\n    Character name (e.g., 'single_horizontal', 'double_topleft', 'rounded_topleft')\n\n    .OUTPUTS\n    Unicode box-drawing character\n    ##CLOSEBRACKET##\n    [string] GetBoxChar([string]$charName) {\n        if ($this._boxChars.ContainsKey($charName)) {\n            return $this._boxChars[$charName]\n        }\n        return ''\n    }\n\n    <#\n    .SYNOPSIS\n    Build a horizontal line with specified style\n\n    .PARAMETER width\n    Width in characters\n\n    .PARAMETER style\n    Line style: 'single' (default), 'double', 'heavy'\n\n    .OUTPUTS\n    String containing repeated horizontal line character\n    ##CLOSEBRACKET##\n    [string] BuildHorizontalLine([int]$width, [string]$style = 'single') {\n        $char = $this.GetBoxChar(\"${style}_horizontal\")\n        if ([string]::IsNullOrEmpty($char)) {\n            $char = '─'\n        }\n        return $char * $width\n    }\n\n    <#\n    .SYNOPSIS\n    Build a box border string (top, middle, or bottom line)\n\n    .PARAMETER width\n    Width in characters (total, including corners)\n\n    .PARAMETER position\n    'top', 'middle', 'bottom'\n\n    .PARAMETER style\n    Border style: 'single', 'double', 'heavy', 'rounded'\n\n    .OUTPUTS\n    String containing full border line with corners\n\n    .EXAMPLE\n    $topLine = $this.BuildBoxBorder(40, 'top', 'single')      # \"┌──────────────────────────────────────┐\"\n    $bottomLine = $this.BuildBoxBorder(40, 'bottom', 'rounded')  # \"╰──────────────────────────────────────╯\"\n    ##CLOSEBRACKET##\n    [string] BuildBoxBorder([int]$width, [string]$position, [string]$style = 'single') {\n        if ($width -lt 2) { return '' }\n\n        $leftChar = ''\n        $rightChar = ''\n        $horizChar = $this.GetBoxChar(\"${style}_horizontal\")\n\n        # Handle rounded style (special case - uses single for horizontal)\n        if ($style -eq 'rounded') {\n            $horizChar = $this.GetBoxChar('single_horizontal')\n            switch ($position) {\n                'top' {\n                    $leftChar = $this.GetBoxChar('rounded_topleft')\n                    $rightChar = $this.GetBoxChar('rounded_topright')\n                }\n                'bottom' {\n                    $leftChar = $this.GetBoxChar('rounded_bottomleft')\n                    $rightChar = $this.GetBoxChar('rounded_bottomright')\n                }\n                default {\n                    $leftChar = $this.GetBoxChar('single_vertical')\n                    $rightChar = $this.GetBoxChar('single_vertical')\n                }\n            }\n        }\n        else {\n            switch ($position) {\n                'top' {\n                    $leftChar = $this.GetBoxChar(\"${style}_topleft\")\n                    $rightChar = $this.GetBoxChar(\"${style}_topright\")\n                }\n                'bottom' {\n                    $leftChar = $this.GetBoxChar(\"${style}_bottomleft\")\n                    $rightChar = $this.GetBoxChar(\"${style}_bottomright\")\n                }\n                default {\n                    $leftChar = $this.GetBoxChar(\"${style}_vertical\")\n                    $rightChar = $this.GetBoxChar(\"${style}_vertical\")\n                }\n            }\n        }\n\n        $innerWidth = $width - 2\n        return $leftChar + ($horizChar * $innerWidth) + $rightChar\n    }\n\n    # === Layout Constraint Methods ===\n\n    <#\n    .SYNOPSIS\n    Apply layout constraints to calculate actual position and size\n\n    .PARAMETER termWidth\n    Terminal width in characters\n\n    .PARAMETER termHeight\n    Terminal height in characters\n\n    .DESCRIPTION\n    Supports percentage-based positioning and sizing:\n    - X/Y: Can be integers or strings like \"10%\" or \"CENTER\"\n    - Width/Height: Can be integers or strings like \"50%\" or \"FILL\"\n    ##CLOSEBRACKET##\n    [void] ApplyLayoutConstraints([int]$termWidth, [int]$termHeight) {\n        if (-not $this.LayoutConstraints -or $this.LayoutConstraints.Count -eq 0) {\n            return\n        }\n\n        $newX = $this.X\n        $newY = $this.Y\n        $newWidth = $this.Width\n        $newHeight = $this.Height\n\n        # Process X constraint\n        if ($this.LayoutConstraints.ContainsKey('X')) {\n            $xConstraint = $this.LayoutConstraints['X']\n            if ($xConstraint -is [string]) {\n                if ($xConstraint -match '^(\\d+)%$') {\n                    $pct = [int]$Matches[1]\n                    $newX = [Math]::Floor($termWidth * $pct / 100.0)\n                }\n                elseif ($xConstraint -eq 'CENTER') {\n                    $newX = [Math]::Floor(($termWidth - $newWidth) / 2.0)\n                }\n            }\n            else {\n                $newX = [int]$xConstraint\n            }\n        }\n\n        # Process Y constraint\n        if ($this.LayoutConstraints.ContainsKey('Y')) {\n            $yConstraint = $this.LayoutConstraints['Y']\n            if ($yConstraint -is [string]) {\n                if ($yConstraint -match '^(\\d+)%$') {\n                    $pct = [int]$Matches[1]\n                    $newY = [Math]::Floor($termHeight * $pct / 100.0)\n                }\n                elseif ($yConstraint -match '^BOTTOM-(\\d+)$') {\n                    $offset = [int]$Matches[1]\n                    $newY = $termHeight - $offset\n                }\n                elseif ($yConstraint -eq 'BOTTOM') {\n                    $newY = $termHeight - 1\n                }\n            }\n            else {\n                $newY = [int]$yConstraint\n            }\n        }\n\n        # Process Width constraint\n        if ($this.LayoutConstraints.ContainsKey('Width')) {\n            $widthConstraint = $this.LayoutConstraints['Width']\n            if ($widthConstraint -is [string]) {\n                if ($widthConstraint -match '^(\\d+)%$') {\n                    $pct = [int]$Matches[1]\n                    $newWidth = [Math]::Floor($termWidth * $pct / 100.0)\n                }\n                elseif ($widthConstraint -eq 'FILL') {\n                    $newWidth = $termWidth - $newX\n                }\n            }\n            else {\n                $newWidth = [int]$widthConstraint\n            }\n        }\n\n        # Process Height constraint\n        if ($this.LayoutConstraints.ContainsKey('Height')) {\n            $heightConstraint = $this.LayoutConstraints['Height']\n            if ($heightConstraint -is [string]) {\n                if ($heightConstraint -match '^(\\d+)%$') {\n                    $pct = [int]$Matches[1]\n                    $newHeight = [Math]::Floor($termHeight * $pct / 100.0)\n                }\n                elseif ($heightConstraint -eq 'FILL') {\n                    $newHeight = $termHeight - $newY\n                }\n            }\n            else {\n                $newHeight = [int]$heightConstraint\n            }\n        }\n\n        # Apply calculated bounds (uses SpeedTUI's methods)\n        $this.SetPosition($newX, $newY)\n        $this.SetSize($newWidth, $newHeight)\n    }\n\n    # === Terminal Resize Handling ===\n\n    <#\n    .SYNOPSIS\n    Handle terminal resize events\n\n    .DESCRIPTION\n    Override from Component to add layout constraint recalculation\n    ##CLOSEBRACKET##\n    [void] OnTerminalResize([int]$newWidth, [int]$newHeight) {\n        # Recalculate constraints\n        $this.ApplyLayoutConstraints($newWidth, $newHeight)\n\n        # Call base implementation (handles children, invalidation)\n        ([Component]$this).OnTerminalResize($newWidth, $newHeight)\n    }\n\n    # === Utility Methods ===\n\n    <#\n    .SYNOPSIS\n    Build a VT100 cursor position sequence\n\n    .PARAMETER x\n    X coordinate (column, 0-based)\n\n    .PARAMETER y\n    Y coordinate (row, 0-based)\n\n    .OUTPUTS\n    ANSI escape sequence to move cursor\n    ##CLOSEBRACKET##\n    [string] BuildMoveTo([int]$x, [int]$y) {\n        # VT100 uses 1-based coordinates\n        $col = $x + 1\n        $row = $y + 1\n        return \"`e[${row};${col}H\"\n    }\n\n    <#\n    .SYNOPSIS\n    Get cached spaces string (performance optimization)\n\n    .PARAMETER count\n    Number of spaces\n\n    .OUTPUTS\n    String of spaces\n    ##CLOSEBRACKET##\n    [string] GetSpaces([int]$count) {\n        if ($count -le 0) { return '' }\n        return (\" \" * $count)\n    }\n\n    <#\n    .SYNOPSIS\n    Truncate text to fit width with ellipsis\n\n    .PARAMETER text\n    Text to truncate\n\n    .PARAMETER maxWidth\n    Maximum width\n\n    .OUTPUTS\n    Truncated text with ellipsis if needed\n    ##CLOSEBRACKET##\n    [string] TruncateText([string]$text, [int]$maxWidth) {\n        if ([string]::IsNullOrEmpty($text)) { return '' }\n\n        # Use visible length for truncation decision\n        $visibleLen = $this.GetVisibleLength($text)\n        if ($visibleLen -le $maxWidth) { return $text }\n        if ($maxWidth -le 1) { return '…' }\n\n        # Truncation with ANSI codes is complex - strip codes, truncate, return\n        # (We lose color formatting, but that's acceptable for truncated text)\n        $stripped = $text -replace '\\e\\[[0-9;]*m', ''\n        return $stripped.Substring(0, $maxWidth - 1) + '…'\n    }\n\n    <#\n    .SYNOPSIS\n    Get visible length of text (excluding ANSI escape codes)\n\n    .PARAMETER text\n    Text to measure\n\n    .OUTPUTS\n    Visible character count\n    ##CLOSEBRACKET##\n    [int] GetVisibleLength([string]$text) {\n        if ([string]::IsNullOrEmpty($text)) { return 0 }\n        # Remove ANSI escape sequences: \\e[...m or \\e[..;..m etc.\n        $stripped = $text -replace '\\e\\[[0-9;]*m', ''\n        return $stripped.Length\n    }\n\n    <#\n    .SYNOPSIS\n    Pad text to specified width\n\n    .PARAMETER text\n    Text to pad (may contain ANSI escape codes)\n\n    .PARAMETER width\n    Target width in visible characters\n\n    .PARAMETER align\n    Alignment: 'left' (default), 'center', 'right'\n\n    .OUTPUTS\n    Padded text\n    ##CLOSEBRACKET##\n    [string] PadText([string]$text, [int]$width, [string]$align = 'left') {\n        if ([string]::IsNullOrEmpty($text)) { return (\" \" * $width) }\n\n        # Use visible length instead of raw .Length to account for ANSI codes\n        $visibleLen = $this.GetVisibleLength($text)\n        if ($text.Length -lt 50) {\n            # Write-PmcTuiLog \"PadText: text='$text' rawLen=$($text.Length) visibleLen=$visibleLen width=$width align=$align\"\n        }\n\n        if ($visibleLen -ge $width) {\n            # Text is already wide enough - truncate if needed\n            # For now, just return as-is (truncation is complex with ANSI codes)\n            return $text\n        }\n\n        $padding = $width - $visibleLen\n        $result = switch ($align) {\n            'center' {\n                $leftPad = [Math]::Floor($padding / 2.0)\n                $rightPad = $padding - $leftPad\n                (\" \" * $leftPad) + $text + (\" \" * $rightPad)\n            }\n            'right' { (\" \" * $padding) + $text }\n            default { $text + (\" \" * $padding) }\n        }\n        return $result\n    }\n\n    <#\n    .SYNOPSIS\n    L-POL-1: Truncate help text to fit narrow terminals\n\n    .PARAMETER text\n    Help text to truncate\n\n    .PARAMETER maxWidth\n    Maximum width (defaults to terminal width - 10)\n\n    .OUTPUTS\n    Truncated string with ellipsis if needed\n    ##CLOSEBRACKET##\n    [string] TruncateHelpText([string]$text, [int]$maxWidth = -1) {\n        if ($maxWidth -lt 0) {\n            # L-POL-1: Use centralized terminal service (cached, optimized)\n            $termWidth = [Console]::WindowWidth\n            $maxWidth = $termWidth - 10\n        }\n\n        if ($text.Length -le $maxWidth) {\n            return $text\n        }\n\n        # Truncate with ellipsis\n        return $text.Substring(0, $maxWidth - 3) + \"...\"\n    }\n}\n\n\n# Classes and functions are exported automatically in PowerShell 5.1+\n"}, {"path": "module/Pmc.Strict/consoleui/widgets/ProjectPicker.ps1", "content": "using namespace System\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# ProjectPicker.ps1 - Project selection widget with fuzzy search and inline create\r\n#\r\n# Usage:\r\n#   $picker = [ProjectPicker]::new()\r\n#   $picker.SetPosition(10, 5)\r\n#   $picker.SetSize(35, 12)\r\n#   $picker.OnProjectSelected = { param($project) Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [ProjectPicker] Selected: $project\" }\r\n#\r\n#   # Render\r\n#   $picker.RenderToEngine($engine)\r\n#\r\n#   # Handle input\r\n#   $key = [Console]::ReadKey($true)\r\n#   $handled = $picker.HandleInput($key)\r\n#\r\n#   # Get result\r\n#   if ($picker.IsConfirmed) {\r\n#       $selected = $picker.GetSelectedProject()\r\n#   }\r\n\r\nSet-StrictMode -Off\r\n\r\n# Load PmcWidget base class if not already loaded\r\nif (-not ([System.Management.Automation.PSTypeName]'PmcWidget').Type) {\r\n    . \"$PSScriptRoot/PmcWidget.ps1\"\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nProject selection widget with fuzzy search and inline project creation\r\n\r\n.DESCRIPTION\r\nFeatures:\r\n- Load projects from Get-PmcData\r\n- Type-ahead fuzzy filtering (matches substrings and initials)\r\n- Arrow key navigation through filtered list\r\n- Enter to select project\r\n- Alt+N to create new project inline (switches to TextInput mode)\r\n- Recent projects shown at top\r\n- Project count display\r\n- OnProjectSelected event callback\r\n- Visual list with scroll indicators\r\n- Empty state handling\r\n\r\n.EXAMPLE\r\n$picker = [ProjectPicker]::new()\r\n$picker.SetPosition(10, 5)\r\n$picker.SetSize(35, 12)\r\n$picker.RenderToEngine($engine)\r\n##CLOSEBRACKET##\r\nclass ProjectPicker : PmcWidget {\r\n    # === Public Properties ===\r\n    [string]$Label = \"Select Project\"      # Widget title\r\n    [bool]$ShowRecentFirst = $true         # Show recent projects at top\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnProjectSelected = {}   # Called when project selected: param($projectName)\r\n    [scriptblock]$OnProjectCreated = {}    # Called when new project created: param($projectName)\r\n    [scriptblock]$OnCancelled = {}         # Called when Esc pressed\r\n\r\n    # === State Flags ===\r\n    [bool]$IsConfirmed = $false            # True when project selected\r\n    [bool]$IsCancelled = $false            # True when Esc pressed\r\n\r\n    # === Private State ===\r\n    hidden [string[]]$_allProjects = @()           # All available projects\r\n    hidden [string[]]$_filteredProjects = @()      # Filtered project list\r\n    hidden [string]$_searchText = \"\"               # Current search filter\r\n    hidden [int]$_selectedIndex = 0                # Selected item index in filtered list\r\n    hidden [int]$_scrollOffset = 0                 # Scroll offset for long lists\r\n    hidden [bool]$_isCreateMode = $false           # True when creating new project\r\n    hidden [string]$_createText = \"\"               # Text for new project name\r\n    hidden [int]$_createCursorPos = 0              # Cursor position in create mode\r\n    hidden [string]$_errorMessage = \"\"             # Error message to display\r\n    hidden [DateTime]$_lastRefresh = [DateTime]::MinValue\r\n\r\n    # === Constructor ===\r\n    ProjectPicker() : base(\"ProjectPicker\") {\r\n        $this.Width = 35\r\n        $this.Height = 12\r\n        $this.CanFocus = $true\r\n        $this._LoadProjects()\r\n    }\r\n\r\n    # === Public API Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Refresh project list from data source\r\n    ##CLOSEBRACKET##\r\n    [void] RefreshProjects() {\r\n        $this._LoadProjects()\r\n        $this._ApplyDoFilter()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get the currently selected project name\r\n\r\n    .OUTPUTS\r\n    String project name or empty string if none selected\r\n    ##CLOSEBRACKET##\r\n    [string] GetSelectedProject() {\r\n        if ($this._filteredProjects.Count -eq 0) {\r\n            return \"\"\r\n        }\r\n\r\n        if ($this._selectedIndex -ge 0 -and $this._selectedIndex -lt $this._filteredProjects.Count) {\r\n            $selected = $this._filteredProjects[$this._selectedIndex]\r\n            if ($selected -eq \"(No Project)\") { return \"\" }\r\n            return $selected\r\n        }\r\n\r\n        return \"\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set initial search filter text\r\n    ##CLOSEBRACKET##\r\n    [void] SetSearchText([string]$text) {\r\n        $this._searchText = $text\r\n        $this._ApplyDoFilter()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set the selected project by name (without filtering)\r\n    ##CLOSEBRACKET##\r\n    [void] SetSelectedProject([string]$projectName) {\r\n        # Find the project in the full list\r\n        for ($i = 0; $i -lt $this._filteredProjects.Count; $i++) {\r\n            if ($this._filteredProjects[$i] -eq $projectName) {\r\n                $this._selectedIndex = $i\r\n                $this._AdjustScrollOffset()\r\n                return\r\n            }\r\n        }\r\n        # Not found - select first item\r\n        $this._selectedIndex = 0\r\n        $this._AdjustScrollOffset()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle keyboard input\r\n    ##CLOSEBRACKET##\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        # Check if we need to refresh projects (every 5 seconds)\r\n        if (([DateTime]::Now - $this._lastRefresh).TotalSeconds -gt 5) {\r\n            $this._LoadProjects()\r\n            $this._ApplyDoFilter()\r\n        }\r\n\r\n        # Create mode has different input handling\r\n        if ($this._isCreateMode) {\r\n            return $this._HandleCreateModeInput($keyInfo)\r\n        }\r\n\r\n        # Enter - select current project\r\n        if ($keyInfo.Key -eq 'Enter') {\r\n            $selected = $this.GetSelectedProject()\r\n            $this.IsConfirmed = $true\r\n            # Callback with selected project (empty string if No Project)\r\n            $this._InvokeCallback($this.OnProjectSelected, $selected)\r\n            return $true\r\n        }\r\n\r\n        # Escape - cancel\r\n        if ($keyInfo.Key -eq 'Escape') {\r\n            $this.IsCancelled = $true\r\n            $this._InvokeCallback($this.OnCancelled, $null)\r\n            return $true\r\n        }\r\n\r\n        # Alt+N - create new project\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt -and $keyInfo.Key -eq 'N') {\r\n            $this._EnterCreateMode()\r\n            return $true\r\n        }\r\n\r\n        # Navigation\r\n        if ($keyInfo.Key -eq 'UpArrow') {\r\n            $this._MoveSelectionUp()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'DownArrow') {\r\n            $this._MoveSelectionDown()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'PageUp') {\r\n            $this._MoveSelectionUp()\r\n            $this._MoveSelectionUp()\r\n            $this._MoveSelectionUp()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'PageDown') {\r\n            $this._MoveSelectionDown()\r\n            $this._MoveSelectionDown()\r\n            $this._MoveSelectionDown()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'Home') {\r\n            $this._selectedIndex = 0\r\n            $this._AdjustScrollOffset()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'End') {\r\n            $this._selectedIndex = [Math]::Max(0, $this._filteredProjects.Count - 1)\r\n            $this._AdjustScrollOffset()\r\n            return $true\r\n        }\r\n\r\n        # Backspace - remove character from search\r\n        if ($keyInfo.Key -eq 'Backspace') {\r\n            if ($this._searchText.Length -gt 0) {\r\n                $this._searchText = $this._searchText.Substring(0, $this._searchText.Length - 1)\r\n                $this._ApplyDoFilter()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Ctrl+U - clear search\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control -and $keyInfo.Key -eq 'U') {\r\n            $this._searchText = \"\"\r\n            $this._ApplyDoFilter()\r\n            return $true\r\n        }\r\n\r\n        # Regular character - add to search\r\n        if ($keyInfo.KeyChar -ge 32 -and $keyInfo.KeyChar -le 126) {\r\n            $this._searchText += $keyInfo.KeyChar\r\n            $this._ApplyDoFilter()\r\n            return $true\r\n        }\r\n\r\n        # Space\r\n        if ($keyInfo.Key -eq 'Spacebar') {\r\n            $this._searchText += ' '\r\n            $this._ApplyDoFilter()\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n        # Regions removed - using direct WriteAt in RenderToEngine\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render project picker to engine\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        # Clamp to bounds\r\n        $this._ClampToBounds($engine)\r\n        \r\n        # Begin layer elevation (popup z-order)\r\n        if ($engine.PSObject.Methods['BeginLayer']) {\r\n            $engine.BeginLayer(100)\r\n        }\r\n        \r\n        # Get themed colors\r\n        $borderFg = $this.GetThemedInt('Border.Widget')\r\n        $fg = $this.GetThemedInt('Foreground.Row')\r\n        $bg = $this.GetThemedBgInt('Background.Row', $this.Width, 0)\r\n        $primaryFg = $this.GetThemedInt('Foreground.Primary')\r\n        $mutedFg = $this.GetThemedInt('Foreground.Muted')\r\n        $highlightBg = $this.GetThemedBgInt('Background.RowSelected', $this.Width, 0)\r\n        $highlightFg = $this.GetThemedInt('Foreground.RowSelected')\r\n        $errorFg = $this.GetThemedInt('Foreground.Error')\r\n        \r\n        # Draw border box\r\n        $engine.DrawBox($this.X, $this.Y, $this.Width, $this.Height, $borderFg, $bg)\r\n        \r\n        # Draw title\r\n        $titleText = \" $($this.Label) \"\r\n        $engine.WriteAt($this.X + 2, $this.Y, $titleText, $primaryFg, $bg)\r\n        \r\n        # Draw count (if not in create mode)\r\n        if (-not $this._isCreateMode) {\r\n            $countStr = \"($($this._filteredProjects.Count))\"\r\n            $engine.WriteAt($this.X + $this.Width - $countStr.Length - 2, $this.Y + 1, $countStr, $mutedFg, $bg)\r\n        }\r\n        \r\n        # Separator line under title\r\n        $engine.Fill($this.X + 1, $this.Y + 2, $this.Width - 2, 1, [char]0x2500, $borderFg, $bg)\r\n\r\n        if ($this._isCreateMode) {\r\n            # Create Input at Y+3\r\n            $inputY = $this.Y + 3\r\n            \r\n            # Input Prompt/border\r\n            $engine.WriteAt($this.X, $inputY, [char]0x2502, $borderFg, $bg) # Left border\r\n            $engine.WriteAt($this.X + $this.Width - 1, $inputY, [char]0x2502, $borderFg, $bg) # Right border\r\n            \r\n            # Input content\r\n            $inputStr = $this._createText\r\n            $innerWidth = $this.Width - 4\r\n            \r\n            if ([string]::IsNullOrEmpty($inputStr)) {\r\n                $engine.WriteAt($this.X + 2, $inputY, \"Enter project name...\", $mutedFg, $bg)\r\n            }\r\n            else {\r\n                # Simple rendering without complex scrolling for now\r\n                $display = $inputStr\r\n                if ($display.Length -gt $innerWidth) { $display = $display.Substring($display.Length - $innerWidth) }\r\n                $engine.WriteAt($this.X + 2, $inputY, $display, $fg, $bg)\r\n            }\r\n            \r\n            # Help at Y+5\r\n            $helpText = \"Enter=Create | Esc=Cancel\"\r\n            $engine.WriteAt($this.X + 2, $this.Y + 5, $this.PadText($helpText, $this.Width - 4, 'left'), $mutedFg, $bg)\r\n        }\r\n        else {\r\n            # Count\r\n            $countText = \"($($this._filteredProjects.Count))\"\r\n            $countX = $this.X + $this.Width - $countText.Length - 2\r\n            if ($countX -gt $this.X + 2) {\r\n                $engine.WriteAt($countX, $this.Y + 1, $countText, $mutedFg, $bg)\r\n            }\r\n            \r\n            # Search at Y+2\r\n            $searchText = if ([string]::IsNullOrWhiteSpace($this._searchText)) { \"Type to filter...\" } else { $this._searchText }\r\n            $searchFg = if ([string]::IsNullOrWhiteSpace($this._searchText)) { $mutedFg } else { $primaryFg }\r\n            $engine.WriteAt($this.X + 2, $this.Y + 2, $this.PadText($searchText, $this.Width - 4, 'left'), $searchFg, $bg)\r\n            \r\n            # List at Y+3\r\n            $listY = $this.Y + 3\r\n            $listHeight = [Math]::Max(1, $this.Height - 5)\r\n            $visibleProjects = @()\r\n            if ($this._filteredProjects.Count -gt 0) {\r\n                $endIndex = [Math]::Min($this._scrollOffset + $listHeight, $this._filteredProjects.Count)\r\n                for ($i = $this._scrollOffset; $i -lt $endIndex; $i++) {\r\n                    $visibleProjects += $this._filteredProjects[$i]\r\n                }\r\n            }\r\n            \r\n            for ($i = 0; $i -lt $listHeight; $i++) {\r\n                $currentY = $listY + $i\r\n                if ($currentY -ge $this.Y + $this.Height - 1) { break } # Safety\r\n                \r\n                if ($i -lt $visibleProjects.Count) {\r\n                    $projectName = $visibleProjects[$i]\r\n                    $isSelected = ($this._scrollOffset + $i) -eq $this._selectedIndex\r\n                    \r\n                    $iBg = if ($isSelected) { $highlightBg } else { $bg }\r\n                    $iFg = if ($isSelected) { $highlightFg } else { $fg }\r\n                    \r\n                    $taskCount = $this._GetTaskCountForProject($projectName)\r\n                    $displayName = if ($taskCount -ge 0) { \"$projectName ($taskCount)\" } else { $projectName }\r\n                    \r\n                    # Manual fill for row background\r\n                    $engine.Fill($this.X + 1, $currentY, $this.Width - 2, 1, ' ', $iFg, $iBg)\r\n                    $engine.WriteAt($this.X + 2, $currentY, $this.TruncateText($displayName, $this.Width - 4), $iFg, $iBg)\r\n                }\r\n                else {\r\n                    # Empty row\r\n                    $engine.Fill($this.X + 1, $currentY, $this.Width - 2, 1, ' ', $fg, $bg)\r\n                }\r\n            }\r\n\r\n            # Help\r\n            $helpText = \"Enter=Select | Alt+N=Create\"\r\n            $engine.WriteAt($this.X + 2, $this.Y + $this.Height - 2, $this.PadText($helpText, $this.Width - 4, 'left'), $mutedFg, $bg)\r\n        }\r\n        \r\n        if ($this._errorMessage) {\r\n            $engine.WriteAt($this.X + 2, $this.Y + $this.Height - 1, $this.PadText($this._errorMessage, $this.Width - 4, 'left'), $errorFg, $bg)\r\n        }\r\n        \r\n        # End layer elevation\r\n        if ($engine.PSObject.Methods['EndLayer']) {\r\n            $engine.EndLayer()\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Ensure widget stays within screen bounds (Engine Viewport)\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _ClampToBounds([object]$engine) {\r\n        # Check Engine bounds first (Authoritative Viewport)\r\n        if ($engine -and $engine.PSObject.Properties['Width']) {\r\n            $termWidth = $engine.Width\r\n            $termHeight = $engine.Height\r\n        }\r\n        else {\r\n            # Fallback to console (but verify console availability)\r\n            try {\r\n                $termWidth = [Console]::WindowWidth\r\n                $termHeight = [Console]::WindowHeight\r\n            }\r\n            catch {\r\n                $termWidth = 80\r\n                $termHeight = 24\r\n            }\r\n        }\r\n        \r\n        # Clamp X: ensure widget fits within right edge (0-indexed, so -1 for right boundary)\r\n        if ($this.X + $this.Width -gt $termWidth) {\r\n            $this.X = [Math]::Max(0, $termWidth - $this.Width)\r\n        }\r\n\r\n        # Clamp Y: ensure widget fits within bottom edge\r\n        if ($this.Y + $this.Height -gt $termHeight) {\r\n            $this.Y = [Math]::Max(0, $termHeight - $this.Height)\r\n        }\r\n    }\r\n\r\n    # === Private Helper Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Load projects from PMC data\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _LoadProjects() {\r\n        try {\r\n            . \"$PSScriptRoot/../services/TaskStore.ps1\"\r\n            $store = [TaskStore]::GetInstance()\r\n            $projectsData = $store.GetAllProjects()\r\n\r\n            # FIX: Always include \"(No Project)\" option at the beginning\r\n            $projects = @(\"(No Project)\")\r\n\r\n            if ($null -ne $projectsData -and $projectsData.Count -gt 0) {\r\n                foreach ($proj in $projectsData) {\r\n                    if ($null -ne $proj.name -and -not [string]::IsNullOrWhiteSpace($proj.name)) {\r\n                        $projects += $proj.name.ToString()\r\n                    }\r\n                }\r\n            }\r\n\r\n            $this._allProjects = $projects\r\n            $this._lastRefresh = [DateTime]::Now\r\n        }\r\n        catch {\r\n            # Failed to load projects - use \"(No Project)\" only\r\n            $this._allProjects = @(\"(No Project)\")\r\n        }\r\n\r\n        # Apply filter to refresh filtered list\r\n        $this._ApplyDoFilter()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Apply fuzzy search filter to project list\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _ApplyDoFilter() {\r\n        if ([string]::IsNullOrWhiteSpace($this._searchText)) {\r\n            $this._filteredProjects = $this._allProjects\r\n        }\r\n        else {\r\n            $searchLower = $this._searchText.ToLower()\r\n            $filtered = @()\r\n\r\n            foreach ($project in $this._allProjects) {\r\n                $projectLower = $project.ToLower()\r\n\r\n                # Exact substring match\r\n                if ($projectLower.Contains($searchLower)) {\r\n                    $filtered += $project\r\n                    continue\r\n                }\r\n\r\n                # Fuzzy match - initials or character sequence\r\n                if ($this._FuzzyMatch($projectLower, $searchLower)) {\r\n                    $filtered += $project\r\n                }\r\n            }\r\n\r\n            $this._filteredProjects = $filtered\r\n        }\r\n\r\n        # Ensure filtered projects is initialized\r\n        if ($null -eq $this._filteredProjects) {\r\n            $this._filteredProjects = @()\r\n        }\r\n\r\n        # Reset selection if out of bounds\r\n        if ($this._selectedIndex -ge $this._filteredProjects.Count) {\r\n            $this._selectedIndex = [Math]::Max(0, $this._filteredProjects.Count - 1)\r\n        }\r\n\r\n        $this._AdjustScrollOffset()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Fuzzy match algorithm - matches initials and subsequences\r\n\r\n    .PARAMETER text\r\n    Text to search in (lowercase)\r\n\r\n    .PARAMETER pattern\r\n    Pattern to match (lowercase)\r\n\r\n    .OUTPUTS\r\n    True if pattern matches text\r\n    ##CLOSEBRACKET##\r\n    hidden [bool] _FuzzyMatch([string]$text, [string]$pattern) {\r\n        $patternIdx = 0\r\n        $textIdx = 0\r\n\r\n        while ($patternIdx -lt $pattern.Length -and $textIdx -lt $text.Length) {\r\n            if ($pattern[$patternIdx] -eq $text[$textIdx]) {\r\n                $patternIdx++\r\n            }\r\n            $textIdx++\r\n        }\r\n\r\n        return $patternIdx -eq $pattern.Length\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move selection up\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _MoveSelectionUp() {\r\n        if ($this._selectedIndex -gt 0) {\r\n            $this._selectedIndex--\r\n            $this._AdjustScrollOffset()\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move selection down\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _MoveSelectionDown() {\r\n        if ($this._selectedIndex -lt ($this._filteredProjects.Count - 1)) {\r\n            $this._selectedIndex++\r\n            $this._AdjustScrollOffset()\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Adjust scroll offset to keep selection visible\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _AdjustScrollOffset() {\r\n        $maxVisibleItems = $this.Height - 4\r\n\r\n        # If selected item is above visible area, scroll up\r\n        if ($this._selectedIndex -lt $this._scrollOffset) {\r\n            $this._scrollOffset = $this._selectedIndex\r\n        }\r\n\r\n        # If selected item is below visible area, scroll down\r\n        if ($this._selectedIndex -ge ($this._scrollOffset + $maxVisibleItems)) {\r\n            $this._scrollOffset = $this._selectedIndex - $maxVisibleItems + 1\r\n        }\r\n\r\n        # Clamp scroll offset\r\n        if ($this._scrollOffset -lt 0) {\r\n            $this._scrollOffset = 0\r\n        }\r\n\r\n        $maxScroll = [Math]::Max(0, $this._filteredProjects.Count - $maxVisibleItems)\r\n        if ($this._scrollOffset -gt $maxScroll) {\r\n            $this._scrollOffset = $maxScroll\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Enter create mode for new project\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _EnterCreateMode() {\r\n        $this._isCreateMode = $true\r\n        $this._createText = \"\"\r\n        $this._createCursorPos = 0\r\n        $this._errorMessage = \"\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle input in create mode\r\n\r\n    .PARAMETER keyInfo\r\n    ConsoleKeyInfo\r\n\r\n    .OUTPUTS\r\n    True if handled\r\n    ##CLOSEBRACKET##\r\n    hidden [bool] _HandleCreateModeInput([ConsoleKeyInfo]$keyInfo) {\r\n        # Enter - create project\r\n        if ($keyInfo.Key -eq 'Enter') {\r\n            $projectName = $this._createText.Trim()\r\n\r\n            if ([string]::IsNullOrWhiteSpace($projectName)) {\r\n                $this._errorMessage = \"Project name cannot be empty\"\r\n                return $true\r\n            }\r\n\r\n            # Check for duplicates\r\n            $exists = $false\r\n            foreach ($existing in $this._allProjects) {\r\n                if ($existing.ToLower() -eq $projectName.ToLower()) {\r\n                    $exists = $true\r\n                    break\r\n                }\r\n            }\r\n\r\n            if ($exists) {\r\n                $this._errorMessage = \"Project already exists\"\r\n                return $true\r\n            }\r\n\r\n            # Create project in PMC data\r\n            try {\r\n                $data = Get-PmcData\r\n                if ($null -eq $data.projects) {\r\n                    $data | Add-Member -NotePropertyName 'projects' -NotePropertyValue @() -Force\r\n                }\r\n\r\n                $newProject = [PSCustomObject]@{\r\n                    name        = $projectName\r\n                    description = \"\"\r\n                    aliases     = @()\r\n                    created     = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n                }\r\n\r\n                $data.projects += $newProject\r\n                Save-PmcData $data\r\n\r\n                # Refresh and select new project\r\n                $this._LoadProjects()\r\n                $this._isCreateMode = $false\r\n                $this._createText = \"\"\r\n                $this._errorMessage = \"\"\r\n\r\n                # Find and select the new project\r\n                for ($i = 0; $i -lt $this._filteredProjects.Count; $i++) {\r\n                    if ($this._filteredProjects[$i] -eq $projectName) {\r\n                        $this._selectedIndex = $i\r\n                        $this._AdjustScrollOffset()\r\n                        break\r\n                    }\r\n                }\r\n\r\n                $this.IsConfirmed = $true\r\n                $this._InvokeCallback($this.OnProjectCreated, $projectName)\r\n                $this._InvokeCallback($this.OnProjectSelected, $projectName)\r\n\r\n                return $true\r\n            }\r\n            catch {\r\n                $this._errorMessage = \"Failed to create project\"\r\n                return $true\r\n            }\r\n        }\r\n\r\n        # Escape - cancel create mode\r\n        if ($keyInfo.Key -eq 'Escape') {\r\n            $this._isCreateMode = $false\r\n            $this._createText = \"\"\r\n            $this._createCursorPos = 0\r\n            $this._errorMessage = \"\"\r\n            return $true\r\n        }\r\n\r\n        # Backspace\r\n        if ($keyInfo.Key -eq 'Backspace') {\r\n            if ($this._createCursorPos -gt 0) {\r\n                $before = $this._createText.Substring(0, $this._createCursorPos - 1)\r\n                $after = $(if ($this._createCursorPos -lt $this._createText.Length) {\r\n                        $this._createText.Substring($this._createCursorPos)\r\n                    }\r\n                    else { \"\" })\r\n                $this._createText = $before + $after\r\n                $this._createCursorPos--\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Delete\r\n        if ($keyInfo.Key -eq 'Delete') {\r\n            if ($this._createCursorPos -lt $this._createText.Length) {\r\n                $before = $this._createText.Substring(0, $this._createCursorPos)\r\n                $after = $(if ($this._createCursorPos + 1 -lt $this._createText.Length) {\r\n                        $this._createText.Substring($this._createCursorPos + 1)\r\n                    }\r\n                    else { \"\" })\r\n                $this._createText = $before + $after\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Navigation\r\n        if ($keyInfo.Key -eq 'LeftArrow') {\r\n            if ($this._createCursorPos -gt 0) {\r\n                $this._createCursorPos--\r\n            }\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'RightArrow') {\r\n            if ($this._createCursorPos -lt $this._createText.Length) {\r\n                $this._createCursorPos++\r\n            }\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'Home') {\r\n            $this._createCursorPos = 0\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'End') {\r\n            $this._createCursorPos = $this._createText.Length\r\n            return $true\r\n        }\r\n\r\n        # Regular character input\r\n        if ($keyInfo.KeyChar -ge 32 -and $keyInfo.KeyChar -le 126) {\r\n            $before = $this._createText.Substring(0, $this._createCursorPos)\r\n            $after = $(if ($this._createCursorPos -lt $this._createText.Length) {\r\n                    $this._createText.Substring($this._createCursorPos)\r\n                }\r\n                else { \"\" })\r\n            $this._createText = $before + $keyInfo.KeyChar + $after\r\n            $this._createCursorPos++\r\n            return $true\r\n        }\r\n\r\n        # Space\r\n        if ($keyInfo.Key -eq 'Spacebar') {\r\n            $before = $this._createText.Substring(0, $this._createCursorPos)\r\n            $after = $(if ($this._createCursorPos -lt $this._createText.Length) {\r\n                    $this._createText.Substring($this._createCursorPos)\r\n                }\r\n                else { \"\" })\r\n            $this._createText = $before + ' ' + $after\r\n            $this._createCursorPos++\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    L-POL-8: Get task count for a project\r\n\r\n    .PARAMETER projectName\r\n    Name of the project\r\n\r\n    .OUTPUTS\r\n    Number of tasks in project, or -1 if count unavailable\r\n    ##CLOSEBRACKET##\r\n    hidden [int] _GetTaskCountForProject([string]$projectName) {\r\n        try {\r\n            . \"$PSScriptRoot/../services/TaskStore.ps1\"\r\n            $store = [TaskStore]::GetInstance()\r\n            $allTasks = $store.GetAllTasks()\r\n\r\n            if ($null -eq $allTasks) {\r\n                return -1\r\n            }\r\n\r\n            $count = 0\r\n            foreach ($task in $allTasks) {\r\n                $taskProject = $task.project\r\n                if ($taskProject -eq $projectName -and -not ($task.completed)) {\r\n                    $count++\r\n                }\r\n            }\r\n\r\n            return $count\r\n        }\r\n        catch {\r\n            # Failed to get count - return -1 to skip displaying count\r\n            return -1\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Invoke a callback scriptblock safely\r\n\r\n    .PARAMETER callback\r\n    Scriptblock to invoke\r\n\r\n    .PARAMETER args\r\n    Arguments to pass\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _InvokeCallback([scriptblock]$callback, $argument) {\r\n        if ($null -ne $callback) {\r\n            try {\r\n                if ($null -ne $argument) {\r\n                    & $callback $argument\r\n                }\r\n                else {\r\n                    & $callback\r\n                }\r\n            }\r\n            catch {\r\n                # Callback failed - log but don't crash widget\r\n            }\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/widgets/SimpleFilePicker.ps1", "content": "using namespace System.Collections.Generic\n\n# SimpleFilePicker.ps1 - Simple file/folder picker that works with SpeedTUI\n\nSet-StrictMode -Version Latest\n\n# Ensure PmcWidget is loaded\nif (-not ([System.Management.Automation.PSTypeName]'PmcWidget').Type) {\n    . \"$PSScriptRoot/PmcWidget.ps1\"\n}\n\nclass SimpleFilePicker : PmcWidget {\n    [string]$CurrentPath = ''\n    [List[object]]$Items = $null\n    [int]$SelectedIndex = 0\n    [int]$ScrollOffset = 0\n    [bool]$IsComplete = $false\n    [bool]$Result = $false\n    [string]$SelectedPath = ''\n    [bool]$DirectoriesOnly = $false\n\n    SimpleFilePicker([string]$startPath, [bool]$directoriesOnly) : base(\"SimpleFilePicker\") {\n        $this.Width = 60\n        $this.Height = 20\n        $this.DirectoriesOnly = $directoriesOnly\n        $this.Items = [List[object]]::new()\n\n        # Validate and set start path\n        if ([string]::IsNullOrWhiteSpace($startPath) -or -not (Test-Path $startPath)) {\n            $this.CurrentPath = [Environment]::GetFolderPath('UserProfile')\n        }\n        else {\n            if (Test-Path -Path $startPath -PathType Leaf) {\n                # If it's a file, use parent directory\n                $this.CurrentPath = Split-Path -Parent $startPath\n            }\n            else {\n                $this.CurrentPath = $startPath\n            }\n        }\n\n        $this.LoadItems()\n    }\n\n    [void] LoadItems() {\n        $this.Items.Clear()\n        $this.SelectedIndex = 0\n        $this.ScrollOffset = 0\n\n        try {\n            # Add parent directory\n            $parent = Split-Path -Parent $this.CurrentPath\n            if ($parent) {\n                $this.Items.Add(@{\n                        Name        = '..'\n                        Path        = $parent\n                        IsDirectory = $true\n                    })\n            }\n\n            # Get directories\n            $dirs = Get-ChildItem -Path $this.CurrentPath -Directory -ErrorAction SilentlyContinue | Sort-Object Name\n            foreach ($dir in $dirs) {\n                $this.Items.Add(@{\n                        Name        = $dir.Name\n                        Path        = $dir.FullName\n                        IsDirectory = $true\n                    })\n            }\n\n            # Get files if not directories-only\n            if (-not $this.DirectoriesOnly) {\n                $files = Get-ChildItem -Path $this.CurrentPath -File -ErrorAction SilentlyContinue | Sort-Object Name\n                foreach ($file in $files) {\n                    $this.Items.Add(@{\n                            Name        = $file.Name\n                            Path        = $file.FullName\n                            IsDirectory = $false\n                        })\n                }\n            }\n        }\n        catch {\n            # On error, go to home\n            $this.CurrentPath = [Environment]::GetFolderPath('UserProfile')\n            $this.LoadItems()\n        }\n    }\n\n    [bool] HandleInput([ConsoleKeyInfo]$key) {\n        switch ($key.Key) {\n            'UpArrow' {\n                if ($this.SelectedIndex -gt 0) {\n                    $this.SelectedIndex--\n                    # Adjust scroll if needed\n                    if ($this.SelectedIndex -lt $this.ScrollOffset) {\n                        $this.ScrollOffset = $this.SelectedIndex\n                    }\n                }\n                return $true\n            }\n            'DownArrow' {\n                if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {\n                    $this.SelectedIndex++\n                    # Adjust scroll if needed (show 15 items at a time - or Height-5)\n                    $visibleItems = $this.Height - 5\n                    if ($this.SelectedIndex -ge ($this.ScrollOffset + $visibleItems)) {\n                        $this.ScrollOffset = $this.SelectedIndex - $visibleItems + 1\n                    }\n                }\n                return $true\n            }\n            'Enter' {\n                if ($this.Items.Count -eq 0) {\n                    return $true\n                }\n\n                $selected = $this.Items[$this.SelectedIndex]\n                if ($selected.IsDirectory) {\n                    # Navigate into directory\n                    $this.CurrentPath = $selected.Path\n                    $this.LoadItems()\n                }\n                else {\n                    # Select file\n                    $this.SelectedPath = $selected.Path\n                    $this.Result = $true\n                    $this.IsComplete = $true\n                }\n                return $true\n            }\n            'Spacebar' {\n                # Select current directory\n                $this.SelectedPath = $this.CurrentPath\n                $this.Result = $true\n                $this.IsComplete = $true\n                return $true\n            }\n            'Escape' {\n                $this.Result = $false\n                $this.IsComplete = $true\n                return $true\n            }\n        }\n        return $false\n    }\n\n    # === Layout System ===\n\n    [void] RegisterLayout([object]$engine) {\n        ([PmcWidget]$this).RegisterLayout($engine)\n        \n        $engine.DefineRegion(\"$($this.RegionID)_Title\", $this.X + 2, $this.Y + 1, $this.Width - 4, 1)\n        $engine.DefineRegion(\"$($this.RegionID)_Path\", $this.X + 2, $this.Y + 2, $this.Width - 4, 1)\n        \n        $listHeight = [Math]::Max(1, $this.Height - 6)\n        $engine.DefineRegion(\"$($this.RegionID)_List\", $this.X + 2, $this.Y + 4, $this.Width - 4, $listHeight)\n        \n        $engine.DefineRegion(\"$($this.RegionID)_Help\", $this.X + 2, $this.Y + $this.Height - 2, $this.Width - 4, 1)\n    }\n\n    <#\n    .SYNOPSIS\n    Render directly to engine (new high-performance path)\n    ##CLOSEBRACKET##\n    [void] RenderToEngine([object]$engine) {\n        $this.RegisterLayout($engine)\n\n        # Colors (Ints)\n        # Colors (Ints)\n        $bg = $this.GetThemedBgInt('Background.Panel', 1, 0)\n        $fg = $this.GetThemedInt('Foreground.Row')\n        $highlightBg = $this.GetThemedBgInt('Background.RowSelected', 1, 0)\n        $highlightFg = $this.GetThemedInt('Foreground.RowSelected')\n        $dirColor = $this.GetThemedInt('Foreground.Title')\n        $muted = $this.GetThemedInt('Foreground.Muted')\n        \n        # Draw Box\n        $engine.Fill($this.X, $this.Y, $this.Width, $this.Height, ' ', $fg, $bg)\n        $engine.DrawBox($this.X, $this.Y, $this.Width, $this.Height, $fg, $bg)\n        \n        # Title\n        $title = if ($this.DirectoriesOnly) { \"Select Folder\" } else { \"Select File\" }\n        $engine.WriteToRegion(\"$($this.RegionID)_Title\", \"=== $title ===\", $fg, $bg)\n        \n        # Path\n        $engine.WriteToRegion(\"$($this.RegionID)_Path\", \"Current: $($this.CurrentPath)\", $fg, $bg)\n        \n        # List\n        $listRegion = \"$($this.RegionID)_List\"\n        $bounds = $engine.GetRegionBounds($listRegion)\n        \n        if ($bounds) {\n            $visibleCount = $bounds.Height\n            \n            for ($i = 0; $i -lt $visibleCount; $i++) {\n                $idx = $this.ScrollOffset + $i\n                if ($idx -ge $this.Items.Count) { break }\n                \n                $item = $this.Items[$idx]\n                $isSelected = ($idx -eq $this.SelectedIndex)\n                \n                $iBg = if ($isSelected) { $highlightBg } else { $bg }\n                $iFg = if ($isSelected) { $highlightFg } else { if ($item.IsDirectory) { $dirColor } else { $fg } }\n                \n                $prefix = if ($item.IsDirectory) { \"[DIR]\" } else { \"[FILE]\" }\n                $text = if ($isSelected) { \"> $prefix $($item.Name)\" } else { \"  $prefix $($item.Name)\" }\n                \n                $engine.Fill($bounds.X, $bounds.Y + $i, $bounds.Width, 1, ' ', $iFg, $iBg)\n                $engine.WriteAt($bounds.X, $bounds.Y + $i, $text, $iFg, $iBg)\n            }\n        }\n        \n        # Help\n        $help = \"Up/Down: Navigate | Enter: Open | Space: Select | Esc: Cancel\"\n        $engine.WriteToRegion(\"$($this.RegionID)_Help\", $help, $muted, $bg)\n    }\n\n    [string] Render() { return \"\" }\n}"}, {"path": "module/Pmc.Strict/consoleui/widgets/TabPanel.ps1", "content": "# TabPanel.ps1 - Tabbed interface widget for organizing fields into logical groups\r\n#\r\n# Usage:\r\n#   $tabPanel = [TabPanel]::new()\r\n#   $tabPanel.AddTab('Identity', @(\r\n#       @{Name='ID1'; Label='ID1'; Value='12345'}\r\n#       @{Name='ID2'; Label='ID2'; Value='ABC-2024'}\r\n#   ))\r\n#   $tabPanel.AddTab('Request', @(...))\r\n#\r\n#   # Navigation\r\n#   $tabPanel.NextTab()       # Tab key\r\n#   $tabPanel.PrevTab()       # Shift+Tab\r\n#   $tabPanel.SelectTab(2)    # Number keys 1-6\r\n#   $tabPanel.NextField()     # Down arrow\r\n#   $tabPanel.PrevField()     # Up arrow\r\n#\r\n#   # Rendering\r\n#   $output = $tabPanel.Render()\r\n\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Load PmcWidget base class\r\nif (-not ([System.Management.Automation.PSTypeName]'PmcWidget').Type) {\r\n    . \"$PSScriptRoot/PmcWidget.ps1\"\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nTabbed interface widget for organizing many fields into logical groups\r\n\r\n.DESCRIPTION\r\nTabPanel provides a tab-based navigation interface for displaying and editing\r\ngrouped fields. Perfect for forms with many fields that need organization.\r\n\r\nFeatures:\r\n- Multiple tabs with labels\r\n- Keyboard navigation (Tab/Shift+Tab, arrow keys, number keys)\r\n- Inline field editing\r\n- Theme integration\r\n- Visual tab indicators (active, inactive)\r\n- Field highlighting and selection\r\n- Scrolling within tabs if needed\r\n\r\n.EXAMPLE\r\n$tabs = [TabPanel]::new()\r\n$tabs.AddTab('General', @(\r\n    @{Name='name'; Label='Name'; Value='John Doe'}\r\n    @{Name='email'; Label='Email'; Value='john@example.com'}\r\n))\r\n$tabs.AddTab('Details', @(...))\r\n$output = $tabs.Render()\r\n##CLOSEBRACKET##\r\nclass TabPanel : PmcWidget {\r\n    # === Tab Structure ===\r\n    [List[hashtable]]$Tabs = [List[hashtable]]::new()\r\n    [int]$CurrentTabIndex = 0\r\n    [int]$SelectedFieldIndex = 0  # Field index within current tab\r\n\r\n    # === Display Configuration ===\r\n    [int]$TabBarHeight = 2        # Rows for tab bar\r\n    [int]$ContentPadding = 2      # Padding inside content area\r\n    [int]$LabelWidth = 22         # Width for field labels\r\n    [bool]$ShowTabNumbers = $true # Show [1] [2] [3] on tabs\r\n\r\n    # === Events ===\r\n    [scriptblock]$OnTabChanged = {}      # Called when tab changes: param($tabIndex)\r\n    [scriptblock]$OnFieldSelected = {}   # Called when field selected: param($field)\r\n    [scriptblock]$OnFieldEdit = {}       # Called when field edited: param($field, $newValue)\r\n\r\n    # === Constructor ===\r\n    TabPanel() : base(\"TabPanel\") {\r\n        $this.Width = 80\r\n        $this.Height = 25\r\n        $this.CanFocus = $true\r\n    }\r\n\r\n    # === Tab Management ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Add a new tab with fields\r\n\r\n    .PARAMETER name\r\n    Tab name/label\r\n\r\n    .PARAMETER fields\r\n    Array of field hashtables: @{Name=''; Label=''; Value=''; Type='text'}\r\n    ##CLOSEBRACKET##\r\n    [void] AddTab([string]$name, [array]$fields) {\r\n        $tab = @{\r\n            Name         = $name\r\n            Fields       = $fields\r\n            ScrollOffset = 0\r\n        }\r\n        $this.Tabs.Add($tab)\r\n    }\r\n    [void] ClearTabs() { $this.Tabs.Clear(); $this.CurrentTabIndex = 0; $this.SelectedFieldIndex = 0 }\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get current tab\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetCurrentTab() {\r\n        if ($this.Tabs.Count -eq 0) {\r\n            return $null\r\n        }\r\n        return $this.Tabs[$this.CurrentTabIndex]\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get currently selected field\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetCurrentField() {\r\n        $tab = $this.GetCurrentTab()\r\n        if ($null -eq $tab -or $tab.Fields.Count -eq 0) {\r\n            return $null\r\n        }\r\n\r\n        if ($this.SelectedFieldIndex -ge 0 -and $this.SelectedFieldIndex -lt $tab.Fields.Count) {\r\n            return $tab.Fields[$this.SelectedFieldIndex]\r\n        }\r\n\r\n        return $null\r\n    }\r\n\r\n    # === Navigation ===\r\n\r\n    [void] NextTab() {\r\n        if ($this.Tabs.Count -eq 0) { return }\r\n\r\n        $oldIndex = $this.CurrentTabIndex\r\n        $this.CurrentTabIndex = ($this.CurrentTabIndex + 1) % $this.Tabs.Count\r\n        $this.SelectedFieldIndex = 0  # Reset to first field in new tab\r\n\r\n        if ($oldIndex -ne $this.CurrentTabIndex) {\r\n            $this._InvokeCallback($this.OnTabChanged, $this.CurrentTabIndex)\r\n        }\r\n    }\r\n\r\n    [void] PrevTab() {\r\n        if ($this.Tabs.Count -eq 0) { return }\r\n\r\n        $oldIndex = $this.CurrentTabIndex\r\n        $this.CurrentTabIndex--\r\n        if ($this.CurrentTabIndex -lt 0) {\r\n            $this.CurrentTabIndex = $this.Tabs.Count - 1\r\n        }\r\n        $this.SelectedFieldIndex = 0\r\n\r\n        if ($oldIndex -ne $this.CurrentTabIndex) {\r\n            $this._InvokeCallback($this.OnTabChanged, $this.CurrentTabIndex)\r\n        }\r\n    }\r\n\r\n    [void] SelectTab([int]$index) {\r\n        if ($index -ge 0 -and $index -lt $this.Tabs.Count) {\r\n            $oldIndex = $this.CurrentTabIndex\r\n            $this.CurrentTabIndex = $index\r\n            $this.SelectedFieldIndex = 0\r\n\r\n            if ($oldIndex -ne $this.CurrentTabIndex) {\r\n                $this._InvokeCallback($this.OnTabChanged, $this.CurrentTabIndex)\r\n            }\r\n        }\r\n    }\r\n\r\n    [void] NextField() {\r\n        $tab = $this.GetCurrentTab()\r\n        if ($null -eq $tab -or $tab.Fields.Count -eq 0) { return }\r\n\r\n        $this.SelectedFieldIndex++\r\n        if ($this.SelectedFieldIndex -ge $tab.Fields.Count) {\r\n            $this.SelectedFieldIndex = $tab.Fields.Count - 1\r\n        }\r\n\r\n        # Auto-scroll if needed\r\n        $this._EnsureFieldVisible()\r\n\r\n        $field = $this.GetCurrentField()\r\n        if ($field) {\r\n            $this._InvokeCallback($this.OnFieldSelected, $field)\r\n        }\r\n    }\r\n\r\n    [void] PrevField() {\r\n        $tab = $this.GetCurrentTab()\r\n        if ($null -eq $tab -or $tab.Fields.Count -eq 0) { return }\r\n\r\n        $this.SelectedFieldIndex--\r\n        if ($this.SelectedFieldIndex -lt 0) {\r\n            $this.SelectedFieldIndex = 0\r\n        }\r\n\r\n        # Auto-scroll if needed\r\n        $this._EnsureFieldVisible()\r\n\r\n        $field = $this.GetCurrentField()\r\n        if ($field) {\r\n            $this._InvokeCallback($this.OnFieldSelected, $field)\r\n        }\r\n    }\r\n\r\n    hidden [void] _EnsureFieldVisible() {\r\n        $tab = $this.GetCurrentTab()\r\n        if ($null -eq $tab) { return }\r\n\r\n        $visibleRows = $this.Height - $this.TabBarHeight - 4  # Tab bar + padding\r\n\r\n        # If selected field is above visible area\r\n        if ($this.SelectedFieldIndex -lt $tab.ScrollOffset) {\r\n            $tab.ScrollOffset = $this.SelectedFieldIndex\r\n        }\r\n\r\n        # If selected field is below visible area\r\n        if ($this.SelectedFieldIndex -ge ($tab.ScrollOffset + $visibleRows)) {\r\n            $tab.ScrollOffset = $this.SelectedFieldIndex - $visibleRows + 1\r\n        }\r\n    }\r\n\r\n    # === Input Handling ===\r\n\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        if ($keyInfo.Key -eq 'Tab') {\r\n            if ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift) {\r\n                $this.PrevTab()\r\n            }\r\n            else {\r\n                $this.NextTab()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Left/Right arrows cycle through tabs\r\n        if ($keyInfo.Key -eq 'LeftArrow') {\r\n            $this.PrevTab()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'RightArrow') {\r\n            $this.NextTab()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'UpArrow') {\r\n            $this.PrevField()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'DownArrow') {\r\n            $this.NextField()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'PageDown') {\r\n            # Jump 10 fields down\r\n            for ($i = 0; $i -lt 10; $i++) {\r\n                $this.NextField()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'PageUp') {\r\n            # Jump 10 fields up\r\n            for ($i = 0; $i -lt 10; $i++) {\r\n                $this.PrevField()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'Home') {\r\n            $this.SelectedFieldIndex = 0\r\n            $tab = $this.GetCurrentTab()\r\n            if ($tab) {\r\n                $tab.ScrollOffset = 0\r\n            }\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'End') {\r\n            $tab = $this.GetCurrentTab()\r\n            if ($tab -and $tab.Fields.Count -gt 0) {\r\n                $this.SelectedFieldIndex = $tab.Fields.Count - 1\r\n                $this._EnsureFieldVisible()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Number keys 1-9 to jump to tabs\r\n        if ($this.ShowTabNumbers -and $keyInfo.KeyChar -match '[1-9]') {\r\n            $tabNum = [int]$keyInfo.KeyChar - [int][char]'1'  # 0-based index\r\n            $this.SelectTab($tabNum)\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n\r\n        $engine.DefineRegion(\"$($this.RegionID)_Tabs\", $this.X, $this.Y, $this.Width, 1)\r\n        $engine.DefineRegion(\"$($this.RegionID)_Separator\", $this.X, $this.Y + 1, $this.Width, 1)\r\n\r\n        $contentHeight = $this.Height - 2\r\n        $engine.DefineRegion(\"$($this.RegionID)_Content\", $this.X, $this.Y + 2, $this.Width, $contentHeight)\r\n    }\r\n\r\n\r\n    # === Rendering ===\r\n\r\n    [void] RenderToEngine([object]$engine) {\r\n        $this.RegisterLayout($engine)\r\n\r\n        # Use Z-layer 10 for tabs to ensure they render above other content\r\n        if ($engine.PSObject.Methods['BeginLayer']) {\r\n            $engine.BeginLayer(10)\r\n        }\r\n\r\n        if ($this.Tabs.Count -eq 0) {\r\n            # Render empty state\r\n            $fgSec = $this.GetThemedInt(\"Foreground.Secondary\"); $engine.WriteAt($this.X, $this.Y, \"No tabs defined\", $fgSec, -1)\n            if ($engine.PSObject.Methods['EndLayer']) {\r\n                $engine.EndLayer()\r\n            }\r\n            return\r\n        }\r\n\r\n        # 1. Render Tab Bar\r\n        $currentX = $this.X\r\n        for ($i = 0; $i -lt $this.Tabs.Count; $i++) {\r\n            $tab = $this.Tabs[$i]\r\n            $isCurrent = ($i -eq $this.CurrentTabIndex)\r\n            \r\n            $label = $tab.Name\r\n            if ($this.ShowTabNumbers) {\r\n                $label = \"[$($i+1)] $label\"\r\n            }\r\n            \r\n            # Add padding\r\n            $label = \" $label \"\r\n            \r\n            if ($isCurrent) {\r\n                # Active Tab\r\n                $bg = $this.GetThemedInt(\"Background.Accent\")\r\n                $fg = $this.GetThemedInt(\"Foreground.Primary\")\r\n                $engine.WriteAt($currentX, $this.Y, $label, $fg, $bg)\r\n            } else {\r\n                # Inactive Tab\r\n                $bg = $this.GetThemedInt(\"Background.Panel\")\r\n                $fg = $this.GetThemedInt(\"Foreground.Secondary\")\r\n                $engine.WriteAt($currentX, $this.Y, $label, $fg, $bg)\r\n            }\r\n            \r\n            $currentX += $label.Length + 1\r\n        }\r\n\r\n        # 2. Render Separator\r\n        $sepColor = $this.GetThemedInt(\"Foreground.Border\")\r\n        $line = [string]::new([char]0x2500, $this.Width); $engine.WriteAt($this.X, $this.Y + 1, $line, $sepColor, -1)\n\r\n        # 3. Render Content (Fields)\r\n        $tab = $this.GetCurrentTab()\r\n        if ($tab) {\r\n            $startY = $this.Y + 2\r\n            $fields = $tab.Fields\r\n            \r\n            # Handle scrolling\r\n            if (-not $tab.ContainsKey('ScrollOffset')) { $tab.ScrollOffset = 0 }\r\n            \r\n            $visibleRows = $this.Height - 2 - 1 # Height - TabBar - Separator\r\n            \r\n            for ($i = 0; $i -lt $visibleRows; $i++) {\r\n                $fieldIndex = $tab.ScrollOffset + $i\r\n                if ($fieldIndex -ge $fields.Count) { break }\r\n                \r\n                $field = $fields[$fieldIndex]\r\n                $isSelected = ($fieldIndex -eq $this.SelectedFieldIndex)\r\n                $rowY = $startY + $i\r\n                \r\n                # Render Label\n                if ($isSelected) {\n                    $labelBg = $this.GetThemedInt(\"Background.Selection\"); $labelFg = $this.GetThemedInt(\"Foreground.Selection\")\n                } else {\n                    $labelBg = $this.GetThemedInt(\"Background.Primary\"); $labelFg = $this.GetThemedInt(\"Foreground.Secondary\")\n                }\n                $engine.WriteAt($this.X + 2, $rowY, $field.Label.PadRight($this.LabelWidth), $labelFg, $labelBg)\n                \r\n                # Render Value\r\n                $valueX = $this.X + 2 + $this.LabelWidth + 1\r\n                $valueWidth = $this.Width - ($valueX - $this.X) - 2\r\n                $displayValue = if ($field.Value) { $field.Value.ToString() } else { \"\" }\r\n                \r\n                if ($displayValue.Length -gt $valueWidth) {\r\n                    $displayValue = $displayValue.Substring(0, $valueWidth - 3) + \"...\"\r\n                }\r\n                \r\n                if ($isSelected) {\r\n                    $bg = $this.GetThemedInt(\"Background.Selection\")\r\n                    $fg = $this.GetThemedInt(\"Foreground.Selection\")\r\n                    $engine.WriteAt($valueX, $rowY, $displayValue.PadRight($valueWidth), $fg, $bg)\r\n                } else {\r\n                    $fg = $this.GetThemedInt(\"Foreground.Primary\")\r\n                    $engine.WriteAt($valueX, $rowY, $displayValue, $fg, -1)\n                }\r\n            }\r\n            \r\n            # Scroll indicators if needed\r\n            if ($tab.ScrollOffset -gt 0) {\r\n                $fgAcc = $this.GetThemedInt(\"Foreground.Accent\"); $engine.WriteAt($this.X + $this.Width - 1, $startY, \"^\", $fgAcc, -1)\n            }\r\n            if (($tab.ScrollOffset + $visibleRows) -lt $fields.Count) {\r\n                $fgAcc2 = $this.GetThemedInt(\"Foreground.Accent\"); $engine.WriteAt($this.X + $this.Width - 1, $startY + $visibleRows - 1, \"v\", $fgAcc2, -1)\n            }\r\n        }\r\n\r\n        if ($engine.PSObject.Methods['EndLayer']) {\r\n            $engine.EndLayer()\r\n        }\r\n    }\r\n\r\n    # === Helper Methods ===\r\n\r\n    hidden [void] _InvokeCallback([scriptblock]$callback, $arg) {\r\n        if ($null -ne $callback -and $callback -ne {}) {\r\n            try {\r\n                if ($null -ne $arg) {\r\n                    & $callback $arg\r\n                }\r\n                else {\r\n                    & $callback\r\n                }\r\n            }\r\n            catch {\r\n                # Silently ignore callback errors\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Update a field value\r\n    ##CLOSEBRACKET##\r\n    [void] UpdateFieldValue([string]$fieldName, $newValue) {\r\n        $tab = $this.GetCurrentTab()\r\n        if ($null -eq $tab) { return }\r\n\r\n        foreach ($field in $tab.Fields) {\r\n            if ($field.Name -eq $fieldName) {\r\n                $oldValue = $field.Value\r\n                $field.Value = $newValue\r\n                $this._InvokeCallback($this.OnFieldEdit, @($field, $newValue))\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get all field values from all tabs as hashtable\r\n    ##CLOSEBRACKET##\r\n    [hashtable] GetAllValues() {\r\n        $values = @{}\r\n\r\n        foreach ($tab in $this.Tabs) {\r\n            foreach ($field in $tab.Fields) {\r\n                $values[$field.Name] = $field.Value\r\n            }\r\n        }\r\n\r\n        return $values\r\n    }\r\n}\r\n\r\n# Export\r\nExport-ModuleMember -Variable @()"}, {"path": "module/Pmc.Strict/consoleui/widgets/TagEditor.ps1", "content": "using namespace System\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# TagEditor.ps1 - Multi-select tag editor with autocomplete chips\r\n#\r\n# Usage:\r\n#   $editor = [TagEditor]::new()\r\n#   $editor.SetPosition(5, 10)\r\n#   $editor.SetSize(60, 5)\r\n#   $editor.SetTags(@(\"work\", \"urgent\"))\r\n#\r\n#   # Render\r\n#   $ansiOutput = $editor.Render()\r\n#   Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [TagEditor] Rendering tag editor\"\r\n#\r\n#   # Handle input\r\n#   $key = [Console]::ReadKey($true)\r\n#   $handled = $editor.HandleInput($key)\r\n#\r\n#   # Get result\r\n#   $tags = $editor.GetTags()\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Load PmcWidget base class if not already loaded\r\nif (-not ([System.Management.Automation.PSTypeName]'PmcWidget').Type) {\r\n    . \"$PSScriptRoot/PmcWidget.ps1\"\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nMulti-select tag editor with autocomplete chips\r\n\r\n.DESCRIPTION\r\nFeatures:\r\n- Display selected tags as colored chips: [work] [urgent] [bug]\r\n- Type to add tags with autocomplete from existing tags\r\n- Backspace to remove last tag or edit current input\r\n- Tab/Enter to confirm current input as tag\r\n- Arrow keys to select chips for removal (future enhancement)\r\n- OnTagsChanged event callback\r\n- Visual chip layout with color coding\r\n- Max tags limit (configurable, default 10)\r\n- Load existing tags from all tasks for autocomplete\r\n- Validation: No duplicate tags, no empty tags\r\n- Color-coded chips (hash tag name to consistent color)\r\n\r\n.EXAMPLE\r\n$editor = [TagEditor]::new()\r\n$editor.SetPosition(5, 10)\r\n$editor.SetSize(60, 5)\r\n$editor.SetTags(@(\"work\", \"urgent\"))\r\n$editor.MaxTags = 5\r\n$ansiOutput = $editor.Render()\r\n##CLOSEBRACKET##\r\nclass TagEditor : PmcWidget {\r\n    # === Public Properties ===\r\n    [string]$Label = \"Tags\"                # Widget title\r\n    [int]$MaxTags = 10                     # Maximum number of tags\r\n    [bool]$AllowNewTags = $true            # Allow creating tags not in autocomplete list\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnTagsChanged = {}       # Called when tags change: param($tags)\r\n    [scriptblock]$OnConfirmed = {}         # Called when Enter pressed: param($tags)\r\n    [scriptblock]$OnCancelled = {}         # Called when Esc pressed\r\n\r\n    # === State Flags ===\r\n    [bool]$IsConfirmed = $false            # True when Enter pressed\r\n    [bool]$IsCancelled = $false            # True when Esc pressed\r\n\r\n    # === Private State ===\r\n    hidden [List[string]]$_selectedTags = [List[string]]::new()     # Currently selected tags\r\n    hidden [string]$_inputText = \"\"                                  # Current input text\r\n    hidden [int]$_cursorPosition = 0                                 # Cursor position in input\r\n    hidden [string[]]$_allKnownTags = @()                           # All tags from tasks (for autocomplete)\r\n    hidden [string[]]$_autocompleteMatches = @()                    # Current autocomplete suggestions\r\n    hidden [int]$_selectedAutocompleteIndex = 0                     # Selected autocomplete item\r\n    hidden [bool]$_showAutocomplete = $false                        # Show autocomplete dropdown\r\n    hidden [string]$_errorMessage = \"\"                              # Error message to display\r\n    hidden [DateTime]$_lastTagRefresh = [DateTime]::MinValue       # Last time tags were loaded\r\n\r\n    # Color palette for tag chips (cycling through these)\r\n    hidden [string[]]$_chipColors = @(\r\n        '#3498db'  # Blue\r\n        '#2ecc71'  # Green\r\n        '#e74c3c'  # Red\r\n        '#f39c12'  # Orange\r\n        '#9b59b6'  # Purple\r\n        '#1abc9c'  # Teal\r\n        '#e67e22'  # Dark orange\r\n        '#16a085'  # Dark teal\r\n    )\r\n\r\n    # === Constructor ===\r\n    TagEditor() : base(\"TagEditor\") {\r\n        $this.Width = 60\r\n        $this.Height = 5\r\n        $this.CanFocus = $true\r\n        $this._LoadKnownTags()\r\n    }\r\n\r\n    # === Public API Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set the tags collection\r\n\r\n    .PARAMETER tags\r\n    Array of tag strings\r\n    ##CLOSEBRACKET##\r\n    [void] SetTags([string[]]$tags) {\r\n        $this._selectedTags.Clear()\r\n\r\n        if ($null -ne $tags -and $tags.Count -gt 0) {\r\n            foreach ($tag in $tags) {\r\n                if (-not [string]::IsNullOrWhiteSpace($tag)) {\r\n                    $cleanTag = $tag.Trim()\r\n                    if (-not $this._selectedTags.Contains($cleanTag)) {\r\n                        $this._selectedTags.Add($cleanTag)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        $this._InvokeCallback($this.OnTagsChanged, $this.GetTags())\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get the current tags as array\r\n\r\n    .OUTPUTS\r\n    String array of tags\r\n    ##CLOSEBRACKET##\r\n    [string[]] GetTags() {\r\n        return $this._selectedTags.ToArray()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Add a tag to the collection\r\n\r\n    .PARAMETER tag\r\n    Tag to add\r\n\r\n    .OUTPUTS\r\n    True if added, False if duplicate or invalid\r\n    ##CLOSEBRACKET##\r\n    [bool] AddTag([string]$tag) {\r\n        if ([string]::IsNullOrWhiteSpace($tag)) {\r\n            return $false\r\n        }\r\n\r\n        $cleanTag = $tag.Trim()\r\n\r\n        if ($this._selectedTags.Contains($cleanTag)) {\r\n            $this._errorMessage = \"Tag already added\"\r\n            return $false\r\n        }\r\n\r\n        if ($this._selectedTags.Count -ge $this.MaxTags) {\r\n            $this._errorMessage = \"Maximum $($this.MaxTags) tags allowed\"\r\n            return $false\r\n        }\r\n\r\n        $this._selectedTags.Add($cleanTag)\r\n        $this._InvokeCallback($this.OnTagsChanged, $this.GetTags())\r\n        return $true\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Remove a tag from the collection\r\n\r\n    .PARAMETER tag\r\n    Tag to remove\r\n\r\n    .OUTPUTS\r\n    True if removed, False if not found\r\n    ##CLOSEBRACKET##\r\n    [bool] RemoveTag([string]$tag) {\r\n        $result = $this._selectedTags.Remove($tag)\r\n        if ($result) {\r\n            $this._InvokeCallback($this.OnTagsChanged, $this.GetTags())\r\n        }\r\n        return $result\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Clear all tags\r\n    ##CLOSEBRACKET##\r\n    [void] ClearTags() {\r\n        $this._selectedTags.Clear()\r\n        $this._inputText = \"\"\r\n        $this._cursorPosition = 0\r\n        $this._showAutocomplete = $false\r\n        $this._errorMessage = \"\"\r\n        $this._InvokeCallback($this.OnTagsChanged, $this.GetTags())\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle keyboard input\r\n\r\n    .PARAMETER keyInfo\r\n    ConsoleKeyInfo from [Console]::ReadKey($true)\r\n\r\n    .OUTPUTS\r\n    True if input was handled, False otherwise\r\n    ##CLOSEBRACKET##\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        # Refresh known tags periodically\r\n        if (([DateTime]::Now - $this._lastTagRefresh).TotalSeconds -gt 10) {\r\n            $this._LoadKnownTags()\r\n        }\r\n\r\n        # Enter - confirm tags or add current input\r\n        if ($keyInfo.Key -eq 'Enter') {\r\n            if (-not [string]::IsNullOrWhiteSpace($this._inputText)) {\r\n                # Add current input as tag first\r\n                $this._AddCurrentInputAsTag()\r\n            }\r\n\r\n            $this.IsConfirmed = $true\r\n            $this._InvokeCallback($this.OnConfirmed, $this.GetTags())\r\n            return $true\r\n        }\r\n\r\n        # Escape - cancel\r\n        if ($keyInfo.Key -eq 'Escape') {\r\n            $this.IsCancelled = $true\r\n            $this._InvokeCallback($this.OnCancelled, $null)\r\n            return $true\r\n        }\r\n\r\n        # Tab - autocomplete or add current input\r\n        if ($keyInfo.Key -eq 'Tab') {\r\n            if ($this._showAutocomplete -and $this._autocompleteMatches.Count -gt 0) {\r\n                # Use selected autocomplete suggestion\r\n                $selected = $this._autocompleteMatches[$this._selectedAutocompleteIndex]\r\n                $this._inputText = $selected\r\n                $this._cursorPosition = $selected.Length\r\n                $this._AddCurrentInputAsTag()\r\n            }\r\n            elseif (-not [string]::IsNullOrWhiteSpace($this._inputText)) {\r\n                # Add current input as tag\r\n                $this._AddCurrentInputAsTag()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Comma - treat as tag separator\r\n        if ($keyInfo.KeyChar -eq ',') {\r\n            if (-not [string]::IsNullOrWhiteSpace($this._inputText)) {\r\n                $this._AddCurrentInputAsTag()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Backspace - remove last tag if input is empty, otherwise edit input\r\n        if ($keyInfo.Key -eq 'Backspace') {\r\n            if ([string]::IsNullOrEmpty($this._inputText)) {\r\n                # Remove last tag\r\n                if ($this._selectedTags.Count -gt 0) {\r\n                    $this._selectedTags.RemoveAt($this._selectedTags.Count - 1)\r\n                    $this._InvokeCallback($this.OnTagsChanged, $this.GetTags())\r\n                }\r\n            }\r\n            else {\r\n                # Remove character from input\r\n                if ($this._cursorPosition -gt 0) {\r\n                    $before = $this._inputText.Substring(0, $this._cursorPosition - 1)\r\n                    $after = $(if ($this._cursorPosition -lt $this._inputText.Length) {\r\n                            $this._inputText.Substring($this._cursorPosition)\r\n                        }\r\n                        else { \"\" })\r\n                    $this._inputText = $before + $after\r\n                    $this._cursorPosition--\r\n                    $this._UpdateAutocomplete()\r\n                }\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Delete - delete character at cursor\r\n        if ($keyInfo.Key -eq 'Delete') {\r\n            if ($this._cursorPosition -lt $this._inputText.Length) {\r\n                $before = $this._inputText.Substring(0, $this._cursorPosition)\r\n                $after = $(if ($this._cursorPosition + 1 -lt $this._inputText.Length) {\r\n                        $this._inputText.Substring($this._cursorPosition + 1)\r\n                    }\r\n                    else { \"\" })\r\n                $this._inputText = $before + $after\r\n                $this._UpdateAutocomplete()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Arrow keys for autocomplete navigation\r\n        if ($keyInfo.Key -eq 'UpArrow') {\r\n            if ($this._showAutocomplete -and $this._autocompleteMatches.Count -gt 0) {\r\n                if ($this._selectedAutocompleteIndex -gt 0) {\r\n                    $this._selectedAutocompleteIndex--\r\n                }\r\n            }\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'DownArrow') {\r\n            if ($this._showAutocomplete -and $this._autocompleteMatches.Count -gt 0) {\r\n                if ($this._selectedAutocompleteIndex -lt ($this._autocompleteMatches.Count - 1)) {\r\n                    $this._selectedAutocompleteIndex++\r\n                }\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Left/Right arrow for cursor movement\r\n        if ($keyInfo.Key -eq 'LeftArrow') {\r\n            if ($this._cursorPosition -gt 0) {\r\n                $this._cursorPosition--\r\n            }\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'RightArrow') {\r\n            if ($this._cursorPosition -lt $this._inputText.Length) {\r\n                $this._cursorPosition++\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Home/End\r\n        if ($keyInfo.Key -eq 'Home') {\r\n            $this._cursorPosition = 0\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'End') {\r\n            $this._cursorPosition = $this._inputText.Length\r\n            return $true\r\n        }\r\n\r\n        # Regular character input\r\n        if ($keyInfo.KeyChar -ge 32 -and $keyInfo.KeyChar -le 126 -and $keyInfo.KeyChar -ne ',') {\r\n            $before = $this._inputText.Substring(0, $this._cursorPosition)\r\n            $after = $(if ($this._cursorPosition -lt $this._inputText.Length) {\r\n                    $this._inputText.Substring($this._cursorPosition)\r\n                }\r\n                else { \"\" })\r\n            $this._inputText = $before + $keyInfo.KeyChar + $after\r\n            $this._cursorPosition++\r\n            $this._UpdateAutocomplete()\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n        # Regions removed - using direct WriteAt in RenderToEngine\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render directly to engine (new high-performance path)\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        $this._blinkFrameCount++\r\n        if ($this._blinkFrameCount -ge $this._blinkFrameInterval) {\r\n            $this._showCursor = -not $this._showCursor\r\n            $this._blinkFrameCount = 0\r\n        }\r\n\r\n        $this.RegisterLayout($engine)\r\n\r\n        # Colors (Ints)\r\n        # Use Panel background\r\n        $bg = $this.GetThemedBgInt('Background.Panel', 1, 0)\r\n        # Fallback removed - strict theme enforcement\r\n\r\n        $fg = $this.GetThemedInt('Foreground.Row')\r\n        $borderFg = $this.GetThemedInt('Border.Widget')\r\n        $primaryFg = $this.GetThemedInt('Foreground.Title')\r\n        $mutedFg = $this.GetThemedInt('Foreground.Muted')\r\n        $errorFg = $this.GetThemedInt('Foreground.Error')\r\n        $highlightBg = $this.GetThemedBgInt('Background.RowSelected', 1, 0)\r\n        $highlightFg = $this.GetThemedInt('Foreground.RowSelected')\r\n        \r\n        # Draw Box\r\n        $engine.Fill($this.X, $this.Y, $this.Width, $this.Height, ' ', $fg, $bg)\r\n        $engine.DrawBox($this.X, $this.Y, $this.Width, $this.Height, $borderFg, $bg)\r\n        \r\n        # Title\r\n        $title = \" $($this.Label) \"\r\n        $pad = [Math]::Max(0, [Math]::Floor(($this.Width - 4 - $title.Length) / 2))\r\n        $engine.WriteAt($this.X + 2 + $pad, $this.Y + 1, $title, $primaryFg, $bg)\r\n        \r\n        # Count\r\n        $countText = \"($($this._selectedTags.Count)/$($this.MaxTags))\"\r\n        $countX = $this.X + $this.Width - $countText.Length - 2\r\n        if ($countX -gt $this.X + 2) {\r\n            $engine.WriteAt($countX, $this.Y + 1, $countText, $mutedFg, $bg)\r\n        }\r\n        \r\n        # Chips & Input Area\r\n        $chipsX = $this.X + 2\r\n        $chipsY = $this.Y + 2\r\n        $chipsWidth = $this.Width - 4\r\n        $chipsHeight = 2\r\n        \r\n        $currentX = $chipsX\r\n        $currentY = $chipsY\r\n        $maxX = $chipsX + $chipsWidth\r\n        $maxY = $chipsY + $chipsHeight\r\n        \r\n        # Draw Chips\r\n        foreach ($tag in $this._selectedTags) {\r\n            $chipText = \"[$tag]\"\r\n            $chipLen = $tag.Length + 2\r\n            \r\n            if ($currentX + $chipLen + 1 -gt $maxX) {\r\n                $currentX = $chipsX\r\n                $currentY++\r\n            }\r\n            \r\n            if ($currentY -ge $maxY) { break }\r\n            \r\n            # Get chip color (Int)\r\n            $ansiColor = $this._GetChipColor($tag)\r\n            $chipFg = [HybridRenderEngine]::AnsiColorToInt($ansiColor)\r\n            \r\n            $engine.WriteAt($currentX, $currentY, $chipText, $chipFg, $bg)\r\n            $currentX += $chipLen + 1\r\n        }\r\n        \r\n        # Draw Input\r\n        if ($currentY -lt $maxY) {\r\n            $inputSpace = $maxX - $currentX\r\n            if ($inputSpace -lt 15) {\r\n                # Need new line?\r\n                $currentX = $chipsX\r\n                $currentY++\r\n            }\r\n            \r\n            if ($currentY -lt $maxY) {\r\n                $prefix = if ([string]::IsNullOrEmpty($this._inputText)) { \"type tag...\" } else { $this._inputText }\r\n                $pColor = if ([string]::IsNullOrEmpty($this._inputText)) { $mutedFg } else { $fg }\r\n                \r\n                # Highlight cursor\r\n                if ([string]::IsNullOrEmpty($this._inputText)) {\r\n                    $engine.WriteAt($currentX, $currentY, $prefix, $pColor, $bg)\r\n                }\r\n                else {\r\n                    # Simple cursor\r\n                    $engine.WriteAt($currentX, $currentY, $prefix, $pColor, $bg)\r\n                    if ($this._cursorPosition -lt $prefix.Length) {\r\n                        $char = $prefix[$this._cursorPosition]\r\n                        $engine.WriteAt($currentX + $this._cursorPosition, $currentY, \"$char\", $bg, $pColor) # Invert\r\n                    }\r\n                    elseif ($this._cursorPosition -eq $prefix.Length) {\r\n                        $engine.WriteAt($currentX + $this._cursorPosition, $currentY, \" \", $bg, $pColor)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        # Autocomplete (Overlay)\r\n        if ($this._showAutocomplete -and $this._autocompleteMatches.Count -gt 0) {\r\n            $acX = $this.X + 4\r\n            $acY = $this.Y + 3\r\n            if ($acY -ge $this.Y + $this.Height) { $acY = $this.Y + $this.Height - 1 } # Clamp/Adjust?\r\n            # Actually Autocomplete usually floats.\r\n            \r\n            $acWidth = $this.Width - 8\r\n            $acHeight = [Math]::Min(3, $this._autocompleteMatches.Count) + 2\r\n            \r\n            # Using BeginLayer to ensure popup is on top (if engine supports it, but we are inside widget)\r\n            # We can just draw over since we render last?\r\n            \r\n            $engine.Fill($acX, $acY, $acWidth, $acHeight, ' ', $fg, $bg)\r\n            $engine.DrawBox($acX, $acY, $acWidth, $acHeight, $borderFg, $bg)\r\n            \r\n            for ($i = 0; $i -lt [Math]::Min(3, $this._autocompleteMatches.Count); $i++) {\r\n                $tag = $this._autocompleteMatches[$i]\r\n                $isSel = ($i -eq $this._selectedAutocompleteIndex)\r\n                $itemFg = if ($isSel) { $highlightFg } else { $mutedFg }\r\n                $itemBg = if ($isSel) { $highlightBg } else { $bg }\r\n                \r\n                $engine.Fill($acX + 1, $acY + 1 + $i, $acWidth - 2, 1, ' ', $itemFg, $itemBg)\r\n                $engine.WriteAt($acX + 1, $acY + 1 + $i, $tag, $itemFg, $itemBg)\r\n            }\r\n        }\r\n        \r\n        # Help\r\n        $helpText = \"Tab/Enter=Add | Backspace=Remove | Esc=Cancel\"\r\n        $engine.WriteAt($this.X + 2, $this.Y + $this.Height - 2, $this.PadText($helpText, $this.Width - 4, 'left'), $mutedFg, $bg)\r\n        \r\n        # Error\r\n        if ($this._errorMessage) {\r\n            $engine.WriteAt($this.X + 2, $this.Y + $this.Height - 1, $this._errorMessage, $errorFg, $bg)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render the tag editor widget\r\n\r\n    .OUTPUTS\r\n    ANSI string ready for display\r\n    ##CLOSEBRACKET##\r\n    [string] Render() {\r\n        $sb = [StringBuilder]::new(2048)\r\n\r\n        # Colors from new theme system\r\n        $borderColor = $this.GetThemedFg('Border.Widget')\r\n        $textColor = $this.GetThemedFg('Foreground.Row')\r\n        $primaryColor = $this.GetThemedFg('Foreground.Title')\r\n        $mutedColor = $this.GetThemedFg('Foreground.Muted')\r\n        $errorColor = $this.GetThemedFg('Foreground.Error')\r\n        $successColor = $this.GetThemedFg('Foreground.Success')\r\n        $highlightBg = $this.GetThemedBg('Background.RowSelected', 1, 0)\r\n        $highlightFg = $this.GetThemedFg('Foreground.RowSelected')\r\n        $reset = \"`e[0m\"\r\n\r\n        # Reset any inherited formatting from parent\r\n        $sb.Append($reset)\r\n\r\n        # Draw top border\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.BuildBoxBorder($this.Width, 'top', 'single'))\r\n\r\n        # Title\r\n        $title = \" $($this.Label) \"\r\n        $titlePos = 2\r\n        $sb.Append($this.BuildMoveTo($this.X + $titlePos, $this.Y))\r\n        $sb.Append($primaryColor)\r\n        $sb.Append($title)\r\n\r\n        # Tag count\r\n        $countText = \"($($this._selectedTags.Count)/$($this.MaxTags))\"\r\n        $sb.Append($this.BuildMoveTo($this.X + $this.Width - $countText.Length - 2, $this.Y))\r\n        $sb.Append($mutedColor)\r\n        $sb.Append($countText)\r\n\r\n        # Chips and input area (rows 1-2)\r\n        $chipRow1Y = $this.Y + 1\r\n        $chipRow2Y = $this.Y + 2\r\n\r\n        # Build chip display\r\n        $chipsText = $this._BuildChipsDisplay()\r\n\r\n        # Render chips across two rows if needed\r\n        $sb.Append($this.BuildMoveTo($this.X, $chipRow1Y))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        $innerWidth = $this.Width - 4\r\n        $currentX = 0\r\n        $currentY = 0\r\n\r\n        # Render chips\r\n        foreach ($tag in $this._selectedTags) {\r\n            $chipText = $this._FormatChip($tag)\r\n            $chipDisplayLen = $tag.Length + 3  # [tag] length\r\n\r\n            # Check if we need to wrap to next row\r\n            if ($currentX + $chipDisplayLen -gt $innerWidth) {\r\n                # Fill rest of current row\r\n                $padding = $innerWidth - $currentX\r\n                $sb.Append(\" \" * $padding)\r\n\r\n                # Move to next row\r\n                $currentY++\r\n                $currentX = 0\r\n\r\n                if ($currentY -ge 2) {\r\n                    # Out of space, stop rendering chips\r\n                    break\r\n                }\r\n\r\n                # Draw border for new row\r\n                $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $chipRow1Y + $currentY - 1))\r\n                $sb.Append($borderColor)\r\n                $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n                $sb.Append($this.BuildMoveTo($this.X, $chipRow1Y + $currentY))\r\n                $sb.Append($borderColor)\r\n                $sb.Append($this.GetBoxChar('single_vertical'))\r\n            }\r\n\r\n            # Position for chip\r\n            if ($currentX -eq 0) {\r\n                $sb.Append($this.BuildMoveTo($this.X + 2, $chipRow1Y + $currentY))\r\n            }\r\n\r\n            # Render chip\r\n            $chipColor = $this._GetChipColor($tag)\r\n            $sb.Append($chipColor)\r\n            $sb.Append($chipText)\r\n            $sb.Append($reset)\r\n            $sb.Append(\" \")\r\n\r\n            $currentX += $chipDisplayLen + 1  # +1 for space\r\n        }\r\n\r\n        # Input field on same row or next row\r\n        $inputFieldY = $chipRow1Y + $currentY\r\n        $inputStartX = $currentX\r\n\r\n        # Check if we need new row for input\r\n        $inputSpaceNeeded = 15  # Minimum space for input\r\n        if ($inputStartX + $inputSpaceNeeded -gt $innerWidth) {\r\n            # Move input to next row\r\n            $currentY++\r\n            $inputFieldY = $chipRow1Y + $currentY\r\n            $inputStartX = 0\r\n\r\n            # Fill rest of current row\r\n            if ($currentX -lt $innerWidth) {\r\n                $padding = $innerWidth - $currentX\r\n                $sb.Append(\" \" * $padding)\r\n            }\r\n\r\n            # Draw border for current row\r\n            $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $chipRow1Y + $currentY - 1))\r\n            $sb.Append($borderColor)\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n            # Start new row\r\n            $sb.Append($this.BuildMoveTo($this.X, $inputFieldY))\r\n            $sb.Append($borderColor)\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n        }\r\n\r\n        # Render input field\r\n        if ($inputFieldY -lt $chipRow2Y + 1) {\r\n            $sb.Append($this.BuildMoveTo($this.X + 2 + $inputStartX, $inputFieldY))\r\n\r\n            if ([string]::IsNullOrEmpty($this._inputText)) {\r\n                $sb.Append($mutedColor)\r\n                $sb.Append(\"type tag...\")\r\n                $inputDisplayLen = 11\r\n            }\r\n            else {\r\n                $sb.Append($textColor)\r\n\r\n                # Render text with cursor\r\n                $displayText = $this._inputText\r\n                $maxInputWidth = $innerWidth - $inputStartX\r\n\r\n                if ($displayText.Length -gt $maxInputWidth) {\r\n                    $displayText = $displayText.Substring(0, $maxInputWidth)\r\n                }\r\n\r\n                # Text before cursor\r\n                if ($this._cursorPosition -gt 0 -and $this._cursorPosition -le $displayText.Length) {\r\n                    $sb.Append($displayText.Substring(0, $this._cursorPosition))\r\n                }\r\n\r\n                # Cursor and text after\r\n                if ($this._cursorPosition -lt $displayText.Length) {\r\n                    # Cursor on character\r\n                    $sb.Append(\"`e[7m\")\r\n                    $sb.Append($displayText[$this._cursorPosition])\r\n                    $sb.Append(\"`e[27m\")\r\n\r\n                    # Text after cursor\r\n                    if ($this._cursorPosition + 1 -lt $displayText.Length) {\r\n                        $sb.Append($displayText.Substring($this._cursorPosition + 1))\r\n                    }\r\n                }\r\n                else {\r\n                    # Cursor at end - show block cursor\r\n                    $sb.Append(\"`e[7m `e[27m\")\r\n                }\r\n\r\n                $inputDisplayLen = $displayText.Length + 1\r\n            }\r\n\r\n            # Padding for input row\r\n            $remainingSpace = $innerWidth - $inputStartX - $inputDisplayLen\r\n            if ($remainingSpace -gt 0) {\r\n                $sb.Append(\" \" * $remainingSpace)\r\n            }\r\n        }\r\n\r\n        # Complete all rows with borders\r\n        for ($row = 0; $row -le 1; $row++) {\r\n            $rowY = $chipRow1Y + $row\r\n\r\n            # Right border\r\n            $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $rowY))\r\n            $sb.Append($borderColor)\r\n            $sb.Append($this.GetBoxChar('single_vertical'))\r\n        }\r\n\r\n        # Autocomplete dropdown (if shown)\r\n        if ($this._showAutocomplete -and $this._autocompleteMatches.Count -gt 0) {\r\n            $acRow = $chipRow2Y + 1\r\n            $maxAcItems = [Math]::Min(3, $this._autocompleteMatches.Count)\r\n\r\n            for ($i = 0; $i -lt $maxAcItems; $i++) {\r\n                $acY = $acRow + $i\r\n                if ($acY -ge $this.Y + $this.Height - 1) {\r\n                    break\r\n                }\r\n\r\n                $sb.Append($this.BuildMoveTo($this.X, $acY))\r\n                $sb.Append($borderColor)\r\n                $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n                $sb.Append($this.BuildMoveTo($this.X + 4, $acY))\r\n\r\n                $tag = $this._autocompleteMatches[$i]\r\n                if ($i -eq $this._selectedAutocompleteIndex) {\r\n                    $sb.Append($highlightBg)\r\n                    $sb.Append($highlightFg)\r\n                }\r\n                else {\r\n                    $sb.Append($mutedColor)\r\n                }\r\n\r\n                $sb.Append($this.TruncateText($tag, $this.Width - 6))\r\n                $sb.Append($reset)\r\n\r\n                $displayLen = [Math]::Min($tag.Length, $this.Width - 6)\r\n                $padding = $this.Width - 6 - $displayLen\r\n                if ($padding -gt 0) {\r\n                    $sb.Append(\" \" * $padding)\r\n                }\r\n\r\n                $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $acY))\r\n                $sb.Append($borderColor)\r\n                $sb.Append($this.GetBoxChar('single_vertical'))\r\n            }\r\n        }\r\n\r\n        # Help/status row\r\n        $helpRowY = $this.Y + $this.Height - 2\r\n        $sb.Append($this.BuildMoveTo($this.X, $helpRowY))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        $sb.Append($this.BuildMoveTo($this.X + 2, $helpRowY))\r\n        $sb.Append($mutedColor)\r\n        $helpText = \"Tab/Enter=Add | Backspace=Remove | Esc=Done\"\r\n        $sb.Append($this.TruncateText($helpText, $this.Width - 4))\r\n\r\n        $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $helpRowY))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        # Bottom border\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y + $this.Height - 1))\r\n        $sb.Append($borderColor)\r\n        $sb.Append($this.BuildBoxBorder($this.Width, 'bottom', 'single'))\r\n\r\n        # Error message in bottom border\r\n        if (-not [string]::IsNullOrWhiteSpace($this._errorMessage)) {\r\n            $errorMsg = \" $($this._errorMessage) \"\r\n            $sb.Append($this.BuildMoveTo($this.X + 2, $this.Y + $this.Height - 1))\r\n            $sb.Append($errorColor)\r\n            $sb.Append($this.TruncateText($errorMsg, $this.Width - 4))\r\n        }\r\n\r\n        $sb.Append($reset)\r\n        return $sb.ToString()\r\n    }\r\n\r\n    # === Private Helper Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Load known tags from all tasks in PMC data\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _LoadKnownTags() {\r\n        try {\r\n            $data = Get-PmcData\r\n            $tagSet = [HashSet[string]]::new()\r\n\r\n            if ($null -ne $data.tasks) {\r\n                foreach ($task in $data.tasks) {\r\n                    if ($null -ne $task.tags -and $task.tags.Count -gt 0) {\r\n                        foreach ($tag in $task.tags) {\r\n                            if (-not [string]::IsNullOrWhiteSpace($tag)) {\r\n                                [void]$tagSet.Add($tag.ToString().Trim())\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            $this._allKnownTags = @($tagSet | Sort-Object)\r\n            $this._lastTagRefresh = [DateTime]::Now\r\n        }\r\n        catch {\r\n            # Failed to load tags - use empty array\r\n            $this._allKnownTags = @()\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Update autocomplete suggestions based on current input\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _UpdateAutocomplete() {\r\n        if ([string]::IsNullOrWhiteSpace($this._inputText)) {\r\n            $this._showAutocomplete = $false\r\n            $this._autocompleteMatches = @()\r\n            return\r\n        }\r\n\r\n        $inputLower = $this._inputText.ToLower()\r\n        $matches = @()\r\n\r\n        foreach ($tag in $this._allKnownTags) {\r\n            # Skip already selected tags\r\n            if ($this._selectedTags.Contains($tag)) {\r\n                continue\r\n            }\r\n\r\n            # Match tags starting with input\r\n            if ($tag.ToLower().StartsWith($inputLower)) {\r\n                $matches += $tag\r\n            }\r\n        }\r\n\r\n        $this._autocompleteMatches = $matches\r\n        $this._showAutocomplete = $matches.Count -gt 0\r\n        $this._selectedAutocompleteIndex = 0\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Add current input text as a tag\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _AddCurrentInputAsTag() {\r\n        $tagText = $this._inputText.Trim()\r\n\r\n        if ([string]::IsNullOrWhiteSpace($tagText)) {\r\n            return\r\n        }\r\n\r\n        if ($this._selectedTags.Contains($tagText)) {\r\n            $this._errorMessage = \"Tag already added\"\r\n            $this._inputText = \"\"\r\n            $this._cursorPosition = 0\r\n            $this._showAutocomplete = $false\r\n            return\r\n        }\r\n\r\n        if ($this._selectedTags.Count -ge $this.MaxTags) {\r\n            $this._errorMessage = \"Max $($this.MaxTags) tags\"\r\n            return\r\n        }\r\n\r\n        # Check if tag exists in known tags or if we allow new tags\r\n        $isKnown = $this._allKnownTags -contains $tagText\r\n        if (-not $isKnown -and -not $this.AllowNewTags) {\r\n            $this._errorMessage = \"Unknown tag (use existing tags)\"\r\n            return\r\n        }\r\n\r\n        $this._selectedTags.Add($tagText)\r\n        $this._inputText = \"\"\r\n        $this._cursorPosition = 0\r\n        $this._showAutocomplete = $false\r\n        $this._errorMessage = \"\"\r\n\r\n        $this._InvokeCallback($this.OnTagsChanged, $this.GetTags())\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Build display string for all chips\r\n\r\n    .OUTPUTS\r\n    String containing all chip representations\r\n    ##CLOSEBRACKET##\r\n    hidden [string] _BuildChipsDisplay() {\r\n        $sb = [StringBuilder]::new()\r\n\r\n        foreach ($tag in $this._selectedTags) {\r\n            $sb.Append($this._FormatChip($tag))\r\n            $sb.Append(\" \")\r\n        }\r\n\r\n        return $sb.ToString()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Format a single chip with color\r\n\r\n    .PARAMETER tag\r\n    Tag text\r\n\r\n    .OUTPUTS\r\n    ANSI-colored chip string\r\n    ##CLOSEBRACKET##\r\n    hidden [string] _FormatChip([string]$tag) {\r\n        return \"[$tag]\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get color for a tag chip (consistent color based on tag name)\r\n\r\n    .PARAMETER tag\r\n    Tag text\r\n\r\n    .OUTPUTS\r\n    ANSI color sequence\r\n    ##CLOSEBRACKET##\r\n    hidden [string] _GetChipColor([string]$tag) {\r\n        # Hash tag name to get consistent color\r\n        $hash = 0\r\n        foreach ($char in $tag.ToCharArray()) {\r\n            $hash = ($hash * 31 + [int]$char) % 2147483647\r\n        }\r\n\r\n        $colorIndex = $hash % $this._chipColors.Count\r\n        $hex = $this._chipColors[$colorIndex]\r\n\r\n        # Convert hex to RGB\r\n        $hex = $hex.TrimStart('#')\r\n        $r = [Convert]::ToInt32($hex.Substring(0, 2), 16)\r\n        $g = [Convert]::ToInt32($hex.Substring(2, 2), 16)\r\n        $b = [Convert]::ToInt32($hex.Substring(4, 2), 16)\r\n\r\n        return \"`e[38;2;${r};${g};${b}m\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Invoke a callback scriptblock safely\r\n\r\n    .PARAMETER callback\r\n    Scriptblock to invoke\r\n\r\n    .PARAMETER args\r\n    Arguments to pass\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _InvokeCallback([scriptblock]$callback, $args) {\r\n        if ($null -ne $callback) {\r\n            try {\r\n                if ($null -ne $args) {\r\n                    & $callback $args\r\n                }\r\n                else {\r\n                    & $callback\r\n                }\r\n            }\r\n            catch {\r\n                # Callback failed - log but don't crash widget\r\n            }\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/widgets/TextAreaEditor.ps1", "content": "# TextAreaEditor.ps1 - Full-featured multiline text editor for PMC ConsoleUI\n# Ported from Praxis FullNotesEditor with adaptations for PMC\n# Features: Gap buffer, undo/redo, word navigation, auto-save, scrolling, selection, copy/paste, find/replace\n\nSet-StrictMode -Version Latest\n\n# Selection mode enum\nenum SelectionMode {\n    None\n    Stream      # Normal selection (character-based)\n    Block       # Rectangular/column selection\n}\n\nclass TextAreaEditor : PmcWidget {\n    # Widget position and size (Inherited from PmcWidget)\n    # [int]$X = 0\n    # [int]$Y = 0\n    # [int]$Width = 80\n    # [int]$Height = 24\n\n    # The actual text content using gap buffer\n    hidden [GapBuffer]$_gapBuffer\n\n    # Line tracking for efficient operations\n    hidden [System.Collections.ArrayList]$_lineStarts\n    hidden [bool]$_lineIndexDirty = $true\n\n    # Cursor position\n    [int]$CursorX = 0\n    [int]$CursorY = 0\n    [int]$ScrollOffsetY = 0\n    [int]$ScrollOffsetX = 0\n\n    # Selection state\n    [SelectionMode]$SelectionMode = [SelectionMode]::None\n    [int]$SelectionAnchorX = 0  # Where selection started\n    [int]$SelectionAnchorY = 0\n    [int]$SelectionEndX = 0     # Where selection ends (current cursor)\n    [int]$SelectionEndY = 0\n\n    # Internal clipboard (app-only, performant)\n    static [string]$_clipboard = \"\"\n\n    # Undo/redo with full state tracking\n    hidden [System.Collections.ArrayList]$_undoStack\n    hidden [System.Collections.ArrayList]$_redoStack\n\n    # Editor settings\n    [string]$Style = \"\"\n    [int]$TabWidth = 4\n    [bool]$Modified = $false\n    [bool]$EnableUndo = $false  # PERFORMANCE: Undo disabled by default for responsiveness\n    [bool]$ShowStatistics = $false\n    [bool]$ShowCursor = $false  # Controls cursor visibility (for focus)\n\n    # File info\n    [string]$FilePath = \"\"\n    hidden [string]$_originalText = \"\"\n    hidden [datetime]$_lastSaveTime = [datetime]::MinValue\n\n    TextAreaEditor() : base(\"TextAreaEditor\") {\n        $this._gapBuffer = [GapBuffer]::new()\n        $this._gapBuffer.Insert(0, \"\")  # Start with empty content\n        $this._lineStarts = [System.Collections.ArrayList]::new()\n        $this._undoStack = [System.Collections.ArrayList]::new()\n        $this._redoStack = [System.Collections.ArrayList]::new()\n        $this.BuildLineIndex()\n        \n        $this.Width = 80\n        $this.Height = 24\n        $this.CanFocus = $true\n    }\n\n    [void] SetBounds([int]$x, [int]$y, [int]$width, [int]$height) {\n        $this.X = $x\n        $this.Y = $y\n        $this.Width = $width\n        $this.Height = $height\n    }\n\n    [void] SetText([string]$text) {\n        # Store original text for comparison\n        $this._originalText = $text\n\n        # Clear buffer and insert new text\n        $this._gapBuffer.Delete(0, $this._gapBuffer.GetLength())\n        if ([string]::IsNullOrEmpty($text)) {\n            $this._gapBuffer.Insert(0, \"\")\n        }\n        else {\n            $this._gapBuffer.Insert(0, $text)\n        }\n\n        $this.BuildLineIndex()\n        $this.CursorX = 0\n        $this.CursorY = 0\n        $this.ScrollOffsetY = 0\n        $this.ScrollOffsetX = 0\n        $this.Modified = $false\n        $this._undoStack.Clear()\n        $this._redoStack.Clear()\n        $this._lastSaveTime = [datetime]::Now\n    }\n\n    [string] GetText() {\n        return $this._gapBuffer.GetText()\n    }\n\n    [object] GetStatistics() {\n        # Performance optimization: Don't calculate if disabled\n        if (-not $this.ShowStatistics) {\n            return [PSCustomObject]@{\n                Lines = 0\n                Words = 0\n                Chars = 0\n            }\n        }\n\n        # Use optimized C# implementation from GapBuffer if available\n        # This avoids allocating the full string and regex matching\n        if ($this._gapBuffer.PSObject.Methods['GetContentStatistics']) {\n            $stats = $this._gapBuffer.GetContentStatistics()\n            return [PSCustomObject]@{\n                Lines = $stats.Lines\n                Words = $stats.Words\n                Chars = $stats.Chars\n            }\n        }\n\n        # Fallback (slow path)\n        $text = $this.GetText()\n        $lines = $this.GetLineCount()\n        $words = @($text -split '\\s+' | Where-Object { $_ }).Count\n        $chars = $text.Length\n        \n        return [PSCustomObject]@{\n            Lines = $lines\n            Words = $words\n            Chars = $chars\n        }\n    }\n\n    # Build line index for efficient line operations\n    hidden [void] BuildLineIndex() {\n        $this._lineStarts.Clear()\n        $this._lineStarts.Add(0) | Out-Null  # First line starts at position 0\n\n        # Optimized: Use GapBuffer.FindAll to get all newlines at once\n        $newlines = $this._gapBuffer.FindAll(\"`n\")\n        foreach ($index in $newlines) {\n            $this._lineStarts.Add($index + 1) | Out-Null\n        }\n\n        $this._lineIndexDirty = $false\n    }\n\n    [int] GetLineCount() {\n        if ($this._lineIndexDirty) {\n            $this.BuildLineIndex()\n        }\n        return [Math]::Max(1, $this._lineStarts.Count)\n    }\n\n    [string] GetLine([int]$lineIndex) {\n        if ($this._lineIndexDirty) {\n            $this.BuildLineIndex()\n        }\n\n        if ($lineIndex -lt 0 -or $lineIndex -ge $this.GetLineCount()) {\n            return \"\"\n        }\n\n        $lineStart = $this._lineStarts[$lineIndex]\n        $lineEnd = $(if ($lineIndex + 1 -lt $this._lineStarts.Count) {\n                $this._lineStarts[$lineIndex + 1] - 1\n            }\n            else {\n                $this._gapBuffer.GetLength()\n            })\n\n        # Exclude the newline character\n        if ($lineEnd -gt $lineStart -and $this._gapBuffer.GetChar($lineEnd - 1) -eq \"`n\") {\n            $lineEnd--\n        }\n\n        $lineLength = [Math]::Max(0, $lineEnd - $lineStart)\n        if ($lineLength -eq 0) {\n            return \"\"\n        }\n\n        return $this._gapBuffer.GetText($lineStart, $lineLength)\n    }\n\n    # Get position in buffer from line/column\n    hidden [int] GetPositionFromLineCol([int]$line, [int]$col) {\n        if ($this._lineIndexDirty) {\n            $this.BuildLineIndex()\n        }\n\n        if ($line -lt 0 -or $line -ge $this.GetLineCount()) {\n            return -1\n        }\n\n        $lineStart = $this._lineStarts[$line]\n        $lineText = $this.GetLine($line)\n        $actualCol = [Math]::Min($col, $lineText.Length)\n\n        return $lineStart + $actualCol\n    }\n\n    # === Layout System ===\n    # RenderToEngine implementation (replaces Render)\n    [void] RenderToEngine([object]$engine) {\n        # Ensure bounds are valid\n        if ($this.Width -le 0 -or $this.Height -le 0) {\n            return\n        }\n\n        # Theme colors - use consistent theme for ALL text\n        $textFg = $this.GetThemedInt('Foreground.Row')\n        $textBg = $this.GetThemedBgInt('Background.Field', 1, 0)\n        $selFg = $this.GetThemedInt('Foreground.RowSelected')\n        $selBg = $this.GetThemedBgInt('Background.RowSelected', 1, 0)\n        $cursorBg = $this.GetThemedBgInt('Background.RowSelected', 1, 0)\n        \n        # Fallback colors removed for strict theme enforcement\n        # if ($textBg -eq -1) { $textBg = [HybridRenderEngine]::_PackRGB(30, 30, 30) }\n        # if ($selBg -eq -1) { $selBg = [HybridRenderEngine]::_PackRGB(0, 80, 160) }\n        # if ($cursorBg -eq -1) { $cursorBg = [HybridRenderEngine]::_PackRGB(200, 200, 200) }\n\n        # Draw background\n        for ($r = 0; $r -lt $this.Height; $r++) {\n            $engine.WriteAt($this.X, $this.Y + $r, (\" \" * $this.Width), $textFg, $textBg)\n        }\n\n        # Normalize selection bounds\n        $hasSelection = ($this.SelectionMode -ne [SelectionMode]::None)\n        $selStartLine = 0; $selEndLine = 0; $selStartCol = 0; $selEndCol = 0\n        if ($hasSelection) {\n            $selStartLine = [Math]::Min($this.SelectionAnchorY, $this.SelectionEndY)\n            $selEndLine = [Math]::Max($this.SelectionAnchorY, $this.SelectionEndY)\n            if ($selStartLine -eq $selEndLine) {\n                $selStartCol = [Math]::Min($this.SelectionAnchorX, $this.SelectionEndX)\n                $selEndCol = [Math]::Max($this.SelectionAnchorX, $this.SelectionEndX)\n            } else {\n                if ($this.SelectionAnchorY -lt $this.SelectionEndY) {\n                    $selStartCol = $this.SelectionAnchorX\n                    $selEndCol = $this.SelectionEndX\n                } else {\n                    $selStartCol = $this.SelectionEndX\n                    $selEndCol = $this.SelectionAnchorX\n                }\n            }\n        }\n\n        # Calculate visible range\n        $startLine = $this.ScrollOffsetY\n        $endLine = [Math]::Min($this.GetLineCount() - 1, $startLine + $this.Height - 1)\n\n        # Draw text content with selection highlighting\n        for ($i = 0; $i -le ($endLine - $startLine); $i++) {\n            $lineIndex = $startLine + $i\n            $lineText = $this.GetLine($lineIndex)\n            $screenY = $this.Y + $i\n            \n            # Handle horizontal scrolling\n            $visibleStart = $this.ScrollOffsetX\n            $visibleEnd = [Math]::Min($lineText.Length, $visibleStart + $this.Width)\n            \n            if ($visibleStart -lt $lineText.Length) {\n                $visibleText = $lineText.Substring($visibleStart, [Math]::Min($this.Width, $lineText.Length - $visibleStart))\n                \n                # Check if this line has selection\n                if ($hasSelection -and $lineIndex -ge $selStartLine -and $lineIndex -le $selEndLine) {\n                    # Determine selection range on this line\n                    $lineSelStart = 0\n                    $lineSelEnd = $lineText.Length\n                    \n                    if ($this.SelectionMode -eq [SelectionMode]::Block) {\n                        # Block Selection: Fixed columns for all lines\n                        $blockStart = [Math]::Min($this.SelectionAnchorX, $this.SelectionEndX)\n                        $blockEnd = [Math]::Max($this.SelectionAnchorX, $this.SelectionEndX)\n                        \n                        $lineSelStart = $blockStart\n                        $lineSelEnd = $blockEnd\n                    }\n                    else {\n                        # Stream Selection\n                        if ($lineIndex -eq $selStartLine) { $lineSelStart = $selStartCol }\n                        if ($lineIndex -eq $selEndLine) { $lineSelEnd = $selEndCol }\n                    }\n                    \n                    # Adjust for scroll offset\n                    $lineSelStart = [Math]::Max(0, $lineSelStart - $visibleStart)\n                    $lineSelEnd = [Math]::Max(0, $lineSelEnd - $visibleStart)\n                    $lineSelEnd = [Math]::Min($lineSelEnd, $this.Width)\n                    \n                    # Draw text in three parts: before, selected, after\n                    if ($lineSelStart -gt 0) {\n                        $beforeText = $visibleText.Substring(0, [Math]::Min($lineSelStart, $visibleText.Length))\n                        $engine.WriteAt($this.X, $screenY, $beforeText, $textFg, $textBg)\n                    }\n                    if ($lineSelEnd -gt $lineSelStart -and $lineSelStart -lt $visibleText.Length) {\n                        $selText = $visibleText.Substring($lineSelStart, [Math]::Min($lineSelEnd - $lineSelStart, $visibleText.Length - $lineSelStart))\n                        $engine.WriteAt($this.X + $lineSelStart, $screenY, $selText, $selFg, $selBg)\n                    }\n                    if ($lineSelEnd -lt $visibleText.Length) {\n                        $afterText = $visibleText.Substring($lineSelEnd)\n                        $engine.WriteAt($this.X + $lineSelEnd, $screenY, $afterText, $textFg, $textBg)\n                    }\n                } else {\n                    # No selection on this line\n                    $engine.WriteAt($this.X, $screenY, $visibleText, $textFg, $textBg)\n                }\n            }\n        }\n\n        # Draw cursor (inverted character at cursor position) - ONLY if ShowCursor is true\n        if ($this.ShowCursor) {\n            $cursorScreenY = $this.CursorY - $this.ScrollOffsetY\n            $cursorScreenX = $this.CursorX - $this.ScrollOffsetX\n            if ($cursorScreenY -ge 0 -and $cursorScreenY -lt $this.Height -and $cursorScreenX -ge 0 -and $cursorScreenX -lt $this.Width) {\n                $cursorLine = $this.GetLine($this.CursorY)\n                $cursorChar = \" \"  # Default to space for end-of-line cursor\n                if ($this.CursorX -ge 0 -and $this.CursorX -lt $cursorLine.Length) {\n                    # Get character at cursor position as string\n                    $cursorChar = [string]$cursorLine.Substring($this.CursorX, 1)\n                }\n                # Draw cursor with high contrast (use selection foreground which is usually white/bright)\n                $engine.WriteAt($this.X + $cursorScreenX, $this.Y + $cursorScreenY, $cursorChar, $selFg, $cursorBg)\n            }\n        }\n    }\n\n    hidden [bool] IsLineSelected([int]$line, [int]$startLine, [int]$endLine, [int]$startCol, [int]$endCol) {\n        if ($this.SelectionMode -eq [SelectionMode]::None) {\n            return $false\n        }\n\n        if ($line -lt $startLine -or $line -gt $endLine) {\n            return $false\n        }\n\n        if ($this.SelectionMode -eq [SelectionMode]::Stream) {\n            # Stream selection\n            if ($line -eq $startLine -and $line -eq $endLine) {\n                return $true # Simplified: assumes if line is in range, it has some selection\n            }\n            elseif ($line -eq $startLine) {\n                return $true\n            }\n            elseif ($line -eq $endLine) {\n                return $true\n            }\n            else {\n                return $true\n            }\n        }\n        elseif ($this.SelectionMode -eq [SelectionMode]::Block) {\n            # Block selection\n            return $true\n        }\n\n        return $false\n    }\n\n    # Legacy Render() removed in favor of RenderToEngine\n    [string] Render() { return \"\" }\n\n    [void] RenderLineWithSelection([System.Text.StringBuilder]$sb, [string]$text, [int]$lineIndex) {\n        # Legacy method stub\n    }\n\n    [bool] HandleInput([System.ConsoleKeyInfo]$key) {\n        $handled = $true\n        $isShift = $key.Modifiers -band [System.ConsoleModifiers]::Shift\n        $isCtrl = $key.Modifiers -band [System.ConsoleModifiers]::Control\n\n        # Save state for undo before modifications\n        if (-not ($key.Key -in @([System.ConsoleKey]::LeftArrow, [System.ConsoleKey]::RightArrow,\n                    [System.ConsoleKey]::UpArrow, [System.ConsoleKey]::DownArrow,\n                    [System.ConsoleKey]::Home, [System.ConsoleKey]::End))) {\n            $this.SaveUndoState()\n        }\n\n        switch ($key.Key) {\n            # Navigation with selection support\n            ([System.ConsoleKey]::LeftArrow) {\n                if ($isShift) {\n                    # Start or extend selection\n                    if ($this.SelectionMode -eq [SelectionMode]::None) {\n                        $mode = $(if ($isCtrl) { [SelectionMode]::Block } else { [SelectionMode]::Stream })\n                        $this.StartSelection($mode)\n                    }\n                    if ($isCtrl) { $this.MoveCursorWordLeft() } else { $this.MoveCursorLeft() }\n                    $this.ExtendSelection()\n                }\n                else {\n                    if ($this.SelectionMode -ne [SelectionMode]::None) { $this.ClearSelection() }\n                    if ($isCtrl) { $this.MoveCursorWordLeft() } else { $this.MoveCursorLeft() }\n                }\n            }\n            ([System.ConsoleKey]::RightArrow) {\n                if ($isShift) {\n                    if ($this.SelectionMode -eq [SelectionMode]::None) {\n                        $mode = $(if ($isCtrl) { [SelectionMode]::Block } else { [SelectionMode]::Stream })\n                        $this.StartSelection($mode)\n                    }\n                    if ($isCtrl) { $this.MoveCursorWordRight() } else { $this.MoveCursorRight() }\n                    $this.ExtendSelection()\n                }\n                else {\n                    if ($this.SelectionMode -ne [SelectionMode]::None) { $this.ClearSelection() }\n                    if ($isCtrl) { $this.MoveCursorWordRight() } else { $this.MoveCursorRight() }\n                }\n            }\n            ([System.ConsoleKey]::UpArrow) {\n                if ($isShift) {\n                    if ($this.SelectionMode -eq [SelectionMode]::None) {\n                        $mode = $(if ($isCtrl) { [SelectionMode]::Block } else { [SelectionMode]::Stream })\n                        $this.StartSelection($mode)\n                    }\n                    $this.MoveCursorUp()\n                    $this.ExtendSelection()\n                }\n                else {\n                    if ($this.SelectionMode -ne [SelectionMode]::None) { $this.ClearSelection() }\n                    $this.MoveCursorUp()\n                }\n            }\n            ([System.ConsoleKey]::DownArrow) {\n                if ($isShift) {\n                    if ($this.SelectionMode -eq [SelectionMode]::None) {\n                        $mode = $(if ($isCtrl) { [SelectionMode]::Block } else { [SelectionMode]::Stream })\n                        $this.StartSelection($mode)\n                    }\n                    $this.MoveCursorDown()\n                    $this.ExtendSelection()\n                }\n                else {\n                    if ($this.SelectionMode -ne [SelectionMode]::None) { $this.ClearSelection() }\n                    $this.MoveCursorDown()\n                }\n            }\n            ([System.ConsoleKey]::Home) {\n                if ($key.Modifiers -band [System.ConsoleModifiers]::Control) {\n                    $this.CursorX = 0\n                    $this.CursorY = 0\n                    $this.EnsureCursorVisible()\n                }\n                else {\n                    $this.CursorX = 0\n                    $this.EnsureCursorVisible()\n                }\n            }\n            ([System.ConsoleKey]::End) {\n                if ($key.Modifiers -band [System.ConsoleModifiers]::Control) {\n                    $this.CursorY = $this.GetLineCount() - 1\n                    $this.CursorX = $this.GetLine($this.CursorY).Length\n                    $this.EnsureCursorVisible()\n                }\n                else {\n                    $this.CursorX = $this.GetLine($this.CursorY).Length\n                    $this.EnsureCursorVisible()\n                }\n            }\n            ([System.ConsoleKey]::PageUp) {\n                $this.CursorY = [Math]::Max(0, $this.CursorY - $this.Height)\n                $this.EnsureCursorVisible()\n            }\n            ([System.ConsoleKey]::PageDown) {\n                $this.CursorY = [Math]::Min($this.GetLineCount() - 1, $this.CursorY + $this.Height)\n                $this.EnsureCursorVisible()\n            }\n\n            # Editing\n            ([System.ConsoleKey]::Enter) { $this.InsertNewLine() }\n            ([System.ConsoleKey]::Backspace) { $this.Backspace() }\n            ([System.ConsoleKey]::Delete) { $this.Delete() }\n            ([System.ConsoleKey]::Tab) { $this.InsertTab() }\n\n            # Undo/Redo\n            ([System.ConsoleKey]::Z) {\n                if ($key.Modifiers -band [System.ConsoleModifiers]::Control) {\n                    $this.Undo()\n                }\n                else {\n                    $this.InsertChar($key.KeyChar)\n                }\n            }\n\n            # Redo\n            ([System.ConsoleKey]::Y) {\n                if ($key.Modifiers -band [System.ConsoleModifiers]::Control) {\n                    $this.Redo()\n                }\n                else {\n                    $this.InsertChar($key.KeyChar)\n                }\n            }\n\n            # Select All\n            ([System.ConsoleKey]::A) {\n                if ($isCtrl) {\n                    $this.SelectAll()\n                }\n                else {\n                    $this.InsertChar($key.KeyChar)\n                }\n            }\n\n            # Copy\n            ([System.ConsoleKey]::C) {\n                if ($isCtrl) {\n                    $this.Copy()\n                }\n                else {\n                    $this.InsertChar($key.KeyChar)\n                }\n            }\n\n            # Cut\n            ([System.ConsoleKey]::X) {\n                if ($isCtrl) {\n                    $this.Cut()\n                }\n                else {\n                    $this.InsertChar($key.KeyChar)\n                }\n            }\n\n            # Paste\n            ([System.ConsoleKey]::V) {\n                if ($isCtrl) {\n                    $this.Paste()\n                }\n                else {\n                    $this.InsertChar($key.KeyChar)\n                }\n            }\n\n            # Find\n            ([System.ConsoleKey]::F) {\n                if ($isCtrl) {\n                    # Future feature: Implement find dialog with search highlighting\n                    # Reserved: Ctrl+F keybinding for future find functionality\n                    $handled = $false  # Let parent handle for now\n                }\n                else {\n                    $this.InsertChar($key.KeyChar)\n                }\n            }\n\n            # Replace\n            ([System.ConsoleKey]::H) {\n                if ($isCtrl) {\n                    # Future feature: Implement find/replace dialog with preview\n                    # Reserved: Ctrl+H keybinding for future replace functionality\n                    $handled = $false  # Let parent handle for now\n                }\n                else {\n                    $this.InsertChar($key.KeyChar)\n                }\n            }\n\n            # Escape - clear selection\n            ([System.ConsoleKey]::Escape) {\n                if ($this.SelectionMode -ne [SelectionMode]::None) {\n                    $this.ClearSelection()\n                }\n                else {\n                    $handled = $false\n                }\n            }\n\n            default {\n                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {\n                    $this.InsertChar($key.KeyChar)\n                }\n                else {\n                    $handled = $false\n                }\n            }\n        }\n\n        return $handled\n    }\n\n    # Cursor movement methods\n    [void] MoveCursorLeft() {\n        if ($this.CursorX -gt 0) {\n            $this.CursorX--\n        }\n        elseif ($this.CursorY -gt 0) {\n            $this.CursorY--\n            $this.CursorX = $this.GetLine($this.CursorY).Length\n        }\n        $this.EnsureCursorVisible()\n    }\n\n    [void] MoveCursorRight() {\n        $lineLength = $this.GetLine($this.CursorY).Length\n        if ($this.CursorX -lt $lineLength) {\n            $this.CursorX++\n        }\n        elseif ($this.CursorY -lt ($this.GetLineCount() - 1)) {\n            $this.CursorY++\n            $this.CursorX = 0\n        }\n        $this.EnsureCursorVisible()\n    }\n\n    [void] MoveCursorUp() {\n        if ($this.CursorY -gt 0) {\n            $this.CursorY--\n            $lineLength = $this.GetLine($this.CursorY).Length\n            $this.CursorX = [Math]::Min($this.CursorX, $lineLength)\n        }\n        $this.EnsureCursorVisible()\n    }\n\n    [void] MoveCursorDown() {\n        if ($this.CursorY -lt ($this.GetLineCount() - 1)) {\n            $this.CursorY++\n            $lineLength = $this.GetLine($this.CursorY).Length\n            $this.CursorX = [Math]::Min($this.CursorX, $lineLength)\n        }\n        $this.EnsureCursorVisible()\n    }\n\n    [void] MoveCursorWordLeft() {\n        # Move to previous word boundary\n        $line = $this.GetLine($this.CursorY)\n        if ($this.CursorX -gt 0) {\n            # Skip current word\n            while ($this.CursorX -gt 0 -and $line[$this.CursorX - 1] -match '\\w') {\n                $this.CursorX--\n            }\n            # Skip whitespace\n            while ($this.CursorX -gt 0 -and $line[$this.CursorX - 1] -match '\\s') {\n                $this.CursorX--\n            }\n            # Move to start of previous word\n            while ($this.CursorX -gt 0 -and $line[$this.CursorX - 1] -match '\\w') {\n                $this.CursorX--\n            }\n        }\n        elseif ($this.CursorY -gt 0) {\n            $this.MoveCursorLeft()\n        }\n        $this.EnsureCursorVisible()\n    }\n\n    [void] MoveCursorWordRight() {\n        # Move to next word boundary\n        $line = $this.GetLine($this.CursorY)\n        if ($this.CursorX -lt $line.Length) {\n            # Skip current word\n            while ($this.CursorX -lt $line.Length -and $line[$this.CursorX] -match '\\w') {\n                $this.CursorX++\n            }\n            # Skip whitespace\n            while ($this.CursorX -lt $line.Length -and $line[$this.CursorX] -match '\\s') {\n                $this.CursorX++\n            }\n        }\n        elseif ($this.CursorY -lt ($this.GetLineCount() - 1)) {\n            $this.MoveCursorRight()\n        }\n        $this.EnsureCursorVisible()\n    }\n\n    [void] EnsureCursorVisible() {\n        # Vertical scrolling\n        if ($this.CursorY -lt $this.ScrollOffsetY) {\n            $this.ScrollOffsetY = $this.CursorY\n        }\n        elseif ($this.CursorY -ge ($this.ScrollOffsetY + $this.Height)) {\n            $this.ScrollOffsetY = $this.CursorY - $this.Height + 1\n        }\n\n        # Horizontal scrolling\n        if ($this.CursorX -lt $this.ScrollOffsetX) {\n            $this.ScrollOffsetX = $this.CursorX\n        }\n        elseif ($this.CursorX -ge ($this.ScrollOffsetX + $this.Width)) {\n            $this.ScrollOffsetX = $this.CursorX - $this.Width + 1\n        }\n    }\n\n    # Selection methods\n    [void] StartSelection([SelectionMode]$mode) {\n        $this.SelectionMode = $mode\n        $this.SelectionAnchorX = $this.CursorX\n        $this.SelectionAnchorY = $this.CursorY\n        $this.SelectionEndX = $this.CursorX\n        $this.SelectionEndY = $this.CursorY\n    }\n\n    [void] ExtendSelection() {\n        $this.SelectionEndX = $this.CursorX\n        $this.SelectionEndY = $this.CursorY\n    }\n\n    [void] ClearSelection() {\n        $this.SelectionMode = [SelectionMode]::None\n    }\n\n    [void] SelectAll() {\n        $this.SelectionMode = [SelectionMode]::Stream\n        $this.SelectionAnchorX = 0\n        $this.SelectionAnchorY = 0\n        $this.SelectionEndY = $this.GetLineCount() - 1\n        $this.SelectionEndX = $this.GetLine($this.SelectionEndY).Length\n        $this.CursorX = $this.SelectionEndX\n        $this.CursorY = $this.SelectionEndY\n    }\n\n    # Editing methods\n    [void] InsertChar([char]$c) {\n        if ($this.SelectionMode -ne [SelectionMode]::None) {\n            $this.DeleteSelection()\n        }\n\n        $pos = $this.GetPositionFromLineCol($this.CursorY, $this.CursorX)\n        $this._gapBuffer.Insert($pos, [string]$c)\n        $this.CursorX++\n        $this.Modified = $true\n        $this._lineIndexDirty = $true\n        $this.EnsureCursorVisible()\n    }\n\n    [void] InsertNewLine() {\n        if ($this.SelectionMode -ne [SelectionMode]::None) {\n            $this.DeleteSelection()\n        }\n\n        $pos = $this.GetPositionFromLineCol($this.CursorY, $this.CursorX)\n        $this._gapBuffer.Insert($pos, \"`n\")\n        $this.CursorY++\n        $this.CursorX = 0\n        $this.Modified = $true\n        $this._lineIndexDirty = $true\n        $this.EnsureCursorVisible()\n    }\n\n    [void] Backspace() {\n        if ($this.SelectionMode -ne [SelectionMode]::None) {\n            $this.DeleteSelection()\n            return\n        }\n\n        $pos = $this.GetPositionFromLineCol($this.CursorY, $this.CursorX)\n        if ($pos -gt 0) {\n            $this._gapBuffer.Delete($pos - 1, 1)\n            \n            # Update cursor\n            if ($this.CursorX -gt 0) {\n                $this.CursorX--\n            }\n            elseif ($this.CursorY -gt 0) {\n                $this.CursorY--\n                $this._lineIndexDirty = $true # Force rebuild to get correct line length\n                $this.CursorX = $this.GetLine($this.CursorY).Length\n            }\n\n            $this.Modified = $true\n            $this._lineIndexDirty = $true\n            $this.EnsureCursorVisible()\n        }\n    }\n\n    [void] Delete() {\n        if ($this.SelectionMode -ne [SelectionMode]::None) {\n            $this.DeleteSelection()\n            return\n        }\n\n        $pos = $this.GetPositionFromLineCol($this.CursorY, $this.CursorX)\n        if ($pos -lt $this._gapBuffer.GetLength()) {\n            $this._gapBuffer.Delete($pos, 1)\n            $this.Modified = $true\n            $this._lineIndexDirty = $true\n        }\n    }\n\n    [void] InsertTab() {\n        # Insert spaces for tab\n        $spaces = \" \" * $this.TabWidth\n        $this.InsertString($spaces)\n    }\n\n    [void] InsertString([string]$s) {\n        if ($this.SelectionMode -ne [SelectionMode]::None) {\n            $this.DeleteSelection()\n        }\n\n        $pos = $this.GetPositionFromLineCol($this.CursorY, $this.CursorX)\n        $this._gapBuffer.Insert($pos, $s)\n        $this.CursorX += $s.Length\n        $this.Modified = $true\n        $this._lineIndexDirty = $true\n        $this.EnsureCursorVisible()\n    }\n\n    # Get text in selection range (efficient - no regex)\n    hidden [string] GetSelectedText() {\n        if ($this.SelectionMode -eq [SelectionMode]::None) { return \"\" }\n        \n        # Normalize anchor and end (anchor might be after end if selecting backwards)\n        $startLine = [Math]::Min($this.SelectionAnchorY, $this.SelectionEndY)\n        $endLine = [Math]::Max($this.SelectionAnchorY, $this.SelectionEndY)\n        \n        if ($startLine -eq $endLine) {\n            $startCol = [Math]::Min($this.SelectionAnchorX, $this.SelectionEndX)\n            $endCol = [Math]::Max($this.SelectionAnchorX, $this.SelectionEndX)\n        } else {\n            if ($this.SelectionAnchorY -lt $this.SelectionEndY) {\n                $startCol = $this.SelectionAnchorX\n                $endCol = $this.SelectionEndX\n            } else {\n                $startCol = $this.SelectionEndX\n                $endCol = $this.SelectionAnchorX\n            }\n        }\n        \n        $startPos = $this.GetPositionFromLineCol($startLine, $startCol)\n        $endPos = $this.GetPositionFromLineCol($endLine, $endCol)\n        $length = $endPos - $startPos\n        \n        if ($length -le 0) { return \"\" }\n        return $this._gapBuffer.GetText($startPos, $length)\n    }\n\n    [void] DeleteSelection() {\n        if ($this.SelectionMode -eq [SelectionMode]::None) { return }\n        \n        # Get normalized positions\n        $startLine = [Math]::Min($this.SelectionAnchorY, $this.SelectionEndY)\n        $endLine = [Math]::Max($this.SelectionAnchorY, $this.SelectionEndY)\n        \n        if ($startLine -eq $endLine) {\n            $startCol = [Math]::Min($this.SelectionAnchorX, $this.SelectionEndX)\n            $endCol = [Math]::Max($this.SelectionAnchorX, $this.SelectionEndX)\n        } else {\n            if ($this.SelectionAnchorY -lt $this.SelectionEndY) {\n                $startCol = $this.SelectionAnchorX\n                $endCol = $this.SelectionEndX\n            } else {\n                $startCol = $this.SelectionEndX\n                $endCol = $this.SelectionAnchorX\n            }\n        }\n        \n        $startPos = $this.GetPositionFromLineCol($startLine, $startCol)\n        $endPos = $this.GetPositionFromLineCol($endLine, $endCol)\n        $length = $endPos - $startPos\n        \n        if ($length -gt 0) {\n            $this._gapBuffer.Delete($startPos, $length)\n            $this._lineIndexDirty = $true\n            $this.Modified = $true\n            \n            # Move cursor to start of deleted region\n            $this.CursorY = $startLine\n            $this.CursorX = $startCol\n            $this.EnsureCursorVisible()\n        }\n        \n        $this.ClearSelection()\n    }\n\n    # Clipboard operations (internal clipboard - no system clipboard for performance)\n    [void] Copy() {\n        $text = $this.GetSelectedText()\n        if ($text) {\n            [TextAreaEditor]::_clipboard = $text\n        }\n    }\n\n    [void] Cut() {\n        $this.Copy()\n        $this.DeleteSelection()\n    }\n\n    [void] Paste() {\n        if ([TextAreaEditor]::_clipboard) {\n            if ($this.SelectionMode -ne [SelectionMode]::None) {\n                $this.DeleteSelection()\n            }\n            $this.InsertString([TextAreaEditor]::_clipboard)\n        }\n    }\n\n    # Undo/Redo (stubs)\n    [void] SaveUndoState() { }\n    [void] Undo() { }\n    [void] Redo() { }\n}"}, {"path": "module/Pmc.Strict/consoleui/widgets/TextInput.ps1", "content": "using namespace System\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# TextInput.ps1 - Single-line text input widget with validation and cursor support\r\n#\r\n# Usage:\r\n#   $input = [TextInput]::new()\r\n#   $input.SetPosition(5, 5)\r\n#   $input.SetSize(40, 3)\r\n#   $input.Placeholder = \"Enter task text...\"\r\n#   $input.MaxLength = 200\r\n#   $input.Validator = { param($text) $text.Length -gt 0 }\r\n#\r\n#   # Render\r\n#   $ansiOutput = $input.Render()\r\n#   Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [TextInput] Rendering text input\"\r\n#\r\n#   # Handle input\r\n#   $key = [Console]::ReadKey($true)\r\n#   $handled = $input.HandleInput($key)\r\n#\r\n#   # Get result\r\n#   $text = $input.GetText()\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Load PmcWidget base class if not already loaded\r\nif (-not ([System.Management.Automation.PSTypeName]'PmcWidget').Type) {\r\n    . \"$PSScriptRoot/PmcWidget.ps1\"\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nSingle-line text input widget with cursor, validation, and event callbacks\r\n\r\n.DESCRIPTION\r\nFeatures:\r\n- Single-line text input with cursor position tracking\r\n- Left/Right arrow navigation, Home/End keys\r\n- Backspace/Delete character editing\r\n- Character insertion with MaxLength enforcement\r\n- Visual cursor indicator (inverted colors)\r\n- Placeholder text with ANSI color support\r\n- Validation with custom scriptblock\r\n- OnTextChanged event callback\r\n- Theme integration with border and colors\r\n- Horizontal scrolling for long text\r\n\r\n.EXAMPLE\r\n$input = [TextInput]::new()\r\n$input.SetPosition(5, 5)\r\n$input.SetSize(40, 3)\r\n$input.Text = \"Initial value\"\r\n$input.Placeholder = \"Type something...\"\r\n$input.MaxLength = 100\r\n$input.Validator = { param($text) $text.Length -ge 3 }\r\n$ansiOutput = $input.Render()\r\n##CLOSEBRACKET##\r\nclass TextInput : PmcWidget {\r\n    # === Public Properties ===\r\n    [string]$Text = \"\"                      # Current text content\r\n    [string]$Placeholder = \"\"               # Placeholder shown when empty\r\n    [int]$MaxLength = 500                   # Maximum text length\r\n    [scriptblock]$Validator = $null         # Validation function: param($text) -> bool\r\n    [string]$Label = \"\"                     # Optional label above input\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnTextChanged = {}        # Called when text changes: param($newText)\r\n    [scriptblock]$OnValidationFailed = {}   # Called when validation fails: param($text, $error)\r\n    [scriptblock]$OnConfirmed = {}          # Called when Enter pressed: param($text)\r\n    [scriptblock]$OnCancelled = {}          # Called when Esc pressed\r\n\r\n    # === State Flags ===\r\n    [bool]$IsConfirmed = $false             # True when Enter pressed\r\n    [bool]$IsCancelled = $false             # True when Esc pressed\r\n    [bool]$IsValid = $true                  # Current validation state\r\n\r\n    # === Private State ===\r\n    hidden [int]$_cursorPosition = 0        # Cursor position (0-based index)\r\n    hidden [int]$_scrollOffset = 0          # Horizontal scroll offset for long text\r\n    hidden [string]$_validationError = \"\"   # Last validation error message\r\n    hidden [bool]$_showCursor = $true       # Cursor blink state\r\n    hidden [int]$_blinkFrameCount = 0       # Frame counter for blink (more efficient than DateTime)\r\n    hidden [int]$_blinkFrameInterval = 30   # Blink every 30 frames (at 60fps = 500ms)\r\n\r\n    # === Constructor ===\r\n    TextInput() : base(\"TextInput\") {\r\n        $this.Width = 40\r\n        $this.Height = 3\r\n        $this.CanFocus = $true\r\n        $this._cursorPosition = 0\r\n    }\r\n\r\n    # === Public API Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set the text content programmatically\r\n\r\n    .PARAMETER text\r\n    Text to set\r\n    ##CLOSEBRACKET##\r\n    [void] SetText([string]$text) {\r\n        $newText = $text\r\n        if ($newText.Length -gt $this.MaxLength) {\r\n            $newText = $newText.Substring(0, $this.MaxLength)\r\n        }\r\n\r\n        $oldText = $this.Text\r\n        $this.Text = $newText\r\n        $this._cursorPosition = $text.Length\r\n        $this._AdjustScrollOffset()\r\n\r\n        # Validate and trigger event if changed\r\n        if ($oldText -ne $text) {\r\n            $this._ValidateText()\r\n            $this._InvokeCallback($this.OnTextChanged, $text)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get the current text content\r\n\r\n    .OUTPUTS\r\n    String content\r\n    ##CLOSEBRACKET##\r\n    [string] GetText() {\r\n        return $this.Text\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Clear the input text\r\n\r\n    .PARAMETER keepFocus\r\n    If true, maintains focus after clearing\r\n    ##CLOSEBRACKET##\r\n    [void] Clear([bool]$keepFocus = $true) {\r\n        $this.Text = \"\"\r\n        $this._cursorPosition = 0\r\n        $this._scrollOffset = 0\r\n        $this.IsConfirmed = $false\r\n        $this.IsCancelled = $false\r\n        $this._validationError = \"\"\r\n        $this.IsValid = $true\r\n\r\n        if ($keepFocus) {\r\n            $this.HasFocus = $true\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle keyboard input\r\n\r\n    .PARAMETER keyInfo\r\n    ConsoleKeyInfo from [Console]::ReadKey($true)\r\n\r\n    .OUTPUTS\r\n    True if input was handled, False otherwise\r\n    ##CLOSEBRACKET##\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        # DEBUG: Log all input\r\n        # Write-PmcTuiLog \"TextInput.HandleInput: ENTRY - Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' CurrentText='$($this.Text)'\" \"DEBUG\"\r\n\r\n        # Enter - confirm input\r\n        if ($keyInfo.Key -eq 'Enter') {\r\n            if ($this._ValidateText()) {\r\n                $this.IsConfirmed = $true\r\n                $this._InvokeCallback($this.OnConfirmed, $this.Text)\r\n                return $true\r\n            }\r\n            else {\r\n                # Validation failed, don't confirm\r\n                $this._InvokeCallback($this.OnValidationFailed, @($this.Text, $this._validationError))\r\n                return $true\r\n            }\r\n        }\r\n\r\n        # Escape - cancel input\r\n        if ($keyInfo.Key -eq 'Escape') {\r\n            $this.IsCancelled = $true\r\n            $this._InvokeCallback($this.OnCancelled, $null)\r\n            return $true\r\n        }\r\n\r\n        # Navigation keys\r\n        if ($keyInfo.Key -eq 'LeftArrow') {\r\n            $this._MoveCursorLeft()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'RightArrow') {\r\n            $this._MoveCursorRight()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'Home') {\r\n            $this._cursorPosition = 0\r\n            $this._AdjustScrollOffset()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'End') {\r\n            $this._cursorPosition = $this.Text.Length\r\n            $this._AdjustScrollOffset()\r\n            return $true\r\n        }\r\n\r\n        # Editing keys\r\n        if ($keyInfo.Key -eq 'Backspace') {\r\n            $this._DeleteCharBefore()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'Delete') {\r\n            $this._DeleteCharAt()\r\n            return $true\r\n        }\r\n\r\n        # Ctrl+A - select all (move to beginning for now)\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control -and $keyInfo.Key -eq 'A') {\r\n            $this._cursorPosition = 0\r\n            $this._AdjustScrollOffset()\r\n            return $true\r\n        }\r\n\r\n        # Ctrl+E - end (like Emacs)\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control -and $keyInfo.Key -eq 'E') {\r\n            $this._cursorPosition = $this.Text.Length\r\n            $this._AdjustScrollOffset()\r\n            return $true\r\n        }\r\n\r\n        # Ctrl+U - clear line\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control -and $keyInfo.Key -eq 'U') {\r\n            $this.Text = \"\"\r\n            $this._cursorPosition = 0\r\n            $this._scrollOffset = 0\r\n            $this._ValidateText()\r\n            $this._InvokeCallback($this.OnTextChanged, $this.Text)\r\n            return $true\r\n        }\r\n\r\n        # L-POL-11: Ctrl+C - copy to clipboard\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control -and $keyInfo.Key -eq 'C') {\r\n            # FIX: Access $PSVersionTable via Get-Variable to work in strict mode class methods\r\n            $psVersion = (Get-Variable -Name PSVersionTable -ValueOnly -ErrorAction SilentlyContinue)\r\n            if ($null -ne $psVersion -and $psVersion.PSVersion.Major -ge 7 -and -not [string]::IsNullOrEmpty($this.Text)) {\r\n                try {\r\n                    Set-Clipboard -Value $this.Text\r\n                }\r\n                catch {\r\n                    # Clipboard access may fail - silently ignore\r\n                }\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # L-POL-11: Ctrl+V - paste from clipboard\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control -and $keyInfo.Key -eq 'V') {\r\n            # FIX: Access $PSVersionTable via Get-Variable to work in strict mode class methods\r\n            $psVersion = (Get-Variable -Name PSVersionTable -ValueOnly -ErrorAction SilentlyContinue)\r\n            if ($null -ne $psVersion -and $psVersion.PSVersion.Major -ge 7) {\r\n                try {\r\n                    $clipText = Get-Clipboard -Raw\r\n                    if (-not [string]::IsNullOrEmpty($clipText)) {\r\n                        # Remove newlines from pasted text (single-line input)\r\n                        $clipText = $clipText -replace '[\\r\\n]+', ' '\r\n\r\n                        # Insert at cursor position\r\n                        $before = $this.Text.Substring(0, $this._cursorPosition)\r\n                        $after = $this.Text.Substring($this._cursorPosition)\r\n                        $newText = $before + $clipText + $after\r\n\r\n                        # Enforce max length\r\n                        if ($newText.Length -gt $this.MaxLength) {\r\n                            $newText = $newText.Substring(0, $this.MaxLength)\r\n                        }\r\n\r\n                        $this.Text = $newText\r\n                        $this._cursorPosition = [Math]::Min($this._cursorPosition + $clipText.Length, $this.Text.Length)\r\n                        $this._AdjustScrollOffset()\r\n                        $this._ValidateText()\r\n                        $this._InvokeCallback($this.OnTextChanged, $this.Text)\r\n                    }\r\n                }\r\n                catch {\r\n                    # Clipboard access may fail - silently ignore\r\n                }\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Regular character input\r\n        if ($keyInfo.KeyChar -ge 32 -and $keyInfo.KeyChar -le 126) {\r\n            $this._InsertChar($keyInfo.KeyChar)\r\n            return $true\r\n        }\r\n\r\n        # Space\r\n        if ($keyInfo.Key -eq 'Spacebar') {\r\n            $this._InsertChar(' ')\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n        # Regions removed - using direct WriteAt in RenderToEngine\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render directly to engine (new high-performance path)\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        $this._blinkFrameCount++\r\n        if ($this._blinkFrameCount -ge $this._blinkFrameInterval) {\r\n            $this._showCursor = -not $this._showCursor\r\n            $this._blinkFrameCount = 0\r\n        }\r\n\r\n        $this.RegisterLayout($engine)\r\n\r\n        # Colors (Ints)\r\n        # using Panel background for consistency with other inputs\r\n        $bg = $this.GetThemedBgInt('Background.Panel', 1, 0)\r\n        # Fallback removed - strict theme enforcement\r\n\r\n        $fg = $this.GetThemedInt('Foreground.Row')\r\n        $borderFg = $this.GetThemedInt('Border.Widget')\r\n        $primaryFg = $this.GetThemedInt('Foreground.Title')\r\n        $mutedFg = $this.GetThemedInt('Foreground.Muted')\r\n        $errorFg = $this.GetThemedInt('Foreground.Error')\r\n        \r\n        # Border Color\r\n        $activeBorderFg = if (-not $this.IsValid) { $errorFg } elseif ($this.HasFocus) { $primaryFg } else { $borderFg }\r\n\r\n        # Draw Box\r\n        $engine.Fill($this.X, $this.Y, $this.Width, $this.Height, ' ', $fg, $bg)\r\n        $engine.DrawBox($this.X, $this.Y, $this.Width, $this.Height, $activeBorderFg, $bg)\r\n        \r\n        # Title\r\n        if ($this.Label) {\r\n            $engine.WriteAt($this.X + 2, $this.Y, \" $($this.Label) \", $primaryFg, $bg)\r\n        }\r\n        \r\n        # Input Area logic\r\n        $inputX = $this.X + 2\r\n        $inputY = $this.Y + 1\r\n        $inputWidth = $this.Width - 4\r\n        \r\n        $displayText = \"\"\r\n        if ([string]::IsNullOrEmpty($this.Text)) {\r\n            if (-not $this.HasFocus) {\r\n                # Placeholder\r\n                $displayText = $this.Placeholder\r\n                if ($displayText.Length -gt $inputWidth) { $displayText = $displayText.Substring(0, $inputWidth) }\r\n                $engine.WriteAt($inputX, $inputY, $displayText, $mutedFg, $bg)\r\n            }\r\n            else {\r\n                # Focused but empty - show cursor at 0\r\n                if ($this._showCursor) {\r\n                    $engine.WriteAt($inputX, $inputY, \" \", $bg, $fg) # Inverse space\r\n                }\r\n                if ($this.Placeholder) {\r\n                    # Show placeholder starting at 1? Or overwrite cursor?\r\n                    # Generally placeholders disappear when typing starts, but here we are empty.\r\n                    # If cursor is at 0, we can show placeholder starting at 1 if valid?\r\n                    # Or just show cursor.\r\n                    # Previous logic showed placeholder at X+1.\r\n                    if ($inputWidth -gt 1) {\r\n                        $ph = $this.Placeholder\r\n                        if ($ph.Length -gt ($inputWidth - 1)) { $ph = $ph.Substring(0, $inputWidth - 1) }\r\n                        $engine.WriteAt($inputX + 1, $inputY, $ph, $mutedFg, $bg)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            # Visible Text\r\n            $visibleText = $this.Text.Substring($this._scrollOffset)\r\n            if ($visibleText.Length -gt $inputWidth) {\r\n                $visibleText = $visibleText.Substring(0, $inputWidth)\r\n            }\r\n            \r\n            $cursorOffset = $this._cursorPosition - $this._scrollOffset\r\n            \r\n            # Simple rendering: just write text\r\n            $engine.WriteAt($inputX, $inputY, $visibleText, $fg, $bg)\r\n            \r\n            # Overwrite cursor char if focused and visible\r\n            if ($this.HasFocus -and $this._showCursor -and $cursorOffset -ge 0 -and $cursorOffset -le $visibleText.Length) {\r\n                \r\n                $char = if ($cursorOffset -lt $visibleText.Length) { $visibleText[$cursorOffset] } else { ' ' }\r\n                $engine.WriteAt($inputX + $cursorOffset, $inputY, \"$char\", $bg, $fg) # Inverse\r\n            }\r\n        }\r\n        \r\n        # Error\r\n        if (-not $this.IsValid -and $this._validationError) {\r\n            # Truncate error to width\r\n            $err = \" $($this._validationError) \"\r\n            if ($err.Length -gt $inputWidth) { $err = $err.Substring(0, $inputWidth) }\r\n            $engine.WriteAt($this.X + 2, $this.Y + 2, $err, $errorFg, $bg)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render the text input widget\r\n\r\n    .OUTPUTS\r\n    ANSI string ready for display\r\n    ##CLOSEBRACKET##\r\n    [string] Render() {\r\n        $sb = [StringBuilder]::new(1024)\r\n\r\n        # Update cursor blink using frame counter (more efficient than DateTime)\r\n        $this._blinkFrameCount++\r\n        if ($this._blinkFrameCount -ge $this._blinkFrameInterval) {\r\n            $this._showCursor = -not $this._showCursor\r\n            $this._blinkFrameCount = 0\r\n        }\r\n\r\n        # Colors from new theme system\r\n        $borderColor = $this.GetThemedFg('Border.Widget')\r\n        $textColor = $this.GetThemedFg('Foreground.Row')\r\n        $primaryColor = $this.GetThemedFg('Foreground.Title')\r\n        $mutedColor = $this.GetThemedFg('Foreground.Muted')\r\n        $errorColor = $this.GetThemedFg('Foreground.Error')\r\n        $successColor = $this.GetThemedFg('Foreground.Success')\r\n        $reset = \"`e[0m\"\r\n\r\n        # Choose border color based on validation state\r\n        $activeBorderColor = $(if (-not $this.IsValid) { $errorColor } elseif ($this.HasFocus) { $primaryColor } else { $borderColor })\r\n\r\n        # Draw top border\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y))\r\n        $sb.Append($activeBorderColor)\r\n        $sb.Append($this.BuildBoxBorder($this.Width, 'top', 'single'))\r\n\r\n        # Label in top border if provided\r\n        if (-not [string]::IsNullOrWhiteSpace($this.Label)) {\r\n            $labelText = \" $($this.Label) \"\r\n            $labelPos = 2\r\n            $sb.Append($this.BuildMoveTo($this.X + $labelPos, $this.Y))\r\n            $sb.Append($primaryColor)\r\n            $sb.Append($labelText)\r\n        }\r\n\r\n        # Draw middle row (text input area)\r\n        $rowY = $this.Y + 1\r\n        $sb.Append($this.BuildMoveTo($this.X, $rowY))\r\n        $sb.Append($activeBorderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        # Calculate visible text area\r\n        $innerWidth = $this.Width - 4  # Leave 2 chars padding on each side\r\n        $displayText = \"\"\r\n        $cursorDisplayPos = -1\r\n\r\n        if ([string]::IsNullOrEmpty($this.Text)) {\r\n            # Show placeholder\r\n            $displayText = $this.Placeholder\r\n            $sb.Append($this.BuildMoveTo($this.X + 2, $rowY))\r\n            $sb.Append($mutedColor)\r\n            $sb.Append($this.TruncateText($displayText, $innerWidth))\r\n\r\n            # Cursor at beginning if focused\r\n            if ($this.HasFocus -and $this._showCursor) {\r\n                $cursorDisplayPos = 0\r\n            }\r\n        }\r\n        else {\r\n            # Show actual text with scroll offset\r\n            $visibleText = $this.Text.Substring($this._scrollOffset)\r\n            if ($visibleText.Length -gt $innerWidth) {\r\n                $visibleText = $visibleText.Substring(0, $innerWidth)\r\n            }\r\n\r\n            $displayText = $visibleText\r\n            $sb.Append($this.BuildMoveTo($this.X + 2, $rowY))\r\n            $sb.Append($textColor)\r\n\r\n            # Calculate cursor position in visible area\r\n            $cursorOffsetPos = $this._cursorPosition - $this._scrollOffset\r\n\r\n            # Render text with cursor highlighting\r\n            if ($this.HasFocus -and $cursorOffsetPos -ge 0 -and $cursorOffsetPos -le $displayText.Length -and $this._showCursor) {\r\n                # Text before cursor\r\n                if ($cursorOffsetPos -gt 0) {\r\n                    $sb.Append($displayText.Substring(0, $cursorOffsetPos))\r\n                }\r\n\r\n                # Cursor character (inverted)\r\n                $cursorChar = $(if ($cursorOffsetPos -lt $displayText.Length) {\r\n                        $displayText[$cursorOffsetPos]\r\n                    }\r\n                    else {\r\n                        ' '\r\n                    })\r\n                $sb.Append(\"`e[7m\")  # Invert colors\r\n                $sb.Append($cursorChar)\r\n                $sb.Append(\"`e[27m\")  # Normal colors\r\n\r\n                # Text after cursor\r\n                if ($cursorOffsetPos + 1 -lt $displayText.Length) {\r\n                    $sb.Append($displayText.Substring($cursorOffsetPos + 1))\r\n                }\r\n            }\r\n            else {\r\n                # No cursor, just render text\r\n                $sb.Append($displayText)\r\n            }\r\n        }\r\n\r\n        # Pad remaining space\r\n        $textLen = $(if ($displayText) { $displayText.Length } else { 0 })\r\n        $padding = $innerWidth - $textLen\r\n        if ($padding -gt 0) {\r\n            $sb.Append(\" \" * $padding)\r\n        }\r\n\r\n        # Right border for middle row\r\n        $sb.Append($this.BuildMoveTo($this.X + $this.Width - 1, $rowY))\r\n        $sb.Append($activeBorderColor)\r\n        $sb.Append($this.GetBoxChar('single_vertical'))\r\n\r\n        # Draw bottom border\r\n        $sb.Append($this.BuildMoveTo($this.X, $this.Y + 2))\r\n        $sb.Append($activeBorderColor)\r\n        $sb.Append($this.BuildBoxBorder($this.Width, 'bottom', 'single'))\r\n\r\n        # Validation error or status message\r\n        if (-not $this.IsValid -and -not [string]::IsNullOrWhiteSpace($this._validationError)) {\r\n            $errorMsg = \" $($this._validationError) \"\r\n            $errorPos = 2\r\n            $sb.Append($this.BuildMoveTo($this.X + $errorPos, $this.Y + 2))\r\n            $sb.Append($errorColor)\r\n            $sb.Append($this.TruncateText($errorMsg, $this.Width - 4))\r\n        }\r\n\r\n        $sb.Append($reset)\r\n        return $sb.ToString()\r\n    }\r\n\r\n    # === Private Helper Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move cursor left by one position\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _MoveCursorLeft() {\r\n        if ($this._cursorPosition -gt 0) {\r\n            $this._cursorPosition--\r\n            $this._AdjustScrollOffset()\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move cursor right by one position\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _MoveCursorRight() {\r\n        if ($this._cursorPosition -lt $this.Text.Length) {\r\n            $this._cursorPosition++\r\n            $this._AdjustScrollOffset()\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Insert a character at cursor position\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _InsertChar([char]$ch) {\r\n        # DEBUG: Log insertion attempt\r\n        # Write-PmcTuiLog \"TextInput._InsertChar: ENTRY - ch='$ch' CurrentText='$($this.Text)' Length=$($this.Text.Length) MaxLength=$($this.MaxLength)\" \"DEBUG\"\r\n\r\n        # Check length limit\r\n        if ($this.Text.Length -ge $this.MaxLength) {\r\n            # Write-PmcTuiLog \"TextInput._InsertChar: REJECTED - Text length ($($this.Text.Length)) >= MaxLength ($($this.MaxLength))\" \"DEBUG\"\r\n            return\r\n        }\r\n\r\n        # Basic input sanitization - reject control characters and null bytes\r\n        $charCode = [int]$ch\r\n        if ($charCode -lt 32 -and $charCode -ne 9) {\r\n            # Allow tab (9) but reject other control chars\r\n            return\r\n        }\r\n        if ($charCode -eq 0) {\r\n            # Null byte\r\n            return\r\n        }\r\n        if ($charCode -eq 127) {\r\n            # DEL control char\r\n            return\r\n        }\r\n\r\n        # Insert character\r\n        if ($this._cursorPosition -eq $this.Text.Length) {\r\n            # Append\r\n            $this.Text += $ch\r\n            # Write-PmcTuiLog \"TextInput._InsertChar: Appended '$ch' -> Text='$($this.Text)'\" \"DEBUG\"\r\n        }\r\n        else {\r\n            # Insert in middle\r\n            $before = $this.Text.Substring(0, $this._cursorPosition)\r\n            $after = $this.Text.Substring($this._cursorPosition)\r\n            $this.Text = $before + $ch + $after\r\n            # Write-PmcTuiLog \"TextInput._InsertChar: Inserted '$ch' at position $($this._cursorPosition) -> Text='$($this.Text)'\" \"DEBUG\"\r\n        }\r\n\r\n        $this._cursorPosition++\r\n        $this._AdjustScrollOffset()\r\n        $this._ValidateText()\r\n        $this._InvokeCallback($this.OnTextChanged, $this.Text)\r\n        # Write-PmcTuiLog \"TextInput._InsertChar: EXIT - Text='$($this.Text)'\" \"DEBUG\"\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Delete character before cursor (Backspace)\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _DeleteCharBefore() {\r\n        if ($this._cursorPosition -eq 0) {\r\n            return\r\n        }\r\n\r\n        # Delete character before cursor\r\n        if ($this._cursorPosition -eq $this.Text.Length) {\r\n            # Delete last char\r\n            $this.Text = $this.Text.Substring(0, $this.Text.Length - 1)\r\n        }\r\n        else {\r\n            # Delete in middle\r\n            $before = $this.Text.Substring(0, $this._cursorPosition - 1)\r\n            $after = $this.Text.Substring($this._cursorPosition)\r\n            $this.Text = $before + $after\r\n        }\r\n\r\n        $this._cursorPosition--\r\n        $this._AdjustScrollOffset()\r\n        $this._ValidateText()\r\n        $this._InvokeCallback($this.OnTextChanged, $this.Text)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Delete character at cursor position (Delete key)\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _DeleteCharAt() {\r\n        if ($this._cursorPosition -ge $this.Text.Length) {\r\n            return\r\n        }\r\n\r\n        # Delete character at cursor\r\n        if ($this._cursorPosition -eq 0 -and $this.Text.Length -eq 1) {\r\n            $this.Text = \"\"\r\n        }\r\n        else {\r\n            $before = $this.Text.Substring(0, $this._cursorPosition)\r\n            $after = $(if ($this._cursorPosition + 1 -lt $this.Text.Length) {\r\n                    $this.Text.Substring($this._cursorPosition + 1)\r\n                }\r\n                else {\r\n                    \"\"\r\n                })\r\n            $this.Text = $before + $after\r\n        }\r\n\r\n        $this._AdjustScrollOffset()\r\n        $this._ValidateText()\r\n        $this._InvokeCallback($this.OnTextChanged, $this.Text)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Adjust scroll offset to keep cursor visible\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _AdjustScrollOffset() {\r\n        $innerWidth = $this.Width - 4\r\n\r\n        # If cursor is before visible area, scroll left\r\n        if ($this._cursorPosition -lt $this._scrollOffset) {\r\n            $this._scrollOffset = $this._cursorPosition\r\n        }\r\n\r\n        # If cursor is after visible area, scroll right\r\n        if ($this._cursorPosition -gt ($this._scrollOffset + $innerWidth - 1)) {\r\n            $this._scrollOffset = $this._cursorPosition - $innerWidth + 1\r\n        }\r\n\r\n        # Clamp scroll offset\r\n        if ($this._scrollOffset -lt 0) {\r\n            $this._scrollOffset = 0\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Validate current text using the Validator scriptblock\r\n\r\n    .OUTPUTS\r\n    True if valid, False if invalid\r\n    ##CLOSEBRACKET##\r\n    hidden [bool] _ValidateText() {\r\n        if ($null -eq $this.Validator) {\r\n            $this.IsValid = $true\r\n            $this._validationError = \"\"\r\n            return $true\r\n        }\r\n\r\n        try {\r\n            $result = & $this.Validator $this.Text\r\n            if ($result -is [bool]) {\r\n                $this.IsValid = $result\r\n                if (-not $result) {\r\n                    $this._validationError = \"Invalid input\"\r\n                }\r\n                else {\r\n                    $this._validationError = \"\"\r\n                }\r\n                return $result\r\n            }\r\n            elseif ($result -is [hashtable] -and $result.ContainsKey('Valid')) {\r\n                $this.IsValid = $result.Valid\r\n                $this._validationError = $(if ($result.ContainsKey('Message')) { $result.Message } else { \"\" })\r\n                return $result.Valid\r\n            }\r\n            else {\r\n                # Assume valid if validator returns non-bool\r\n                $this.IsValid = $true\r\n                $this._validationError = \"\"\r\n                return $true\r\n            }\r\n        }\r\n        catch {\r\n            # Validator threw exception - treat as invalid\r\n            $this.IsValid = $false\r\n            $this._validationError = \"Validation error: $_\"\r\n            return $false\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Invoke a callback scriptblock safely\r\n\r\n    .PARAMETER callback\r\n    Scriptblock to invoke\r\n\r\n    .PARAMETER args\r\n    Arguments to pass to scriptblock\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _InvokeCallback([scriptblock]$callback, $args) {\r\n        if ($null -ne $callback) {\r\n            try {\r\n                if ($null -ne $args) {\r\n                    & $callback $args\r\n                }\r\n                else {\r\n                    & $callback\r\n                }\r\n            }\r\n            catch {\r\n                # Callback failed - log but don't crash widget\r\n            }\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/widgets/TimeEntryDetailDialog.ps1", "content": "using namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Ensure PmcWidget is loaded\r\nif (-not ([System.Management.Automation.PSTypeName]'PmcWidget').Type) {\r\n    . \"$PSScriptRoot/PmcWidget.ps1\"\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nDialog to show individual time entries within an aggregated group\r\n##CLOSEBRACKET##\r\nclass TimeEntryDetailDialog : PmcWidget {\r\n    [string]$Title\r\n    [array]$Entries\r\n    # [int]$Width  # Inherited\r\n    # [int]$Height # Inherited\r\n    [bool]$IsComplete = $false\r\n    [int]$ScrollOffset = 0\r\n    [int]$SelectedIndex = 0\r\n\r\n    TimeEntryDetailDialog([string]$title, [array]$entries) : base(\"TimeEntryDetail\") {\r\n        $this.Title = $title\r\n        $this.Entries = $entries\r\n        $this.Width = 80\r\n        $this.Height = [Math]::Min(25, $entries.Count + 7)\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] RegisterLayout([object]$engine) {\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n        # Regions removed - using direct WriteAt in RenderToEngine\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render directly to engine (new high-performance path)\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        $this.RegisterLayout($engine)\r\n\r\n        # Colors\r\n        # Use Panel background\r\n        $bg = [HybridRenderEngine]::AnsiColorToInt($this.GetThemedBg('Background.Panel', 1, 0))\r\n        $fg = [HybridRenderEngine]::AnsiColorToInt($this.GetThemedFg('Foreground.Row'))\r\n        $borderFg = [HybridRenderEngine]::AnsiColorToInt($this.GetThemedFg('Border.Widget'))\r\n        $highlightFg = [HybridRenderEngine]::AnsiColorToInt($this.GetThemedFg('Foreground.Title'))\r\n        $selectedBg = [HybridRenderEngine]::AnsiColorToInt($this.GetThemedBg('Background.RowSelected', 1, 0))\r\n        \r\n        if ($bg -eq -1) { $bg = [HybridRenderEngine]::_PackRGB(45, 55, 72) }\r\n\r\n        # Draw Box\r\n        $engine.Fill($this.X, $this.Y, $this.Width, $this.Height, ' ', $fg, $bg)\r\n        $engine.DrawBox($this.X, $this.Y, $this.Width, $this.Height, $borderFg, $bg)\r\n        \r\n        # Title\r\n        $pad = [Math]::Max(0, [Math]::Floor(($this.Width - 4 - $this.Title.Length) / 2))\r\n        $engine.WriteAt($this.X + 2 + $pad, $this.Y + 1, $this.Title, $highlightFg, $bg)\r\n        \r\n        # Header\r\n        $headerText = \" Task\".PadRight(25) + \" Hours  \" + \" Notes\"\r\n        # Manual clip if needed - header is fixed width usually\r\n        $engine.WriteAt($this.X + 2, $this.Y + 2, $headerText, $highlightFg, $bg)\r\n        \r\n        # Separator 1\r\n        $engine.WriteAt($this.X, $this.Y + 3, \"├\" + (\"─\" * ($this.Width - 2)) + \"┤\", $borderFg, $bg)\r\n        \r\n        # List Area\r\n        $listX = $this.X + 2\r\n        $listY = $this.Y + 4\r\n        $listWidth = $this.Width - 4\r\n        $listHeight = $this.Height - 6\r\n        \r\n        for ($i = 0; $i -lt $listHeight; $i++) {\r\n            $entryIndex = $this.ScrollOffset + $i\r\n            if ($entryIndex -ge $this.Entries.Count) { break }\r\n            \r\n            $entry = $this.Entries[$entryIndex]\r\n            $isSelected = ($entryIndex -eq $this.SelectedIndex)\r\n            \r\n            $iBg = if ($isSelected) { $selectedBg } else { $bg }\r\n            \r\n            # Format\r\n            $task = if ($entry.ContainsKey('task')) { $entry.task } else { '' }\r\n            if ($task.Length -gt 24) { $task = $task.Substring(0, 21) + \"...\" }\r\n            \r\n            $minutes = if ($entry.ContainsKey('minutes')) { $entry.minutes } else { 0 }\r\n            $hours = [Math]::Round($minutes / 60.0, 2)\r\n            \r\n            $notes = if ($entry.ContainsKey('notes')) { $entry.notes } else { '' }\r\n            $maxNotesLen = $this.Width - 35\r\n            if ($notes.Length -gt $maxNotesLen) { $notes = $notes.Substring(0, $maxNotesLen - 3) + \"...\" }\r\n            \r\n            $line = \" $($task.PadRight(24)) $($hours.ToString('0.00').PadLeft(5))  $notes\"\r\n            \r\n            # Ensure line fits\r\n            if ($line.Length -gt $listWidth) { $line = $line.Substring(0, $listWidth) }\r\n            \r\n            $engine.Fill($listX, $listY + $i, $listWidth, 1, ' ', $fg, $iBg)\r\n            $engine.WriteAt($listX, $listY + $i, $line, $fg, $iBg)\r\n        }\r\n        \r\n        # Separator 2\r\n        $engine.WriteAt($this.X, $this.Y + $this.Height - 3, \"├\" + (\"─\" * ($this.Width - 2)) + \"┤\", $borderFg, $bg)\r\n        \r\n        # Footer\r\n        $footer = \" ↑/↓: Navigate  Enter/Esc: Close\"\r\n        $engine.WriteAt($this.X + 2, $this.Y + $this.Height - 2, $footer, $fg, $bg)\r\n    }\r\n\r\n\r\n\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        switch ($keyInfo.Key) {\r\n            'UpArrow' {\r\n                if ($this.SelectedIndex -gt 0) {\r\n                    $this.SelectedIndex--\r\n                    # Adjust scroll if needed\r\n                    if ($this.SelectedIndex -lt $this.ScrollOffset) {\r\n                        $this.ScrollOffset = $this.SelectedIndex\r\n                    }\r\n                }\r\n                return $true\r\n            }\r\n            'DownArrow' {\r\n                if ($this.SelectedIndex -lt ($this.Entries.Count - 1)) {\r\n                    $this.SelectedIndex++\r\n                    # Adjust scroll if needed\r\n                    $maxVisible = $this.Height - 6  # 6 rows for border/header/footer\r\n                    if ($this.SelectedIndex -ge ($this.ScrollOffset + $maxVisible)) {\r\n                        $this.ScrollOffset = $this.SelectedIndex - $maxVisible + 1\r\n                    }\r\n                }\r\n                return $true\r\n            }\r\n            'Enter' {\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n            'Escape' {\r\n                $this.IsComplete = $true\r\n                return $true\r\n            }\r\n        }\r\n        return $false\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/consoleui/widgets/UniversalList.ps1", "content": "using namespace System\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Text\r\n\r\n# UniversalList.ps1 - Generic list widget with columns, sorting, filtering, and inline editing\r\n# THE BIG ONE - Replaces 12+ specialized list screens!\r\n#\r\n#\r\n# Usage:\r\n#   $columns = @(\r\n#       @{ Name='id'; Label='ID'; Width=4; Align='right' }\r\n#       @{ Name='priority'; Label='Pri'; Width=4; Align='center'; Format={ \"[P$_]\" }}\r\n#       @{ Name='text'; Label='Task'; Width=40; Align='left' }\r\n#       @{ Name='due'; Label='Due'; Width=12; Format={ $_.ToString('MMM dd yyyy') }}\r\n#       @{ Name='project'; Label='Project'; Width=15 }\r\n#   )\r\n#\r\n#   $list = [UniversalList]::new()\r\n#   $list.SetColumns($columns)\r\n#   $list.SetData($tasks)\r\n#   $list.SetPosition(0, 3)\r\n#   $list.SetSize(120, 35)\r\n#\r\n#   # Events\r\n#   $list.OnSelectionChanged = { param($item) Add-Content -Path \"/tmp/pmc-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] [UniversalList] Selected: $($item.text)\" }\r\n#   $list.OnItemEdit = { param($item) $this.ShowInlineEditor($item) }\r\n#   $list.OnItemDelete = { param($item) Remove-PmcTask $item.id }\r\n#\r\n#   # Actions (shown in footer)\r\n#   $list.AddAction('a', 'Add', { $this.ShowInlineEditor(@{}) })\r\n#   $list.AddAction('e', 'Edit', { $this.ShowInlineEditor($this.SelectedItem) })\r\n#   $list.AddAction('d', 'Delete', { $this.DeleteSelectedItem() })\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Load PmcWidget base class\r\nif (-not ([System.Management.Automation.PSTypeName]'PmcWidget').Type) {\r\n    . \"$PSScriptRoot/PmcWidget.ps1\"\r\n}\r\n\r\n# NOTE: InlineEditor and FilterPanel are now loaded by the launcher script.\r\n# Commenting out to avoid circular dependency issues.\r\n# . \"$PSScriptRoot/InlineEditor.ps1\"\r\n# . \"$PSScriptRoot/FilterPanel.ps1\"\r\n\r\n<#\r\n.SYNOPSIS\r\nUniversal list widget with columns, sorting, filtering, inline editing\r\n\r\n.DESCRIPTION\r\nFeatures:\r\n- Column configuration with width, alignment, formatting\r\n- Data binding to array of objects\r\n- Sorting by column (click header or hotkey)\r\n- Filtering with FilterPanel integration\r\n- Selection with arrow keys, Home/End, PageUp/Down\r\n- Multi-select mode (Space to toggle)\r\n- Inline editing with InlineEditor integration\r\n- Configurable actions (Add, Edit, Delete, etc.)\r\n- Virtual scrolling for large datasets (handles 1000+ items)\r\n- Differential rendering for performance\r\n- Search mode (/ key to filter by text)\r\n- Column resizing (future enhancement)\r\n\r\n.EXAMPLE\r\n$list = [UniversalList]::new()\r\n$columns = @(\r\n    @{ Name='id'; Label='ID'; Width=4 }\r\n    @{ Name='text'; Label='Task'; Width=40 }\r\n)\r\n$list.SetColumns($columns)\r\n$list.SetData($tasks)\r\n##CLOSEBRACKET##\r\n\r\n<#\r\n.SYNOPSIS\r\nCell information passed to Format callbacks\r\n\r\n.DESCRIPTION\r\nProvides context about a cell during rendering:\r\n- Column metadata (name, width, alignment)\r\n- Screen position (X, Y coordinates)\r\n- Edit state (is this cell focused for editing?)\r\n- Row state (is the row being edited?)\r\n\r\nThis allows Format callbacks to make rendering decisions based on\r\ncell state without needing to check global variables.\r\n\r\n.EXAMPLE\r\nFormat = { param($item, $cellInfo)\r\n    if ($cellInfo.IsFocused) {\r\n        return \"$orangeColor$($cellInfo.Value)\"\r\n    }\r\n    return $cellInfo.Value\r\n}\r\n##CLOSEBRACKET##\r\nclass CellInfo {\r\n    [string]$ColumnName        # Column identifier\r\n    [object]$Value             # Raw cell value (from item data)\r\n    [int]$X                    # Screen X position\r\n    [int]$Y                    # Screen Y position\r\n    [int]$Width                # Allocated width for this cell\r\n    [string]$Align             # Alignment: 'left', 'center', 'right'\r\n    [bool]$IsFocused           # Is this cell currently focused in edit mode?\r\n    [bool]$IsInEditMode        # Is the parent row in edit mode?\r\n    [bool]$IsSelected          # Is the parent row selected?\r\n    [int]$RowIndex             # Row index in the list\r\n    [int]$ColumnIndex          # Column index in the row\r\n\r\n    CellInfo(\r\n        [string]$columnName,\r\n        [object]$value,\r\n        [int]$x,\r\n        [int]$y,\r\n        [int]$width,\r\n        [string]$align,\r\n        [bool]$isFocused,\r\n        [bool]$isInEditMode,\r\n        [bool]$isSelected,\r\n        [int]$rowIndex,\r\n        [int]$columnIndex\r\n    ) {\r\n        $this.ColumnName = $columnName\r\n        $this.Value = $value\r\n        $this.X = $x\r\n        $this.Y = $y\r\n        $this.Width = $width\r\n        $this.Align = $align\r\n        $this.IsFocused = $isFocused\r\n        $this.IsInEditMode = $isInEditMode\r\n        $this.IsSelected = $isSelected\r\n        $this.RowIndex = $rowIndex\r\n        $this.ColumnIndex = $columnIndex\r\n    }\r\n}\r\n\r\nclass UniversalList : PmcWidget {\r\n    # === Public Properties ===\r\n    [string]$Title = \"List\"                    # List title\r\n    [bool]$AllowMultiSelect = $true            # Allow multi-select mode\r\n    [bool]$AllowInlineEdit = $true             # Allow inline editing\r\n    [bool]$AllowSearch = $true                 # Allow search mode\r\n    [bool]$ShowLineNumbers = $false            # Show line numbers in first column\r\n    [int]$ItemsPerPage = 10                    # Items per page (for PageUp/Down)\r\n\r\n    # === Event Callbacks ===\r\n    [scriptblock]$OnSelectionChanged = {}      # Called when selection changes: param($item)\r\n    [scriptblock]$OnItemEdit = {}              # Called when item edited: param($item)\r\n    [scriptblock]$OnItemDelete = {}            # Called when item deleted: param($item)\r\n    [scriptblock]$OnItemActivated = {}         # Called when item activated (Enter): param($item)\r\n    [scriptblock]$OnMultiSelectChanged = {}    # Called when multi-select changes: param($selectedItems)\r\n    [scriptblock]$OnDataChanged = {}           # Called when data changes: param($newData)\r\n\r\n    # === Edit Mode Callbacks (for CellInfo) ===\r\n    # Parent screen sets these to provide edit state info to Format callbacks via CellInfo\r\n    [scriptblock]$GetIsInEditMode = {}         # Returns true if row is in edit mode: param($item)\r\n    [scriptblock]$GetFocusedColumnIndex = {}   # Returns focused column index: param($item) -> int (-1 if not focused)\r\n    [scriptblock]$GetEditValue = {}            # Returns edit value for cell: param($item, $columnName) -> value or null\r\n\r\n    # === State Flags ===\r\n    [bool]$IsInMultiSelectMode = $false        # True when in multi-select mode\r\n    [bool]$IsInSearchMode = $false             # True when in search mode\r\n    [bool]$IsInFilterMode = $false             # True when filter panel shown\r\n\r\n    # === Private State ===\r\n    hidden [List[hashtable]]$_columns = [List[hashtable]]::new()         # Column definitions\r\n    hidden [object[]]$_data = @()                                        # Original data array\r\n    hidden [object[]]$_filteredData = @()                                # Filtered/sorted data\r\n    hidden [int]$_selectedIndex = 0                                      # Selected item index\r\n    hidden [HashSet[int]]$_selectedIndices = [HashSet[int]]::new()       # Multi-select indices\r\n    hidden [int]$_scrollOffset = 0                                       # Virtual scroll offset\r\n    hidden [string]$_sortColumn = \"\"                                     # Current sort column\r\n    hidden [bool]$_sortAscending = $true                                 # Sort direction\r\n    hidden [string]$_searchText = \"\"                                     # Search filter text\r\n    hidden [hashtable]$_actions = @{}                                    # Registered actions (key -> scriptblock)\r\n    hidden [object]$_filterPanel = $null                                 # Filter panel instance (FilterPanel)\r\n    hidden [object]$_inlineEditor = $null                                # Inline editor instance (InlineEditor)\r\n    hidden [bool]$_showInlineEditor = $false                             # Show inline editor overlay\r\n    hidden [string]$_lastRenderedContent = \"\"                            # Last rendered content (for diff)\r\n    # L-POL-22: Column width adjustment\r\n    hidden [hashtable]$_columnWidths = @{}                               # Custom column widths (overrides defaults)\r\n\r\n    # === Region Cache for Layout System ===\r\n    hidden [string[]]$_headerColRegions = @()                            # Region IDs for header columns\r\n    hidden [hashtable]$_rowColRegions = @{}                              # Region IDs for data row columns (key: row index, value: array of region IDs)\r\n\r\n    # Reset column widths to defaults\r\n    [void] ResetColumnWidths() {\r\n        $this._columnWidths.Clear()\r\n        $this._cacheGeneration++\r\n        $this._rowCache.Clear()\r\n        $this._cacheAccessOrder.Clear()\r\n    }\r\n    hidden [int]$_selectedColumnIndex = -1                               # Currently selected column for width adjustment\r\n\r\n    # === Row-Level Caching for Performance ===\r\n    hidden [hashtable]$_rowCache = @{}                                   # Cache of rendered rows by index\r\n    hidden [int]$_cacheGeneration = 0                                    # Increment to invalidate all cache\r\n    # H-MEM-1: LRU cache management\r\n    hidden [System.Collections.Generic.LinkedList[string]]$_cacheAccessOrder = [System.Collections.Generic.LinkedList[string]]::new()\r\n    hidden [int]$_maxCacheSize = 500                                     # Maximum cache entries\r\n\r\n    # === Constructor ===\r\n    UniversalList() : base(\"UniversalList\") {\r\n        $this.Width = 120\r\n        $this.Height = 35\r\n        $this.CanFocus = $true\r\n\r\n        # Initialize filter panel\r\n        $this._filterPanel = [FilterPanel]::new()\r\n        $this._filterPanel.SetPosition($this.X + 10, $this.Y + 5)\r\n        $this._filterPanel.SetSize(60, 12)\r\n        $self = $this\r\n        $this._filterPanel.OnFiltersChanged = { param($filters)\r\n            $self._ApplyFilters()\r\n        }\r\n    }\r\n\r\n    # === Layout System ===\r\n\r\n    [void] SetPosition([int]$x, [int]$y) {\r\n        ([PmcWidget]$this).SetPosition($x, $y)\r\n        \r\n        # Update filter panel relative position\r\n        if ($this._filterPanel) {\r\n            $this._filterPanel.SetPosition($x + 10, $y + 5)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Register layout regions with the engine.\r\n    This defines the grid structure for the list.\r\n    ##CLOSEBRACKET##\r\n    [void] RegisterLayout([object]$engine) {\r\n        # Call base class to register its own region\r\n        ([PmcWidget]$this).RegisterLayout($engine)\r\n        \r\n        # NOTE: We do not define sub-regions for cells/headers.\r\n        # We render dynamic content using WriteAt (FilterPanel pattern) \r\n        # to ensure robust visibility and precise layout control.\r\n    }\r\n\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get property value from item (handles both hashtable and PSCustomObject)\r\n\r\n    .PARAMETER item\r\n    The item (hashtable or PSCustomObject)\r\n\r\n    .PARAMETER propertyName\r\n    Property name to retrieve\r\n\r\n    .OUTPUTS\r\n    Property value or $null if not found\r\n    ##CLOSEBRACKET##\r\n    hidden [object] _GetItemProperty([object]$item, [string]$propertyName) {\r\n        if ($null -eq $item) { return $null }\r\n\r\n        if ($item -is [hashtable]) {\r\n            $hasKey = $item.ContainsKey($propertyName)\r\n            # Write-PmcTuiLog \"_GetItemProperty: hashtable propertyName='$propertyName' hasKey=$hasKey\"\r\n            if ($hasKey) {\r\n                $value = $item[$propertyName]\r\n                $typeStr = $(if ($null -ne $value) { $value.GetType().Name } else { 'NULL' })\r\n                # Write-PmcTuiLog \"_GetItemProperty: returning value='$value' (type=$typeStr)\"\r\n                return $value\r\n            }\r\n        }\r\n        elseif ($item.PSObject.Properties[$propertyName]) {\r\n            $value = $item.$propertyName\r\n            # Write-PmcTuiLog \"_GetItemProperty: PSObject propertyName='$propertyName' value='$value'\"\r\n            return $value\r\n        }\r\n\r\n        # Write-PmcTuiLog \"_GetItemProperty: propertyName='$propertyName' NOT FOUND, returning null\"\r\n        return $null\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Check if item has property (handles both hashtable and PSCustomObject)\r\n    ##CLOSEBRACKET##\r\n    hidden [bool] _HasItemProperty([object]$item, [string]$propertyName) {\r\n        if ($null -eq $item) { return $false }\r\n\r\n        if ($item -is [hashtable]) {\r\n            return $item.ContainsKey($propertyName)\r\n        }\r\n        else {\r\n            return $null -ne $item.PSObject.Properties[$propertyName]\r\n        }\r\n    }\r\n\r\n    # === Public API Methods ===\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set column definitions\r\n\r\n    .PARAMETER columns\r\n    Array of column hashtables:\r\n    - Name: Property name (required)\r\n    - Label: Display label (required)\r\n    - Width: Column width in characters (required)\r\n    - Align: 'left', 'center', 'right' (optional, default 'left')\r\n    - Format: Scriptblock to format value (optional)\r\n    - Sortable: Whether column is sortable (optional, default $true)\r\n    ##CLOSEBRACKET##\r\n    [void] SetColumns([hashtable[]]$columns) {\r\n        $this._columns.Clear()\r\n\r\n        # Force array type to prevent unwrapping\r\n        $columnsArray = @($columns)\r\n\r\n        if ($null -eq $columnsArray -or $columnsArray.Count -eq 0) {\r\n            throw \"At least one column is required\"\r\n        }\r\n\r\n        foreach ($col in $columnsArray) {\r\n            if (-not $col.ContainsKey('Name')) {\r\n                throw \"Column missing 'Name' property\"\r\n            }\r\n            if (-not $col.ContainsKey('Label')) {\r\n                throw \"Column missing 'Label' property\"\r\n            }\r\n            if (-not $col.ContainsKey('Width')) {\r\n                throw \"Column missing 'Width' property\"\r\n            }\r\n\r\n            # Set defaults\r\n            if (-not $col.ContainsKey('Align')) {\r\n                $col.Align = 'left'\r\n            }\r\n            if (-not $col.ContainsKey('Sortable')) {\r\n                $col.Sortable = $true\r\n            }\r\n\r\n            $this._columns.Add($col)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set data array\r\n\r\n    .PARAMETER data\r\n    Array of objects to display\r\n    ##CLOSEBRACKET##\r\n    [void] SetData([array]$data) {\r\n        try {\r\n            # Write-PmcTuiLog \"UniversalList.SetData: START\" \"DEBUG\"\r\n        \r\n            if ($null -ne $data) {\r\n                $this._data = [object[]]@($data)\r\n            }\r\n            else {\r\n                $this._data = [object[]]@()\r\n            }\r\n\r\n            $this._filteredData = [object[]]@($this._data)\r\n            $this._selectedIndex = 0\r\n            $this._scrollOffset = 0\r\n            $this._selectedIndices.Clear()\r\n\r\n            $this._cacheGeneration++\r\n            $this._rowCache.Clear()\r\n            $this._cacheAccessOrder.Clear()\r\n\r\n            $this._ApplyFilters()\r\n            $this._ApplySearch()\r\n\r\n            $this._InvokeCallback($this.OnDataChanged, $this._data)\r\n            # Write-PmcTuiLog \"UniversalList.SetData: COMPLETE ($($this._data.Count) items)\" \"DEBUG\"\r\n        }\r\n        catch {\r\n            # Write-PmcTuiLog \"FATAL ERROR UniversalList.SetData: $_\" \"ERROR\"\r\n            throw\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get currently selected item\r\n\r\n    .OUTPUTS\r\n    Selected item object or $null if none selected\r\n    ##CLOSEBRACKET##\r\n    [object] GetSelectedItem() {\r\n        if ($this._filteredData.Count -eq 0) {\r\n            return $null\r\n        }\r\n\r\n        if ($this._selectedIndex -ge 0 -and $this._selectedIndex -lt $this._filteredData.Count) {\r\n            return $this._filteredData[$this._selectedIndex]\r\n        }\r\n\r\n        return $null\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get currently selected index\r\n    ##CLOSEBRACKET##\r\n    <#\r\n    .SYNOPSIS\r\n    Get currently selected index\r\n    ##CLOSEBRACKET##\r\n    [int] GetSelectedIndex() {\r\n        return $this._selectedIndex\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get current scroll offset\r\n    ##CLOSEBRACKET##\r\n    [int] GetScrollOffset() {\r\n        return $this._scrollOffset\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set selected index\r\n    ##CLOSEBRACKET##\r\n    [void] SelectIndex([int]$index) {\r\n        if ($index -ge 0 -and $index -lt $this._filteredData.Count) {\r\n            $this._selectedIndex = $index\r\n            $this._AdjustScrollOffset()\r\n            $this._TriggerSelectionChanged()\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get all selected items (multi-select mode)\r\n\r\n    .OUTPUTS\r\n    Array of selected items\r\n    ##CLOSEBRACKET##\r\n    [array] GetSelectedItems() {\r\n        $selected = @()\r\n\r\n        foreach ($index in $this._selectedIndices) {\r\n            if ($index -ge 0 -and $index -lt $this._filteredData.Count) {\r\n                $selected += $this._filteredData[$index]\r\n            }\r\n        }\r\n\r\n        return $selected\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Get the count of filtered items\r\n    ##CLOSEBRACKET##\r\n    [int] GetItemCount() {\r\n        return $this._filteredData.Count\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Invalidate the row rendering cache.\r\n    Call this when external state that affects row rendering changes.\r\n    ##CLOSEBRACKET##\r\n    [void] InvalidateCache() {\r\n        $this._cacheGeneration++\r\n        $this._rowCache.Clear()\r\n        $this._cacheAccessOrder.Clear()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Set sort column and direction\r\n\r\n    .PARAMETER columnName\r\n    Column name to sort by\r\n\r\n    .PARAMETER ascending\r\n    Sort ascending if $true, descending if $false\r\n    ##CLOSEBRACKET##\r\n    [void] SetSortColumn([string]$columnName, [bool]$ascending) {\r\n        $this._sortColumn = $columnName\r\n        $this._sortAscending = $ascending\r\n        $this._ApplySort()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Add an action (hotkey + callback)\r\n\r\n    .PARAMETER key\r\n    Hotkey character\r\n\r\n    .PARAMETER label\r\n    Action label for display\r\n\r\n    .PARAMETER callback\r\n    Scriptblock to invoke when action triggered\r\n    ##CLOSEBRACKET##\r\n    [void] AddAction([string]$key, [string]$label, [scriptblock]$callback) {\r\n        $this._actions[$key] = @{\r\n            Label    = $label\r\n            Callback = $callback\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Remove an action\r\n\r\n    .PARAMETER key\r\n    Hotkey character\r\n    ##CLOSEBRACKET##\r\n    [void] RemoveAction([string]$key) {\r\n        $this._actions.Remove($key)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Show inline editor for an item\r\n\r\n    .PARAMETER item\r\n    Item to edit (or empty hashtable for new item)\r\n\r\n    .PARAMETER fieldDefinitions\r\n    Field definitions for InlineEditor (optional, will infer from columns)\r\n    ##CLOSEBRACKET##\r\n    [void] ShowInlineEditor([object]$item, [hashtable[]]$fieldDefinitions = $null) {\r\n        if (-not $this.AllowInlineEdit) {\r\n            return\r\n        }\r\n\r\n        # Create inline editor if not exists\r\n        if ($null -eq $this._inlineEditor) {\r\n            $this._inlineEditor = [InlineEditor]::new()\r\n            # Position and Size are now managed by the Layout System via TargetRegionID\r\n        }\r\n\r\n        # Build field definitions from columns if not provided\r\n        if ($null -eq $fieldDefinitions) {\r\n            $fields = @()\r\n            foreach ($col in $this._columns) {\r\n                $field = @{\r\n                    Name  = $col.Name\r\n                    Label = $col.Label\r\n                    Type  = 'text'  # Default to text, could be smarter\r\n                    Value = $(if ($item.($col.Name)) { $item.($col.Name) } else { \"\" })\r\n                }\r\n                $fields += $field\r\n            }\r\n            $fieldDefinitions = $fields\r\n        }\r\n\r\n        $this._inlineEditor.SetFields($fieldDefinitions)\r\n        $this._inlineEditor.IsConfirmed = $false\r\n        $this._inlineEditor.IsCancelled = $false\r\n\r\n        # Set callback for when editor confirms\r\n        $this._inlineEditor.OnConfirmed = { param($values)\r\n            # Update item with new values\r\n            foreach ($key in $values.Keys) {\r\n                $item.$key = $values[$key]\r\n            }\r\n            $this._InvokeCallback($this.OnItemEdit, $item)\r\n            $this._showInlineEditor = $false\r\n        }\r\n\r\n        $this._inlineEditor.OnCancelled = {\r\n            $this._showInlineEditor = $false\r\n        }\r\n\r\n        $this._showInlineEditor = $true\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Show filter panel\r\n    ##CLOSEBRACKET##\r\n    [void] ShowFilterPanel() {\r\n        $this.IsInFilterMode = $true\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Hide filter panel\r\n    ##CLOSEBRACKET##\r\n    [void] HideFilterPanel() {\r\n        $this.IsInFilterMode = $false\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle keyboard input\r\n\r\n    .PARAMETER keyInfo\r\n    ConsoleKeyInfo from [Console]::ReadKey($true)\r\n\r\n    .OUTPUTS\r\n    True if input was handled, False otherwise\r\n    ##CLOSEBRACKET##\r\n    [bool] HandleInput([ConsoleKeyInfo]$keyInfo) {\r\n        # DON'T handle inline editor input here - let StandardListScreen handle it\r\n        # This prevents the list and screen from getting out of sync\r\n        # if ($this._showInlineEditor) {\r\n        #     $handled = $this._inlineEditor.HandleInput($keyInfo)\r\n        #\r\n        #     if ($this._inlineEditor.IsConfirmed -or $this._inlineEditor.IsCancelled) {\r\n        #         $this._showInlineEditor = $false\r\n        #     }\r\n        #\r\n        #     # If editor handled the key, we're done\r\n        #     # Otherwise, fall through to allow parent/global handlers (e.g., Ctrl+Q)\r\n        #     if ($handled) {\r\n        #         return $true\r\n        #     }\r\n        #     # Don't return false here - let parent handlers have a chance\r\n        # }\r\n\r\n        # Route input to filter panel if shown\r\n        if ($this.IsInFilterMode) {\r\n            $handled = $this._filterPanel.HandleInput($keyInfo)\r\n\r\n            # Esc closes filter panel\r\n            if ($keyInfo.Key -eq 'Escape') {\r\n                $this.IsInFilterMode = $false\r\n                return $true\r\n            }\r\n\r\n            # If filter panel handled the key, we're done\r\n            # Otherwise, fall through to allow parent/global handlers\r\n            if ($handled) {\r\n                return $true\r\n            }\r\n            # Don't return false here - let parent handlers have a chance\r\n        }\r\n\r\n        # Search mode input\r\n        if ($this.IsInSearchMode) {\r\n            $handled = $this._HandleSearchInput($keyInfo)\r\n            # If search handled the key, we're done\r\n            # Otherwise, fall through to allow parent/global handlers (e.g., Ctrl+Q)\r\n            if ($handled) {\r\n                return $true\r\n            }\r\n            # Don't return false here - let parent handlers have a chance\r\n        }\r\n\r\n        # Global shortcuts\r\n        if ($keyInfo.Key -eq 'Enter') {\r\n            # Don't activate item if inline editor is showing\r\n            if ($this._showInlineEditor) {\r\n                return $false  # Let parent handle it\r\n            }\r\n            # Activate selected item\r\n            try {\r\n                $selectedItem = $this.GetSelectedItem()\r\n                if ($null -ne $selectedItem) {\r\n                    $this._InvokeCallback($this.OnItemActivated, $selectedItem)\r\n                }\r\n                else {\r\n                }\r\n            }\r\n            catch {\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Navigation\r\n        if ($keyInfo.Key -eq 'UpArrow') {\r\n            $this._MoveSelectionUp(1)\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'DownArrow') {\r\n            $this._MoveSelectionDown(1)\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'PageUp') {\r\n            $this._MoveSelectionUp($this.ItemsPerPage)\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'PageDown') {\r\n            $this._MoveSelectionDown($this.ItemsPerPage)\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'Home') {\r\n            if ($this._filteredData.Count -eq 0) {\r\n                $this._selectedIndex = -1\r\n            }\r\n            else {\r\n                $this._selectedIndex = 0\r\n            }\r\n            $this._AdjustScrollOffset()\r\n            $this._TriggerSelectionChanged()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'End') {\r\n            if ($this._filteredData.Count -eq 0) {\r\n                $this._selectedIndex = -1\r\n            }\r\n            else {\r\n                $this._selectedIndex = $this._filteredData.Count - 1\r\n            }\r\n            $this._AdjustScrollOffset()\r\n            $this._TriggerSelectionChanged()\r\n            return $true\r\n        }\r\n\r\n        # Multi-select mode\r\n        if ($keyInfo.Key -eq 'Spacebar' -and $this.AllowMultiSelect) {\r\n            $this._ToggleMultiSelect()\r\n            return $true\r\n        }\r\n\r\n        # Enter multi-select mode\r\n        if ($keyInfo.Key -eq 'M' -and $this.AllowMultiSelect) {\r\n            $this.IsInMultiSelectMode = -not $this.IsInMultiSelectMode\r\n            if (-not $this.IsInMultiSelectMode) {\r\n                $this._selectedIndices.Clear()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # /: Toggle sort (cycle through columns)\r\n        if ($keyInfo.KeyChar -eq '/') {\r\n            if ($this._columns.Count -gt 0) {\r\n                # Find current sort column index\r\n                $currentIdx = -1\r\n                for ($i = 0; $i -lt $this._columns.Count; $i++) {\r\n                    if ($this._columns[$i].Name -eq $this._sortColumn) {\r\n                        $currentIdx = $i\r\n                        break\r\n                    }\r\n                }\r\n\r\n                # Move to next column (or reverse if same column)\r\n                if ($currentIdx -eq -1) {\r\n                    # No sort, start with first column\r\n                    $this._sortColumn = $this._columns[0].Name\r\n                    $this._sortAscending = $true\r\n                }\r\n                elseif ($this._sortAscending) {\r\n                    # Same column, reverse to descending\r\n                    $this._sortAscending = $false\r\n                }\r\n                else {\r\n                    # Next column, ascending\r\n                    $nextIdx = ($currentIdx + 1) % $this._columns.Count\r\n                    $this._sortColumn = $this._columns[$nextIdx].Name\r\n                    $this._sortAscending = $true\r\n                }\r\n\r\n                # Re-sort data\r\n                $this._ApplySort()\r\n                return $true\r\n            }\r\n        }\r\n\r\n        # ?: Search mode (filter by text)\r\n        if ($keyInfo.KeyChar -eq '?' -and $this.AllowSearch) {\r\n            $this.IsInSearchMode = $true\r\n            $this._searchText = \"\"\r\n            return $true\r\n        }\r\n\r\n        # F: Filter mode\r\n        if ($keyInfo.Key -eq 'F') {\r\n            $this.ShowFilterPanel()\r\n            return $true\r\n        }\r\n\r\n        # L-POL-22: Alt+Left/Right - adjust column width, Alt+0 - reset all widths\r\n        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Alt) {\r\n            if ($keyInfo.Key -eq 'LeftArrow') {\r\n                # Decrease width of current column\r\n                if ($this._selectedColumnIndex -ge 0 -and $this._selectedColumnIndex -lt $this._columns.Count) {\r\n                    $colName = $this._columns[$this._selectedColumnIndex].Name\r\n                    $currentWidth = $(if ($this._columnWidths.ContainsKey($colName)) {\r\n                            $this._columnWidths[$colName]\r\n                        }\r\n                        else {\r\n                            $this._columns[$this._selectedColumnIndex].Width\r\n                        })\r\n                    $this._columnWidths[$colName] = [Math]::Max(5, $currentWidth - 2)\r\n                    # Invalidate row cache\r\n                    $this._cacheGeneration++\r\n                    $this._rowCache.Clear()\r\n                    $this._cacheAccessOrder.Clear()\r\n                }\r\n                return $true\r\n            }\r\n            if ($keyInfo.Key -eq 'RightArrow') {\r\n                # Increase width of current column\r\n                if ($this._selectedColumnIndex -ge 0 -and $this._selectedColumnIndex -lt $this._columns.Count) {\r\n                    $colName = $this._columns[$this._selectedColumnIndex].Name\r\n                    $currentWidth = $(if ($this._columnWidths.ContainsKey($colName)) {\r\n                            $this._columnWidths[$colName]\r\n                        }\r\n                        else {\r\n                            $this._columns[$this._selectedColumnIndex].Width\r\n                        })\r\n                    $this._columnWidths[$colName] = [Math]::Min(100, $currentWidth + 2)\r\n                    # Invalidate row cache\r\n                    $this._cacheGeneration++\r\n                    $this._rowCache.Clear()\r\n                    $this._cacheAccessOrder.Clear()\r\n                }\r\n                return $true\r\n            }\r\n            if ($keyInfo.Key -eq 'D0' -or $keyInfo.KeyChar -eq '0') {\r\n                # Reset all column widths to defaults\r\n                $this.ResetColumnWidths()\r\n                return $true\r\n            }\r\n        }\r\n\r\n        # C key - cycle selected column for width adjustment\r\n        if ($keyInfo.KeyChar -eq 'c' -or $keyInfo.KeyChar -eq 'C') {\r\n            $this._selectedColumnIndex = ($this._selectedColumnIndex + 1) % $this._columns.Count\r\n            return $true\r\n        }\r\n\r\n        # Action handling\r\n        $keyChar = $keyInfo.KeyChar.ToString().ToLower()\r\n\r\n        if ($this._actions.ContainsKey($keyChar)) {\r\n            $action = $this._actions[$keyChar]\r\n            $this._InvokeCallback($action.Callback, $this)\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Render the universal list using native HybridRenderEngine\r\n    ##CLOSEBRACKET##\r\n    [void] RenderToEngine([object]$engine) {\r\n        # Ensure layout is registered (for mouse/interaction if supported)\r\n        $this.RegisterLayout($engine)\r\n\r\n        $borderColor = $this.GetThemedColorInt('Border.Widget')\r\n        $textColor = $this.GetThemedColorInt('Foreground.Row')\r\n        $primaryColor = $this.GetThemedColorInt('Foreground.Title')\r\n        $mutedColor = $this.GetThemedColorInt('Foreground.Muted')\r\n        $successColor = $this.GetThemedColorInt('Foreground.Success')\r\n\r\n        $rowBg = $this.GetThemedColorInt('Background.Row')\r\n        $selBg = $this.GetThemedColorInt('Background.RowSelected')\r\n        $selFg = $this.GetThemedColorInt('Foreground.RowSelected')\r\n        $warnBg = $this.GetThemedColorInt('Background.Warning')\r\n\r\n        # 1. Draw Container Box\r\n        $engine.DrawBox($this.X, $this.Y, $this.Width, $this.Height, $borderColor, $rowBg)\r\n\r\n        # 2. Draw Title\r\n        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {\r\n            try {\r\n                $engine.WriteAt($this.X + 2, $this.Y, \" $($this.Title) \", $primaryColor, $rowBg)\r\n            }\r\n            catch {\r\n                # Title write failure is non-critical\r\n            }\r\n        }\r\n\r\n\r\n        # Get Theme Ints directly\r\n        $borderColor = $this.GetThemedInt('Border.Widget')\r\n        $textColor = $this.GetThemedInt('Foreground.Row')\r\n        $primaryColor = $this.GetThemedInt('Foreground.Title')\r\n        $mutedColor = $this.GetThemedInt('Foreground.Muted')\r\n        $defaultBg = -1 # Transparent/Default\r\n\r\n        $highlightBg = $this.GetThemedBgInt('Background.RowSelected', 1, 0)\r\n        $highlightFg = $this.GetThemedInt('Foreground.RowSelected')\r\n\r\n        # Fallbacks removed for strict theme enforcement\r\n        # if ($highlightBg -eq -1) { $highlightBg = [HybridRenderEngine]::_PackRGB(64, 94, 117) } # Blue\r\n        # if ($highlightFg -eq -1) { $highlightFg = [HybridRenderEngine]::_PackRGB(255, 255, 255) } # White\r\n\r\n\r\n        $currentRow = 1\r\n\r\n        # Draw Headers (Using WriteAt - Matching FilterPanel Pattern)\r\n        $supportsUnicode = $env:LANG -match 'UTF-8' -or [Console]::OutputEncoding.EncodingName -match 'UTF'\r\n        $sortUpSymbol = $(if ($supportsUnicode) { \"↑\" } else { \"^\" })\r\n        $sortDownSymbol = $(if ($supportsUnicode) { \"↓\" } else { \"v\" })\r\n\r\n        $currentX = $this.X + 2\r\n        for ($i = 0; $i -lt $this._columns.Count; $i++) {\r\n            $col = $this._columns[$i]\r\n            $label = $col.Label\r\n\r\n            # Determine Width\r\n            $colWidth = 10\r\n            if ($this._columnWidths.ContainsKey($col.Name)) {\r\n                $colWidth = $this._columnWidths[$col.Name]\r\n            }\r\n            elseif ($col.Width) {\r\n                $colWidth = $col.Width\r\n            }\r\n\r\n            if ($this._sortColumn -eq $col.Name) {\r\n                $sortIndicator = $(if ($this._sortAscending) { \" $sortUpSymbol\" } else { \" $sortDownSymbol\" })\r\n                $label += $sortIndicator\r\n            }\r\n\r\n            # Clip Label\r\n            if ($label.Length -gt $colWidth) {\r\n                $label = $label.Substring(0, $colWidth)\r\n            }\r\n            \r\n            # Write Header directly\r\n            $engine.WriteAt($currentX, $this.Y + 1, $label, $primaryColor, $defaultBg)\r\n            $currentX += $colWidth\r\n        }\r\n        \r\n        # 4. Draw Rows (Virtual Scrolling with WriteAt)\r\n        $maxVisibleRows = $this.Height - 6 \r\n        $visibleStartIndex = $this._scrollOffset\r\n        $itemCount = $this.GetItemCount()\r\n        \r\n        for ($i = 0; $i -lt $maxVisibleRows; $i++) {\r\n            $dataIndex = $visibleStartIndex + $i\r\n            $rowY = $this.Y + 3 + $i\r\n\r\n            # If beyond data, fill with background (preserve borders!)\r\n            if ($dataIndex -ge $itemCount) {\r\n                # BORDER FIX: Fill ONLY content area (X+1 to Width-2), not borders\r\n                $engine.Fill($this.X + 1, $rowY, $this.Width - 2, 1, ' ', $textColor, $rowBg)\r\n                continue\r\n            }\r\n\r\n            $item = $this._filteredData[$dataIndex]\r\n            $isSelected = ($dataIndex -eq $this._selectedIndex)\r\n            $isMultiSelected = $this._selectedIndices.Contains($dataIndex)\r\n\r\n            # Skip rendering selected row if inline editor is active (editor will render in its place)\r\n            # But clear the row to avoid visual artifacts\r\n            if ($isSelected -and $this._showInlineEditor) {\r\n                # CRITICAL FIX: Clear ONLY the content area, NOT the borders\r\n                # Clear from X+2 (after left border+padding) to Width-4 (before right padding+border)\r\n                if ($global:PmcEnableFlowDebug) {\r\n                    # Add-Content -Path \"/tmp/pmc-universallist-debug.log\" -Value \"[$(Get-Date -Format 'HH:mm:ss.fff')] CLEARING ROW: dataIndex=$dataIndex rowY=$rowY Y=$($this.Y) selectedIndex=$($this._selectedIndex) fillWidth=$($this.Width)\"\r\n                }\r\n                $engine.Fill($this.X + 2, $rowY, $this.Width - 4, 1, ' ', $textColor, $rowBg)\r\n                continue\r\n            }\r\n            \r\n            # Colors for this row\r\n            $fg = $textColor\r\n            $bg = $rowBg\r\n            \r\n            if ($isSelected) {\r\n                $fg = $selFg\r\n                $bg = $selBg\r\n            }\r\n            elseif ($isMultiSelected) {\r\n                $fg = $successColor\r\n                $bg = $rowBg\r\n            }\r\n            \r\n            # RENDERING FIX: Fill entire row background FIRST to clear any editor artifacts\r\n            # This ensures the previous inline editor's background doesn't bleed through\r\n            $engine.Fill($this.X + 1, $rowY, $this.Width - 2, 1, ' ', $fg, $bg)\r\n            \r\n            # Render Cells\r\n            $cellX = $this.X + 2\r\n            for ($c = 0; $c -lt $this._columns.Count; $c++) {\r\n                $col = $this._columns[$c]\r\n                \r\n                # Determine Width\r\n                $colWidth = 10\r\n                if ($this._columnWidths.ContainsKey($col.Name)) {\r\n                    $colWidth = $this._columnWidths[$col.Name]\r\n                }\r\n                elseif ($col.Width) {\r\n                    $colWidth = $col.Width\r\n                }\r\n                \r\n                # 4a. Get Value\r\n                $val = $this._GetItemProperty($item, $col.Name)\r\n                \r\n                # 4b. Format Value\r\n                if ($col.ContainsKey('Format') -and $col.Format) {\r\n                    try {\r\n                        $val = & $col.Format $item $null\r\n                    }\r\n                    catch {\r\n                        # Format callback failed - use raw value\r\n                    }\r\n                }\r\n                \r\n                $strVal = $(if ($val -ne $null) { $val.ToString() } else { \"\" })\r\n                \r\n                # 4c. Clip & Pad\r\n                if ($strVal.Length -gt $colWidth) {\r\n                    $strVal = $strVal.Substring(0, $colWidth)\r\n                }\r\n                \r\n                $strVal = $strVal.PadRight($colWidth)\r\n                \r\n                # 4d. Write - Use WriteThemedAt for gradient support on non-selected rows\r\n                if ($isSelected -or $isMultiSelected) {\r\n                    # Selected rows use solid colors for readability\r\n                    $engine.WriteAt($cellX, $rowY, $strVal, $fg, $bg)\r\n                }\r\n                else {\r\n                    # Normal rows use themed gradient (if theme defines it)\r\n                    $this.WriteThemedAt($engine, $cellX, $rowY, $strVal, 'Foreground.Row', 'Background.Row')\r\n                }\r\n                \r\n                $cellX += $colWidth\r\n            }\r\n        }\r\n        \r\n        # 5. Status Footer (Item Count)\r\n        try {\r\n            $countText = \"($($itemCount) items)\"\r\n            $engine.WriteAt($this.X + $this.Width - $countText.Length - 2, $this.Y, $countText, $mutedColor, $rowBg)\r\n        }\r\n        catch {\r\n            # Item count display is non-critical\r\n        }\r\n        \r\n        # 6. Inline Editor (Delegate)\r\n        if ($this._showInlineEditor -and $this._inlineEditor) {\r\n            $relIndex = $this._selectedIndex - $this._scrollOffset\r\n            if ($relIndex -ge 0 -and $relIndex -lt $maxVisibleRows) {\r\n                $rowY = $this.Y + 3 + $relIndex\r\n\r\n                # Position editor at the selected row\r\n                $this._inlineEditor.X = $this.X + 2\r\n                $this._inlineEditor.Y = $rowY\r\n                $this._inlineEditor.Width = $this.Width - 4\r\n                $this._inlineEditor.Height = 1\r\n\r\n\r\n                # Render Editor\r\n                $this._inlineEditor.RenderToEngine($engine)\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    # Helper methods for search/input remain...\r\n    # Helper methods for search/input follow...\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move selection up\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _MoveSelectionUp() {\r\n        $this._MoveSelectionUp(1)\r\n    }\r\n\r\n    hidden [void] _MoveSelectionUp([int]$count) {\r\n        if ($this._filteredData.Count -eq 0) {\r\n            $this._selectedIndex = -1\r\n        }\r\n        else {\r\n            $this._selectedIndex = [Math]::Max(0, $this._selectedIndex - $count)\r\n            $this._selectedIndex = [Math]::Min($this._selectedIndex, $this._filteredData.Count - 1)\r\n        }\r\n        $this._AdjustScrollOffset()\r\n        $this._TriggerSelectionChanged()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Move selection down\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _MoveSelectionDown() {\r\n        $this._MoveSelectionDown(1)\r\n    }\r\n\r\n    hidden [void] _MoveSelectionDown([int]$count) {\r\n        if ($this._filteredData.Count -eq 0) {\r\n            $this._selectedIndex = -1\r\n        }\r\n        else {\r\n            $this._selectedIndex = [Math]::Min($this._filteredData.Count - 1, $this._selectedIndex + $count)\r\n            $this._selectedIndex = [Math]::Max(0, $this._selectedIndex)\r\n        }\r\n        $this._AdjustScrollOffset()\r\n        $this._TriggerSelectionChanged()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Adjust scroll offset to keep selection visible\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _AdjustScrollOffset() {\r\n        $maxVisibleRows = $this.Height - 6\r\n\r\n        # If selected item is above visible area, scroll up\r\n        if ($this._selectedIndex -lt $this._scrollOffset) {\r\n            $this._scrollOffset = $this._selectedIndex\r\n        }\r\n\r\n        # If selected item is below visible area, scroll down\r\n        if ($this._selectedIndex -ge ($this._scrollOffset + $maxVisibleRows)) {\r\n            $this._scrollOffset = $this._selectedIndex - $maxVisibleRows + 1\r\n        }\r\n\r\n        # Clamp scroll offset\r\n        if ($this._scrollOffset -lt 0) {\r\n            $this._scrollOffset = 0\r\n        }\r\n\r\n        $maxScroll = [Math]::Max(0, $this._filteredData.Count - $maxVisibleRows)\r\n        if ($this._scrollOffset -gt $maxScroll) {\r\n            $this._scrollOffset = $maxScroll\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Toggle multi-select for current item\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _ToggleMultiSelect() {\r\n        # Don't toggle if no data or invalid selection\r\n        if ($this._filteredData.Count -eq 0 -or $this._selectedIndex -lt 0) {\r\n            return\r\n        }\r\n\r\n        if ($this._selectedIndices.Contains($this._selectedIndex)) {\r\n            [void]$this._selectedIndices.Remove($this._selectedIndex)\r\n        }\r\n        else {\r\n            [void]$this._selectedIndices.Add($this._selectedIndex)\r\n        }\r\n\r\n        $this._InvokeCallback($this.OnMultiSelectChanged, $this.GetSelectedItems())\r\n\r\n        # Move down to next item\r\n        $this._MoveSelectionDown(1)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Trigger selection changed event\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _TriggerSelectionChanged() {\r\n        $selectedItem = $this.GetSelectedItem()\r\n        $this._InvokeCallback($this.OnSelectionChanged, $selectedItem)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Apply sort to filtered data\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _ApplySort() {\r\n        if ([string]::IsNullOrWhiteSpace($this._sortColumn)) {\r\n            return\r\n        }\r\n\r\n        $col = $this._columns | Where-Object { $_.Name -eq $this._sortColumn } | Select-Object -First 1\r\n\r\n        if ($null -eq $col -or ($col.ContainsKey('Sortable') -and -not $col.Sortable)) {\r\n            return\r\n        }\r\n\r\n        # Sort filtered data\r\n        if ($this._sortAscending) {\r\n            $this._filteredData = @($this._filteredData | Sort-Object -Property $this._sortColumn)\r\n        }\r\n        else {\r\n            $this._filteredData = @($this._filteredData | Sort-Object -Property $this._sortColumn -Descending)\r\n        }\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Apply filters to data\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _ApplyFilters() {\r\n        $this._filteredData = @($this._filterPanel.ApplyFilters($this._data))\r\n        $this._ApplySearch()\r\n        $this._ApplySort()\r\n\r\n        # Reset selection with proper bounds checking\r\n        if ($this._filteredData.Count -eq 0) {\r\n            $this._selectedIndex = -1  # Explicitly invalid when no data\r\n        }\r\n        else {\r\n            $this._selectedIndex = [Math]::Min($this._selectedIndex, $this._filteredData.Count - 1)\r\n            $this._selectedIndex = [Math]::Max(0, $this._selectedIndex)\r\n        }\r\n        $this._AdjustScrollOffset()\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Apply search filter\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _ApplySearch() {\r\n        if ([string]::IsNullOrWhiteSpace($this._searchText)) {\r\n            return\r\n        }\r\n\r\n        $searchLower = $this._searchText.ToLower()\r\n        $filtered = [System.Collections.ArrayList]::new()\r\n\r\n        foreach ($item in $this._filteredData) {\r\n            # Search in all columns\r\n            $match = $false\r\n            foreach ($col in $this._columns) {\r\n                $value = $this._GetItemProperty($item, $col.Name)\r\n                if ($null -eq $value) { $value = \"\" }\r\n                if ($null -ne $value) {\r\n                    $valueStr = $value.ToString().ToLower()\r\n                    if ($valueStr.Contains($searchLower)) {\r\n                        $match = $true\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n\r\n            if ($match) {\r\n                [void]$filtered.Add($item)\r\n            }\r\n        }\r\n\r\n        # Force array type - prevent PowerShell from unwrapping single-item arrays\r\n        $this._filteredData = @($filtered)\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Handle search mode input\r\n    ##CLOSEBRACKET##\r\n    hidden [bool] _HandleSearchInput([ConsoleKeyInfo]$keyInfo) {\r\n        if ($keyInfo.Key -eq 'Escape') {\r\n            $this.IsInSearchMode = $false\r\n            $this._searchText = \"\"\r\n            $this._ApplyFilters()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'Enter') {\r\n            $this.IsInSearchMode = $false\r\n            $this._ApplyFilters()\r\n            return $true\r\n        }\r\n\r\n        if ($keyInfo.Key -eq 'Backspace') {\r\n            if ($this._searchText.Length -gt 0) {\r\n                $this._searchText = $this._searchText.Substring(0, $this._searchText.Length - 1)\r\n                $this._ApplyFilters()\r\n            }\r\n            return $true\r\n        }\r\n\r\n        # Regular character input\r\n        if ($keyInfo.KeyChar -ge 32 -and $keyInfo.KeyChar -le 126) {\r\n            $this._searchText += $keyInfo.KeyChar\r\n            $this._ApplyFilters()\r\n            return $true\r\n        }\r\n\r\n        return $false\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    L-POL-9: Get consistent color for a tag using hash-based selection\r\n\r\n    .PARAMETER tag\r\n    Tag string to colorize\r\n\r\n    .OUTPUTS\r\n    ANSI color code string\r\n    ##CLOSEBRACKET##\r\n    hidden [string] _GetTagColor([string]$tag) {\r\n        # Hash the tag name to get a consistent color\r\n        $hash = 0\r\n        foreach ($char in $tag.ToCharArray()) {\r\n            $hash = ($hash * 31 + [int]$char) % 256\r\n        }\r\n\r\n        # Use a palette of distinct, readable colors\r\n        $colors = @(\r\n            \"`e[94m\"   # Bright blue\r\n            \"`e[92m\"   # Bright green\r\n            \"`e[96m\"   # Bright cyan\r\n            \"`e[93m\"   # Bright yellow\r\n            \"`e[95m\"   # Bright magenta\r\n            \"`e[91m\"   # Bright red\r\n            \"`e[34m\"   # Blue\r\n            \"`e[32m\"   # Green\r\n            \"`e[36m\"   # Cyan\r\n            \"`e[35m\"   # Magenta\r\n        )\r\n\r\n        return $colors[$hash % $colors.Count]\r\n    }\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Invoke callback safely\r\n    ##CLOSEBRACKET##\r\n    hidden [void] _InvokeCallback([scriptblock]$callback, $arg) {\r\n        if ($null -ne $callback -and $callback -ne {}) {\r\n            try {\r\n                if ($null -ne $arg) {\r\n                    # Use Invoke-Command with -ArgumentList to pass single arg without array wrapping\r\n                    Invoke-Command -ScriptBlock $callback -ArgumentList (, $arg)\r\n                }\r\n                else {\r\n                    & $callback\r\n                }\r\n            }\r\n            catch {\r\n                # Log callback errors but DON'T rethrow - callbacks must never crash the app\r\n                if (Get-Command Write-PmcTuiLog -ErrorAction SilentlyContinue) {\r\n                    # Write-PmcTuiLog \"UniversalList callback error: $($_.Exception.Message)\" \"ERROR\"\r\n                    # Write-PmcTuiLog \"Callback code: $($callback.ToString())\" \"ERROR\"\r\n                    # Write-PmcTuiLog \"Stack trace: $($_.ScriptStackTrace)\" \"ERROR\"\r\n                }\r\n                # DON'T rethrow - UI callbacks must not crash\r\n            }\r\n        }\r\n    }\r\n\r\n    # Legacy rendering methods removed. Use RenderToEngine.\r\n\r\n\r\n\r\n}\r\n\r\n"}, {"path": "module/Pmc.Strict/Core/EnhancedCommandProcessor.ps1", "content": "# PMC Enhanced Command Processor - Secure, performant command execution\r\n# Implements Phase 3 core logic improvements\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Input sanitization and validation\r\nclass PmcInputSanitizer {\r\n    static [string] SanitizeCommandInput([string]$input) {\r\n        if (-not $input) { return \"\" }\r\n\r\n        # Validate length\r\n        if ($input.Length -gt 2000) {\r\n            throw \"Command input too long (max 2000 characters)\"\r\n        }\r\n\r\n        # Remove dangerous characters that could enable injection\r\n        $sanitized = $input -replace '[`$;&|<>{}]', ''\r\n\r\n        # Check for potentially dangerous patterns\r\n        $dangerousPatterns = @(\r\n            'Invoke-Expression', 'iex', 'cmd\\.exe', 'powershell\\.exe',\r\n            'Start-Process', 'New-Object.*System\\.', 'Get-WmiObject',\r\n            '\\[.*\\]::.*', 'Add-Type', 'Reflection\\.'\r\n        )\r\n\r\n        foreach ($pattern in $dangerousPatterns) {\r\n            if ($sanitized -match $pattern) {\r\n                throw \"Potentially dangerous input detected: $pattern\"\r\n            }\r\n        }\r\n\r\n        return $sanitized.Trim()\r\n    }\r\n\r\n    static [bool] ValidateTokenSafety([string]$token) {\r\n        if (-not $token) { return $true }\r\n\r\n        # Allow expected PMC patterns\r\n        $safePatterns = @(\r\n            '^@[\\w\\s\\-\\.]+$',      # Project references\r\n            '^p[1-3]$',             # Priority\r\n            '^due:[\\w\\-:]+$',       # Due dates\r\n            '^#[\\w\\-]+$',           # Tags\r\n            '^task:\\d+$',           # Task references\r\n            '^[\\w\\-\\.\\s]+$'         # General text\r\n        )\r\n\r\n        foreach ($pattern in $safePatterns) {\r\n            if ($token -match $pattern) { return $true }\r\n        }\r\n\r\n        # Check length\r\n        if ($token.Length -gt 100) { return $false }\r\n\r\n        # Reject dangerous patterns\r\n        if ($token -match '[`$;&|<>{}()[\\]]') { return $false }\r\n\r\n        return $true\r\n    }\r\n}\r\n\r\n# Enhanced command context with validation\r\nclass PmcEnhancedCommandContext {\r\n    [string] $Domain\r\n    [string] $Action\r\n    [hashtable] $Args = @{}\r\n    [string[]] $FreeText = @()\r\n    [datetime] $Timestamp = [datetime]::Now\r\n    [string] $OriginalInput\r\n    [hashtable] $Metadata = @{}\r\n    [bool] $IsValidated = $false\r\n    [string[]] $ValidationErrors = @()\r\n\r\n    PmcEnhancedCommandContext([string]$domain, [string]$action) {\r\n        $this.Domain = $domain\r\n        $this.Action = $action\r\n    }\r\n\r\n    [void] AddValidationError([string]$error) {\r\n        $this.ValidationErrors += $error\r\n    }\r\n\r\n    [bool] IsValid() {\r\n        return $this.ValidationErrors.Count -eq 0\r\n    }\r\n\r\n    [void] MarkValidated() {\r\n        $this.IsValidated = $true\r\n    }\r\n}\r\n\r\n# Performance monitoring for command execution\r\nclass PmcCommandPerformanceMonitor {\r\n    hidden [hashtable] $_metrics = @{}\r\n    hidden [int] $_commandCount = 0\r\n\r\n    [void] RecordCommand([string]$command, [long]$durationMs, [bool]$success) {\r\n        $this._commandCount++\r\n\r\n        $key = $command.Split(' ')[0]  # Use first token as key\r\n        if (-not $this._metrics.ContainsKey($key)) {\r\n            $this._metrics[$key] = @{\r\n                Count = 0\r\n                TotalMs = 0\r\n                Successes = 0\r\n                Failures = 0\r\n                AvgMs = 0\r\n                MaxMs = 0\r\n                MinMs = [long]::MaxValue\r\n            }\r\n        }\r\n\r\n        $metric = $this._metrics[$key]\r\n        $metric.Count++\r\n        $metric.TotalMs += $durationMs\r\n\r\n        if ($success) { $metric.Successes++ } else { $metric.Failures++ }\r\n\r\n        $metric.AvgMs = [Math]::Round($metric.TotalMs / $metric.Count, 2)\r\n        $metric.MaxMs = [Math]::Max($metric.MaxMs, $durationMs)\r\n        $metric.MinMs = [Math]::Min($metric.MinMs, $durationMs)\r\n    }\r\n\r\n    [hashtable] GetMetrics() {\r\n        return $this._metrics.Clone()\r\n    }\r\n\r\n    [int] GetCommandCount() {\r\n        return $this._commandCount\r\n    }\r\n\r\n    [void] Reset() {\r\n        $this._metrics.Clear()\r\n        $this._commandCount = 0\r\n    }\r\n}\r\n\r\n# Enhanced command processor with security and performance improvements\r\nclass PmcEnhancedCommandProcessor {\r\n    hidden [PmcCommandPerformanceMonitor] $_perfMonitor\r\n    hidden [hashtable] $_cache = @{}\r\n    hidden [datetime] $_lastCacheClean = [datetime]::Now\r\n    hidden [int] $_maxCacheSize = 100\r\n\r\n    PmcEnhancedCommandProcessor() {\r\n        $this._perfMonitor = [PmcCommandPerformanceMonitor]::new()\r\n    }\r\n\r\n    # Enhanced command execution with full pipeline\r\n    [object] ExecuteCommand([string]$input) {\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        $success = $false\r\n        $result = $null\r\n\r\n        try {\r\n            # Step 1: Input sanitization\r\n            $sanitized = [PmcInputSanitizer]::SanitizeCommandInput($input)\r\n            Write-PmcDebug -Level 3 -Category 'EnhancedProcessor' -Message \"Input sanitized\" -Data @{ Original = $input.Length; Sanitized = $sanitized.Length }\r\n\r\n            # Step 2: Tokenization with safety validation\r\n            $tokens = $this.SafeTokenize($sanitized)\r\n\r\n            # Step 3: Context parsing with enhanced validation\r\n            $context = $this.ParseEnhancedContext($tokens, $sanitized)\r\n\r\n            # Step 4: Security validation\r\n            $this.ValidateContextSecurity($context)\r\n\r\n            # Step 5: Business logic validation\r\n            $this.ValidateContextBusiness($context)\r\n\r\n            if (-not $context.IsValid()) {\r\n                throw \"Validation failed: $($context.ValidationErrors -join '; ')\"\r\n            }\r\n\r\n            # Step 6: Execute with performance monitoring\r\n            $result = $this.ExecuteValidatedContext($context)\r\n            $success = $true\r\n\r\n            Write-PmcDebug -Level 2 -Category 'EnhancedProcessor' -Message \"Command executed successfully\" -Data @{ Domain = $context.Domain; Action = $context.Action; Duration = $stopwatch.ElapsedMilliseconds }\r\n\r\n        } catch {\r\n            Write-PmcDebug -Level 1 -Category 'EnhancedProcessor' -Message \"Command execution failed\" -Data @{ Error = $_.ToString(); Input = $input }\r\n            $result = @{ Error = $_.ToString(); Success = $false }\r\n        } finally {\r\n            $stopwatch.Stop()\r\n            $this._perfMonitor.RecordCommand($input, $stopwatch.ElapsedMilliseconds, $success)\r\n            $this.CleanCacheIfNeeded()\r\n        }\r\n\r\n        return $result\r\n    }\r\n\r\n    # Safe tokenization with validation\r\n    [string[]] SafeTokenize([string]$input) {\r\n        $tokens = ConvertTo-PmcTokens $input\r\n\r\n        foreach ($token in $tokens) {\r\n            if (-not [PmcInputSanitizer]::ValidateTokenSafety($token)) {\r\n                throw \"Unsafe token detected: $token\"\r\n            }\r\n        }\r\n\r\n        return $tokens\r\n    }\r\n\r\n    # Enhanced context parsing\r\n    [PmcEnhancedCommandContext] ParseEnhancedContext([string[]]$tokens, [string]$originalInput) {\r\n        # Use existing parser as base, then enhance\r\n        $parsed = ConvertTo-PmcContext $tokens\r\n\r\n        if (-not $parsed.Success) {\r\n            throw \"Parse error: $($parsed.Error)\"\r\n        }\r\n\r\n        # Create enhanced context\r\n        $enhanced = [PmcEnhancedCommandContext]::new($parsed.Context.Domain, $parsed.Context.Action)\r\n        $enhanced.Args = $parsed.Context.Args.Clone()\r\n        $enhanced.FreeText = $parsed.Context.FreeText\r\n        $enhanced.OriginalInput = $originalInput\r\n        $enhanced.Metadata['Handler'] = $parsed.Handler\r\n\r\n        return $enhanced\r\n    }\r\n\r\n    # Security validation layer\r\n    [void] ValidateContextSecurity([PmcEnhancedCommandContext]$context) {\r\n        # Validate domain and action are allowed\r\n        $allowedDomains = @('task', 'project', 'time', 'help', 'config', 'query')\r\n        if ($context.Domain -notin $allowedDomains) {\r\n            $context.AddValidationError(\"Unknown domain: $($context.Domain)\")\r\n        }\r\n\r\n        # Validate argument values for injection attempts\r\n        foreach ($key in $context.Args.Keys) {\r\n            $value = $context.Args[$key]\r\n            if ($value -is [string]) {\r\n                try {\r\n                    [PmcInputSanitizer]::SanitizeCommandInput($value) | Out-Null\r\n                } catch {\r\n                    $context.AddValidationError(\"Unsafe argument value for $key`: $_\")\r\n                }\r\n            }\r\n        }\r\n\r\n        # Validate free text\r\n        foreach ($text in $context.FreeText) {\r\n            if (-not [PmcInputSanitizer]::ValidateTokenSafety($text)) {\r\n                $context.AddValidationError(\"Unsafe free text: $text\")\r\n            }\r\n        }\r\n    }\r\n\r\n    # Business logic validation\r\n    [void] ValidateContextBusiness([PmcEnhancedCommandContext]$context) {\r\n        # Use existing validation but with enhanced error reporting\r\n        try {\r\n            $legacyContext = [PmcCommandContext]::new()\r\n            $legacyContext.Domain = $context.Domain\r\n            $legacyContext.Action = $context.Action\r\n            $legacyContext.Args = $context.Args\r\n            $legacyContext.FreeText = $context.FreeText\r\n\r\n            Set-PmcContextDefaults -Context $legacyContext\r\n            Normalize-PmcContextFields -Context $legacyContext\r\n\r\n            $isValid = Test-PmcContext -Context $legacyContext\r\n            if (-not $isValid) {\r\n                $context.AddValidationError(\"Business logic validation failed\")\r\n            }\r\n\r\n            # Copy back any normalized values\r\n            $context.Args = $legacyContext.Args\r\n\r\n        } catch {\r\n            $context.AddValidationError(\"Business validation error: $_\")\r\n        }\r\n    }\r\n\r\n    # Execute validated context with enhanced error handling\r\n    [object] ExecuteValidatedContext([PmcEnhancedCommandContext]$context) {\r\n        # Prefer enhanced handler registry if available\r\n        $legacyContext = [PmcCommandContext]::new()\r\n        $legacyContext.Domain = $context.Domain\r\n        $legacyContext.Action = $context.Action\r\n        $legacyContext.Args = $context.Args\r\n        $legacyContext.FreeText = $context.FreeText\r\n\r\n        $usedEnhanced = $false\r\n        try {\r\n            if (Get-Command Get-PmcHandler -ErrorAction SilentlyContinue) {\r\n                $desc = Get-PmcHandler -Domain $context.Domain -Action $context.Action\r\n                if ($desc -and $desc.Execute) {\r\n                    $usedEnhanced = $true\r\n                    return (& $desc.Execute $legacyContext)\r\n                }\r\n            }\r\n        } catch {}\r\n\r\n        # Fall back to explicit handler name (must exist)\r\n        $handler = $context.Metadata['Handler']\r\n        if (-not (Get-Command -Name $handler -ErrorAction SilentlyContinue)) {\r\n            throw \"Handler not found: $handler\"\r\n        }\r\n\r\n        return (& $handler -Context $legacyContext)\r\n    }\r\n\r\n    # Cache management\r\n    [void] CleanCacheIfNeeded() {\r\n        $now = [datetime]::Now\r\n        if (($now - $this._lastCacheClean).TotalMinutes -gt 10 -or $this._cache.Count -gt $this._maxCacheSize) {\r\n            $this._cache.Clear()\r\n            $this._lastCacheClean = $now\r\n            Write-PmcDebug -Level 3 -Category 'EnhancedProcessor' -Message \"Cache cleaned\"\r\n        }\r\n    }\r\n\r\n    # Performance metrics\r\n    [hashtable] GetPerformanceMetrics() {\r\n        return $this._perfMonitor.GetMetrics()\r\n    }\r\n\r\n    [int] GetCommandCount() {\r\n        return $this._perfMonitor.GetCommandCount()\r\n    }\r\n\r\n    [void] ResetMetrics() {\r\n        $this._perfMonitor.Reset()\r\n    }\r\n}\r\n\r\n# Global instance\r\n$Script:PmcEnhancedCommandProcessor = $null\r\n\r\nfunction Initialize-PmcEnhancedCommandProcessor {\r\n    if ($Script:PmcEnhancedCommandProcessor) {\r\n        Write-Warning \"PMC Enhanced Command Processor already initialized\"\r\n        return\r\n    }\r\n\r\n    $Script:PmcEnhancedCommandProcessor = [PmcEnhancedCommandProcessor]::new()\r\n    Write-PmcDebug -Level 2 -Category 'EnhancedProcessor' -Message \"Enhanced command processor initialized\"\r\n}\r\n\r\nfunction Get-PmcEnhancedCommandProcessor {\r\n    if (-not $Script:PmcEnhancedCommandProcessor) {\r\n        Initialize-PmcEnhancedCommandProcessor\r\n    }\r\n    return $Script:PmcEnhancedCommandProcessor\r\n}\r\n\r\nfunction Invoke-PmcEnhancedCommand {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [string]$Command\r\n    )\r\n\r\n    $processor = Get-PmcEnhancedCommandProcessor\r\n    return $processor.ExecuteCommand($Command)\r\n}\r\n\r\nfunction Get-PmcCommandPerformanceStats {\r\n    $processor = Get-PmcEnhancedCommandProcessor\r\n    $metrics = $processor.GetPerformanceMetrics()\r\n    $commandCount = $processor.GetCommandCount()\r\n\r\n    Write-Host \"PMC Command Performance Statistics\" -ForegroundColor Green\r\n    Write-Host \"=================================\" -ForegroundColor Green\r\n    Write-Host \"Total Commands: $commandCount\"\r\n    Write-Host \"\"\r\n\r\n    if ($metrics.Count -gt 0) {\r\n        $sorted = $metrics.GetEnumerator() | Sort-Object { $_.Value.Count } -Descending\r\n\r\n        Write-Host \"Top Commands by Usage:\" -ForegroundColor Yellow\r\n        Write-Host \"Command\".PadRight(15) + \"Count\".PadRight(8) + \"Avg(ms)\".PadRight(10) + \"Max(ms)\".PadRight(10) + \"Success%\" -ForegroundColor Cyan\r\n        Write-Host (\"-\" * 50) -ForegroundColor Gray\r\n\r\n        foreach ($entry in $sorted) {\r\n            $cmd = $entry.Key\r\n            $stats = $entry.Value\r\n            $successRate = $(if ($stats.Count -gt 0) { [Math]::Round(($stats.Successes * 100.0) / $stats.Count, 1) } else { 0 })\r\n\r\n            Write-Host ($cmd.PadRight(15) +\r\n                      $stats.Count.ToString().PadRight(8) +\r\n                      $stats.AvgMs.ToString().PadRight(10) +\r\n                      $stats.MaxMs.ToString().PadRight(10) +\r\n                      \"$successRate%\")\r\n        }\r\n    } else {\r\n        Write-Host \"No command statistics available yet.\"\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Initialize-PmcEnhancedCommandProcessor, Get-PmcEnhancedCommandProcessor, Invoke-PmcEnhancedCommand, Get-PmcCommandPerformanceStats"}, {"path": "module/Pmc.Strict/Core/EnhancedQueryEngine.ps1", "content": "# PMC Enhanced Query Engine - Optimized query parsing and execution\r\n# Implements Phase 3 query language improvements\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Enhanced query specification with validation and optimization\r\nclass PmcEnhancedQuerySpec {\r\n    [string] $Domain\r\n    [string[]] $RawTokens = @()\r\n    [hashtable] $Filters = @{}\r\n    [hashtable] $Directives = @{}\r\n    [hashtable] $Metadata = @{}\r\n    [bool] $IsOptimized = $false\r\n    [string[]] $ValidationErrors = @()\r\n    [datetime] $ParseTime = [datetime]::Now\r\n\r\n    # Query optimization hints\r\n    [bool] $UseIndex = $false\r\n    [string[]] $IndexFields = @()\r\n    [int] $EstimatedRows = -1\r\n    [string] $OptimizationStrategy = 'default'\r\n\r\n    [void] AddValidationError([string]$error) {\r\n        $this.ValidationErrors += $error\r\n    }\r\n\r\n    [bool] IsValid() {\r\n        return $this.ValidationErrors.Count -eq 0\r\n    }\r\n\r\n    [void] MarkOptimized([string]$strategy) {\r\n        $this.IsOptimized = $true\r\n        $this.OptimizationStrategy = $strategy\r\n    }\r\n}\r\n\r\n# AST model for enhanced queries (typed, structured)\r\nclass PmcAstNode { }\r\nclass PmcAstFilterNode : PmcAstNode {\r\n    [string] $Field\r\n    [string] $Operator\r\n    [string] $Value\r\n    PmcAstFilterNode([string]$f,[string]$op,[string]$v){ $this.Field=$f; $this.Operator=$op; $this.Value=$v }\r\n}\r\nclass PmcAstDirectiveNode : PmcAstNode {\r\n    [string] $Name\r\n    [object] $Value\r\n    PmcAstDirectiveNode([string]$n,[object]$v){ $this.Name=$n; $this.Value=$v }\r\n}\r\nclass PmcAstQuery : PmcAstNode {\r\n    [string] $Domain\r\n    [System.Collections.Generic.List[PmcAstFilterNode]] $Filters\r\n    [System.Collections.Generic.List[PmcAstDirectiveNode]] $Directives\r\n    [string[]] $SearchTerms\r\n    PmcAstQuery(){ $this.Filters = [System.Collections.Generic.List[PmcAstFilterNode]]::new(); $this.Directives=[System.Collections.Generic.List[PmcAstDirectiveNode]]::new(); $this.SearchTerms=@() }\r\n}\r\n\r\n# Query cache for performance optimization\r\nclass PmcQueryCache {\r\n    hidden [hashtable] $_cache = @{}\r\n    hidden [int] $_maxSize = 50\r\n    hidden [hashtable] $_stats = @{\r\n        Hits = 0\r\n        Misses = 0\r\n        Evictions = 0\r\n    }\r\n\r\n    [string] GenerateCacheKey([PmcEnhancedQuerySpec]$spec) {\r\n        $keyParts = @(\r\n            $spec.Domain,\r\n            ($spec.RawTokens -join '|'),\r\n            ($spec.Filters.GetEnumerator() | Sort-Object Key | ForEach-Object { \"$($_.Key)=$($_.Value)\" }) -join '&',\r\n            ($spec.Directives.GetEnumerator() | Sort-Object Key | ForEach-Object { \"$($_.Key)=$($_.Value)\" }) -join '&'\r\n        )\r\n        return ($keyParts -join '::')\r\n    }\r\n\r\n    [object] Get([string]$key) {\r\n        if ($this._cache.ContainsKey($key)) {\r\n            $entry = $this._cache[$key]\r\n            if (([datetime]::Now - $entry.Timestamp).TotalMinutes -lt 5) {\r\n                $this._stats.Hits++\r\n                $entry.LastAccess = [datetime]::Now\r\n                return $entry.Result\r\n            } else {\r\n                $this._cache.Remove($key)\r\n            }\r\n        }\r\n        $this._stats.Misses++\r\n        return $null\r\n    }\r\n\r\n    [void] Set([string]$key, [object]$result) {\r\n        if ($this._cache.Count -ge $this._maxSize) {\r\n            $this.EvictOldest()\r\n        }\r\n\r\n        $this._cache[$key] = @{\r\n            Result = $result\r\n            Timestamp = [datetime]::Now\r\n            LastAccess = [datetime]::Now\r\n        }\r\n    }\r\n\r\n    [void] EvictOldest() {\r\n        $oldest = $null\r\n        $oldestTime = [datetime]::MaxValue\r\n\r\n        foreach ($entry in $this._cache.GetEnumerator()) {\r\n            if ($entry.Value.LastAccess -lt $oldestTime) {\r\n                $oldestTime = $entry.Value.LastAccess\r\n                $oldest = $entry.Key\r\n            }\r\n        }\r\n\r\n        if ($oldest) {\r\n            $this._cache.Remove($oldest)\r\n            $this._stats.Evictions++\r\n        }\r\n    }\r\n\r\n    [hashtable] GetStats() {\r\n        $total = $this._stats.Hits + $this._stats.Misses\r\n        $hitRate = $(if ($total -gt 0) { [Math]::Round(($this._stats.Hits * 100.0) / $total, 2) } else { 0 })\r\n\r\n        return @{\r\n            Size = $this._cache.Count\r\n            Hits = $this._stats.Hits\r\n            Misses = $this._stats.Misses\r\n            Evictions = $this._stats.Evictions\r\n            HitRate = $hitRate\r\n        }\r\n    }\r\n\r\n    [void] Clear() {\r\n        $this._cache.Clear()\r\n        $this._stats = @{ Hits = 0; Misses = 0; Evictions = 0 }\r\n    }\r\n}\r\n\r\n# Enhanced query parser with validation and optimization\r\nclass PmcEnhancedQueryParser {\r\n    hidden [hashtable] $_allowedDomains = @{\r\n        'task' = @('id', 'text', 'project', 'due', 'priority', 'status', 'tags')\r\n        'project' = @('name', 'description', 'status', 'created', 'updated')\r\n        'timelog' = @('id', 'task', 'project', 'start', 'end', 'duration', 'description')\r\n    }\r\n\r\n    hidden [hashtable] $_optimizationRules = @{\r\n        'task' = @{\r\n            'id' = 'index'\r\n            'project' = 'index'\r\n            'due' = 'range'\r\n            'priority' = 'category'\r\n        }\r\n        'project' = @{\r\n            'name' = 'index'\r\n            'status' = 'category'\r\n        }\r\n        'timelog' = @{\r\n            'task' = 'index'\r\n            'project' = 'index'\r\n            'start' = 'range'\r\n        }\r\n    }\r\n\r\n    [PmcEnhancedQuerySpec] ParseQuery([string[]]$tokens) {\r\n        $spec = [PmcEnhancedQuerySpec]::new()\r\n        $ast = [PmcAstQuery]::new()\r\n\r\n        if ($tokens.Count -eq 0) {\r\n            $spec.AddValidationError(\"Query requires at least a domain\")\r\n            return $spec\r\n        }\r\n\r\n        # Parse domain (first token)\r\n        $domainToken = $tokens[0].ToLower()\r\n        $spec.Domain = $this.NormalizeDomain($domainToken)\r\n        $ast.Domain = $spec.Domain\r\n\r\n        if (-not $spec.Domain) {\r\n            $spec.AddValidationError(\"Unknown domain: $domainToken\")\r\n            return $spec\r\n        }\r\n\r\n        if (-not $this._allowedDomains.ContainsKey($spec.Domain)) {\r\n            $spec.AddValidationError(\"Domain not supported: $($spec.Domain)\")\r\n            return $spec\r\n        }\r\n\r\n        # Parse remaining tokens\r\n        $spec.RawTokens = $tokens | Select-Object -Skip 1\r\n        $this.ParseTokens($spec, $spec.RawTokens)\r\n        # Build AST nodes from parsed spec\r\n        foreach ($field in $spec.Filters.Keys) { foreach ($f in $spec.Filters[$field]) { [void]$ast.Filters.Add([PmcAstFilterNode]::new($field,[string]$f.Operator,[string]$f.Value)) } }\r\n        foreach ($k in $spec.Directives.Keys) { [void]$ast.Directives.Add([PmcAstDirectiveNode]::new($k,$spec.Directives[$k])) }\r\n        if ($spec.Metadata.ContainsKey('search')) { $ast.SearchTerms = @($spec.Metadata['search']) }\r\n        $spec.Metadata['Ast'] = $ast\r\n\r\n        # Apply optimization hints\r\n        $this.OptimizeQuery($spec)\r\n\r\n        return $spec\r\n    }\r\n\r\n    [string] NormalizeDomain([string]$domain) {\r\n        switch ($domain) {\r\n            { $_ -in @('task', 'tasks') } { return 'task' }\r\n            { $_ -in @('project', 'projects') } { return 'project' }\r\n            { $_ -in @('timelog', 'timelogs', 'time') } { return 'timelog' }\r\n            default { return $null }\r\n        }\r\n        # Fallback (should never reach here)\r\n        return $null\r\n    }\r\n\r\n    [void] ParseTokens([PmcEnhancedQuerySpec]$spec, [string[]]$tokens) {\r\n        $allowedFields = $this._allowedDomains[$spec.Domain]\r\n\r\n        foreach ($token in $tokens) {\r\n            if ([string]::IsNullOrWhiteSpace($token)) { continue }\r\n\r\n            if ($token.StartsWith('@')) {\r\n                $proj = $token.Substring(1).Trim('\"')\r\n                if (-not $spec.Filters.ContainsKey('project')) { $spec.Filters['project'] = @() }\r\n                $spec.Filters['project'] += @{ Operator = '='; Value = $proj }\r\n                continue\r\n            }\r\n\r\n            if ($token.StartsWith('#')) {\r\n                $tag = $token.Substring(1).Trim('\"')\r\n                if (-not $spec.Filters.ContainsKey('tags')) { $spec.Filters['tags'] = @() }\r\n                $spec.Filters['tags'] += @{ Operator = 'contains'; Value = $tag }\r\n                continue\r\n            }\r\n\r\n            if ($token -match '^(?i)p(\\d+)$') {\r\n                $val = $matches[1]\r\n                if (-not $spec.Filters.ContainsKey('priority')) { $spec.Filters['priority'] = @() }\r\n                $spec.Filters['priority'] += @{ Operator = '='; Value = $val }\r\n                continue\r\n            }\r\n            if ($token -match '^(?i)p([<>]=?)(\\d+)$') {\r\n                $op = $matches[1]; $val = $matches[2]\r\n                if (-not $spec.Filters.ContainsKey('priority')) { $spec.Filters['priority'] = @() }\r\n                $spec.Filters['priority'] += @{ Operator = $op; Value = $val }\r\n                continue\r\n            }\r\n            if ($token -match '^(?i)p(\\d+)\\.\\.(\\d+)$') {\r\n                $low = $matches[1]; $high = $matches[2]\r\n                if (-not $spec.Filters.ContainsKey('priority')) { $spec.Filters['priority'] = @() }\r\n                $spec.Filters['priority'] += @{ Operator = '>='; Value = $low }\r\n                $spec.Filters['priority'] += @{ Operator = '<='; Value = $high }\r\n                continue\r\n            }\r\n\r\n            if ($spec.Domain -eq 'task' -and $token -in @('overdue','today','tomorrow')) {\r\n                if (-not $spec.Filters.ContainsKey('due')) { $spec.Filters['due'] = @() }\r\n                $spec.Filters['due'] += @{ Operator = ':'; Value = $token }\r\n                continue\r\n            }\r\n            # Directives (cols:, sort:, etc.)\r\n            if ($token -match '^(cols?|columns?):(.+)$') {\r\n                $spec.Directives['columns'] = $matches[2] -split ','\r\n                continue\r\n            }\r\n\r\n            if ($token -match '^sort:(.+)$') {\r\n                $spec.Directives['sort'] = $matches[1]\r\n                continue\r\n            }\r\n\r\n            if ($token -match '^limit:(\\d+)$') {\r\n                $spec.Directives['limit'] = [int]$matches[1]\r\n                continue\r\n            }\r\n\r\n            if ($token -match '^group:(.+)$') {\r\n                $spec.Directives['groupBy'] = $matches[1]\r\n                continue\r\n            }\r\n\r\n            # Field filters (field:value or field>value, etc.)\r\n            if ($token -match '^(\\w+)([:]|>=|<=|=|>|<|~)(.+)$') {\r\n                $field = $matches[1].ToLower()\r\n                $operator = $matches[2]\r\n                $value = $matches[3]\r\n\r\n                if ($field -notin $allowedFields) {\r\n                    $spec.AddValidationError(\"Unknown field for $($spec.Domain): $field\")\r\n                    continue\r\n                }\r\n\r\n                # Validate operator\r\n                if ($operator -notin @(':', '=', '>', '<', '>=', '<=', '~')) {\r\n                    $spec.AddValidationError(\"Unknown operator: $operator\")\r\n                    continue\r\n                }\r\n\r\n                # Sanitize value\r\n                if ($value.Length -gt 100) {\r\n                    $spec.AddValidationError(\"Filter value too long: $field\")\r\n                    continue\r\n                }\r\n\r\n                if (-not $spec.Filters.ContainsKey($field)) {\r\n                    $spec.Filters[$field] = @()\r\n                }\r\n                $spec.Filters[$field] += @{ Operator = $operator; Value = $value }\r\n                continue\r\n            }\r\n\r\n            # Simple field names (for existence checks)\r\n            if ($token -match '^\\w+$' -and $token.ToLower() -in $allowedFields) {\r\n                $field = $token.ToLower()\r\n                if (-not $spec.Filters.ContainsKey($field)) {\r\n                    $spec.Filters[$field] = @()\r\n                }\r\n                $spec.Filters[$field] += @{ Operator = 'exists'; Value = $true }\r\n                continue\r\n            }\r\n\r\n            # Free text search\r\n            if (-not $spec.Metadata.ContainsKey('search')) {\r\n                $spec.Metadata['search'] = @()\r\n            }\r\n            $spec.Metadata['search'] += $token\r\n        }\r\n    }\r\n\r\n    [void] OptimizeQuery([PmcEnhancedQuerySpec]$spec) {\r\n        if (-not $this._optimizationRules.ContainsKey($spec.Domain)) {\r\n            return\r\n        }\r\n\r\n        $rules = $this._optimizationRules[$spec.Domain]\r\n        $indexableFields = @()\r\n        $strategy = 'scan'\r\n\r\n        # Check for indexed fields in filters\r\n        foreach ($field in $spec.Filters.Keys) {\r\n            if ($rules.ContainsKey($field) -and $rules[$field] -eq 'index') {\r\n                $indexableFields += $field\r\n                $strategy = 'index'\r\n            }\r\n        }\r\n\r\n        if ($indexableFields.Count -gt 0) {\r\n            $spec.UseIndex = $true\r\n            $spec.IndexFields = $indexableFields\r\n            $spec.MarkOptimized($strategy)\r\n        }\r\n\r\n        # Estimate result size\r\n        if ($spec.Filters.ContainsKey('id')) {\r\n            $spec.EstimatedRows = 1\r\n        } elseif ($indexableFields.Count -gt 0) {\r\n            $spec.EstimatedRows = 10  # Rough estimate for indexed queries\r\n        } else {\r\n            $spec.EstimatedRows = 100  # Full scan estimate\r\n        }\r\n    }\r\n}\r\n\r\n# Enhanced query executor with performance optimization\r\nclass PmcEnhancedQueryExecutor {\r\n    hidden [PmcQueryCache] $_cache\r\n    hidden [hashtable] $_executionStats = @{\r\n        QueriesExecuted = 0\r\n        TotalDuration = 0\r\n        CacheHits = 0\r\n        CacheMisses = 0\r\n    }\r\n\r\n    PmcEnhancedQueryExecutor() {\r\n        $this._cache = [PmcQueryCache]::new()\r\n    }\r\n\r\n    [object] ExecuteQuery([PmcEnhancedQuerySpec]$spec) {\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n\r\n        try {\r\n            # Check cache first\r\n            $cacheKey = $this._cache.GenerateCacheKey($spec)\r\n            $cached = $this._cache.Get($cacheKey)\r\n\r\n            if ($cached) {\r\n                $this._executionStats.CacheHits++\r\n                Write-PmcDebug -Level 3 -Category 'EnhancedQuery' -Message \"Cache hit for query\" -Data @{ Domain = $spec.Domain; Strategy = 'cache' }\r\n                return $cached\r\n            }\r\n\r\n            $this._executionStats.CacheMisses++\r\n\r\n            # Execute AST first (normalizes spec), then execute optimized path\r\n            $result = $this.ExecuteAst($spec)\r\n\r\n            # Cache successful results\r\n            if ($result -and -not $result.Error) {\r\n                $this._cache.Set($cacheKey, $result)\r\n            }\r\n\r\n            $this._executionStats.QueriesExecuted++\r\n            $this._executionStats.TotalDuration += $stopwatch.ElapsedMilliseconds\r\n\r\n            Write-PmcDebug -Level 2 -Category 'EnhancedQuery' -Message \"Query executed\" -Data @{\r\n                Domain = $spec.Domain\r\n                Strategy = $spec.OptimizationStrategy\r\n                Duration = $stopwatch.ElapsedMilliseconds\r\n                Cached = $false\r\n                Results = $(if ($result.Data) { $result.Data.Count } else { 0 })\r\n            }\r\n\r\n            return $result\r\n\r\n        } catch {\r\n            Write-PmcDebug -Level 1 -Category 'EnhancedQuery' -Message \"Query execution failed\" -Data @{ Error = $_.ToString(); Domain = $spec.Domain }\r\n            return @{ Error = $_.ToString(); Success = $false }\r\n        } finally {\r\n            $stopwatch.Stop()\r\n        }\r\n    }\r\n\r\n    [object] ExecuteAst([PmcEnhancedQuerySpec]$spec) {\r\n        try {\r\n            if (-not $spec.Metadata.ContainsKey('Ast')) { return $this.ExecuteScanQuery($spec) }\r\n            $ast = [PmcAstQuery]$spec.Metadata['Ast']\r\n            if ($null -eq $ast) { return $this.ExecuteScanQuery($spec) }\r\n\r\n            # 1) Resolve dataset\r\n            $data = switch ($ast.Domain) {\r\n                'task'    { if (Get-Command Get-PmcTasksData -ErrorAction SilentlyContinue)    { Get-PmcTasksData }    else { @() } }\r\n                'project' { if (Get-Command Get-PmcProjectsData -ErrorAction SilentlyContinue) { Get-PmcProjectsData } else { @() } }\r\n                'timelog' { if (Get-Command Get-PmcTimeLogsData -ErrorAction SilentlyContinue) { Get-PmcTimeLogsData } else { @() } }\r\n                default { @() }\r\n            }\r\n\r\n            $filtered = @($data)\r\n\r\n            # 2) Apply filters (AND semantics)\r\n            foreach ($node in $ast.Filters) {\r\n                $field = $node.Field; $op = ($node.Operator + '') ; $val = ($node.Value + '')\r\n                $filtered = @($filtered | Where-Object {\r\n                    if ($null -eq $_) { return $false }\r\n                    $has = $_.PSObject.Properties[$field]\r\n                    $v = $(if ($has) { $_.\"$field\" } else { $null })\r\n\r\n                    # Special: due date filters\r\n                    if ($field -eq 'due') {\r\n                        $today = (Get-Date).Date\r\n                        if ($op -eq ':' -and $val -eq 'today') { if (-not $v) { return $false }; try { return ([datetime]$v).Date -eq $today } catch { return $false } }\r\n                        if ($op -eq ':' -and $val -eq 'tomorrow') { if (-not $v) { return $false }; try { return ([datetime]$v).Date -eq $today.AddDays(1) } catch { return $false } }\r\n                        if ($op -eq ':' -and $val -eq 'overdue') { if (-not $v) { return $false }; try { return ([datetime]$v).Date -lt $today } catch { return $false } }\r\n                        if ($op -eq ':' -and $val -match '^\\+(\\d+)$') { if (-not $v) { return $false }; $d=[int]$matches[1]; try { $date=[datetime]$v; return ($date.Date -le $today.AddDays($d)) -and ($date.Date -ge $today) } catch { return $false } }\r\n                        if ($op -eq ':' -and $val -eq 'eow') { if (-not $v) { return $false }; $dow=[int]$today.DayOfWeek; $rem=(7-$dow)%7; try { return ([datetime]$v).Date -le $today.AddDays($rem) -and ([datetime]$v).Date -ge $today } catch { return $false } }\r\n                        if ($op -eq ':' -and $val -eq 'eom') { if (-not $v) { return $false }; $eom=(Get-Date -Day 1).AddMonths(1).AddDays(-1).Date; try { return ([datetime]$v).Date -le $eom -and ([datetime]$v).Date -ge $today } catch { return $false } }\r\n                        # support YYYYMMDD/YYMMDD quick parse\r\n                        if ($op -eq ':' -and $val -match '^(\\d{8}|\\d{6})$') { if (-not $v) { return $false }; try { $dt=[datetime]$v; $y=$val; if ($y.Length -eq 8) { $qry=[datetime]::ParseExact($y,'yyyyMMdd',$null) } else { $qry=[datetime]::ParseExact($y,'yyMMdd',$null) }; return $dt.Date -eq $qry.Date } catch { return $false } }\r\n                        $sv = $(if ($v) { [string]$v } else { '' })\r\n                        return $sv -match [regex]::Escape($val)\r\n                    }\r\n\r\n                    # Special: tags contains\r\n                    if ($field -eq 'tags') {\r\n                        $arr=@(); try { if ($v -is [System.Collections.IEnumerable]) { $arr=@($v) } } catch {}\r\n                        if ($op -eq 'contains') { return ($arr -contains $val) }\r\n                        return $false\r\n                    }\r\n\r\n                    $sv = $(if ($v -ne $null) { [string]$v } else { '' })\r\n                    switch ($op) {\r\n                        'exists' { $has -and $sv -ne '' }\r\n                        ':' { $sv -match [regex]::Escape($val) }\r\n                        '=' { $sv -eq $val }\r\n                        '>' { try { [double]$sv -gt [double]$val } catch { $false } }\r\n                        '<' { try { [double]$sv -lt [double]$val } catch { $false } }\r\n                        '>=' { try { [double]$sv -ge [double]$val } catch { $false } }\r\n                        '<=' { try { [double]$sv -le [double]$val } catch { $false } }\r\n                        '~' { $sv -like \"*${val}*\" }\r\n                        default { $true }\r\n                    }\r\n                })\r\n            }\r\n\r\n            # 3) Apply free text search\r\n            if ($ast.SearchTerms -and @($ast.SearchTerms).Count -gt 0) {\r\n                foreach ($t in $ast.SearchTerms) {\r\n                    $needle = ($t + '').ToLower()\r\n                    $filtered = @($filtered | Where-Object {\r\n                        $text = ''\r\n                        try { $text = (($_.text) + ' ' + ($_.project) + ' ' + ($_.description) + ' ' + ($_.name)) } catch {}\r\n                        $text.ToLower().Contains($needle)\r\n                    })\r\n                }\r\n            }\r\n\r\n            # 4) Apply directives: sort, group, columns, limit\r\n            $dirMap = @{}\r\n            foreach ($d in $ast.Directives) { $dirMap[$d.Name] = $d.Value }\r\n\r\n            # Sort\r\n            if ($dirMap.ContainsKey('sort')) {\r\n                $sortExpr = [string]$dirMap['sort']; $asc = $true; $field = $sortExpr\r\n                if ($sortExpr -match '^(.+?)([+-])$') { $field=$matches[1]; $asc = ($matches[2] -eq '+') }\r\n                $filtered = @($filtered | Sort-Object -Property @{ Expression = { if ($_.PSObject.Properties[$field]) { $_.\"$field\" } else { $null } }; Ascending = $asc })\r\n            }\r\n\r\n            # Group\r\n            $grouped = $false\r\n            if ($dirMap.ContainsKey('groupBy')) {\r\n                $g = [string]$dirMap['groupBy']\r\n                $projected = @()\r\n                foreach ($row in $filtered) {\r\n                    if ($null -eq $row) { continue }\r\n                    $groupVal = $(if ($row.PSObject.Properties[$g]) { $row.\"$g\" } else { $null })\r\n                    $obj = [pscustomobject]@{ Group = $groupVal }\r\n                    foreach ($p in $row.PSObject.Properties) { Add-Member -InputObject $obj -NotePropertyName $p.Name -NotePropertyValue $p.Value -Force }\r\n                    $projected += $obj\r\n                }\r\n                $filtered = @($projected | Sort-Object -Property @{ Expression = { $_.Group } })\r\n                $grouped = $true\r\n            }\r\n\r\n            # Columns\r\n            if ($dirMap.ContainsKey('columns')) {\r\n                $cols = @($dirMap['columns'])\r\n                $projected = @()\r\n                foreach ($row in $filtered) {\r\n                    $obj = [pscustomobject]@{}\r\n                    if ($grouped) { Add-Member -InputObject $obj -NotePropertyName 'Group' -NotePropertyValue $row.Group -Force }\r\n                    foreach ($c in $cols) {\r\n                        $name = [string]$c\r\n                        $val = $(if ($row.PSObject.Properties[$name]) { $row.\"$name\" } else { $null })\r\n                        Add-Member -InputObject $obj -NotePropertyName $name -NotePropertyValue $val -Force\r\n                    }\r\n                    $projected += $obj\r\n                }\r\n                $filtered = $projected\r\n            } elseif ($grouped) {\r\n                # ensure Group column visible when grouped\r\n                $projected = @()\r\n                foreach ($row in $filtered) {\r\n                    $obj = [pscustomobject]@{ Group = $row.Group }\r\n                    foreach ($p in $row.PSObject.Properties) { if ($p.Name -ne 'Group') { Add-Member -InputObject $obj -NotePropertyName $p.Name -NotePropertyValue $p.Value -Force } }\r\n                    $projected += $obj\r\n                }\r\n                $filtered = $projected\r\n            }\r\n\r\n            # Limit\r\n            if ($dirMap.ContainsKey('limit')) { $n = [int]$dirMap['limit']; $filtered = @($filtered | Select-Object -First $n) }\r\n\r\n            return @{\r\n                Success = $true\r\n                Data = ,$filtered\r\n                Metadata = @{\r\n                    EstimatedRows = $spec.EstimatedRows\r\n                    ActualRows = @($filtered).Count\r\n                    Strategy = $spec.OptimizationStrategy\r\n                    Cached = $false\r\n                }\r\n            }\r\n        } catch {\r\n            Write-PmcDebug -Level 2 -Category 'EnhancedQuery' -Message \"AST execution fallback: $_\"\r\n            return $this.ExecuteScanQuery($spec)\r\n        }\r\n    }\r\n\r\n    [object] ExecuteIndexedQuery([PmcEnhancedQuerySpec]$spec) {\r\n        # Indexed path – we still filter in-memory but can apply early prunes by index fields\r\n        return $this.ExecuteScanQuery($spec)\r\n    }\r\n\r\n    [object] ExecuteScanQuery([PmcEnhancedQuerySpec]$spec) {\r\n        # Execute against in-memory data from Storage via pure providers\r\n        $data = switch ($spec.Domain) {\r\n            'task'    { if (Get-Command Get-PmcTasksData -ErrorAction SilentlyContinue)    { Get-PmcTasksData }    else { @() } }\r\n            'project' { if (Get-Command Get-PmcProjectsData -ErrorAction SilentlyContinue) { Get-PmcProjectsData } else { @() } }\r\n            'timelog' { if (Get-Command Get-PmcTimeLogsData -ErrorAction SilentlyContinue) { Get-PmcTimeLogsData } else { @() } }\r\n            default { @() }\r\n        }\r\n\r\n        # Apply filters\r\n        $filtered = @($data)\r\n        foreach ($field in $spec.Filters.Keys) {\r\n            $ops = $spec.Filters[$field]\r\n            foreach ($op in $ops) {\r\n                $operator = [string]$op.Operator\r\n                $val = [string]$op.Value\r\n                $filtered = @($filtered | Where-Object {\r\n                    if ($null -eq $_) { return $false }\r\n                    $has = $_.PSObject.Properties[$field]\r\n                    $v = $(if ($has) { $_.\"$field\" } else { $null })\r\n                    # Special cases\r\n                    if ($field -eq 'due') {\r\n                        $today = (Get-Date).Date\r\n                        if ($val -eq 'today') { if (-not $v) { return $false }; try { return ([datetime]$v).Date -eq $today } catch { return $false } }\r\n                        if ($val -eq 'tomorrow') { if (-not $v) { return $false }; try { return ([datetime]$v).Date -eq $today.AddDays(1) } catch { return $false } }\r\n                        if ($val -eq 'overdue') { if (-not $v) { return $false }; try { return ([datetime]$v).Date -lt $today } catch { return $false } }\r\n                        if ($val -match '^\\+(\\d+)$') { if (-not $v) { return $false }; $d=[int]$matches[1]; try { $date=[datetime]$v; return ($date.Date -le $today.AddDays($d)) -and ($date.Date -ge $today) } catch { return $false } }\r\n                        if ($val -eq 'eow') { if (-not $v) { return $false }; $dow = [int]$today.DayOfWeek; $rem = (7 - $dow) % 7; try { return ([datetime]$v).Date -le $today.AddDays($rem) -and ([datetime]$v).Date -ge $today } catch { return $false } }\r\n                        if ($val -eq 'eom') { if (-not $v) { return $false }; $eom = (Get-Date -Day 1).AddMonths(1).AddDays(-1).Date; try { return ([datetime]$v).Date -le $eom -and ([datetime]$v).Date -ge $today } catch { return $false } }\r\n                        $vv = $(if ($v) { [string]$v } else { '' })\r\n                        return $vv -match [regex]::Escape($val)\r\n                    }\r\n                    if ($field -eq 'tags') {\r\n                        $arr = @(); try { if ($v -is [System.Collections.IEnumerable]) { $arr=@($v) } } catch {}\r\n                        if ($operator -eq 'contains') { return ($arr -contains $val) }\r\n                        return $false\r\n                    }\r\n                    $sv = $(if ($v -ne $null) { [string]$v } else { '' })\r\n                    switch ($operator) {\r\n                        'exists' { $has -and $sv -ne '' }\r\n                        ':' { $sv -match [regex]::Escape($val) }\r\n                        '=' { $sv -eq $val }\r\n                        '>' { try { [double]$sv -gt [double]$val } catch { $false } }\r\n                        '<' { try { [double]$sv -lt [double]$val } catch { $false } }\r\n                        '>=' { try { [double]$sv -ge [double]$val } catch { $false } }\r\n                        '<=' { try { [double]$sv -le [double]$val } catch { $false } }\r\n                        '~' { $sv -like \"*${val}*\" }\r\n                        default { $true }\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n        # Free text search across common fields\r\n        if ($spec.Metadata.ContainsKey('search')) {\r\n            $terms = @($spec.Metadata['search'])\r\n            foreach ($t in $terms) {\r\n                $needle = $t.ToLower()\r\n                $filtered = @($filtered | Where-Object {\r\n                    $text = ''\r\n                    try {\r\n                        $text = (($_.text) + ' ' + ($_.project) + ' ' + ($_.description) + ' ' + ($_.name))\r\n                    } catch {}\r\n                    $text.ToLower().Contains($needle)\r\n                })\r\n            }\r\n        }\r\n\r\n        # Sorting\r\n        if ($spec.Directives.ContainsKey('sort')) {\r\n            $sortExpr = [string]$spec.Directives['sort']\r\n            $asc = $true\r\n            $field = $sortExpr\r\n            if ($sortExpr -match '^(.+?)([+-])$') { $field = $matches[1]; $asc = ($matches[2] -eq '+') }\r\n            $filtered = @($filtered | Sort-Object -Property @{ Expression = { if ($_.PSObject.Properties[$field]) { $_.\"$field\" } else { $null } }; Ascending = $asc })\r\n        }\r\n\r\n        # Grouping (flat projection by adding Group field)\r\n        if ($spec.Directives.ContainsKey('groupBy')) {\r\n            $g = [string]$spec.Directives['groupBy']\r\n            $projected = @()\r\n            foreach ($row in $filtered) {\r\n                if ($null -eq $row) { continue }\r\n                $groupVal = $(if ($row.PSObject.Properties[$g]) { $row.\"$g\" } else { $null })\r\n                $obj = [pscustomobject]@{ Group = $groupVal }\r\n                # Copy existing fields\r\n                foreach ($p in $row.PSObject.Properties) { Add-Member -InputObject $obj -NotePropertyName $p.Name -NotePropertyValue $p.Value -Force }\r\n                $projected += $obj\r\n            }\r\n            $filtered = @($projected | Sort-Object -Property @{ Expression = { $_.Group } })\r\n        }\r\n\r\n        # Columns selection\r\n        if ($spec.Directives.ContainsKey('columns')) {\r\n            $cols = @($spec.Directives['columns'])\r\n            $projected = @()\r\n            foreach ($row in $filtered) {\r\n                $obj = [pscustomobject]@{}\r\n                if ($spec.Directives.ContainsKey('groupBy')) { Add-Member -InputObject $obj -NotePropertyName 'Group' -NotePropertyValue $row.Group -Force }\r\n                foreach ($c in $cols) {\r\n                    $name = [string]$c\r\n                    $val = $(if ($row.PSObject.Properties[$name]) { $row.\"$name\" } else { $null })\r\n                    Add-Member -InputObject $obj -NotePropertyName $name -NotePropertyValue $val -Force\r\n                }\r\n                $projected += $obj\r\n            }\r\n            $filtered = $projected\r\n        } elseif ($spec.Directives.ContainsKey('groupBy')) {\r\n            # Ensure Group column appears by default if grouping\r\n            $projected = @()\r\n            foreach ($row in $filtered) {\r\n                $obj = [pscustomobject]@{ Group = $row.Group }\r\n                foreach ($p in $row.PSObject.Properties) { if ($p.Name -ne 'Group') { Add-Member -InputObject $obj -NotePropertyName $p.Name -NotePropertyValue $p.Value -Force } }\r\n                $projected += $obj\r\n            }\r\n            $filtered = $projected\r\n        }\r\n\r\n        # Limit\r\n        if ($spec.Directives.ContainsKey('limit')) {\r\n            $n = [int]$spec.Directives['limit']\r\n            $filtered = @($filtered | Select-Object -First $n)\r\n        }\r\n\r\n        return @{\r\n            Success = $true\r\n            Data = ,$filtered\r\n            Metadata = @{\r\n                EstimatedRows = $spec.EstimatedRows\r\n                ActualRows = @($filtered).Count\r\n                Strategy = $spec.OptimizationStrategy\r\n                Cached = $false\r\n            }\r\n        }\r\n    }\r\n\r\n    [object] ExecuteLegacyQuery([PmcEnhancedQuerySpec]$spec) {\r\n        # Legacy query path removed - all queries go through AST now\r\n        Write-PmcDebug -Level 1 -Category 'Query' -Message 'Legacy query execution attempted but disabled'\r\n        return @()\r\n        return @{ Success = $true; Data = @(); Metadata = @{ EstimatedRows = 0; ActualRows = 0; Strategy = 'none'; Cached = $false } }\r\n    }\r\n\r\n    [hashtable] GetExecutionStats() {\r\n        $cacheStats = $this._cache.GetStats()\r\n        $avgDuration = $(if ($this._executionStats.QueriesExecuted -gt 0) {\r\n            [Math]::Round($this._executionStats.TotalDuration / $this._executionStats.QueriesExecuted, 2)\r\n        } else { 0 })\r\n\r\n        return @{\r\n            QueriesExecuted = $this._executionStats.QueriesExecuted\r\n            AverageDuration = $avgDuration\r\n            TotalDuration = $this._executionStats.TotalDuration\r\n            CacheStats = $cacheStats\r\n        }\r\n    }\r\n\r\n    [void] ClearCache() {\r\n        $this._cache.Clear()\r\n    }\r\n\r\n    [void] ResetStats() {\r\n        $this._executionStats = @{\r\n            QueriesExecuted = 0\r\n            TotalDuration = 0\r\n            CacheHits = 0\r\n            CacheMisses = 0\r\n        }\r\n        $this._cache.Clear()\r\n    }\r\n}\r\n\r\n# Global instances\r\n$Script:PmcEnhancedQueryParser = $null\r\n$Script:PmcEnhancedQueryExecutor = $null\r\n\r\nfunction Initialize-PmcEnhancedQueryEngine {\r\n    if ($Script:PmcEnhancedQueryParser) {\r\n        Write-Warning \"PMC Enhanced Query Engine already initialized\"\r\n        return\r\n    }\r\n\r\n    $Script:PmcEnhancedQueryParser = [PmcEnhancedQueryParser]::new()\r\n    $Script:PmcEnhancedQueryExecutor = [PmcEnhancedQueryExecutor]::new()\r\n\r\n    Write-PmcDebug -Level 2 -Category 'EnhancedQuery' -Message \"Enhanced query engine initialized\"\r\n}\r\n\r\nfunction Invoke-PmcEnhancedQuery {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [string[]]$Tokens,\r\n\r\n        [switch]$NoCache\r\n    )\r\n\r\n    if (-not $Script:PmcEnhancedQueryParser) {\r\n        Initialize-PmcEnhancedQueryEngine\r\n    }\r\n\r\n    $spec = $Script:PmcEnhancedQueryParser.ParseQuery($Tokens)\r\n\r\n    if (-not $spec.IsValid()) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Query validation failed: $($spec.ValidationErrors -join '; ')\"\r\n        return @{ Success = $false; Errors = $spec.ValidationErrors }\r\n    }\r\n\r\n    if ($NoCache) {\r\n        $Script:PmcEnhancedQueryExecutor.ClearCache()\r\n    }\r\n\r\n    return $Script:PmcEnhancedQueryExecutor.ExecuteQuery($spec)\r\n}\r\n\r\nfunction Get-PmcQueryPerformanceStats {\r\n    if (-not $Script:PmcEnhancedQueryExecutor) {\r\n        Write-Host \"Enhanced query engine not initialized\"\r\n        return\r\n    }\r\n\r\n    $stats = $Script:PmcEnhancedQueryExecutor.GetExecutionStats()\r\n\r\n    Write-Host \"PMC Query Performance Statistics\" -ForegroundColor Green\r\n    Write-Host \"===============================\" -ForegroundColor Green\r\n    Write-Host \"Queries Executed: $($stats.QueriesExecuted)\"\r\n    Write-Host \"Average Duration: $($stats.AverageDuration) ms\"\r\n    Write-Host \"Total Duration: $($stats.TotalDuration) ms\"\r\n    Write-Host \"\"\r\n    Write-Host \"Cache Performance:\" -ForegroundColor Yellow\r\n    Write-Host \"Cache Size: $($stats.CacheStats.Size)\"\r\n    Write-Host \"Cache Hit Rate: $($stats.CacheStats.HitRate)%\"\r\n    Write-Host \"Cache Hits: $($stats.CacheStats.Hits)\"\r\n    Write-Host \"Cache Misses: $($stats.CacheStats.Misses)\"\r\n    Write-Host \"Cache Evictions: $($stats.CacheStats.Evictions)\"\r\n}\r\n\r\nExport-ModuleMember -Function Initialize-PmcEnhancedQueryEngine, Invoke-PmcEnhancedQuery, Get-PmcQueryPerformanceStats"}, {"path": "module/Pmc.Strict/src/Aliases.ps1", "content": "# User alias system: alias, alias add, alias remove; show aliases\r\n\r\nfunction Get-PmcAliasTable {\r\n    $data = Get-PmcDataAlias\r\n    if (-not (Pmc-HasProp $data 'aliases') -or -not $data.aliases) { $data.aliases = @{} }\r\n    # Normalize to hashtable if JSON loaded as PSCustomObject\r\n    if ($data.aliases -is [pscustomobject]) {\r\n        $ht = @{}\r\n        foreach ($p in $data.aliases.PSObject.Properties) { $ht[$p.Name] = $p.Value }\r\n        $data.aliases = $ht\r\n    }\r\n    # Seed helpful defaults if empty\r\n    try {\r\n        $keyCount = 0\r\n        if ($data.aliases -is [hashtable]) { $keyCount = @($data.aliases.Keys).Count }\r\n        elseif ($data.aliases.PSObject -and $data.aliases.PSObject.Properties) { $keyCount = @($data.aliases.PSObject.Properties.Name).Count }\r\n    } catch { $keyCount = 0 }\r\n    if ($keyCount -eq 0) {\r\n        $data.aliases['projects'] = 'view projects'\r\n    }\r\n    return $data.aliases\r\n}\r\n\r\nfunction Save-PmcAliases($aliases) {\r\n    $data = Get-PmcDataAlias\r\n    $data.aliases = $aliases\r\n    Save-StrictData $data 'alias update'\r\n}\r\n\r\nfunction Get-PmcAliasList {\r\n    param([PmcCommandContext]$Context)\r\n    $aliases = Get-PmcAliasTable\r\n    Write-PmcStyled -Style 'Header' -Text \"\\nALIASES\"\r\n    Write-PmcStyled -Style 'Border' -Text \"────────\"\r\n    $rows = @()\r\n    if ($aliases -is [hashtable]) {\r\n        foreach ($entry in $aliases.GetEnumerator()) {\r\n            $rows += @{ alias = [string]$entry.Key; expands = [string]$entry.Value }\r\n        }\r\n    } elseif ($aliases -is [pscustomobject]) {\r\n        foreach ($p in $aliases.PSObject.Properties) {\r\n            $rows += @{ alias = [string]$p.Name; expands = [string]$p.Value }\r\n        }\r\n    }\r\n    if (@($rows).Count -eq 0) { Write-PmcStyled -Style 'Warning' -Text 'No aliases defined'; return }\r\n    $rows = $rows | Sort-Object alias\r\n\r\n    # Convert to universal display format\r\n    $columns = @{\r\n        \"alias\" = @{ Header = \"Alias\"; Width = 16; Alignment = \"Left\"; Editable = $false }\r\n        \"expands\" = @{ Header = \"Expands To\"; Width = 48; Alignment = \"Left\"; Editable = $false }\r\n    }\r\n\r\n    # Convert rows to PSCustomObject format\r\n    $dataObjects = @()\r\n    foreach ($row in $rows) {\r\n        $obj = New-Object PSCustomObject\r\n        foreach ($key in $row.Keys) {\r\n            $obj | Add-Member -NotePropertyName $key -NotePropertyValue $row[$key]\r\n        }\r\n        $dataObjects += $obj\r\n    }\r\n\r\n    Show-PmcCustomGrid -Domain \"config\" -Columns $columns -Data $dataObjects -Title \"User Aliases\"\r\n}\r\n\r\nfunction Add-PmcAlias {\r\n    param(\r\n        $Context,\r\n        [string]$Name,\r\n        [string]$Value\r\n    )\r\n\r\n    # Handle both PmcCommandContext and direct parameter calls\r\n    if ($Context -and -not $Name -and -not $Value) {\r\n        # Called with Context parameter\r\n        if ($Context.PSObject.Properties['FreeText']) {\r\n            $text = ($Context.FreeText -join ' ').Trim()\r\n            if (-not $text -or -not ($text -match '^(\\S+)\\s+(.+)$')) {\r\n                Write-PmcStyled -Style 'Warning' -Text \"Usage: alias add <name> <expansion...>\"\r\n                return\r\n            }\r\n            $name = $matches[1]; $expansion = $matches[2]\r\n        } else {\r\n            Write-PmcStyled -Style 'Error' -Text \"Invalid context parameter\"\r\n            return\r\n        }\r\n    } elseif ($Name -and $Value) {\r\n        # Called with direct parameters\r\n        $name = $Name; $expansion = $Value\r\n    } else {\r\n        Write-PmcStyled -Style 'Warning' -Text \"Usage: Add-PmcAlias -Name <name> -Value <expansion> or alias add <name> <expansion>\"\r\n        return\r\n    }\r\n\r\n    $aliases = Get-PmcAliasTable\r\n    $aliases[$name] = $expansion\r\n    Save-PmcAliases $aliases\r\n    Write-PmcStyled -Style 'Success' -Text (\"Added alias '{0}' = {1}\" -f $name, $expansion)\r\n}\r\n\r\nfunction Remove-PmcAlias {\r\n    param([PmcCommandContext]$Context)\r\n    $name = ($Context.FreeText -join ' ').Trim()\r\n    if ([string]::IsNullOrWhiteSpace($name)) { Write-PmcStyled -Style 'Warning' -Text \"Usage: alias remove <name>\"; return }\r\n    $aliases = Get-PmcAliasTable\r\n    if (-not $aliases.ContainsKey($name)) { Write-PmcStyled -Style 'Error' -Text (\"Alias '{0}' not found\" -f $name); return }\r\n    $aliases.Remove($name) | Out-Null\r\n    Save-PmcAliases $aliases\r\n    Write-PmcStyled -Style 'Success' -Text (\"Removed alias '{0}'\" -f $name)\r\n}\r\n\r\nfunction Expand-PmcUserAliases {\r\n    param([string]$Buffer)\r\n    try {\r\n        $aliases = Get-PmcAliasTable\r\n        if (-not $aliases) { return $Buffer }\r\n        # Normalize alias keys safely\r\n        $keys = @()\r\n        if ($aliases -is [hashtable]) { $keys = @($aliases.Keys) }\r\n        elseif ($aliases.PSObject -and $aliases.PSObject.Properties) { $keys = @($aliases.PSObject.Properties.Name) }\r\n        if (@($keys).Count -eq 0) { return $Buffer }\r\n        $tokens = ConvertTo-PmcTokens $Buffer\r\n        if ($tokens.Count -eq 0) { return $Buffer }\r\n        $first = $tokens[0]\r\n        $hasKey = $false\r\n        $expansion = $null\r\n        if ($aliases -is [hashtable]) { $hasKey = $aliases.ContainsKey($first); if ($hasKey) { $expansion = [string]$aliases[$first] } }\r\n        elseif ($aliases.PSObject) { try { $expansion = [string]($aliases.$first); $hasKey = -not [string]::IsNullOrEmpty($expansion) } catch {\r\n            # Property access failed - alias does not exist\r\n        } }\r\n        if ($hasKey -and $expansion) {\r\n            # Replace first token with its expansion\r\n            $rest = ''\r\n            if ($tokens.Count -gt 1) { $rest = ' ' + ($tokens[1..($tokens.Count-1)] -join ' ') }\r\n            return ($expansion + $rest)\r\n        }\r\n    } catch {\r\n        # Alias expansion failed - return original buffer\r\n    }\r\n    return $Buffer\r\n}\r\n\r\nExport-ModuleMember -Function Get-PmcAliasTable, Save-PmcAliases, Get-PmcAliasList, Add-PmcAlias, Remove-PmcAlias, Expand-PmcUserAliases"}, {"path": "module/Pmc.Strict/src/Analytics.ps1", "content": "# Analytics and Insights: stats, burndown, velocity\r\n\r\nfunction Get-PmcStatistics {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"Analytics\" -Message \"Starting stats\"\r\n\r\n    $data = Get-PmcDataAlias\r\n    $now = Get-Date\r\n    $d7 = $now.Date.AddDays(-7)\r\n    $d30 = $now.Date.AddDays(-30)\r\n\r\n    $pending = @($data.tasks | Where-Object { $_.status -eq 'pending' }).Count\r\n    $completed = @($data.tasks | Where-Object { $_.status -eq 'completed' }).Count\r\n    $completed7 = @($data.tasks | Where-Object { $_.completed -and ([datetime]$_.completed) -ge $d7 }).Count\r\n    $added7 = @($data.tasks | Where-Object { $_.created -and ([datetime]$_.created) -ge $d7 }).Count\r\n\r\n    $logs7 = @($data.timelogs | Where-Object { $_.date -and ([datetime]$_.date) -ge $d7 })\r\n    $minutes7 = ($logs7 | Measure-Object minutes -Sum).Sum\r\n    $hours7 = [Math]::Round(($minutes7/60),2)\r\n\r\n    $rows = @(\r\n        @{ metric='Pending tasks'; value=$pending },\r\n        @{ metric='Completed (all)'; value=$completed },\r\n        @{ metric='Completed (7d)'; value=$completed7 },\r\n        @{ metric='Added (7d)'; value=$added7 },\r\n        @{ metric='Hours logged (7d)'; value=$hours7 }\r\n    )\r\n    # Convert to universal display format\r\n    $columns = @{\r\n        \"metric\" = @{ Header = \"Metric\"; Width = 26; Alignment = \"Left\"; Editable = $false }\r\n        \"value\" = @{ Header = \"Value\"; Width = 10; Alignment = \"Right\"; Editable = $false }\r\n    }\r\n\r\n    # Convert rows to PSCustomObject format\r\n    $dataObjects = @()\r\n    foreach ($row in $rows) {\r\n        $obj = New-Object PSCustomObject\r\n        foreach ($key in $row.Keys) {\r\n            $obj | Add-Member -NotePropertyName $key -NotePropertyValue $row[$key]\r\n        }\r\n        $dataObjects += $obj\r\n    }\r\n\r\n    Show-PmcCustomGrid -Domain \"stats\" -Columns $columns -Data $dataObjects -Title 'STATS'\r\n\r\n    Write-PmcDebug -Level 2 -Category \"Analytics\" -Message \"Stats completed\" -Data @{ Pending=$pending; Completed7=$completed7; Hours7=$hours7 }\r\n}\r\n\r\nfunction Show-PmcBurndownChart {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"Analytics\" -Message \"Starting burndown\"\r\n\r\n    $data = Get-PmcDataAlias\r\n    $today = (Get-Date).Date\r\n    $horizon = 7\r\n    $rows = @()\r\n\r\n    for ($i=0; $i -lt $horizon; $i++) {\r\n        $day = $today.AddDays($i)\r\n        $remaining = @($data.tasks | Where-Object {\r\n            try {\r\n                $_.status -eq 'pending' -and (\r\n                    (-not $_.due) -or ([datetime]$_.due) -ge $day\r\n                )\r\n            } catch { $false }\r\n        }).Count\r\n        $rows += @{ date=$day.ToString('yyyy-MM-dd'); remaining=$remaining }\r\n    }\r\n\r\n    # Convert to universal display format\r\n    $columns = @{\r\n        \"date\" = @{ Header = \"Date\"; Width = 12; Alignment = \"Center\"; Editable = $false }\r\n        \"remaining\" = @{ Header = \"Remaining\"; Width = 12; Alignment = \"Right\"; Editable = $false }\r\n    }\r\n\r\n    # Convert rows to PSCustomObject format\r\n    $dataObjects = @()\r\n    foreach ($row in $rows) {\r\n        $obj = New-Object PSCustomObject\r\n        foreach ($key in $row.Keys) {\r\n            $obj | Add-Member -NotePropertyName $key -NotePropertyValue $row[$key]\r\n        }\r\n        $dataObjects += $obj\r\n    }\r\n\r\n    Show-PmcCustomGrid -Domain \"stats\" -Columns $columns -Data $dataObjects -Title 'BURNDOWN (next 7 days)'\r\n    Show-PmcTip 'Simple burndown: remaining tasks projected by day'\r\n\r\n    Write-PmcDebug -Level 2 -Category \"Analytics\" -Message \"Burndown completed\"\r\n}\r\n\r\nfunction Get-PmcVelocity {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"Analytics\" -Message \"Starting velocity\"\r\n\r\n    $data = Get-PmcDataAlias\r\n    $startOfWeek = (Get-Date).Date.AddDays(-1 * (([int](Get-Date).DayOfWeek + 6) % 7))\r\n    $rows = @()\r\n    for ($w=0; $w -lt 4; $w++) {\r\n        $wStart = $startOfWeek.AddDays(-7*$w)\r\n        $wEnd = $wStart.AddDays(7)\r\n        $done = @($data.tasks | Where-Object { $_.status -eq 'completed' -and $_.completed -and ([datetime]$_.completed) -ge $wStart -and ([datetime]$_.completed) -lt $wEnd }).Count\r\n        $mins = @($data.timelogs | Where-Object { $_.date -and ([datetime]$_.date) -ge $wStart -and ([datetime]$_.date) -lt $wEnd } | Measure-Object minutes -Sum).Sum\r\n        $hrs = [Math]::Round(($mins/60),1)\r\n        $rows += @{ week=$wStart.ToString('yyyy-MM-dd'); completed=$done; hours=$hrs }\r\n    }\r\n\r\n    # Convert to universal display format\r\n    $columns = @{\r\n        \"week\" = @{ Header = \"Week\"; Width = 12; Alignment = \"Center\"; Editable = $false }\r\n        \"completed\" = @{ Header = \"Done\"; Width = 8; Alignment = \"Right\"; Editable = $false }\r\n        \"hours\" = @{ Header = \"Hours\"; Width = 8; Alignment = \"Right\"; Editable = $false }\r\n    }\r\n\r\n    # Convert rows to PSCustomObject format and sort\r\n    $sortedRows = $rows | Sort-Object week\r\n    $dataObjects = @()\r\n    foreach ($row in $sortedRows) {\r\n        $obj = New-Object PSCustomObject\r\n        foreach ($key in $row.Keys) {\r\n            $obj | Add-Member -NotePropertyName $key -NotePropertyValue $row[$key]\r\n        }\r\n        $dataObjects += $obj\r\n    }\r\n\r\n    Show-PmcCustomGrid -Domain \"stats\" -Columns $columns -Data $dataObjects -Title 'VELOCITY (last 4 weeks)'\r\n    Write-PmcDebug -Level 2 -Category \"Analytics\" -Message \"Velocity completed\"\r\n}\r\n\r\nExport-ModuleMember -Function Get-PmcStatistics, Show-PmcBurndownChart, Get-PmcVelocity"}, {"path": "module/Pmc.Strict/src/AstCommandParser.ps1", "content": "# AST-based command parser for PMC\r\n# Replaces regex-heavy Parse-PmcArgsFromTokens with structured parsing\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Token types for semantic parsing\r\nenum PmcTokenType {\r\n    Domain\r\n    Action\r\n    ProjectRef    # @project\r\n    Priority      # p1, p2, p3\r\n    Tag          # #tag\r\n    DueDate      # due:date\r\n    TaskId       # task:123\r\n    StringLiteral # \"quoted text\"\r\n    Flag         # -i, --interactive\r\n    Separator    # --\r\n    FreeText     # unstructured text\r\n}\r\n\r\nclass PmcParsedToken {\r\n    [PmcTokenType]$Type\r\n    [string]$Value\r\n    [string]$RawValue\r\n    [int]$Position\r\n\r\n    PmcParsedToken([PmcTokenType]$type, [string]$value, [string]$raw, [int]$pos) {\r\n        $this.Type = $type\r\n        $this.Value = $value\r\n        $this.RawValue = $raw\r\n        $this.Position = $pos\r\n    }\r\n}\r\n\r\nclass PmcCommandAst {\r\n    [string]$Domain\r\n    [string]$Action\r\n    [hashtable]$Args = @{}\r\n    [string[]]$FreeText = @()\r\n    [PmcParsedToken[]]$Tokens = @()\r\n    [string]$Raw\r\n\r\n    PmcCommandAst([string]$raw) {\r\n        $this.Raw = $raw\r\n        $this.Args = @{}\r\n        $this.FreeText = @()\r\n        $this.Tokens = @()\r\n    }\r\n}\r\n\r\n# Main AST parsing function\r\nfunction ConvertTo-PmcCommandAst {\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [string]$CommandText\r\n    )\r\n\r\n    try {\r\n        # Use PowerShell AST to get proper tokenization\r\n        $ast = [System.Management.Automation.Language.Parser]::ParseInput($CommandText, [ref]$null, [ref]$null)\r\n\r\n        # Find the command AST node\r\n        $cmdAst = $ast.FindAll({$args[0] -is [System.Management.Automation.Language.CommandAst]}, $true) | Select-Object -First 1\r\n\r\n        if (-not $cmdAst) {\r\n            Write-PmcDebug -Level 2 -Category 'AstParser' -Message \"No command AST found, trying fallback parsing\"\r\n            throw \"No command found in input\"\r\n        }\r\n\r\n        $result = [PmcCommandAst]::new($CommandText)\r\n        $elements = $cmdAst.CommandElements\r\n\r\n        if ($elements.Count -lt 1) {\r\n            throw \"Empty command\"\r\n        }\r\n\r\n        # Check if PowerShell AST stripped important tokens (like #tags)\r\n        $originalTokenCount = ($CommandText -split '\\s+').Count\r\n        $astTokenCount = $elements.Count\r\n\r\n        if ($astTokenCount -lt $originalTokenCount) {\r\n            Write-PmcDebug -Level 2 -Category 'AstParser' -Message \"PowerShell AST stripped tokens (comments?), falling back to manual parsing\"\r\n            throw \"AST incomplete, using fallback\"\r\n        }\r\n\r\n        # Parse domain (first element)\r\n        $result.Domain = $elements[0].Extent.Text.ToLower()\r\n\r\n        # Parse action (second element, if exists)\r\n        if ($elements.Count -gt 1) {\r\n            $result.Action = $elements[1].Extent.Text.ToLower()\r\n        }\r\n\r\n        # Parse remaining arguments (semantic parsing)\r\n        if ($elements.Count -gt 2) {\r\n            $argElements = $elements[2..($elements.Count-1)]\r\n            Parse-CommandArguments -Elements $argElements -Result $result\r\n        }\r\n\r\n        return $result\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'AstParser' -Message \"AST parsing failed: $_\" -Data @{ CommandText = $CommandText }\r\n\r\n        # No fallback - throw the error so we know AST isn't working\r\n        throw \"AST parsing failed: $_\"\r\n    }\r\n}\r\n\r\n# Semantic argument parsing\r\nfunction Parse-CommandArguments {\r\n    param(\r\n        [System.Management.Automation.Language.CommandElementAst[]]$Elements,\r\n        [PmcCommandAst]$Result\r\n    )\r\n\r\n    $position = 0\r\n    $seenSeparator = $false\r\n\r\n    foreach ($element in $Elements) {\r\n        $text = $element.Extent.Text\r\n        $position++\r\n\r\n        # Handle separator (everything after -- is free text)\r\n        if ($text -eq '--') {\r\n            $seenSeparator = $true\r\n            $token = [PmcParsedToken]::new([PmcTokenType]::Separator, '', $text, $position)\r\n            $Result.Tokens += $token\r\n            continue\r\n        }\r\n\r\n        if ($seenSeparator) {\r\n            # Everything after -- goes to free text\r\n            $token = [PmcParsedToken]::new([PmcTokenType]::FreeText, $text, $text, $position)\r\n            $Result.Tokens += $token\r\n            $Result.FreeText += $text\r\n            continue\r\n        }\r\n\r\n        # Semantic parsing based on token patterns\r\n        $tokenInfo = Parse-SemanticToken -Text $text -Position $position\r\n        $Result.Tokens += $tokenInfo\r\n\r\n        # Add to appropriate result field based on token type\r\n        switch ($tokenInfo.Type) {\r\n            ([PmcTokenType]::ProjectRef) {\r\n                $Result.Args['project'] = $tokenInfo.Value\r\n            }\r\n            ([PmcTokenType]::Priority) {\r\n                $Result.Args['priority'] = $tokenInfo.Value\r\n            }\r\n            ([PmcTokenType]::Tag) {\r\n                if (-not $Result.Args.ContainsKey('tags')) { $Result.Args['tags'] = @() }\r\n                $Result.Args['tags'] += $tokenInfo.Value\r\n            }\r\n            ([PmcTokenType]::DueDate) {\r\n                $Result.Args['due'] = $tokenInfo.Value\r\n            }\r\n            ([PmcTokenType]::TaskId) {\r\n                $Result.Args['taskId'] = [int]$tokenInfo.Value\r\n            }\r\n            ([PmcTokenType]::Flag) {\r\n                # Handle flags like -i, --interactive\r\n                $flagName = $tokenInfo.Value\r\n                $Result.Args[$flagName] = $true\r\n            }\r\n            ([PmcTokenType]::StringLiteral) {\r\n                # Quoted strings go to free text (usually task titles, descriptions)\r\n                $Result.FreeText += $tokenInfo.Value\r\n            }\r\n            ([PmcTokenType]::FreeText) {\r\n                $Result.FreeText += $tokenInfo.Value\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n# Parse individual tokens semantically\r\nfunction Parse-SemanticToken {\r\n    param(\r\n        [string]$Text,\r\n        [int]$Position\r\n    )\r\n\r\n    # Project reference: @project\r\n    if ($Text -match '^@(.+)$') {\r\n        return [PmcParsedToken]::new([PmcTokenType]::ProjectRef, $matches[1], $Text, $Position)\r\n    }\r\n\r\n    # Priority: p1, p2, p3\r\n    if ($Text -match '^p([1-3])$') {\r\n        return [PmcParsedToken]::new([PmcTokenType]::Priority, $Text, $Text, $Position)\r\n    }\r\n\r\n    # Tag: #tag\r\n    if ($Text -match '^#(.+)$') {\r\n        return [PmcParsedToken]::new([PmcTokenType]::Tag, $matches[1], $Text, $Position)\r\n    }\r\n\r\n    # Due date: due:date\r\n    if ($Text -match '^due:(.+)$') {\r\n        return [PmcParsedToken]::new([PmcTokenType]::DueDate, $matches[1], $Text, $Position)\r\n    }\r\n\r\n    # Task ID: task:123\r\n    if ($Text -match '^task:(\\d+)$') {\r\n        return [PmcParsedToken]::new([PmcTokenType]::TaskId, $matches[1], $Text, $Position)\r\n    }\r\n\r\n    # Flags: -i, --interactive\r\n    if ($Text -match '^-+(.+)$') {\r\n        $flagName = $matches[1]\r\n        # Normalize common flags\r\n        switch ($flagName.ToLower()) {\r\n            'i' { $flagName = 'interactive' }\r\n            'interactive' { $flagName = 'interactive' }\r\n        }\r\n        return [PmcParsedToken]::new([PmcTokenType]::Flag, $flagName, $Text, $Position)\r\n    }\r\n\r\n    # Quoted strings (AST should handle these, but fallback)\r\n    if ($Text -match '^\"(.*)\"$') {\r\n        return [PmcParsedToken]::new([PmcTokenType]::StringLiteral, $matches[1], $Text, $Position)\r\n    }\r\n\r\n    # Everything else is free text\r\n    return [PmcParsedToken]::new([PmcTokenType]::FreeText, $Text, $Text, $Position)\r\n}\r\n\r\n# Fallback parser when AST fails\r\nfunction ConvertTo-PmcCommandAstFallback {\r\n    param([string]$CommandText)\r\n\r\n    $result = [PmcCommandAst]::new($CommandText)\r\n    $tokens = ConvertTo-PmcTokens $CommandText\r\n\r\n    if ($tokens.Count -gt 0) { $result.Domain = $tokens[0].ToLower() }\r\n    if ($tokens.Count -gt 1) { $result.Action = $tokens[1].ToLower() }\r\n\r\n    # Parse remaining tokens\r\n    if ($tokens.Count -gt 2) {\r\n        $argTokens = $tokens[2..($tokens.Count-1)]\r\n        $position = 2\r\n\r\n        foreach ($token in $argTokens) {\r\n            $position++\r\n            $tokenInfo = Parse-SemanticToken -Text $token -Position $position\r\n            $result.Tokens += $tokenInfo\r\n\r\n            # Add to result like above\r\n            switch ($tokenInfo.Type) {\r\n                ([PmcTokenType]::ProjectRef) { $result.Args['project'] = $tokenInfo.Value }\r\n                ([PmcTokenType]::Priority) { $result.Args['priority'] = $tokenInfo.Value }\r\n                ([PmcTokenType]::Tag) {\r\n                    if (-not $result.Args.ContainsKey('tags')) { $result.Args['tags'] = @() }\r\n                    $result.Args['tags'] += $tokenInfo.Value\r\n                }\r\n                ([PmcTokenType]::DueDate) { $result.Args['due'] = $tokenInfo.Value }\r\n                ([PmcTokenType]::TaskId) { $result.Args['taskId'] = [int]$tokenInfo.Value }\r\n                ([PmcTokenType]::Flag) { $result.Args[$tokenInfo.Value] = $true }\r\n                default { $result.FreeText += $tokenInfo.Value }\r\n            }\r\n        }\r\n    }\r\n\r\n    return $result\r\n}\r\n\r\n# Replace the existing Parse-PmcArgsFromTokens function\r\nfunction Parse-PmcArgsFromTokensAst {\r\n    param(\r\n        [string[]]$Tokens,\r\n        [int]$StartIndex = 0\r\n    )\r\n\r\n    # Reconstruct command from tokens\r\n    $commandText = ($Tokens[$StartIndex..($Tokens.Count-1)] -join ' ')\r\n    $astResult = ConvertTo-PmcCommandAst -CommandText $commandText\r\n\r\n    return @{\r\n        Args = $astResult.Args\r\n        Free = $astResult.FreeText\r\n    }\r\n}\r\n\r\n# Get completion context from AST\r\nfunction Get-PmcCompletionContextFromAst {\r\n    param(\r\n        [string]$Buffer,\r\n        [int]$CursorPos\r\n    )\r\n\r\n    try {\r\n        # Parse what we have so far - handle empty/partial commands\r\n        if ([string]::IsNullOrWhiteSpace($Buffer)) {\r\n            $ast = [PmcCommandAst]::new(\"\")\r\n        } else {\r\n            $ast = ConvertTo-PmcCommandAst -CommandText $Buffer\r\n        }\r\n\r\n        # Determine what kind of completion we need\r\n        $context = @{\r\n            Domain = $ast.Domain\r\n            Action = $ast.Action\r\n            Args = $ast.Args\r\n            LastToken = $null\r\n            ExpectedType = $null\r\n            Position = $ast.Tokens.Count\r\n        }\r\n\r\n        # Find the token at cursor position\r\n        $beforeCursor = $Buffer.Substring(0, [Math]::Min($CursorPos, $Buffer.Length))\r\n        $lastSpace = $beforeCursor.LastIndexOf(' ')\r\n\r\n        if ($lastSpace -ge 0 -and $lastSpace -lt $beforeCursor.Length - 1) {\r\n            $context.LastToken = $beforeCursor.Substring($lastSpace + 1)\r\n        } elseif ($lastSpace -eq $beforeCursor.Length - 1) {\r\n            $context.LastToken = ''\r\n        } else {\r\n            $context.LastToken = $beforeCursor\r\n        }\r\n\r\n        # Determine expected completion type\r\n        $context.ExpectedType = Get-ExpectedCompletionType -Context $context\r\n\r\n        return $context\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 2 -Category 'AstCompletion' -Message \"AST completion context failed: $_\"\r\n        return $null\r\n    }\r\n}\r\n\r\n# Determine what type of completion to show\r\nfunction Get-ExpectedCompletionType {\r\n    param([hashtable]$Context)\r\n\r\n    $lastToken = $(if ($Context.LastToken) { $Context.LastToken } else { '' })\r\n\r\n    # If last token has a prefix, complete that type\r\n    if ($lastToken -and $lastToken.StartsWith('@')) { return 'Project' }\r\n    if ($lastToken -and $lastToken.StartsWith('#')) { return 'Tag' }\r\n    if ($lastToken -and $lastToken -match '^p[1-3]?$') { return 'Priority' }  # Only p1, p2, p3, not \"project\"\r\n    if ($lastToken -and $lastToken.StartsWith('due:')) { return 'Date' }\r\n    if ($lastToken -and $lastToken.StartsWith('task:')) { return 'TaskId' }\r\n\r\n    # If we don't have domain/action yet\r\n    if (-not $Context.Domain -or [string]::IsNullOrEmpty($Context.Domain)) { return 'Domain' }\r\n    if (-not $Context.Action -or [string]::IsNullOrEmpty($Context.Action)) { return 'Action' }\r\n\r\n    # Otherwise, suggest argument types\r\n    return 'Arguments'\r\n}\r\n\r\nExport-ModuleMember -Function ConvertTo-PmcCommandAst, Parse-PmcArgsFromTokensAst, Get-PmcCompletionContextFromAst"}, {"path": "module/Pmc.Strict/src/AstCompletion.ps1", "content": "# AST-based tab completion for PMC commands\r\n# Replaces regex-based completion with semantic understanding\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Enhanced completion providers using AST context\r\nfunction Get-PmcCompletionsFromAst {\r\n    param(\r\n        [string]$Buffer,\r\n        [int]$CursorPos\r\n    )\r\n\r\n    try {\r\n        # Handle empty buffer case\r\n        if ([string]::IsNullOrWhiteSpace($Buffer)) {\r\n            Write-PmcDebug -Level 2 -Category 'AstCompletion' -Message \"Empty buffer, providing domain completions\"\r\n            return Get-DomainCompletions\r\n        }\r\n\r\n        $context = Get-PmcCompletionContextFromAst -Buffer $Buffer -CursorPos $CursorPos\r\n\r\n        if (-not $context) {\r\n            Write-PmcDebug -Level 2 -Category 'AstCompletion' -Message \"No AST context available, falling back\"\r\n            return @()\r\n        }\r\n\r\n        Write-PmcDebug -Level 2 -Category 'AstCompletion' -Message \"AST completion context\" -Data @{\r\n            Domain = $context.Domain\r\n            Action = $context.Action\r\n            ExpectedType = $context.ExpectedType\r\n            LastToken = $context.LastToken\r\n        }\r\n\r\n        # Get completions based on expected type\r\n        $completions = @()\r\n        switch ($context.ExpectedType) {\r\n            'Domain' {\r\n                $completions = Get-DomainCompletions -Filter $context.LastToken\r\n            }\r\n            'Action' {\r\n                $completions = Get-ActionCompletions -Domain $context.Domain -Filter $context.LastToken\r\n            }\r\n            'Project' {\r\n                $completions = Get-ProjectCompletions -Filter $context.LastToken\r\n            }\r\n            'Priority' {\r\n                $completions = Get-PriorityCompletions -Filter $context.LastToken\r\n            }\r\n            'Tag' {\r\n                $completions = Get-TagCompletions -Filter $context.LastToken\r\n            }\r\n            'Date' {\r\n                $completions = Get-DateCompletions -Filter $context.LastToken\r\n            }\r\n            'TaskId' {\r\n                $completions = Get-TaskIdCompletions -Filter $context.LastToken\r\n            }\r\n            'Arguments' {\r\n                $completions = Get-ArgumentCompletions -Context $context\r\n            }\r\n            default {\r\n                $completions = Get-GenericCompletions -Context $context\r\n            }\r\n        }\r\n\r\n        Write-PmcDebug -Level 2 -Category 'AstCompletion' -Message \"Completions generated\" -Data @{\r\n            Count = $completions.Count\r\n            Type = $context.ExpectedType\r\n        }\r\n\r\n        return $completions\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'AstCompletion' -Message \"AST completion failed: $_\" -Data @{\r\n            Buffer = $Buffer\r\n            CursorPos = $CursorPos\r\n            Exception = $_.Exception.Message\r\n        }\r\n        # No fallback - re-throw the error so we know AST completion isn't working\r\n        throw \"AST completion failed: $_\"\r\n    }\r\n}\r\n\r\n# Domain completions\r\nfunction Get-DomainCompletions {\r\n    param([string]$Filter = \"\")\r\n\r\n    $domains = @('task', 'project', 'time', 'timer', 'activity', 'help', 'q')\r\n\r\n    if ([string]::IsNullOrEmpty($Filter)) {\r\n        return $domains\r\n    }\r\n\r\n    return $domains | Where-Object { $_.StartsWith($Filter, [StringComparison]::OrdinalIgnoreCase) }\r\n}\r\n\r\n# Action completions based on domain\r\nfunction Get-ActionCompletions {\r\n    param(\r\n        [string]$Domain,\r\n        [string]$Filter = \"\"\r\n    )\r\n\r\n    $actions = @()\r\n\r\n    if ([string]::IsNullOrEmpty($Domain)) {\r\n        Write-PmcDebug -Level 2 -Category 'AstCompletion' -Message \"No domain provided for action completion\"\r\n        return @()\r\n    }\r\n\r\n    switch ($Domain.ToLower()) {\r\n        'task' {\r\n            $actions = @('add', 'list', 'view', 'update', 'done', 'delete', 'move', 'postpone', 'duplicate', 'note', 'edit', 'search', 'priority', 'agenda', 'week', 'month')\r\n        }\r\n        'project' {\r\n            $actions = @('add', 'list', 'view', 'update', 'edit', 'rename', 'delete', 'archive', 'set-fields', 'show-fields', 'stats', 'info', 'recent')\r\n        }\r\n        'time' {\r\n            $actions = @('log', 'report', 'list', 'edit', 'delete')\r\n        }\r\n        'timer' {\r\n            $actions = @('start', 'stop', 'status')\r\n        }\r\n        'activity' {\r\n            $actions = @('list')\r\n        }\r\n        'help' {\r\n            $actions = @('show', 'guide', 'examples', 'query', 'domain', 'command', 'search')\r\n        }\r\n        default {\r\n            return @()\r\n        }\r\n    }\r\n\r\n    if ([string]::IsNullOrEmpty($Filter)) {\r\n        return $actions\r\n    }\r\n\r\n    return $actions | Where-Object { $_.StartsWith($Filter, [StringComparison]::OrdinalIgnoreCase) }\r\n}\r\n\r\n# Project completions\r\nfunction Get-ProjectCompletions {\r\n    param([string]$Filter = \"\")\r\n\r\n    try {\r\n        $data = Get-PmcData\r\n        $projects = @()\r\n\r\n        foreach ($project in $data.projects) {\r\n            $name = \"@\" + $project.name\r\n            $projects += $name\r\n        }\r\n\r\n        if ([string]::IsNullOrEmpty($Filter)) {\r\n            return $projects\r\n        }\r\n\r\n        # Handle @ prefix in filter\r\n        $searchFilter = $(if ($Filter.StartsWith('@')) { $Filter } else { \"@\" + $Filter })\r\n\r\n        return $projects | Where-Object { $_.StartsWith($searchFilter, [StringComparison]::OrdinalIgnoreCase) }\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 2 -Category 'AstCompletion' -Message \"Project completion error: $_\"\r\n        return @('@work', '@personal', '@urgent')  # Fallback\r\n    }\r\n}\r\n\r\n# Priority completions\r\nfunction Get-PriorityCompletions {\r\n    param([string]$Filter = \"\")\r\n\r\n    $priorities = @('p1', 'p2', 'p3')\r\n\r\n    if ([string]::IsNullOrEmpty($Filter)) {\r\n        return $priorities\r\n    }\r\n\r\n    return $priorities | Where-Object { $_.StartsWith($Filter, [StringComparison]::OrdinalIgnoreCase) }\r\n}\r\n\r\n# Tag completions\r\nfunction Get-TagCompletions {\r\n    param([string]$Filter = \"\")\r\n\r\n    try {\r\n        $data = Get-PmcData\r\n        $tags = @()\r\n\r\n        foreach ($task in $data.tasks) {\r\n            if ($task.tags) {\r\n                foreach ($tag in $task.tags) {\r\n                    $tagName = \"#\" + $tag\r\n                    if ($tags -notcontains $tagName) {\r\n                        $tags += $tagName\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if ([string]::IsNullOrEmpty($Filter)) {\r\n            return $tags\r\n        }\r\n\r\n        # Handle # prefix in filter\r\n        $searchFilter = $(if ($Filter.StartsWith('#')) { $Filter } else { \"#\" + $Filter })\r\n\r\n        return $tags | Where-Object { $_.StartsWith($searchFilter, [StringComparison]::OrdinalIgnoreCase) }\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 2 -Category 'AstCompletion' -Message \"Tag completion error: $_\"\r\n        return @('#urgent', '#bug', '#review')  # Fallback\r\n    }\r\n}\r\n\r\n# Date completions\r\nfunction Get-DateCompletions {\r\n    param([string]$Filter = \"\")\r\n\r\n    $dates = @(\r\n        'due:today',\r\n        'due:tomorrow',\r\n        'due:friday',\r\n        'due:+1d',\r\n        'due:+1w',\r\n        'due:+1m',\r\n        'due:2024-12-25'\r\n    )\r\n\r\n    if ([string]::IsNullOrEmpty($Filter)) {\r\n        return $dates\r\n    }\r\n\r\n    return $dates | Where-Object { $_.StartsWith($Filter, [StringComparison]::OrdinalIgnoreCase) }\r\n}\r\n\r\n# Task ID completions\r\nfunction Get-TaskIdCompletions {\r\n    param([string]$Filter = \"\")\r\n\r\n    try {\r\n        $data = Get-PmcData\r\n        $taskIds = @()\r\n\r\n        foreach ($task in $data.tasks) {\r\n            if ($task.id) {\r\n                $taskId = \"task:\" + $task.id\r\n                $taskIds += $taskId\r\n            }\r\n        }\r\n\r\n        if ([string]::IsNullOrEmpty($Filter)) {\r\n            return $taskIds | Select-Object -First 10  # Limit to recent tasks\r\n        }\r\n\r\n        return $taskIds | Where-Object { $_.StartsWith($Filter, [StringComparison]::OrdinalIgnoreCase) } | Select-Object -First 10\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 2 -Category 'AstCompletion' -Message \"Task ID completion error: $_\"\r\n        return @()\r\n    }\r\n}\r\n\r\n# Argument completions when we already have domain/action\r\nfunction Get-ArgumentCompletions {\r\n    param([hashtable]$Context)\r\n\r\n    $completions = @()\r\n\r\n    # Add common argument types that haven't been used yet\r\n    if (-not $Context.Args.ContainsKey('project')) {\r\n        $completions += '@'\r\n    }\r\n\r\n    if (-not $Context.Args.ContainsKey('priority')) {\r\n        $completions += @('p1', 'p2', 'p3')\r\n    }\r\n\r\n    if (-not $Context.Args.ContainsKey('tags')) {\r\n        $completions += '#'\r\n    }\r\n\r\n    if (-not $Context.Args.ContainsKey('due') -and $Context.Domain -eq 'task') {\r\n        $completions += 'due:'\r\n    }\r\n\r\n    if (-not $Context.Args.ContainsKey('taskId') -and $Context.Action -in @('view', 'update', 'done', 'delete')) {\r\n        $completions += 'task:'\r\n    }\r\n\r\n    return $completions\r\n}\r\n\r\n# Generic completions fallback\r\nfunction Get-GenericCompletions {\r\n    param([hashtable]$Context)\r\n\r\n    $completions = @()\r\n\r\n    # Suggest based on domain and action\r\n    switch (\"$($Context.Domain):$($Context.Action)\") {\r\n        'task:add' {\r\n            $completions += @('@', 'p1', 'p2', 'p3', '#', 'due:')\r\n        }\r\n        'task:list' {\r\n            $completions += @('@', 'p1', 'p2', 'p3', '#', 'due:', 'overdue')\r\n        }\r\n        'task:view' {\r\n            $completions += @('task:')\r\n        }\r\n        'project:list' {\r\n            $completions += @('@')\r\n        }\r\n        'time:log' {\r\n            $completions += @('@', 'task:', '#')\r\n        }\r\n        default {\r\n            $completions += @('@', 'p1', '#')\r\n        }\r\n    }\r\n\r\n    return $completions\r\n}\r\n\r\n# Replace completion logic in Interactive.ps1\r\nfunction Get-CompletionsForStateAst {\r\n    param([hashtable]$Context)\r\n\r\n    # Try AST-based completion first\r\n    $buffer = $(if ($null -ne $Context.Buffer -and $Context.Buffer -ne \"\") { $Context.Buffer } else { \"\" })\r\n    $cursorPos = $(if ($null -ne $Context.CursorPos) { $Context.CursorPos } else { 0 })\r\n\r\n    $astCompletions = Get-PmcCompletionsFromAst -Buffer $buffer -CursorPos $cursorPos\r\n\r\n    if ($astCompletions.Count -gt 0) {\r\n        return $astCompletions\r\n    }\r\n\r\n    # Fallback to existing system if AST fails\r\n    Write-PmcDebug -Level 2 -Category 'AstCompletion' -Message \"AST completion failed, using fallback\"\r\n    return @()\r\n}\r\n\r\nExport-ModuleMember -Function Get-PmcCompletionsFromAst, Get-CompletionsForStateAst"}, {"path": "module/Pmc.Strict/src/CommandMap.ps1", "content": "# Canonical domain -> action -> function map (strict)\r\n\r\n$Script:PmcCommandMap = @{\r\n    task = @{\r\n        add     = 'Add-PmcTask'\r\n        list    = 'Get-PmcTaskList'\r\n        view    = 'Show-PmcTask'\r\n        update  = 'Set-PmcTask'\r\n        done    = 'Complete-PmcTask'\r\n        delete  = 'Remove-PmcTask'\r\n        move    = 'Move-PmcTask'\r\n        postpone= 'Set-PmcTaskPostponed'\r\n        duplicate='Copy-PmcTask'\r\n        note    = 'Add-PmcTaskNote'\r\n        edit    = 'Edit-PmcTask'\r\n        search  = 'Find-PmcTask'\r\n        priority= 'Set-PmcTaskPriority'\r\n        agenda  = 'Show-PmcAgenda'\r\n        week    = 'Show-PmcWeekTasksInteractive'\r\n        month   = 'Show-PmcMonthTasksInteractive'\r\n    }\r\n    subtask = @{\r\n        add     = 'Add-PmcSubtask'\r\n    }\r\n    project = @{\r\n        add     = 'Add-PmcProject'\r\n        list    = 'Get-PmcProjectList'\r\n        view    = 'Show-PmcProject'\r\n        update  = 'Set-PmcProject'\r\n        edit    = 'Edit-PmcProject'\r\n        rename  = 'Rename-PmcProject'\r\n        delete  = 'Remove-PmcProject'\r\n        archive = 'Set-PmcProjectArchived'\r\n        'set-fields' = 'Set-PmcProjectFields'\r\n        'show-fields'= 'Show-PmcProjectFields'\r\n        stats   = 'Get-PmcProjectStats'\r\n        info    = 'Show-PmcProjectInfo'\r\n        recent  = 'Get-PmcRecentProjects'\r\n    }\r\n    activity = @{\r\n        list    = 'Get-PmcActivityList'\r\n    }\r\n    time = @{\r\n        log     = 'Add-PmcTimeEntry'\r\n        report  = 'Get-PmcTimeReport'\r\n        list    = 'Get-PmcTimeList'\r\n        edit    = 'Edit-PmcTimeEntry'\r\n        delete  = 'Remove-PmcTimeEntry'\r\n    }\r\n    timer = @{\r\n        start   = 'Start-PmcTimer'\r\n        stop    = 'Stop-PmcTimer'\r\n        status  = 'Get-PmcTimerStatus'\r\n    }\r\n    template = @{\r\n        save    = 'Save-PmcTemplate'\r\n        apply   = 'Invoke-PmcTemplate'\r\n        list    = 'Get-PmcTemplateList'\r\n        remove  = 'Remove-PmcTemplate'\r\n    }\r\n    recurring = @{\r\n        add     = 'Add-PmcRecurringTask'\r\n    }\r\n    alias = @{\r\n        add     = 'Add-PmcAlias'\r\n        remove  = 'Remove-PmcAlias'\r\n    }\r\n    dep = @{\r\n        add     = 'Add-PmcDependency'\r\n        remove  = 'Remove-PmcDependency'\r\n        show    = 'Show-PmcDependencies'\r\n        graph   = 'Show-PmcDependencyGraph'\r\n    }\r\n    focus = @{\r\n        set     = 'Set-PmcFocus'\r\n        clear   = 'Clear-PmcFocus'\r\n        status  = 'Get-PmcFocusStatus'\r\n    }\r\n    system = @{\r\n        undo    = 'Invoke-PmcUndo'\r\n        redo    = 'Invoke-PmcRedo'\r\n        backup  = 'New-PmcBackup'\r\n        clean   = 'Clear-PmcCompletedTasks'\r\n        gui     = 'Start-PmcFakeTUI'\r\n    }\r\n    view = @{\r\n        today     = 'Show-PmcTodayTasksInteractive'\r\n        tomorrow  = 'Show-PmcTomorrowTasksInteractive'\r\n        overdue   = 'Show-PmcOverdueTasksInteractive'\r\n        upcoming  = 'Show-PmcUpcomingTasksInteractive'\r\n        blocked   = 'Show-PmcBlockedTasksInteractive'\r\n        noduedate = 'Show-PmcTasksWithoutDueDateInteractive'\r\n        projects  = 'Show-PmcProjectsInteractive'\r\n        next      = 'Show-PmcNextTasksInteractive'\r\n    }\r\n    excel = @{\r\n        import   = 'Import-PmcExcelData'\r\n        view     = 'Show-PmcExcelPreview'\r\n        latest   = 'Get-PmcLatestExcelFile'\r\n    }\r\n    xflow = @{\r\n        'browse-source' = 'Set-PmcXFlowSourcePathInteractive'\r\n        'browse-dest'   = 'Set-PmcXFlowDestPathInteractive'\r\n        'preview'       = 'Show-PmcXFlowPreview'\r\n        'run'           = 'Invoke-PmcXFlowRun'\r\n        'export'        = 'Export-PmcXFlowText'\r\n        'import-mappings' = 'Import-PmcXFlowMappingsFromFile'\r\n        'set-latest'    = 'Set-PmcXFlowLatestFromFile'\r\n        'config'        = 'Show-PmcXFlowConfig'\r\n    }\r\n    theme = @{\r\n        reset    = 'Reset-PmcTheme'\r\n        adjust   = 'Edit-PmcTheme'\r\n        list     = 'Get-PmcThemeList'\r\n        apply    = 'Apply-PmcTheme'\r\n        info     = 'Show-PmcThemeInfo'\r\n    }\r\n    interactive = @{\r\n        status   = 'Get-PmcInteractiveStatus'\r\n    }\r\n    config = @{\r\n        show    = 'Show-PmcConfig'\r\n        edit    = 'Edit-PmcConfig'\r\n        set     = 'Set-PmcConfigValue'\r\n        reload  = 'Reload-PmcConfig'\r\n        validate= 'Validate-PmcConfig'\r\n        icons   = 'Set-PmcIconMode'\r\n    }\r\n    import = @{\r\n        tasks   = 'Import-PmcTasks'\r\n    }\r\n    export = @{\r\n        tasks   = 'Export-PmcTasks'\r\n    }\r\n    show = @{\r\n        aliases = 'Get-PmcAliasList'\r\n        commands= 'Show-PmcCommands'\r\n    }\r\n    help = @{\r\n        show     = 'Show-PmcSmartHelp'     # Interactive help browser (full takeover)\r\n        domain   = 'Show-PmcHelpDomain'    # Static print of domain actions\r\n        command  = 'Show-PmcHelpCommand'   # Static print of specific command (args/usage)\r\n        query    = 'Show-PmcHelpQuery'     # Static print of query language overview\r\n        guide    = 'Show-PmcHelpGuide'     # Interactive guides for query/kanban\r\n        examples = 'Show-PmcHelpExamples'  # Practical examples\r\n        search   = 'Show-PmcHelpSearch'    # Search across help content and commands\r\n    }\r\n}\r\n\r\n# Single-word shortcuts (domain-less commands)\r\n$Script:PmcShortcutMap = @{\r\n    add       = 'Add-PmcTask'\r\n    done      = 'Complete-PmcTask'\r\n    delete    = 'Remove-PmcTask'\r\n    update    = 'Set-PmcTask'\r\n    move      = 'Move-PmcTask'\r\n    postpone  = 'Set-PmcTaskPostponed'\r\n    duplicate = 'Copy-PmcTask'\r\n    note      = 'Add-PmcTaskNote'\r\n    edit      = 'Edit-PmcTask'\r\n    list      = 'Get-PmcTaskList'\r\n    search    = 'Find-PmcTask'\r\n    priority  = 'Set-PmcTaskPriority'\r\n    agenda    = 'Show-PmcAgenda'\r\n    week      = 'Show-PmcWeekTasksInteractive'\r\n    month     = 'Show-PmcMonthTasksInteractive'\r\n    log       = 'Add-PmcTimeEntry'\r\n    report    = 'Get-PmcTimeReport'\r\n    today     = 'Show-PmcTodayTasksInteractive'\r\n    tomorrow  = 'Show-PmcTomorrowTasksInteractive'\r\n    overdue   = 'Show-PmcOverdueTasksInteractive'\r\n    upcoming  = 'Show-PmcUpcomingTasksInteractive'\r\n    blocked   = 'Show-PmcBlockedTasksInteractive'\r\n    noduedate = 'Show-PmcTasksWithoutDueDateInteractive'\r\n    projects  = 'Show-PmcProjectsInteractive'\r\n    # Explicit interactive aliases\r\n    itoday    = 'Show-PmcTodayTasks'\r\n    ioverdue  = 'Show-PmcOverdueTasks'\r\n    iagenda   = 'Show-PmcAgenda'\r\n    iprojects = 'Show-PmcProjectList'\r\n    itasks    = 'Show-PmcTodayTasks'\r\n    undo      = 'Invoke-PmcUndo'\r\n    redo      = 'Invoke-PmcRedo'\r\n    backup    = 'New-PmcBackup'\r\n    clean     = 'Clear-PmcCompletedTasks'\r\n    focus     = 'Set-PmcFocus'\r\n    unfocus   = 'Clear-PmcFocus'\r\n    context   = 'Get-PmcFocusStatus'\r\n    next      = 'Show-PmcNextTasksInteractive'\r\n    stats     = 'Get-PmcStats'\r\n    burndown  = 'Show-PmcBurndown'\r\n    velocity  = 'Get-PmcVelocity'\r\n    theme     = 'Set-PmcTheme'\r\n    prefs     = 'Show-PmcPreferences'\r\n    '#'       = 'Invoke-PmcShortcutNumber'\r\n    alias     = 'Get-PmcAliasList'\r\n    time      = 'Get-PmcTimeList'\r\n    config    = 'Validate-PmcConfig'\r\n    review    = 'Start-PmcReview'\r\n    import    = 'Import-PmcTasks'\r\n    export    = 'Export-PmcTasks'\r\n    tasks     = 'Show-PmcAllTasksInteractive'\r\n    q         = 'Invoke-PmcQuery'\r\n}\r\n\r\n# Minimal descriptions for help\r\n$Script:PmcCommandMeta = @{\r\n    'task add'      = @{ Desc='Add a new task' }\r\n    'task list'     = @{ Desc='List tasks' }\r\n    'task done'     = @{ Desc='Complete a task' }\r\n    'project add'   = @{ Desc='Create project' }\r\n    'project list'  = @{ Desc='List projects' }\r\n    'time log'      = @{ Desc='Log time entry' }\r\n    'time report'   = @{ Desc='Show time report' }\r\n    'time list'     = @{ Desc='List time logs' }\r\n    'timer start'   = @{ Desc='Start timer' }\r\n    'timer stop'    = @{ Desc='Stop timer' }\r\n    'timer status'  = @{ Desc='Show timer' }\r\n    'dep add'       = @{ Desc='Add task dependency' }\r\n    'dep remove'    = @{ Desc='Remove task dependency' }\r\n    'dep show'      = @{ Desc='Show task dependencies' }\r\n    'dep graph'     = @{ Desc='Visual dependency graph' }\r\n    'focus set'     = @{ Desc='Set project context' }\r\n    'focus clear'   = @{ Desc='Clear project context' }\r\n    'focus status'  = @{ Desc='Show current context' }\r\n    'system undo'   = @{ Desc='Undo last action' }\r\n    'system redo'   = @{ Desc='Redo last action' }\r\n    'system backup' = @{ Desc='Create data backup' }\r\n    'system clean'  = @{ Desc='Clean completed tasks' }\r\n    'system gui'    = @{ Desc='Launch FakeTUI interface' }\r\n    'view today'    = @{ Desc='Tasks due today' }\r\n    'view tomorrow' = @{ Desc='Tasks due tomorrow' }\r\n    'view overdue'  = @{ Desc='Overdue tasks' }\r\n    'view upcoming' = @{ Desc='Upcoming tasks (7 days)' }\r\n    'view blocked'  = @{ Desc='Tasks blocked by dependencies' }\r\n    'view noduedate'= @{ Desc='Tasks without due dates' }\r\n    'view projects' = @{ Desc='Projects dashboard' }\r\n    'view next'     = @{ Desc='Next actions summary' }\r\n    'excel import'  = @{ Desc='Import tasks from Excel/CSV' }\r\n    'excel view'    = @{ Desc='Preview Excel/CSV import' }\r\n    'excel latest'  = @{ Desc='Show latest Excel/CSV file' }\r\n    'xflow browse-source' = @{ Desc='Choose source Excel file (interactive)' }\r\n    'xflow browse-dest'   = @{ Desc='Choose destination Excel file (interactive)' }\r\n    'xflow preview' = @{ Desc='Preview first mapped fields from source' }\r\n    'xflow run'     = @{ Desc='Run Excel mapping; optional text export' }\r\n    'xflow export'  = @{ Desc='Export last extract to CSV/JSON' }\r\n    'xflow import-mappings' = @{ Desc='Import field mappings from settings.json' }\r\n    'xflow set-latest' = @{ Desc='Set latest extract from JSON file' }\r\n    'xflow config' = @{ Desc='Show current xflow configuration' }\r\n    'theme reset'   = @{ Desc='Reset theme to default' }\r\n    'theme adjust'  = @{ Desc='Adjust theme interactively' }\r\n    'config icons'  = @{ Desc='Set icons: ascii|emoji' }\r\n    'stats'         = @{ Desc='Productivity statistics' }\r\n    'burndown'      = @{ Desc='Burndown overview (7d)' }\r\n    'velocity'      = @{ Desc='Velocity (last 4 weeks)' }\r\n    'prefs'         = @{ Desc='Edit preferences' }\r\n    'alias add'     = @{ Desc='Add user alias' }\r\n    'alias remove'  = @{ Desc='Remove user alias' }\r\n    'show aliases'  = @{ Desc='Show user aliases' }\r\n    'show commands' = @{ Desc='List all commands' }\r\n    'help guide'    = @{ Desc='Guides for query language and kanban' }\r\n    'help examples' = @{ Desc='Examples for queries and kanban flows' }\r\n    'help query'    = @{ Desc='Query language overview' }\r\n    'help search'   = @{ Desc='Search help content and commands' }\r\n    'project stats' = @{ Desc='Project statistics' }\r\n    'project info'  = @{ Desc='Project information' }\r\n    'project recent'= @{ Desc='Recent projects' }\r\n    'import tasks'  = @{ Desc='Import tasks from CSV/JSON' }\r\n    'export tasks'  = @{ Desc='Export tasks to CSV/JSON' }\r\n    'review'        = @{ Desc='Weekly review workflow' }\r\n}\r\n\r\n# Ensure Universal Display is available and shortcuts are registered.\r\nfunction Ensure-PmcUniversalDisplay {\r\n    try {\r\n        $ud = Join-Path $PSScriptRoot 'UniversalDisplay.ps1'\r\n        # Load if core entry not available\r\n        if (-not (Get-Command Show-PmcData -ErrorAction SilentlyContinue)) {\r\n            if (-not (Test-Path $ud)) { throw \"UniversalDisplay.ps1 not found at $ud\" }\r\n            . $ud\r\n        }\r\n        if (Get-Command Register-PmcUniversalCommands -ErrorAction SilentlyContinue) {\r\n            Register-PmcUniversalCommands\r\n            return $true\r\n        }\r\n        throw 'Register-PmcUniversalCommands not found after loading UniversalDisplay.ps1'\r\n    } catch {\r\n        # Write-PmcDebug -Level 1 -Category 'UniversalDisplay' -Message \"Initialization failed\" -Data @{ Error = $_.ToString() }\r\n        Write-Warning \"UniversalDisplay initialization failed: $($_.ToString())\"\r\n        return $false\r\n    }\r\n}\r\n\r\n# Initialize Universal Display system when this module is loaded\r\n# Ensure-PmcUniversalDisplay  # Commented out to prevent CommandMap loading issues"}, {"path": "module/Pmc.Strict/src/ComputedFields.ps1", "content": "Set-StrictMode -Version Latest\r\n\r\n# Computed metrics and relations registry for PMC Query Engine\r\n\r\nfunction Get-PmcComputedRegistry {\r\n    # Returns a hashtable keyed by domain with metrics definitions\r\n    # Each metric: @{ Name; AppliesTo; DependsOn=@('timelog'); Type; Resolver=[scriptblock] }\r\n    $weekRange = {\r\n        $today = (Get-Date).Date\r\n        $dow = [int]$today.DayOfWeek # Sunday=0\r\n        $start = $today.AddDays(-$dow) # week starts Sunday\r\n        $end = $start.AddDays(7)\r\n        @{ Start=$start; End=$end }\r\n    }\r\n\r\n    $taskMetrics = @{\r\n        time_week = @{\r\n            Name='time_week'; AppliesTo='task'; DependsOn=@('timelog'); Type='int'\r\n            Resolver = {\r\n                param($row,$data)\r\n                if (-not ($row.PSObject.Properties['id'])) { return 0 }\r\n                $id = [int]$row.id\r\n                $range = & $weekRange\r\n                $logs = @($data.timelogs | Where-Object { $_ -ne $null -and $_.taskId -eq $id -and $_.date -and (try { $d=[datetime]$_.date; $d -ge $range.Start -and $d -lt $range.End } catch { $false }) })\r\n                $mins = (@($logs | Measure-Object minutes -Sum).Sum)\r\n                if ($mins -eq $null) { $mins = 0 }\r\n                return [int]$mins\r\n            }\r\n        }\r\n        overdue_days = @{\r\n            Name='overdue_days'; AppliesTo='task'; DependsOn=@(); Type='int'\r\n            Resolver = {\r\n                param($row,$data)\r\n                if (-not ($row.PSObject.Properties['due'])) { return 0 }\r\n                try {\r\n                    $d = [datetime]$row.due\r\n                    $delta = ((Get-Date).Date - $d.Date).Days\r\n                    return [Math]::Max(0, [int]$delta)\r\n                } catch { return 0 }\r\n            }\r\n        }\r\n        time_today = @{\r\n            Name='time_today'; AppliesTo='task'; DependsOn=@('timelog'); Type='int'\r\n            Resolver = {\r\n                param($row,$data)\r\n                if (-not ($row.PSObject.Properties['id'])) { return 0 }\r\n                $id = [int]$row.id\r\n                $today = (Get-Date).Date\r\n                $logs = @($data.timelogs | Where-Object { $_ -ne $null -and $_.taskId -eq $id -and $_.date -and (try { ([datetime]$_.date).Date -eq $today } catch { $false }) })\r\n                $mins = (@($logs | Measure-Object minutes -Sum).Sum)\r\n                if ($mins -eq $null) { $mins = 0 }\r\n                return [int]$mins\r\n            }\r\n        }\r\n        time_month = @{\r\n            Name='time_month'; AppliesTo='task'; DependsOn=@('timelog'); Type='int'\r\n            Resolver = {\r\n                param($row,$data)\r\n                if (-not ($row.PSObject.Properties['id'])) { return 0 }\r\n                $id = [int]$row.id\r\n                $today = (Get-Date).Date\r\n                $start = Get-Date -Year $today.Year -Month $today.Month -Day 1\r\n                $end = $start.AddMonths(1)\r\n                $logs = @($data.timelogs | Where-Object { $_ -ne $null -and $_.taskId -eq $id -and $_.date -and (try { $d=[datetime]$_.date; $d -ge $start -and $d -lt $end } catch { $false }) })\r\n                $mins = (@($logs | Measure-Object minutes -Sum).Sum)\r\n                if ($mins -eq $null) { $mins = 0 }\r\n                return [int]$mins\r\n            }\r\n        }\r\n    }\r\n\r\n    $projectMetrics = @{\r\n        task_count = @{\r\n            Name='task_count'; AppliesTo='project'; DependsOn=@('task'); Type='int'\r\n            Resolver = {\r\n                param($row,$data)\r\n                $name = $(if ($row.PSObject.Properties['name']) { [string]$row.name } else { '' })\r\n                if (-not $name) { return 0 }\r\n                $tasks = @($data.tasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties['project'] -and $_.project -eq $name })\r\n                return @($tasks).Count\r\n            }\r\n        }\r\n        time_week = @{\r\n            Name='time_week'; AppliesTo='project'; DependsOn=@('timelog'); Type='int'\r\n            Resolver = {\r\n                param($row,$data)\r\n                $name = $(if ($row.PSObject.Properties['name']) { [string]$row.name } else { '' })\r\n                if (-not $name) { return 0 }\r\n                $range = & $weekRange\r\n                $logs = @($data.timelogs | Where-Object { $_ -ne $null -and $_.project -eq $name -and $_.date -and (try { $d=[datetime]$_.date; $d -ge $range.Start -and $d -lt $range.End } catch { $false }) })\r\n                $mins = (@($logs | Measure-Object minutes -Sum).Sum)\r\n                if ($mins -eq $null) { $mins = 0 }\r\n                return [int]$mins\r\n            }\r\n        }\r\n        time_month = @{\r\n            Name='time_month'; AppliesTo='project'; DependsOn=@('timelog'); Type='int'\r\n            Resolver = {\r\n                param($row,$data)\r\n                $name = $(if ($row.PSObject.Properties['name']) { [string]$row.name } else { '' })\r\n                if (-not $name) { return 0 }\r\n                $today = (Get-Date).Date\r\n                $start = Get-Date -Year $today.Year -Month $today.Month -Day 1\r\n                $end = $start.AddMonths(1)\r\n                $logs = @($data.timelogs | Where-Object { $_ -ne $null -and $_.project -eq $name -and $_.date -and (try { $d=[datetime]$_.date; $d -ge $start -and $d -lt $end } catch { $false }) })\r\n                $mins = (@($logs | Measure-Object minutes -Sum).Sum)\r\n                if ($mins -eq $null) { $mins = 0 }\r\n                return [int]$mins\r\n            }\r\n        }\r\n        overdue_task_count = @{\r\n            Name='overdue_task_count'; AppliesTo='project'; DependsOn=@('task'); Type='int'\r\n            Resolver = {\r\n                param($row,$data)\r\n                $name = $(if ($row.PSObject.Properties['name']) { [string]$row.name } else { '' })\r\n                if (-not $name) { return 0 }\r\n                $today = (Get-Date).Date\r\n                $tasks = @($data.tasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties['project'] -and $_.project -eq $name -and $_.PSObject.Properties['due'] -and (try { ([datetime]$_.due).Date -lt $today } catch { $false }) })\r\n                return @($tasks).Count\r\n            }\r\n        }\r\n    }\r\n\r\n    return @{\r\n        task = $taskMetrics\r\n        project = $projectMetrics\r\n        timelog = @{}\r\n    }\r\n}\r\n\r\nfunction Get-PmcMetricsForDomain {\r\n    param([string]$Domain)\r\n    $reg = Get-PmcComputedRegistry\r\n    if ($reg.ContainsKey($Domain)) { return $reg[$Domain] }\r\n    return @{}\r\n}\r\n\r\n# Relation-derived fields\r\nfunction Get-PmcRelationResolvers {\r\n    param([string]$Domain,[string]$Relation)\r\n    $map = @{}\r\n    switch ($Domain) {\r\n        'task' {\r\n            if ($Relation -eq 'project') {\r\n                $map['project_name'] = {\r\n                    param($row,$data)\r\n                    try { if ($row.PSObject.Properties['project']) { return [string]$row.project } } catch {}\r\n                    return ''\r\n                }\r\n            }\r\n        }\r\n        'timelog' {\r\n            if ($Relation -eq 'project') {\r\n                $map['project_name'] = {\r\n                    param($row,$data)\r\n                    try { if ($row.PSObject.Properties['project']) { return [string]$row.project } } catch {}\r\n                    return ''\r\n                }\r\n            }\r\n            if ($Relation -eq 'task') {\r\n                $map['task_text'] = {\r\n                    param($row,$data)\r\n                    try { if ($row.PSObject.Properties['taskId'] -and $row.taskId) { $t = ($data.tasks | Where-Object { $_ -ne $null -and $_.PSObject.Properties['id'] -and [int]$_.id -eq [int]$row.taskId } | Select-Object -First 1); if ($t -and $t.PSObject.Properties['text']) { return [string]$t.text } } } catch {}\r\n                    return ''\r\n                }\r\n            }\r\n        }\r\n        default {}\r\n    }\r\n    return $map\r\n}\r\n\r\n#Export-ModuleMember -Function Get-PmcComputedRegistry, Get-PmcMetricsForDomain, Get-PmcRelationResolvers"}, {"path": "module/Pmc.Strict/src/Config.ps1", "content": "# Config provider indirection - now uses centralized state\r\n\r\nfunction Set-PmcConfigProvider {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$true, Position=0)] [scriptblock]$Get,\r\n        [Parameter(Position=1)] [scriptblock]$Set\r\n    )\r\n    Set-PmcConfigProviders -Get $Get -Set $Set\r\n}\r\n\r\nfunction Get-PmcConfig {\r\n    $providers = Get-PmcConfigProviders\r\n    # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Get-PmcConfig] START\"\r\n    try {\r\n        $cfg = & $providers.Get\r\n        # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Get-PmcConfig] Provider returned: $($cfg | ConvertTo-Json -Compress -Depth 3)\"\r\n        # If provider returns empty config, try reading from default file\r\n        if (-not $cfg -or ($cfg.GetType().Name -eq 'Hashtable' -and $cfg.Count -eq 0)) {\r\n            # Default: read from pmc/config.json (three levels up from module dir, same as tasks.json)\r\n            # CRITICAL FIX: Use workspace root, not module root\r\n            try {\r\n                $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent\r\n                $path = Join-Path $root 'config.json'\r\n                # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Get-PmcConfig] Loading from file: $path\"\r\n                if (Test-Path $path) {\r\n                    $json = Get-Content -Path $path -Raw -Encoding UTF8\r\n                    $cfg = $json | ConvertFrom-Json\r\n                    # Convert PSCustomObject to hashtable recursively\r\n                    $cfg = ConvertPSObjectToHashtable $cfg\r\n                    # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Get-PmcConfig] Loaded config: $($cfg | ConvertTo-Json -Compress -Depth 3)\"\r\n                    return $cfg\r\n                } else {\r\n                    # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Get-PmcConfig] File does not exist: $path\"\r\n                }\r\n            } catch {\r\n                # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Get-PmcConfig] ERROR reading file: $_\"\r\n                # File read failed, return empty\r\n            }\r\n        }\r\n        # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Get-PmcConfig] Returning: $($cfg | ConvertTo-Json -Compress -Depth 3)\"\r\n        return $cfg\r\n    } catch {\r\n        # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Get-PmcConfig] ERROR: $_\"\r\n        return @{}\r\n    }\r\n}\r\n\r\nfunction ConvertPSObjectToHashtable {\r\n    param($obj)\r\n    if ($null -eq $obj) { return $null }\r\n    if ($obj -is [System.Collections.IDictionary]) { return $obj }\r\n    if ($obj -is [System.Collections.IEnumerable] -and $obj -isnot [string]) {\r\n        return @($obj | ForEach-Object { ConvertPSObjectToHashtable $_ })\r\n    }\r\n    if ($obj -is [PSCustomObject]) {\r\n        $ht = @{}\r\n        foreach ($prop in $obj.PSObject.Properties) {\r\n            $ht[$prop.Name] = ConvertPSObjectToHashtable $prop.Value\r\n        }\r\n        return $ht\r\n    }\r\n    return $obj\r\n}\r\n\r\nfunction Save-PmcConfig {\r\n    param($cfg)\r\n    # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Save-PmcConfig] START with config: $($cfg | ConvertTo-Json -Compress -Depth 3)\"\r\n    # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Save-PmcConfig] STACK TRACE: $((Get-PSCallStack | Select-Object -Skip 1 | Select-Object -First 5 | ForEach-Object { \"$($_.Command):$($_.ScriptLineNumber)\" }) -join ' <- ')\"\r\n    $providers = Get-PmcConfigProviders\r\n    if ($providers.Set) {\r\n        try {\r\n            # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Save-PmcConfig] Calling provider Set\"\r\n            & $providers.Set $cfg\r\n            # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Save-PmcConfig] Provider Set succeeded\"\r\n            return\r\n        } catch {\r\n            # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Save-PmcConfig] Provider Set failed: $_\"\r\n            # Custom config provider failed - fall back to default\r\n        }\r\n    }\r\n    # Default: write to pmc/config.json (three levels up from module dir, same as tasks.json)\r\n    # CRITICAL FIX: Use workspace root, not module root\r\n    try {\r\n        $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent\r\n        $path = Join-Path $root 'config.json'\r\n        # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Save-PmcConfig] Writing to file: $path\"\r\n        $cfg | ConvertTo-Json -Depth 10 | Set-Content -Path $path -Encoding UTF8\r\n        # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Save-PmcConfig] File write succeeded\"\r\n    } catch {\r\n        # Add-Content -Path \"$($env:TEMP)\\pmc-config-debug.log\" -Value \"$(Get-Date -Format 'HH:mm:ss.fff') [Save-PmcConfig] File write failed: $_\"\r\n        # Default config file save failed - settings not persisted\r\n    }\r\n}\r\n\r\n# Basic config schema validation and normalization\r\nfunction Get-PmcDefaultConfig {\r\n    return @{\r\n        Display = @{ Theme = @{ Enabled=$true; Hex='#33aaff' }; Icons=@{ Mode='emoji' } }\r\n        Debug = @{ Level=0; LogPath='debug.log'; MaxSize='10MB'; RedactSensitive=$true; IncludePerformance=$false }\r\n        Security = @{ AllowedWritePaths=@('./','./reports/','./backups/'); MaxFileSize='100MB'; MaxMemoryUsage='500MB'; ScanForSensitiveData=$true; RequirePathWhitelist=$true; AuditAllFileOps=$true }\r\n        Behavior = @{ StrictDataMode = $true; SafePathsStrict = $true; MaxBackups = 3; MaxUndoLevels = 10; WhatIf = $false }\r\n    }\r\n}\r\n\r\nfunction Test-PmcConfigSchema {\r\n    $cfg = Get-PmcConfig\r\n    $errors = @(); $warnings=@()\r\n    # Display.Theme.Hex\r\n    try { $hex = [string]$cfg.Display.Theme.Hex; if (-not ($hex -match '^#?[0-9a-fA-F]{6}$')) { $warnings += 'Display.Theme.Hex invalid; using default' } } catch { $warnings += 'Display.Theme.Hex missing' }\r\n    # Icons mode\r\n    try { $mode = [string]$cfg.Display.Icons.Mode; if ($mode -notin @('ascii','emoji')) { $warnings += 'Display.Icons.Mode must be ascii|emoji' } } catch { $warnings += 'Display.Icons.Mode missing' }\r\n    # Debug level\r\n    try { $lvl = [int]$cfg.Debug.Level; if ($lvl -lt 0 -or $lvl -gt 3) { $warnings += 'Debug.Level out of range (0-3)' } } catch { $warnings += 'Debug.Level missing' }\r\n    # Security paths\r\n    try { if (-not ($cfg.Security.AllowedWritePaths -is [System.Collections.IEnumerable])) { $warnings += 'Security.AllowedWritePaths must be an array' } } catch { $warnings += 'Security.AllowedWritePaths missing' }\r\n    return [pscustomobject]@{ IsValid = ($errors.Count -eq 0); Errors=$errors; Warnings=$warnings }\r\n}\r\n\r\nfunction Normalize-PmcConfig {\r\n    $cfg = Get-PmcConfig\r\n    $def = Get-PmcDefaultConfig\r\n    foreach ($k in $def.Keys) {\r\n        if (-not $cfg.ContainsKey($k)) { $cfg[$k] = $def[$k]; continue }\r\n        foreach ($k2 in $def[$k].Keys) {\r\n            if (-not $cfg[$k].ContainsKey($k2)) { $cfg[$k][$k2] = $def[$k][$k2] }\r\n        }\r\n    }\r\n    # Normalize hex\r\n    try { if ($cfg.Display.Theme.Hex -and -not ($cfg.Display.Theme.Hex.ToString().StartsWith('#'))) { $cfg.Display.Theme.Hex = '#' + $cfg.Display.Theme.Hex } } catch {}\r\n    # Icons mode default\r\n    try { if (-not $cfg.Display.Icons.Mode) { $cfg.Display.Icons.Mode = 'emoji' } } catch {}\r\n    Save-PmcConfig $cfg\r\n    return $cfg\r\n}\r\n\r\nfunction Validate-PmcConfig { param([PmcCommandContext]$Context)\r\n    $result = Test-PmcConfigSchema\r\n    if (-not $result.IsValid -or $result.Warnings.Count -gt 0) {\r\n        Write-PmcStyled -Style 'Warning' -Text 'Config issues detected:'\r\n        foreach ($w in $result.Warnings) { Write-PmcStyled -Style 'Muted' -Text ('  - ' + $w) }\r\n    } else {\r\n        Write-PmcStyled -Style 'Success' -Text 'Config looks good.'\r\n    }\r\n}\r\n\r\nfunction Show-PmcConfig {\r\n    param($Context)\r\n    $cfg = Get-PmcConfig\r\n\r\n    Write-PmcStyled -Style 'Header' -Text \"`n⚙️ PMC CONFIGURATION`n\"\r\n    Write-PmcStyled -Style 'Subheader' -Text \"Data Path:\"\r\n    Write-PmcStyled -Style 'Info' -Text \"  $($cfg.Storage.DataPath)\"\r\n    Write-PmcStyled -Style 'Subheader' -Text \"`nDisplay Settings:\"\r\n    Write-PmcStyled -Style 'Info' -Text \"  Icons: $($cfg.Display.Icons.Mode)\"\r\n    Write-PmcStyled -Style 'Subheader' -Text \"`nSecurity Level:\"\r\n    Write-PmcStyled -Style 'Info' -Text \"  $($cfg.Security.Level)\"\r\n}\r\n\r\nfunction Edit-PmcConfig {\r\n    param($Context)\r\n    Write-PmcStyled -Style 'Warning' -Text 'Config editing not yet implemented'\r\n    Write-PmcStyled -Style 'Info' -Text 'Use: Show-PmcConfig to view current settings'\r\n}\r\n\r\nfunction Set-PmcConfigValue {\r\n    param($Context)\r\n    Write-PmcStyled -Style 'Warning' -Text 'Config value setting not yet implemented'\r\n    Write-PmcStyled -Style 'Info' -Text 'Manual config editing required'\r\n}\r\n\r\nfunction Reload-PmcConfig {\r\n    param($Context)\r\n    # Force reload config\r\n    $Script:PmcConfig = $null\r\n    $cfg = Get-PmcConfig\r\n    Write-PmcStyled -Style 'Success' -Text '[OK] Config reloaded'\r\n}\r\n\r\nfunction Set-PmcIconMode {\r\n    param($Context)\r\n\r\n    $mode = 'emoji'\r\n    if ($Context.FreeText.Count -gt 0) {\r\n        $mode = $Context.FreeText[0].ToLower()\r\n    }\r\n\r\n    if ($mode -notin @('ascii', 'emoji')) {\r\n        Write-PmcStyled -Style 'Error' -Text 'Icon mode must be: ascii or emoji'\r\n        return\r\n    }\r\n\r\n    $cfg = Get-PmcConfig\r\n    $cfg.Display.Icons.Mode = $mode\r\n    Save-PmcConfig $cfg\r\n    Write-PmcStyled -Style 'Success' -Text \"[OK] Icon mode set to: $mode\"\r\n}\r\n\r\n# Export config functions - handled by main module (Pmc.Strict.psm1)\r\n# Export-ModuleMember -Function Get-PmcConfig, Save-PmcConfig, Validate-PmcConfig, Show-PmcConfig, Edit-PmcConfig, Set-PmcConfigValue, Reload-PmcConfig, Set-PmcIconMode"}, {"path": "module/Pmc.Strict/src/DataDisplay.ps1", "content": "# DataDisplay.ps1 - Universal data grid system for PMC\r\n# Provides flexible, auto-sizing grid display for any domain combination\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass PmcGridRenderer {\r\n    [hashtable] $ColumnConfig\r\n    [int] $TerminalWidth\r\n    [string[]] $Domains\r\n    [hashtable] $Filters\r\n    [hashtable] $ThemeConfig\r\n    [hashtable] $ProjectLookup\r\n\r\n    # NEW: Interactive navigation state\r\n    [int] $SelectedRow = 0\r\n    [int] $SelectedColumn = 0\r\n    [string] $NavigationMode = \"Row\"  # Row, Cell, MultiSelect\r\n    [bool] $Interactive = $false\r\n    [bool] $ShowInternalHeader = $true\r\n    [string] $TitleText = 'PMC Interactive Data Grid'\r\n    [object[]] $CurrentData = @()\r\n    [object[]] $AllData = @()\r\n    [hashtable] $KeyBindings = @{}\r\n\r\n    # NEW: Navigation mode flags\r\n    [bool] $EditMode = $true          # true = Enter edits cells, false = Enter navigates/selects\r\n    [scriptblock] $OnSelectCallback = $null  # Callback for navigation mode Enter\r\n\r\n    # NEW: Editing state\r\n    [bool] $InEditMode = $false\r\n    [string] $EditingColumn = \"\"\r\n    [string] $EditingValue = \"\"\r\n    [hashtable] $EditCallbacks = @{}\r\n    [bool] $LiveEditing = $false\r\n    [scriptblock] $SaveCallback = $null\r\n\r\n    # NEW: Inline editing state\r\n    [bool] $InlineEditMode = $false\r\n    [int] $EditCursorPos = 0\r\n    [hashtable] $PendingEdits = @{}  # Store pending edits in memory until session completes\r\n    [bool] $AllowSensitiveEdits = $false\r\n    [string] $ConflictPolicy = 'InlineRelaxed'  # InlineRelaxed | Strict\r\n\r\n    # NEW: Selection and multi-select\r\n    [int[]] $SelectedRows = @()\r\n    [bool] $MultiSelectMode = $false\r\n\r\n    # NEW: Performance/diff rendering placeholders\r\n    [hashtable] $RenderCache = @{}\r\n    [bool] $DifferentialMode = $true\r\n\r\n    # NEW: Simple live filtering state\r\n    [string] $FilterQuery = ''\r\n    [string] $LastErrorMessage = ''\r\n\r\n    [string] GetPrimaryDomain() {\r\n        if ($this.Domains -and @($this.Domains).Count -gt 0) { return [string]$this.Domains[0] }\r\n        return ''\r\n    }\r\n\r\n    [hashtable] GetFieldSchema([string]$ColumnName) {\r\n        $dom = $this.GetPrimaryDomain()\r\n        if ($dom) { return (Get-PmcFieldSchema -Domain $dom -Field $ColumnName) }\r\n        return $null\r\n    }\r\n\r\n    [string] GetFieldHint([string]$ColumnName) {\r\n        $sch = $this.GetFieldSchema($ColumnName)\r\n        if ($sch -and $sch.ContainsKey('Hint')) { return [string]$sch.Hint }\r\n        return ''\r\n    }\r\n\r\n    [string] NormalizeField([string]$ColumnName, [string]$Value) {\r\n        $sch = $this.GetFieldSchema($ColumnName)\r\n        if ($sch -and $sch.ContainsKey('Normalize') -and $sch.Normalize) { return (& $sch.Normalize $Value) }\r\n        return $Value\r\n    }\r\n\r\n    [void] ValidateField([string]$ColumnName, [string]$Value) {\r\n        $sch = $this.GetFieldSchema($ColumnName)\r\n        if ($sch -and $sch.ContainsKey('Validate') -and $sch.Validate) { & $sch.Validate $Value | Out-Null }\r\n    }\r\n\r\n    # NEW: Sorting state\r\n    [string] $SortColumn = ''\r\n    [string] $SortDirection = 'None'  # None | Asc | Desc\r\n\r\n    # NEW: Saved views map\r\n    [hashtable] $SavedViews = @{}\r\n\r\n    # NEW: Differential rendering cache/state\r\n    [string[]] $LastLines = @()\r\n\r\n    # NEW: Praxis frame renderer for proper double buffering\r\n    [object] $FrameRenderer = $null\r\n    [bool] $HasInitialRender = $false\r\n    [int] $RefreshIntervalMs = 0\r\n    [datetime] $LastRefreshAt = [datetime]::MinValue\r\n\r\n    # NEW: Layout and scrolling\r\n    [int] $WindowHeight = 0\r\n    [int] $HeaderLines = 4   # Title, border, header, separator\r\n    [int] $ScrollOffset = 0\r\n\r\n    PmcGridRenderer([hashtable]$Columns, [string[]]$Domains, [hashtable]$Filters) {\r\n        $this.ColumnConfig = $Columns\r\n        $this.Domains = $Domains\r\n        $this.Filters = $Filters\r\n        $this.ThemeConfig = $this.InitializeTheme(@{})\r\n        $this.TerminalWidth = $this.GetTerminalWidth()\r\n        $this.WindowHeight = $this.GetTerminalHeight()\r\n        $this.ProjectLookup = $this.LoadProjectLookup()\r\n        $this.InitializeKeyBindings()\r\n        $this.LoadSavedViews()\r\n\r\n        # Initialize Praxis frame renderer for proper double buffering\r\n        $this.FrameRenderer = [PraxisFrameRenderer]::new()\r\n    }\r\n\r\n    [hashtable] InitializeTheme([hashtable]$UserTheme) {\r\n        # Get PMC's existing style system\r\n        $pmcStyles = Get-PmcState -Section 'Display' -Key 'Styles'\r\n\r\n        # Default grid theme using PMC style tokens\r\n        $defaultTheme = @{\r\n            Default = @{\r\n                Style = \"Body\"  # Uses PMC's Body style token\r\n            }\r\n            Columns = @{}\r\n            Rows = @{\r\n                Header = @{ Style = \"Header\" }      # Uses PMC's Header style\r\n                Separator = @{ Style = \"Border\" }   # Uses PMC's Border style\r\n            }\r\n            Cells = @()\r\n        }\r\n\r\n        # Merge user theme with defaults (deep merge)\r\n        if ($UserTheme.PSObject.Properties['Default']) {\r\n            $defaultTheme.Default = $this.MergeStyles($defaultTheme.Default, $UserTheme.Default)\r\n        }\r\n        if ($UserTheme.PSObject.Properties['Columns']) {\r\n            foreach ($col in $UserTheme.Columns.Keys) {\r\n                $defaultTheme.Columns[$col] = $UserTheme.Columns[$col]\r\n            }\r\n        }\r\n        if ($UserTheme.PSObject.Properties['Rows']) {\r\n            foreach ($row in $UserTheme.Rows.Keys) {\r\n                $defaultTheme.Rows[$row] = $this.MergeStyles($defaultTheme.Rows[$row], $UserTheme.Rows[$row])\r\n            }\r\n        }\r\n        if ($UserTheme.PSObject.Properties['Cells']) {\r\n            $defaultTheme.Cells = $UserTheme.Cells\r\n        }\r\n\r\n        return $defaultTheme\r\n    }\r\n\r\n    [hashtable] MergeStyles([hashtable]$Base, [hashtable]$Override) {\r\n        $merged = @{}\r\n        if ($Base) {\r\n            foreach ($key in $Base.Keys) { $merged[$key] = $Base[$key] }\r\n        }\r\n        if ($Override) {\r\n            foreach ($key in $Override.Keys) { $merged[$key] = $Override[$key] }\r\n        }\r\n        return $merged\r\n    }\r\n\r\n    [hashtable] GetCellTheme([object]$Item, [string]$ColumnName, [int]$RowIndex, [bool]$IsHeader) {\r\n        # Start with default theme\r\n        $cellTheme = $this.ThemeConfig.Default.Clone()\r\n\r\n        # Apply column theme\r\n        if ($ColumnName -and $this.ThemeConfig.Columns.PSObject.Properties[$ColumnName]) {\r\n            $cellTheme = $this.MergeStyles($cellTheme, $this.ThemeConfig.Columns[$ColumnName])\r\n        }\r\n\r\n        # Apply row theme\r\n        if ($IsHeader -and $this.ThemeConfig.Rows.PSObject.Properties['Header']) {\r\n            $cellTheme = $this.MergeStyles($cellTheme, $this.ThemeConfig.Rows.Header)\r\n        }\r\n\r\n        # Apply cell-specific themes (conditional)\r\n        if (-not $IsHeader -and $this.ThemeConfig.Cells) {\r\n            foreach ($cellRule in $this.ThemeConfig.Cells) {\r\n                # Check if rule applies to this cell\r\n                if ($cellRule.PSObject.Properties['Column'] -and $cellRule.Column -ne $ColumnName) {\r\n                    continue  # Rule is column-specific and doesn't match\r\n                }\r\n\r\n                $applies = $true\r\n                if ($cellRule.PSObject.Properties['Condition'] -and $cellRule.Condition) {\r\n                    try {\r\n                        $applies = & $cellRule.Condition $Item\r\n                    } catch {\r\n                        $applies = $false\r\n                    }\r\n                }\r\n\r\n                if ($applies -and $cellRule.PSObject.Properties['Style']) {\r\n                    $cellTheme = $this.MergeStyles($cellTheme, $cellRule.Style)\r\n                }\r\n            }\r\n        }\r\n\r\n        # Consult global cell style hook if available\r\n        if (-not $IsHeader) {\r\n            $hook = Get-Command -Name 'Get-PmcCellStyle' -ErrorAction SilentlyContinue\r\n            if ($hook) {\r\n                $val = $null\r\n                if ($Item -ne $null -and $ColumnName) {\r\n                    $val = $this.GetItemValue($Item, $ColumnName)\r\n                }\r\n                $ext = Get-PmcCellStyle -RowData $Item -Column $ColumnName -Value $val\r\n                if ($ext -and ($ext -is [hashtable])) { $cellTheme = $this.MergeStyles($cellTheme, $ext) }\r\n            }\r\n        }\r\n\r\n        return $cellTheme\r\n    }\r\n\r\n    [string] ApplyTheme([string]$Text, [hashtable]$CellTheme) {\r\n        # If we have a PMC style token, use Write-PmcStyled approach\r\n        if ($CellTheme.PSObject.Properties['Style']) {\r\n            $style = Get-PmcStyle $CellTheme.Style\r\n            if ($style -and $style.PSObject.Properties['Fg']) {\r\n                # Use PMC's styling but return the ANSI codes directly for grid integration\r\n                return $this.ConvertPmcStyleToAnsi($Text, $style, $CellTheme)\r\n            }\r\n        }\r\n\r\n        # Direct color specification (RGB, Hex, Named)\r\n        $fgCode = \"\"\r\n        $bgCode = \"\"\r\n\r\n        # Handle foreground color\r\n        if ($CellTheme.PSObject.Properties['Foreground'] -or $CellTheme.PSObject.Properties['Fg']) {\r\n            $fg = $(if ($CellTheme.Foreground) { $CellTheme.Foreground } else { $CellTheme.Fg })\r\n            $fgCode = $this.GetColorCode($fg, $false)\r\n        }\r\n\r\n        # Handle background color\r\n        if ($CellTheme.PSObject.Properties['Background'] -or $CellTheme.PSObject.Properties['Bg']) {\r\n            $bg = $(if ($CellTheme.Background) { $CellTheme.Background } else { $CellTheme.Bg })\r\n            $bgCode = $this.GetColorCode($bg, $true)\r\n        }\r\n\r\n        if ($fgCode -or $bgCode) {\r\n            $pre = \"$fgCode$bgCode\"\r\n            if ($CellTheme.PSObject.Properties['Bold'] -and $CellTheme.Bold) { $pre += [PmcVT]::Bold() }\r\n            return \"$pre$Text\" + [PmcVT]::Reset()\r\n        }\r\n\r\n        return $Text\r\n    }\r\n\r\n    [string] ConvertPmcStyleToAnsi([string]$Text, [hashtable]$PmcStyle, [hashtable]$CellTheme) {\r\n        $codes = \"\"\r\n\r\n        # Convert PMC style to ANSI codes (robust hashtable access)\r\n        $fgVal = $null; $bgVal = $null; $bold = $false\r\n        if ($PmcStyle) {\r\n            if (($PmcStyle -is [hashtable]) -and $PmcStyle.ContainsKey('Fg')) { $fgVal = $PmcStyle['Fg'] }\r\n            elseif ($PmcStyle.PSObject -and $PmcStyle.PSObject.Properties['Fg']) { $fgVal = $PmcStyle.Fg }\r\n            if (($PmcStyle -is [hashtable]) -and $PmcStyle.ContainsKey('Bg')) { $bgVal = $PmcStyle['Bg'] }\r\n            elseif ($PmcStyle.PSObject -and $PmcStyle.PSObject.Properties['Bg']) { $bgVal = $PmcStyle.Bg }\r\n            if (($PmcStyle -is [hashtable]) -and $PmcStyle.ContainsKey('Bold')) { if ($PmcStyle['Bold']) { $bold = $true } }\r\n            elseif ($PmcStyle.PSObject -and $PmcStyle.PSObject.Properties['Bold']) { if ($PmcStyle.Bold) { $bold = $true } }\r\n        }\r\n        if ($fgVal) { $codes += $this.GetColorCode([string]$fgVal, $false) }\r\n        if ($bgVal) { $codes += $this.GetColorCode([string]$bgVal, $true) }\r\n\r\n        # Apply any additional cell-specific overrides\r\n        if ($CellTheme) {\r\n            $cellFg = $null; $cellBg = $null; $cellBold = $false\r\n            if (($CellTheme -is [hashtable]) -and $CellTheme.ContainsKey('Fg')) { $cellFg = $CellTheme['Fg'] }\r\n            elseif ($CellTheme.PSObject -and $CellTheme.PSObject.Properties['Fg']) { $cellFg = $CellTheme.Fg }\r\n            if (($CellTheme -is [hashtable]) -and $CellTheme.ContainsKey('Bg')) { $cellBg = $CellTheme['Bg'] }\r\n            elseif ($CellTheme.PSObject -and $CellTheme.PSObject.Properties['Bg']) { $cellBg = $CellTheme.Bg }\r\n            if (($CellTheme -is [hashtable]) -and $CellTheme.ContainsKey('Bold')) { if ($CellTheme['Bold']) { $cellBold = $true } }\r\n            elseif ($CellTheme.PSObject -and $CellTheme.PSObject.Properties['Bold']) { if ($CellTheme.Bold) { $cellBold = $true } }\r\n            if ($cellFg) { $codes += $this.GetColorCode([string]$cellFg, $false) }\r\n            if ($cellBg) { $codes += $this.GetColorCode([string]$cellBg, $true) }\r\n            if ($cellBold) { $bold = $true }\r\n        }\r\n\r\n        # Bold emphasis if requested\r\n        if ($bold) { $codes += [PmcVT]::Bold() }\r\n\r\n        if ($codes) {\r\n            return \"$codes$Text\" + [PmcVT]::Reset()\r\n        }\r\n        return $Text\r\n    }\r\n\r\n    [string] GetColorCode([string]$Color, [bool]$IsBackground) {\r\n        if (-not $Color) { return \"\" }\r\n\r\n        # Handle hex colors (#RRGGBB or #RGB)\r\n        if ($Color -match '^#([0-9A-Fa-f]{6}|[0-9A-Fa-f]{3})$') {\r\n            $rgb = ConvertFrom-PmcHex $Color\r\n            if ($rgb) {\r\n                if ($IsBackground) {\r\n                    return [PmcVT]::BgRGB($rgb.R, $rgb.G, $rgb.B)\r\n                } else {\r\n                    return [PmcVT]::FgRGB($rgb.R, $rgb.G, $rgb.B)\r\n                }\r\n            }\r\n        }\r\n\r\n        # Handle RGB values (255,128,64)\r\n        if ($Color -match '^(\\d{1,3}),(\\d{1,3}),(\\d{1,3})$') {\r\n            $r = [int]$Matches[1]\r\n            $g = [int]$Matches[2]\r\n            $b = [int]$Matches[3]\r\n            if ($r -le 255 -and $g -le 255 -and $b -le 255) {\r\n                if ($IsBackground) {\r\n                    return [PmcVT]::BgRGB($r, $g, $b)\r\n                } else {\r\n                    return [PmcVT]::FgRGB($r, $g, $b)\r\n                }\r\n            }\r\n        }\r\n\r\n        # Handle named colors (fallback to standard ANSI)\r\n        $ansiCode = $(if ($IsBackground) { 40 } else { 30 })\r\n        switch ($Color.ToLower()) {\r\n            \"black\" { $ansiCode += 0 }\r\n            \"red\" { $ansiCode += 1 }\r\n            \"green\" { $ansiCode += 2 }\r\n            \"yellow\" { $ansiCode += 3 }\r\n            \"blue\" { $ansiCode += 4 }\r\n            \"magenta\" { $ansiCode += 5 }\r\n            \"cyan\" { $ansiCode += 6 }\r\n            \"white\" { $ansiCode += 7 }\r\n            \"gray\" { $ansiCode = $(if ($IsBackground) { 100 } else { 90 }) }\r\n            \"brightred\" { $ansiCode = $(if ($IsBackground) { 101 } else { 91 }) }\r\n            \"brightgreen\" { $ansiCode = $(if ($IsBackground) { 102 } else { 92 }) }\r\n            \"brightyellow\" { $ansiCode = $(if ($IsBackground) { 103 } else { 93 }) }\r\n            \"brightblue\" { $ansiCode = $(if ($IsBackground) { 104 } else { 94 }) }\r\n            \"brightmagenta\" { $ansiCode = $(if ($IsBackground) { 105 } else { 95 }) }\r\n            \"brightcyan\" { $ansiCode = $(if ($IsBackground) { 106 } else { 96 }) }\r\n            \"brightwhite\" { $ansiCode = $(if ($IsBackground) { 107 } else { 97 }) }\r\n            default { return \"\" }\r\n        }\r\n\r\n        return \"`e[${ansiCode}m\"\r\n    }\r\n\r\n    [int] GetTerminalWidth() {\r\n        return [PmcTerminalService]::GetWidth()\r\n    }\r\n\r\n    [int] GetTerminalHeight() {\r\n        return [PmcTerminalService]::GetHeight()\r\n    }\r\n\r\n    [hashtable] GetTerminalBounds() {\r\n        return [PmcTerminalService]::GetDimensions()\r\n    }\r\n\r\n    [bool] ValidateScreenBounds([string]$Content, [int]$MaxWidth = 0, [int]$MaxHeight = 0) {\r\n        return [PmcTerminalService]::ValidateContent($Content, $MaxWidth, $MaxHeight)\r\n    }\r\n\r\n    [string] EnforceScreenBounds([string]$Content, [int]$MaxWidth = 0, [int]$MaxHeight = 0) {\r\n        return [PmcTerminalService]::EnforceContentBounds($Content, $MaxWidth, $MaxHeight)\r\n    }\r\n\r\n    [hashtable] LoadProjectLookup() {\r\n        # Load project data to resolve project names from IDs\r\n        $lookup = @{}\r\n        try {\r\n            $data = Get-PmcDataProvider 'Storage'\r\n            if ($data -and $data.GetData) {\r\n                $projectData = $data.GetData()\r\n                if ($projectData.projects) {\r\n                    foreach ($project in $projectData.projects) {\r\n                        if ($project.name) {\r\n                            $lookup[$project.name] = $project.name\r\n                            # Also map any aliases if they exist\r\n                            if ($project.PSObject.Properties['aliases'] -and $project.aliases) {\r\n                                foreach ($alias in $project.aliases) {\r\n                                    $lookup[$alias] = $project.name\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } catch {\r\n            Write-PmcDebug -Level 2 -Category \"DataDisplay\" -Message \"Failed to load project lookup\" -Data @{ Error = $_.Exception.Message }\r\n        }\r\n        return $lookup\r\n    }\r\n\r\n    [void] InitializeKeyBindings() {\r\n        $this.KeyBindings = @{\r\n            # Navigation\r\n            \"UpArrow\"    = { $this.MoveUp() }\r\n            \"DownArrow\"  = { $this.MoveDown() }\r\n            \"LeftArrow\"  = { $this.MoveLeft() }\r\n            \"RightArrow\" = { $this.MoveRight() }\r\n            \"PageUp\"     = { $this.PageUp() }\r\n            \"PageDown\"   = { $this.PageDown() }\r\n            \"Home\"       = { $this.MoveToStart() }\r\n            \"End\"        = { $this.MoveToDoEnd() }\r\n            \"Ctrl+LeftArrow\"  = { $this.MoveToColumnStart() }\r\n            \"Ctrl+RightArrow\" = { $this.MoveToColumnDoEnd() }\r\n\r\n            # Selection\r\n            \"Shift+UpArrow\"   = { $this.ExtendSelectionUp() }\r\n            \"Shift+DownArrow\" = { $this.ExtendSelectionDown() }\r\n            \"Ctrl+A\"          = { $this.SelectAll() }\r\n\r\n            # Editing/Navigation\r\n            \"Enter\"      = { $this.HandleEnterKey() }\r\n            \"F2\"         = { $this.StartCellEdit() }\r\n            \"Escape\"     = { if ($this.InEditMode -or $this.InlineEditMode) { $this.CancelEdit() } else { $this.ExitInteractive() } }\r\n            \"Delete\"     = { $this.DeleteSelected() }\r\n\r\n            # Actions\r\n            \"Ctrl+S\"     = { $this.SaveChanges() }\r\n            \"Ctrl+Z\"     = { $this.Undo() }\r\n            \"Ctrl+R\"     = { $this.RefreshData() }\r\n            \"F5\"         = { $this.RefreshData() }\r\n            \"Ctrl+F\"     = { $this.PromptDoFilter() }\r\n            # Quick open filter/search with '/'\r\n            \"Oem2\"       = { $this.PromptDoFilter() }  # '/' key on most layouts\r\n            # Sorting\r\n            \"F3\"         = { $this.ToggleSortCurrentColumn() }\r\n            # Saved views\r\n            \"F6\"         = { $this.PromptSaveView() }\r\n            \"F7\"         = { $this.PromptLoadView() }\r\n            \"F8\"         = { $this.ListSavedViews() }\r\n\r\n            # Mode switching\r\n            \"Tab\"        = { $this.SwitchNavigationMode($false) }\r\n            \"Shift+Tab\"  = { $this.SwitchNavigationMode($true) }\r\n\r\n            # Exit\r\n            \"Q\"          = { $this.ExitInteractive() }\r\n            \"Ctrl+C\"     = { $this.ExitInteractive() }\r\n        }\r\n    }\r\n\r\n    # Navigation methods\r\n    [void] MoveUp() {\r\n        if (@($this.CurrentData).Count -eq 0) { return }\r\n        if ($this.SelectedRow -gt 0) {\r\n            $oldRow = $this.SelectedRow\r\n            $this.SelectedRow--\r\n            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'MoveUp navigation' -Data @{ From = $oldRow; To = $this.SelectedRow; DataCount = @($this.CurrentData).Count }\r\n            $this.EnsureInView()\r\n            $this.RefreshDisplay()\r\n        }\r\n    }\r\n\r\n    [void] MoveDown() {\r\n        if (@($this.CurrentData).Count -eq 0) { return }\r\n        if ($this.SelectedRow -lt (@($this.CurrentData).Count - 1)) {\r\n            $oldRow = $this.SelectedRow\r\n            $this.SelectedRow++\r\n            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'MoveDown navigation' -Data @{ From = $oldRow; To = $this.SelectedRow; DataCount = @($this.CurrentData).Count }\r\n            $this.EnsureInView()\r\n            $this.RefreshDisplay()\r\n        }\r\n    }\r\n\r\n    [void] MoveLeft() {\r\n        if ($this.NavigationMode -eq \"Cell\") {\r\n            $columns = @($this.ColumnConfig.Keys)\r\n            if ($this.SelectedColumn -gt 0) {\r\n                $this.SelectedColumn--\r\n                $this.RefreshDisplay()\r\n            }\r\n        }\r\n    }\r\n\r\n    [void] MoveRight() {\r\n        if ($this.NavigationMode -eq \"Cell\") {\r\n            $columns = @($this.ColumnConfig.Keys)\r\n            if ($this.SelectedColumn -lt ($columns.Count - 1)) {\r\n                $this.SelectedColumn++\r\n                $this.RefreshDisplay()\r\n            }\r\n        }\r\n    }\r\n\r\n    [void] PageUp() {\r\n        if (@($this.CurrentData).Count -eq 0) { return }\r\n        try {\r\n            $winHeight = [PmcTerminalService]::GetHeight()\r\n            $pageSize = [Math]::Max(1, $winHeight - ($this.HeaderLines + 2))\r\n        } catch {\r\n            $pageSize = 10  # Fallback page size\r\n        }\r\n        $this.SelectedRow = [Math]::Max(0, $this.SelectedRow - $pageSize)\r\n        $this.EnsureInView()\r\n        $this.RefreshDisplay()\r\n    }\r\n\r\n    [void] PageDown() {\r\n        if (@($this.CurrentData).Count -eq 0) { return }\r\n        try {\r\n            $winHeight = [PmcTerminalService]::GetHeight()\r\n            $pageSize = [Math]::Max(1, $winHeight - ($this.HeaderLines + 2))\r\n        } catch {\r\n            $pageSize = 10  # Fallback page size\r\n        }\r\n        $this.SelectedRow = [Math]::Min(@($this.CurrentData).Count - 1, $this.SelectedRow + $pageSize)\r\n        $this.EnsureInView()\r\n        $this.RefreshDisplay()\r\n    }\r\n\r\n    [void] MoveToStart() {\r\n        $this.SelectedRow = 0\r\n        $this.ScrollOffset = 0\r\n        $this.RefreshDisplay()\r\n    }\r\n\r\n    [void] MoveToDoEnd() {\r\n        if (@($this.CurrentData).Count -gt 0) {\r\n            $this.SelectedRow = @($this.CurrentData).Count - 1\r\n            $this.EnsureInView()\r\n            $this.RefreshDisplay()\r\n        }\r\n    }\r\n\r\n    # Selection methods\r\n    [void] ExtendSelectionUp() {\r\n        $this.MultiSelectMode = $true\r\n        if (@($this.SelectedRows).Count -eq 0) {\r\n            $this.SelectedRows = @($this.SelectedRow)\r\n        }\r\n        if ($this.SelectedRow -gt 0) {\r\n            $this.SelectedRow--\r\n            if ($this.SelectedRows -notcontains $this.SelectedRow) {\r\n                $this.SelectedRows += $this.SelectedRow\r\n            }\r\n            $this.RefreshDisplay()\r\n        }\r\n    }\r\n\r\n    [void] ExtendSelectionDown() {\r\n        $this.MultiSelectMode = $true\r\n        if (@($this.SelectedRows).Count -eq 0) {\r\n            $this.SelectedRows = @($this.SelectedRow)\r\n        }\r\n        if ($this.SelectedRow -lt (@($this.CurrentData).Count - 1)) {\r\n            $this.SelectedRow++\r\n            if ($this.SelectedRows -notcontains $this.SelectedRow) {\r\n                $this.SelectedRows += $this.SelectedRow\r\n            }\r\n            $this.RefreshDisplay()\r\n        }\r\n    }\r\n\r\n    [void] SelectAll() {\r\n        $this.MultiSelectMode = $true\r\n        $this.SelectedRows = @(0..(@($this.CurrentData).Count - 1))\r\n        $this.RefreshDisplay()\r\n    }\r\n\r\n    # Editing methods\r\n    # NEW: Handle Enter key based on mode\r\n    [void] HandleEnterKey() {\r\n        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'HandleEnterKey' -Data @{ EditMode=$this.EditMode; HasCallback=($this.OnSelectCallback -ne $null) }\r\n\r\n        if ($this.EditMode) {\r\n            # Edit mode: Start cell editing (original behavior)\r\n            $this.StartCellEdit()\r\n        } else {\r\n            # Navigation mode: Execute selection callback or exit\r\n            if ($this.OnSelectCallback -ne $null) {\r\n                Write-PmcDebug -Level 2 -Category 'DataDisplay' -Message 'Executing OnSelectCallback'\r\n                try {\r\n                    $selectedItem = $(if (@($this.CurrentData).Count -gt 0 -and $this.SelectedRow -lt @($this.CurrentData).Count) {\r\n                        $this.CurrentData[$this.SelectedRow]\r\n                    } else {\r\n                        $null\r\n                    })\r\n                    & $this.OnSelectCallback $selectedItem $this.SelectedRow\r\n                } catch {\r\n                    Write-PmcDebug -Level 1 -Category 'DataDisplay' -Message 'OnSelectCallback error' -Data @{ Error = $_.Exception.Message }\r\n                }\r\n            } else {\r\n                # No callback, exit interactive mode\r\n                Write-PmcDebug -Level 2 -Category 'DataDisplay' -Message 'No callback, exiting interactive mode'\r\n                $this.Interactive = $false\r\n            }\r\n        }\r\n    }\r\n\r\n    [void] StartCellEdit() {\r\n        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'StartCellEdit' -Data @{ Nav=$this.NavigationMode; Row=$this.SelectedRow; Count=@($this.CurrentData).Count }\r\n\r\n        if (@($this.CurrentData).Count -eq 0 -or $this.SelectedRow -ge @($this.CurrentData).Count) {\r\n            Write-PmcDebug -Level 2 -Category 'DataDisplay' -Message 'StartCellEdit: No data or invalid row'\r\n            return\r\n        }\r\n\r\n        $columns = @($this.ColumnConfig.Keys)\r\n        $editableColumns = $this.GetEditableColumns()\r\n        $columnName = $null\r\n\r\n        # Determine which column to edit based on navigation mode\r\n        if ($this.NavigationMode -eq \"Row\") {\r\n            # Start with the first editable column (defaults generally to 'text')\r\n            if (@($editableColumns).Count -gt 0) { $columnName = $editableColumns[0] }\r\n            elseif (@($columns).Count -gt 0) { $columnName = $columns[0] }\r\n        }\r\n        elseif ($this.NavigationMode -eq \"Cell\" -and $this.SelectedColumn -lt @($columns).Count) {\r\n            $tryCol = $columns[$this.SelectedColumn]\r\n            if ($this.IsColumnEditable($tryCol)) { $columnName = $tryCol }\r\n            else {\r\n                # Find the next editable column from the current position (wrapping)\r\n                for ($i = 1; $i -le @($columns).Count; $i++) {\r\n                    $idx = ($this.SelectedColumn + $i) % @($columns).Count\r\n                    $c = $columns[$idx]\r\n                    if ($this.IsColumnEditable($c)) { $columnName = $c; break }\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($columnName) {\r\n            $currentItem = $this.CurrentData[$this.SelectedRow]\r\n            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'Editing item' -Data $currentItem\r\n            if ($this.PendingEdits.ContainsKey($columnName)) { $currentValue = [string]$this.PendingEdits[$columnName] }\r\n            else { $currentValue = $this.GetItemValue($currentItem, $columnName) }\r\n\r\n            $this.InEditMode = $true\r\n            $this.EditingColumn = $columnName\r\n            $this.EditingValue = $currentValue\r\n            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Starting edit for column '{0}'\" -f $columnName) -Data @{ Value=$currentValue }\r\n            $this.ShowEditDialog($columnName, $currentValue)\r\n        }\r\n        else {\r\n            Write-PmcDebug -Level 2 -Category 'DataDisplay' -Message 'StartCellEdit: Invalid mode or column'\r\n        }\r\n    }\r\n\r\n    [void] ShowEditDialog([string]$ColumnName, [string]$CurrentValue) {\r\n        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"ShowEditDialog: start '{0}'\" -f $ColumnName)\r\n\r\n        # Start inline editing mode\r\n        $this.EditingValue = $CurrentValue\r\n        $this.EditCursorPos = $CurrentValue.Length\r\n        $this.InlineEditMode = $true\r\n        $this.LastErrorMessage = ''\r\n\r\n        while ($true) {\r\n            # Redraw with edit indicator and get new value through key input\r\n            $this.RefreshDisplay()\r\n            $newVal = $this.HandleInlineEdit()\r\n\r\n            if ($null -eq $newVal) {\r\n                # Escape or navigation-only path: discard staged and exit dialog\r\n                $this.CancelEdit()\r\n                return\r\n            }\r\n\r\n            # Normalize then stage current column value\r\n            try {\r\n                $normalized = $this.NormalizeField($ColumnName, [string]$newVal)\r\n            } catch {\r\n                $this.LastErrorMessage = $_.Exception.Message\r\n                # Re-enter editing on same column with user input intact\r\n                $this.EditingValue = [string]$newVal\r\n                $this.EditCursorPos = $this.EditingValue.Length\r\n                $this.InlineEditMode = $true\r\n                continue\r\n            }\r\n            $this.PendingEdits[$ColumnName] = [string]$normalized\r\n\r\n            # Validate all staged edits\r\n            $validationError = $null\r\n            foreach ($col in @($this.PendingEdits.Keys)) {\r\n                $val = [string]$this.PendingEdits[$col]\r\n                if ($this.EditCallbacks.ContainsKey($col)) {\r\n                    $ok = & $this.EditCallbacks[$col] $val\r\n                    if (-not $ok) { $validationError = \"Invalid value for $col\"; break }\r\n                } else {\r\n                    try {\r\n                        $this.ValidateField($col, $val)\r\n                    } catch {\r\n                        $validationError = $_.Exception.Message\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n\r\n            if ($validationError) {\r\n                $this.LastErrorMessage = $validationError\r\n                # Re-enter editing on current column\r\n                $this.EditingValue = [string]$normalized\r\n                $this.EditCursorPos = $this.EditingValue.Length\r\n                $this.InlineEditMode = $true\r\n                continue\r\n            }\r\n\r\n            # Apply batch and exit\r\n            try {\r\n                $this.ApplyPendingEdits()\r\n                $this.LastErrorMessage = ''\r\n                $this.CancelEdit()\r\n                return\r\n            } catch {\r\n                $this.LastErrorMessage = \"Failed to save: $($_.Exception.Message)\"\r\n                # Keep editing to allow correction\r\n                $this.InlineEditMode = $true\r\n            }\r\n        }\r\n    }\r\n\r\n    # Per-field normalization moved to FieldSchemas\r\n\r\n    [void] CancelEdit() {\r\n        $this.InEditMode = $false\r\n        $this.InlineEditMode = $false\r\n        $this.EditingColumn = \"\"\r\n        $this.EditingValue = \"\"\r\n        # Clear pending edits without saving\r\n        $this.PendingEdits.Clear()\r\n        $this.RefreshDisplay()\r\n    }\r\n\r\n    [void] ApplyPendingEdits() {\r\n        Write-PmcDebug -Level 2 -Category 'DataDisplay' -Message 'ApplyPendingEdits' -Data @{ Columns = @($this.PendingEdits.Keys) }\r\n        foreach ($column in $this.PendingEdits.Keys) {\r\n            $value = $this.PendingEdits[$column]\r\n            try {\r\n                # Inline editing: skip value conflict checks (opt-in strict policy can be implemented per-view later)\r\n                $this.ApplyCellEdit($this.SelectedRow, $column, $value, $null)\r\n                Write-PmcDebug -Level 2 -Category 'DataDisplay' -Message (\"Applied edit for '{0}'\" -f $column) -Data @{ Value=$value }\r\n            } catch {\r\n                Write-PmcDebug -Level 1 -Category 'DataDisplay' -Message (\"Failed to apply edit for '{0}'\" -f $column) -Data @{ Error = $_.ToString() }\r\n            }\r\n        }\r\n        $this.PendingEdits.Clear()\r\n    }\r\n\r\n    [void] EnableInlineEditing([string]$Column, [scriptblock]$Validator) {\r\n        if (-not $Column) { throw \"EnableInlineEditing: Column is required\" }\r\n        $this.EditCallbacks[$Column] = $Validator\r\n    }\r\n\r\n    [void] ApplyCellEdit([int]$RowIndex, [string]$ColumnName, [string]$NewValue, [string]$OriginalValue) {\r\n        if ($RowIndex -lt 0 -or $RowIndex -ge @($this.CurrentData).Count) { throw \"Invalid row index\" }\r\n        $item = $this.CurrentData[$RowIndex]\r\n        if (-not $item) { throw \"No item at row $RowIndex\" }\r\n\r\n        # Wizard/form editing: in-memory only, no persistence\r\n        $primaryDomain = $this.GetPrimaryDomain()\r\n        if ($primaryDomain -eq 'wizard') {\r\n            if ($item.PSObject.Properties[$ColumnName]) { $item.$ColumnName = [string]$NewValue }\r\n            else { $item | Add-Member -NotePropertyName $ColumnName -NotePropertyValue ([string]$NewValue) -Force }\r\n            return\r\n        }\r\n\r\n        # Update in persistent store by ID when available\r\n        $id = $null\r\n        if ($item.PSObject.Properties['id']) { $id = [int]$item.id }\r\n        if ($null -eq $id) { throw \"Cannot edit item without id\" }\r\n\r\n        $root = Get-PmcDataAlias\r\n        if (-not $root -or -not $root.tasks) { throw \"Data store not available\" }\r\n\r\n        $target = $root.tasks | Where-Object { $_ -ne $null -and $_.id -eq $id } | Select-Object -First 1\r\n        if (-not $target) { throw \"Item #$id not found\" }\r\n\r\n        # Optional optimistic concurrency check\r\n        if ($OriginalValue -ne $null) {\r\n            $currentOnDisk = ''\r\n            if ($target.PSObject.Properties[$ColumnName]) { $currentOnDisk = [string]$target.$ColumnName }\r\n            if ($currentOnDisk -ne $OriginalValue) {\r\n                throw (\"Conflict: {0} changed externally (was '{1}', now '{2}')\" -f $ColumnName, $OriginalValue, $currentOnDisk)\r\n            }\r\n        }\r\n\r\n        switch ($ColumnName) {\r\n            'text'     { $target.text = [string]$NewValue }\r\n            'project'  {\r\n                $dataAll = Get-PmcDataAlias\r\n                $resolved = Resolve-Project -Data $dataAll -Name ([string]$NewValue)\r\n                if (-not $resolved) { throw (\"Unknown project '{0}'\" -f $NewValue) }\r\n                $target.project = [string]$resolved.name\r\n            }\r\n            'priority' { $target.priority = [int]$NewValue }\r\n            'due'      { $target.due = [string]$NewValue }\r\n            default    { $target | Add-Member -NotePropertyName $ColumnName -NotePropertyValue $NewValue -Force }\r\n        }\r\n\r\n        Save-PmcData -data $root -Action \"edit:$ColumnName\"\r\n\r\n        # Reflect changes in current view item as well\r\n        if ($item.PSObject.Properties[$ColumnName]) { $item.$ColumnName = $NewValue }\r\n        else { $item | Add-Member -NotePropertyName $ColumnName -NotePropertyValue $NewValue -Force }\r\n    }\r\n\r\n    [void] SaveChanges() {\r\n        if ($this.SaveCallback) {\r\n            & $this.SaveCallback @{}\r\n            return\r\n        }\r\n        throw \"No pending changes or SaveCallback configured\"\r\n    }\r\n\r\n    [void] DeleteSelected() {\r\n        # Only support deleting tasks for now\r\n        if (-not ($this.Domains -contains 'task')) { throw \"Delete not supported for this view\" }\r\n        if (@($this.CurrentData).Count -eq 0) { return }\r\n        $rows = @()\r\n        if ($this.MultiSelectMode -and @($this.SelectedRows).Count -gt 0) { $rows = @($this.SelectedRows) } else { $rows = @($this.SelectedRow) }\r\n        $ids = @()\r\n        foreach ($ri in $rows) {\r\n            if ($ri -ge 0 -and $ri -lt @($this.CurrentData).Count) {\r\n                $it = $this.CurrentData[$ri]\r\n                if ($it -and $it.PSObject.Properties['id']) { $ids += [int]$it.id }\r\n            }\r\n        }\r\n        if (@($ids).Count -eq 0) { return }\r\n\r\n        $root = Get-PmcDataAlias\r\n        if (-not $root -or -not $root.tasks) { throw \"Data store not available\" }\r\n        $root.tasks = @($root.tasks | Where-Object { $_ -eq $null -or ($_.PSObject.Properties['id'] -and (-not ($ids -contains [int]$_.id))) })\r\n        Save-PmcData -data $root -Action 'delete:task'\r\n        $this.RefreshData()\r\n    }\r\n\r\n    [void] Undo() {\r\n        if (Get-Command Invoke-PmcUndo -ErrorAction SilentlyContinue) {\r\n            Invoke-PmcUndo | Out-Null\r\n            $this.RefreshData()\r\n            return\r\n        }\r\n        throw \"Undo not available\"\r\n    }\r\n\r\n    [void] PromptDoFilter() {\r\n        $row = [PmcTerminalService]::GetHeight() - 2\r\n        Write-Host ([PmcVT]::MoveTo(0, $row) + [PmcVT]::ClearLine())\r\n        Write-Host -NoNewline \"DoFilter (text or re:/pattern/): \"\r\n        $q = Read-Host\r\n        if ($null -ne $q) { $this.FilterQuery = [string]$q; $this.ApplyDoFilter(); $this.RefreshDisplay() }\r\n    }\r\n\r\n    [void] RefreshData() {\r\n        # Reload data from PMC and refresh display\r\n        if ($this.Interactive) {\r\n            $newData = Get-PmcFilteredData -Domains $this.Domains -Filters $this.Filters\r\n            $this.AllData = $newData\r\n            $this.ApplyDoFilter()\r\n            $this.RefreshDisplay()\r\n        }\r\n    }\r\n\r\n    [void] SwitchNavigationMode([bool]$Reverse = $false) {\r\n        if ($Reverse) {\r\n            $this.NavigationMode = $(if ($this.NavigationMode -eq \"Row\") { \"Cell\" } else { \"Row\" })\r\n        } else {\r\n            $this.NavigationMode = $(if ($this.NavigationMode -eq \"Cell\") { \"Row\" } else { \"Cell\" })\r\n        }\r\n        $this.RefreshDisplay()\r\n    }\r\n\r\n    [string] HandleInlineEdit() {\r\n        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'HandleInlineEdit: start'\r\n\r\n        $editBuffer = $this.EditingValue\r\n        $cursorPos = $this.EditCursorPos\r\n\r\n        while ($this.InlineEditMode) {\r\n            try {\r\n                if ([Console]::KeyAvailable) {\r\n                $key = [Console]::ReadKey($true)\r\n                $keyName = $key.Key.ToString()\r\n\r\n                Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'Inline edit key' -Data @{ Key=$keyName; Char=[int]$key.KeyChar }\r\n\r\n                switch ($key.Key) {\r\n                    \"Enter\" {\r\n                        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'Enter: save current field and exit edit mode' -Data @{ Value=$editBuffer }\r\n\r\n                        # Store current field edit in pending edits\r\n                        $this.PendingEdits[$this.EditingColumn] = $editBuffer\r\n                        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Staged final edit for '{0}' on Enter\" -f $this.EditingColumn) -Data @{ Value=$editBuffer }\r\n\r\n                        # Exit edit mode and signal to save all pending edits\r\n                        $this.InlineEditMode = $false\r\n                        return $editBuffer\r\n                    }\r\n                    \"Escape\" {\r\n                        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'Inline edit cancelled'\r\n                        $this.InlineEditMode = $false\r\n                        return $null\r\n                    }\r\n                    \"Tab\" {\r\n                        # Check for Shift modifier\r\n                        if ($key.Modifiers -band [ConsoleModifiers]::Shift) {\r\n                            # Shift+Tab moves to previous column\r\n                            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'Shift+Tab: previous column'\r\n\r\n                            # Store current edit in memory instead of saving immediately\r\n                            $this.PendingEdits[$this.EditingColumn] = $editBuffer\r\n                            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Staged edit for '{0}'\" -f $this.EditingColumn) -Data @{ Value=$editBuffer }\r\n\r\n                            # Move to previous column\r\n                            $this.MoveToPreviousColumnAndEdit()\r\n                            return $null\r\n                        } else {\r\n                            # Tab moves to next column and continues editing\r\n                            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'Tab: next column'\r\n\r\n                            # Store current edit in memory instead of saving immediately\r\n                            $this.PendingEdits[$this.EditingColumn] = $editBuffer\r\n                            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Staged edit for '{0}'\" -f $this.EditingColumn) -Data @{ Value=$editBuffer }\r\n\r\n                            # Move to next column\r\n                            $this.MoveToNextColumnAndEdit()\r\n                            return $null  # Don't return the value, we're continuing to edit\r\n                        }\r\n                    }\r\n                    \"LeftArrow\" {\r\n                        if ($cursorPos -gt 0) {\r\n                            $cursorPos--\r\n                            $this.EditCursorPos = $cursorPos\r\n                            $this.RefreshDisplay()\r\n                        }\r\n                    }\r\n                    \"RightArrow\" {\r\n                        if ($cursorPos -lt $editBuffer.Length) {\r\n                            $cursorPos++\r\n                            $this.EditCursorPos = $cursorPos\r\n                            $this.RefreshDisplay()\r\n                        }\r\n                    }\r\n                    \"Home\" {\r\n                        $cursorPos = 0\r\n                        $this.EditCursorPos = $cursorPos\r\n                        $this.RefreshDisplay()\r\n                    }\r\n                    \"End\" {\r\n                        $cursorPos = $editBuffer.Length\r\n                        $this.EditCursorPos = $cursorPos\r\n                        $this.RefreshDisplay()\r\n                    }\r\n                    \"Backspace\" {\r\n                        if ($cursorPos -gt 0) {\r\n                            $editBuffer = $editBuffer.Remove($cursorPos - 1, 1)\r\n                            $cursorPos--\r\n                            $this.EditingValue = $editBuffer\r\n                            $this.EditCursorPos = $cursorPos\r\n                            $this.RefreshDisplay()\r\n                        }\r\n                    }\r\n                    \"Delete\" {\r\n                        if ($cursorPos -lt $editBuffer.Length) {\r\n                            $editBuffer = $editBuffer.Remove($cursorPos, 1)\r\n                            $this.EditingValue = $editBuffer\r\n                            $this.RefreshDisplay()\r\n                        }\r\n                    }\r\n                    default {\r\n                        # Add printable characters at cursor position\r\n                        if ($key.KeyChar -and [int]$key.KeyChar -ge 32 -and [int]$key.KeyChar -le 126) {\r\n                            $editBuffer = $editBuffer.Insert($cursorPos, $key.KeyChar)\r\n                            $cursorPos++\r\n                            $this.EditingValue = $editBuffer\r\n                            $this.EditCursorPos = $cursorPos\r\n                            $this.RefreshDisplay()\r\n                        }\r\n                    }\r\n                }\r\n                } else {\r\n                    Start-Sleep -Milliseconds 50\r\n                }\r\n            } catch {\r\n                # Fallback for non-interactive environments\r\n                Start-Sleep -Milliseconds 50\r\n            }\r\n        }\r\n        return $null\r\n    }\r\n\r\n    [void] MoveToNextColumnAndEdit() {\r\n        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'MoveToNextColumnAndEdit'\r\n        $columns = $this.GetEditableColumns()\r\n        if (@($columns).Count -eq 0) { $this.CancelEdit(); return }\r\n        $currentIndex = $columns.IndexOf($this.EditingColumn)\r\n        if ($currentIndex -lt 0) { $currentIndex = 0 }\r\n        $nextIndex = ($currentIndex + 1) % @($columns).Count\r\n        $nextColumn = $columns[$nextIndex]\r\n        $currentItem = $this.CurrentData[$this.SelectedRow]\r\n        if ($this.PendingEdits.ContainsKey($nextColumn)) {\r\n            $nextValue = $this.PendingEdits[$nextColumn]\r\n                Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Using staged value for '{0}'\" -f $nextColumn) -Data @{ Value=$nextValue }\r\n        } else {\r\n            $nextValue = $this.GetItemValue($currentItem, $nextColumn)\r\n                Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Using original value for '{0}'\" -f $nextColumn) -Data @{ Value=$nextValue }\r\n        }\r\n\r\n            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Move edit focus: '{0}' -> '{1}'\" -f $this.EditingColumn, $nextColumn)\r\n\r\n        $this.EditingColumn = $nextColumn\r\n        $this.EditingValue = $nextValue\r\n        $this.EditCursorPos = $nextValue.Length\r\n        $this.InlineEditMode = $true\r\n        $this.RefreshDisplay()\r\n\r\n        # Continue editing the new column\r\n            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'Continue edit on new column'\r\n        $newVal = $this.HandleInlineEdit()\r\n        if ($newVal -ne $null) {\r\n            # Store the edit in memory instead of applying immediately\r\n            $this.PendingEdits[$nextColumn] = $newVal\r\n                Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Staged final value for '{0}'\" -f $nextColumn) -Data @{ Value=$newVal }\r\n        }\r\n    }\r\n\r\n    [void] MoveToPreviousColumnAndEdit() {\r\n        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'MoveToPreviousColumnAndEdit'\r\n        $columns = $this.GetEditableColumns()\r\n        if (@($columns).Count -eq 0) { $this.CancelEdit(); return }\r\n        $currentIndex = $columns.IndexOf($this.EditingColumn)\r\n        if ($currentIndex -lt 0) { $currentIndex = 0 }\r\n        $prevIndex = ($currentIndex - 1)\r\n        if ($prevIndex -lt 0) { $prevIndex = @($columns).Count - 1 }\r\n        $prevColumn = $columns[$prevIndex]\r\n        $currentItem = $this.CurrentData[$this.SelectedRow]\r\n        if ($this.PendingEdits.ContainsKey($prevColumn)) {\r\n            $prevValue = $this.PendingEdits[$prevColumn]\r\n                Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Using staged value for '{0}'\" -f $prevColumn) -Data @{ Value=$prevValue }\r\n        } else {\r\n            $prevValue = $this.GetItemValue($currentItem, $prevColumn)\r\n                Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Using original value for '{0}'\" -f $prevColumn) -Data @{ Value=$prevValue }\r\n        }\r\n\r\n            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Move edit focus: '{0}' -> '{1}'\" -f $this.EditingColumn, $prevColumn)\r\n\r\n        $this.EditingColumn = $prevColumn\r\n        $this.EditingValue = $prevValue\r\n        $this.EditCursorPos = $prevValue.Length\r\n        $this.InlineEditMode = $true\r\n        $this.RefreshDisplay()\r\n\r\n        # Continue editing the new column\r\n            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'Continue edit on previous column'\r\n        $newVal = $this.HandleInlineEdit()\r\n        if ($newVal -ne $null) {\r\n            # Store the edit in memory instead of applying immediately\r\n            $this.PendingEdits[$prevColumn] = $newVal\r\n                Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Staged final value for '{0}'\" -f $prevColumn) -Data @{ Value=$newVal }\r\n        }\r\n    }\r\n\r\n    [string[]] GetEditableColumns() {\r\n        $cols = @()\r\n        foreach ($c in $this.ColumnConfig.Keys) {\r\n            if ($this.IsColumnEditable($c)) { $cols += $c }\r\n        }\r\n        return $cols\r\n    }\r\n\r\n    [bool] IsColumnEditable([string]$ColumnName) {\r\n        if (-not $this.ColumnConfig.Keys -contains $ColumnName) { return $false }\r\n        $cfg = $this.ColumnConfig[$ColumnName]\r\n        $sch = $this.GetFieldSchema($ColumnName)\r\n        $editable = $true\r\n        if ($cfg.PSObject.Properties['Editable']) { $editable = [bool]$cfg.Editable }\r\n        elseif ($sch -and $sch.ContainsKey('Editable')) { $editable = [bool]$sch.Editable }\r\n        else { $editable = $true }\r\n\r\n        $sensitive = $false\r\n        if ($cfg.PSObject.Properties['Sensitive']) { $sensitive = [bool]$cfg.Sensitive }\r\n        elseif ($sch -and $sch.ContainsKey('Sensitive')) { $sensitive = [bool]$sch.Sensitive }\r\n        if ($sensitive -and (-not $this.AllowSensitiveEdits)) { return $false }\r\n        return $editable\r\n    }\r\n\r\n    [void] ExitInteractive() {\r\n        $this.Interactive = $false\r\n        Write-Host ([PmcVT]::Show())  # Show cursor\r\n    }\r\n\r\n    # Display refresh method (Praxis frame-based rendering only)\r\n    [void] RefreshDisplay() {\r\n        if (-not $this.Interactive) { return }\r\n\r\n        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'RefreshDisplay (Praxis frame)' -Data @{ Row=$this.SelectedRow }\r\n\r\n        # Build complete frame content using Praxis approach (single owner painter)\r\n        $title = $(if ([string]::IsNullOrWhiteSpace($this.TitleText)) { 'PMC Interactive Data Grid' } else { $this.TitleText })\r\n        $frameContent = [PraxisGridFrameBuilder]::BuildGridFrame(\r\n            $this.CurrentData,\r\n            $this.ColumnConfig,\r\n            $title,\r\n            $this.SelectedRow,\r\n            $this.ThemeConfig,\r\n            $this\r\n        )\r\n\r\n        # Single atomic write with internal double-buffering\r\n        $this.FrameRenderer.RenderFrame($frameContent)\r\n    }\r\n\r\n    [string[]] RenderGridWithinBounds([object[]]$Data, [object]$ContentBounds) {\r\n        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'RenderGridWithinBounds' -Data @{\r\n            DataCount = @($Data).Count\r\n            BoundsWidth = $ContentBounds.Width\r\n            BoundsHeight = $ContentBounds.Height\r\n        }\r\n\r\n        # Use content bounds for width/height when computing column layout\r\n        $oldWidth = $this.TerminalWidth\r\n        $oldHeight = $this.WindowHeight\r\n        try {\r\n            $this.TerminalWidth = [int]$ContentBounds.Width\r\n            $this.WindowHeight = [int]$ContentBounds.Height\r\n        } catch {}\r\n\r\n        # Build lines with adjusted bounds\r\n        $this.CurrentData = $Data\r\n        $allLines = $this.BuildInteractiveLines()\r\n\r\n        # Restore previous metrics\r\n        $this.TerminalWidth = $oldWidth\r\n        $this.WindowHeight = $oldHeight\r\n\r\n        # Truncate to fit within content bounds\r\n        $maxLines = $ContentBounds.Height - 1  # Reserve space for status\r\n        $gridLines = @()\r\n\r\n        for ($i = 0; $i -lt [Math]::Min($allLines.Count, $maxLines); $i++) {\r\n            $line = $allLines[$i]\r\n            # Truncate line to fit width\r\n            if ($line.Length -gt $ContentBounds.Width) {\r\n                $line = $line.Substring(0, $ContentBounds.Width - 3) + \"...\"\r\n            }\r\n            $gridLines += $line\r\n        }\r\n\r\n        return $gridLines\r\n    }\r\n\r\n    [void] ShowStatusLine() {\r\n        $statusRow = [PmcTerminalService]::GetHeight() - 1\r\n        $mode = $(if ($this.NavigationMode -eq \"Cell\") { \"CELL\" } else { \"ROW\" })\r\n        $shownStart = [Math]::Min(@($this.CurrentData).Count, $this.ScrollOffset + 1)\r\n        $visible = [Math]::Max(1, [PmcTerminalService]::GetHeight() - ($this.HeaderLines + 1))\r\n        $shownEnd = [Math]::Min(@($this.CurrentData).Count, $this.ScrollOffset + $visible)\r\n        $position = \"[$($this.SelectedRow + 1)/$(@($this.CurrentData).Count) | $shownStart-$shownEnd]\"\r\n        $selection = $(if ($this.MultiSelectMode -and @($this.SelectedRows).Count -gt 1) { \" [$(@($this.SelectedRows).Count) selected]\" } else { \"\" })\r\n        $filter = $(if ($this.FilterQuery) { \" | Filter: '$($this.FilterQuery)'\" } else { '' })\r\n        $sort = $(if ($this.SortDirection -ne 'None' -and $this.SortColumn) { \" | Sort: $($this.SortColumn) $($this.SortDirection.ToLower())\" } else { '' })\r\n        $status = \"$mode $position$selection$filter$sort | Arrow keys: Navigate | Enter: Edit | Tab: Switch mode | F3: Sort | F6/F7: Save/Load view | Q: Exit\"\r\n\r\n        Write-Host ([PmcVT]::MoveTo(0, $statusRow) + [PmcVT]::ClearLine())\r\n        Write-PmcStyled -Style 'Muted' -Text $status -NoNewline\r\n    }\r\n\r\n    [hashtable] GetColumnWidths([object[]]$Data) {\r\n        $widths = @{}\r\n        $totalFixed = 0\r\n        $flexColumns = @()\r\n\r\n        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'GetColumnWidths' -Data @{ Width=$this.TerminalWidth; Count=$this.ColumnConfig.Keys.Count }\r\n\r\n        # Smart default widths for common columns\r\n        $smartDefaults = @{\r\n            \"due\" = 10          # yyyy-MM-dd = 10 chars\r\n            \"priority\" = 3      # P1/P2/P3 = 3 chars\r\n            \"P\" = 3\r\n            \"#\" = 4             # Task numbers\r\n            \"id\" = 4\r\n        }\r\n\r\n        # Calculate fixed widths and identify flex columns (respect schema MinWidth)\r\n        foreach ($col in $this.ColumnConfig.Keys) {\r\n            $minW = 0\r\n            $sch = $this.GetFieldSchema($col)\r\n            if ($sch -and $sch.ContainsKey('MinWidth')) { try { $minW = [int]$sch.MinWidth } catch { $minW = 0 } }\r\n            if ($smartDefaults.ContainsKey($col)) {\r\n                # Smart defaults ALWAYS take priority for known column types\r\n                $widths[$col] = [Math]::Max($minW, $smartDefaults[$col])\r\n                $totalFixed += $widths[$col]\r\n            } elseif ($this.ColumnConfig[$col].Width) {\r\n                # Explicit width for custom columns only\r\n                $widths[$col] = [Math]::Max($minW, [int]$this.ColumnConfig[$col].Width)\r\n                $totalFixed += $widths[$col]\r\n            } else {\r\n                # This is a flex column (will get remaining space)\r\n                $flexColumns += $col\r\n            }\r\n        }\r\n\r\n        # Calculate available space for flex columns\r\n        $padding = (@($this.ColumnConfig.Keys).Count - 1) * 2  # 2 spaces between columns\r\n        $available = $this.TerminalWidth - $totalFixed - $padding - 4  # 4 for margins\r\n\r\n        if (@($flexColumns).Count -gt 0) {\r\n            $flexBase = [Math]::Max(8, [Math]::Floor($available / @($flexColumns).Count))\r\n            foreach ($col in $flexColumns) {\r\n                $minW = 0\r\n                $sch2 = $this.GetFieldSchema($col)\r\n                if ($sch2 -and $sch2.ContainsKey('MinWidth')) { try { $minW = [int]$sch2.MinWidth } catch { $minW = 0 } }\r\n                $widths[$col] = [Math]::Max($minW, $flexBase)\r\n            }\r\n        }\r\n\r\n        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'GetColumnWidths result' -Data $widths\r\n        return $widths\r\n    }\r\n\r\n    [string] FormatRow([object]$Item, [hashtable]$Widths, [bool]$IsHeader = $false, [int]$RowIndex = 0, [bool]$IsSelected = $false) {\r\n        $parts = @()\r\n\r\n        foreach ($col in $this.ColumnConfig.Keys) {\r\n            $width = $Widths[$col]\r\n            $formatted = \"\"\r\n            $colConfig = $this.ColumnConfig[$col]\r\n\r\n            if ($IsHeader) {\r\n                $value = $(if ($colConfig.PSObject.Properties['Header']) { $colConfig.Header } else { $col })\r\n            } else {\r\n                $value = $this.GetItemValue($Item, $col)\r\n            }\r\n\r\n            # Apply truncation if needed\r\n            if ($colConfig.PSObject.Properties['Truncate'] -and $colConfig.Truncate -and $value.Length -gt $width) {\r\n                $value = $value.Substring(0, $width - 3) + \"...\"\r\n            } elseif ($value.Length -gt $width) {\r\n                $value = $value.Substring(0, $width)\r\n            }\r\n\r\n            # Apply alignment\r\n            $alignment = $(if ($colConfig.PSObject.Properties['Alignment'] -and $colConfig.Alignment) { $colConfig.Alignment } else { \"Left\" })\r\n\r\n            switch ($alignment) {\r\n                \"Right\" { $formatted = $value.PadLeft($width) }\r\n                \"Center\" {\r\n                    $padding = $width - $value.Length\r\n                    $leftPad = [Math]::Floor($padding / 2)\r\n                    $rightPad = $padding - $leftPad\r\n                    $formatted = \" \" * $leftPad + $value + \" \" * $rightPad\r\n                }\r\n                default { $formatted = $value.PadRight($width) }  # Left\r\n            }\r\n\r\n            # Apply theming to the formatted cell content\r\n            $cellTheme = $this.GetCellTheme($Item, $col, $RowIndex, $IsHeader)\r\n\r\n            # Apply selection highlighting\r\n            if ($IsSelected -and -not $IsHeader) {\r\n                $cellTheme = $this.MergeStyles($cellTheme, @{ Bg = \"#0078d4\"; Fg = \"White\" })\r\n            }\r\n\r\n            # Emphasize currently editing cell\r\n            if ($this.InEditMode -and -not $IsHeader -and $RowIndex -eq $this.SelectedRow) {\r\n                $cols = @($this.ColumnConfig.Keys)\r\n                if ($this.NavigationMode -eq 'Cell' -and $this.SelectedColumn -lt @($cols).Count) {\r\n                    if ($col -eq $cols[$this.SelectedColumn]) { $cellTheme = $this.MergeStyles($cellTheme, @{ Bold = $true }) }\r\n                }\r\n            }\r\n\r\n            $themedText = $this.ApplyTheme($formatted, $cellTheme)\r\n            $parts += $themedText\r\n        }\r\n\r\n        # Add selection indicator for row mode\r\n        $indicator = $(if ($IsSelected -and -not $IsHeader) { \"►\" } else { \" \" })\r\n        return \"$indicator \" + ($parts -join \"  \")\r\n    }\r\n\r\n    [string] GetItemValue([object]$Item, [string]$ColumnName) {\r\n        try {\r\n            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"GetItemValue: '{0}'\" -f $ColumnName)\r\n            switch ($ColumnName) {\r\n                \"id\" {\r\n                    $val = (Pmc-GetProp $Item 'id' '') -as [string]\r\n                    Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'GetItemValue: id' -Data @{ Value=$val }\r\n                    return $val\r\n                }\r\n                \"text\" {\r\n                    $val = (Pmc-GetProp $Item 'text' '') -as [string]\r\n                    Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message 'GetItemValue: text' -Data @{ Value=$val }\r\n                    return $val\r\n                }\r\n                \"Task\" { return (Pmc-GetProp $Item 'text' '') -as [string] }  # Map Task to text\r\n                \"project\" {\r\n                    $projectId = (Pmc-GetProp $Item 'project' 'inbox') -as [string]\r\n                    # Resolve project name if lookup is available\r\n                    if ($this.ProjectLookup -and $this.ProjectLookup.PSObject.Properties[$projectId]) {\r\n                        return $this.ProjectLookup[$projectId]\r\n                    }\r\n                    return $projectId\r\n                }\r\n                \"due\" {\r\n                    $dueVal = (Pmc-GetProp $Item 'due' $null)\r\n                    if ($dueVal) {\r\n                        try {\r\n                            $date = [datetime]$dueVal\r\n                            return $date.ToString('MM/dd')\r\n                        } catch {\r\n                            return [string]$dueVal\r\n                        }\r\n                    }\r\n                    return \"\"\r\n                }\r\n                \"priority\" {\r\n                    $p = (Pmc-GetProp $Item 'priority' 0)\r\n                    if ($p -and $p -le 3) {\r\n                        return \"P$($p)\"\r\n                    }\r\n                    return \"\"\r\n                }\r\n                \"status\" {\r\n                    if ($Item.status) {\r\n                        return $Item.status\r\n                    } else {\r\n                        return \"pending\"\r\n                    }\r\n                }\r\n                default {\r\n                    # Dynamic property access\r\n                    if ($Item.PSObject.Properties[$ColumnName]) {\r\n                        return $Item.$ColumnName.ToString()\r\n                    }\r\n                    return \"\"\r\n                }\r\n            }\r\n            return \"\"\r\n        } catch {\r\n            return \"\"\r\n        }\r\n    }\r\n\r\n    [object[]] RenderGrid([object[]]$Data) {\r\n        return $this.BuildInteractiveLines()\r\n    }\r\n\r\n    [object[]] BuildInteractiveLines() {\r\n        $lines = @()\r\n        if (-not $this.CurrentData -or @($this.CurrentData).Count -eq 0) {\r\n            $lines += $this.StyleText('Muted', '  No data to display')\r\n            return $lines\r\n        }\r\n        # Recalculate terminal metrics and adjust layout\r\n        try {\r\n            $this.TerminalWidth = $this.GetTerminalWidth()\r\n            $this.WindowHeight = $this.GetTerminalHeight()\r\n        } catch {}\r\n        $widths = $this.GetColumnWidths($this.CurrentData)\r\n        if ($this.ShowInternalHeader) {\r\n            $lines += $this.StyleText('Title', $this.TitleText)\r\n            $lines += $this.StyleText('Border', (\"═\" * 50))\r\n        }\r\n        $headerLine = $this.FormatRow($null, $widths, $true, -1, $false)\r\n        if ($this.SortDirection -ne 'None' -and $this.SortColumn) {\r\n            $arrow = $(if ($this.SortDirection -eq 'Asc') { '↑' } else { '↓' })\r\n            $headerLine = $headerLine + \"  (sorted by $($this.SortColumn) $arrow)\"\r\n        }\r\n        $lines += $headerLine\r\n        $separatorParts = @(); foreach ($col in $this.ColumnConfig.Keys) { $separatorParts += \"─\" * $widths[$col] }\r\n        $separatorLine = \"  \" + ($separatorParts -join \"  \")\r\n        $lines += $this.StyleText('Border', $separatorLine)\r\n        # Determine visible rows based on window height\r\n        $available = [Math]::Max(1, $this.WindowHeight - ($this.HeaderLines + 1))\r\n        $this.EnsureInView()\r\n        $start = $this.ScrollOffset\r\n        $endExclusive = [Math]::Min(@($this.CurrentData).Count, $start + $available)\r\n        for ($i = $start; $i -lt $endExclusive; $i++) {\r\n            $item = $this.CurrentData[$i]\r\n            $isSelected = ($i -eq $this.SelectedRow) -or ($this.MultiSelectMode -and $this.SelectedRows -contains $i)\r\n            $lines += $this.FormatRow($item, $widths, $false, $i, $isSelected)\r\n        }\r\n        # Indicate more content above/below when scrolled\r\n        if ($this.ScrollOffset -gt 0) { $lines[$this.HeaderLines] = (\"↑ \" + ($lines[$this.HeaderLines].Substring(2))) }\r\n        if ($endExclusive -lt @($this.CurrentData).Count) { $lines[@($lines).Count-1] = ($lines[@($lines).Count-1] + ' …') }\r\n        return $lines\r\n    }\r\n\r\n    [void] EnsureInView() {\r\n        $this.WindowHeight = $this.GetTerminalHeight()\r\n        $available = [Math]::Max(1, $this.WindowHeight - ($this.HeaderLines + 1))\r\n        if ($this.SelectedRow -lt $this.ScrollOffset) { $this.ScrollOffset = $this.SelectedRow }\r\n        elseif ($this.SelectedRow -ge ($this.ScrollOffset + $available)) { $this.ScrollOffset = $this.SelectedRow - $available + 1 }\r\n        if ($this.ScrollOffset -lt 0) { $this.ScrollOffset = 0 }\r\n    }\r\n\r\n    [string] StyleText([string]$StyleToken, [string]$Text) {\r\n        $sty = Get-PmcStyle $StyleToken\r\n        $styledText = $this.ConvertPmcStyleToAnsi($Text, $sty, @{})\r\n\r\n        # Apply screen bounds enforcement\r\n        return $this.EnforceScreenBounds($styledText, 0, 0)\r\n    }\r\n\r\n    # Main interactive method\r\n    [void] StartInteractive([object[]]$Data) {\r\n        Write-PmcDebug -Level 1 -Category 'Grid' -Message \"StartInteractive called\" -Data @{ DataCount = @($Data).Count }\r\n        $this.Interactive = $true\r\n        $this.AllData = $Data\r\n        $this.ApplyDoFilter()\r\n        $this.SelectedRow = 0\r\n        $this.SelectedColumn = 0\r\n        $this.MultiSelectMode = $false\r\n        $this.SelectedRows = @()\r\n        $this.HasInitialRender = $false\r\n        $this.LastLines = @()\r\n        $this.LastRefreshAt = Get-Date\r\n\r\n        # Hide cursor for cleaner display\r\n        Write-Host ([PmcVT]::Hide())\r\n        Write-PmcDebug -Level 1 -Category 'Grid' -Message \"Starting interactive loop\"\r\n\r\n        try {\r\n            # Initial display\r\n            $this.RefreshDisplay()\r\n\r\n            # Main input loop\r\n            while ($this.Interactive) {\r\n                try {\r\n                    if ([Console]::KeyAvailable) {\r\n                        $key = [Console]::ReadKey($true)\r\n                        Write-PmcDebug -Level 2 -Category 'Grid' -Message \"Key pressed\" -Data @{ Key = $key.Key; KeyChar = $key.KeyChar }\r\n                        $this.HandleKeyPress($key)\r\n                    } else {\r\n                        if ($this.RefreshIntervalMs -gt 0) {\r\n                            $now = Get-Date\r\n                            if ((($now - $this.LastRefreshAt).TotalMilliseconds) -ge $this.RefreshIntervalMs) {\r\n                                $this.LastRefreshAt = $now\r\n                                $this.RefreshDisplay()\r\n                            }\r\n                        }\r\n                        Start-Sleep -Milliseconds 50\r\n                    }\r\n                } catch {\r\n                    # Fallback for non-interactive or redirected environments\r\n                    Start-Sleep -Milliseconds 50\r\n                    if ($this.RefreshIntervalMs -gt 0) {\r\n                        $now = Get-Date\r\n                        if ((($now - $this.LastRefreshAt).TotalMilliseconds) -ge $this.RefreshIntervalMs) {\r\n                            $this.LastRefreshAt = $now\r\n                            $this.RefreshData()\r\n                        }\r\n                    }\r\n                    Start-Sleep -Milliseconds 50\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            # Always restore cursor visibility\r\n            Write-Host ([PmcVT]::Show())\r\n        }\r\n    }\r\n\r\n    [void] HandleKeyPress([ConsoleKeyInfo]$Key) {\r\n        $keyName = $Key.Key.ToString()\r\n\r\n        # Handle modifier keys\r\n        if ($Key.Modifiers -band [ConsoleModifiers]::Shift) {\r\n            $keyName = \"Shift+$keyName\"\r\n        }\r\n        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {\r\n            $keyName = \"Ctrl+$keyName\"\r\n        }\r\n\r\n        Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Key pressed: '{0}'\" -f $keyName)\r\n\r\n        # Execute key binding if it exists\r\n        if ($this.KeyBindings.ContainsKey($keyName)) {\r\n            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"Execute key binding: '{0}'\" -f $keyName)\r\n            try {\r\n                & $this.KeyBindings[$keyName]\r\n            } catch {\r\n                Write-PmcDebug -Level 1 -Category 'DataDisplay' -Message (\"Key binding error: '{0}'\" -f $keyName) -Data @{ Error = $_.Exception.Message }\r\n                Write-PmcDebug -Level 1 -Category \"DataDisplay\" -Message \"Key binding error\" -Data @{\r\n                    Key = $keyName;\r\n                    Error = $_.Exception.Message\r\n                }\r\n            }\r\n        } else {\r\n            Write-PmcDebug -Level 3 -Category 'DataDisplay' -Message (\"No key binding for: '{0}'\" -f $keyName)\r\n            # Type-to-filter: accept printable chars; Backspace handled here when not bound\r\n            $ch = $Key.KeyChar\r\n            if ([int]$ch -ge 32 -and [int]$ch -le 126 -and -not ($Key.Modifiers -band [ConsoleModifiers]::Control)) {\r\n                $this.FilterQuery += [string]$ch\r\n                $this.ApplyDoFilter(); $this.RefreshDisplay(); return\r\n            }\r\n            if ($Key.Key -eq [ConsoleKey]::Backspace -and -not ($Key.Modifiers -band [ConsoleModifiers]::Control)) {\r\n                if ($this.FilterQuery.Length -gt 0) { $this.FilterQuery = $this.FilterQuery.Substring(0, $this.FilterQuery.Length - 1); $this.ApplyDoFilter(); $this.RefreshDisplay(); return }\r\n            }\r\n            # Unhandled key - ignore\r\n        }\r\n    }\r\n\r\n    [void] ToggleSortCurrentColumn() {\r\n        $columns = @($this.ColumnConfig.Keys)\r\n        $col = ''\r\n        if ($this.NavigationMode -eq 'Cell' -and $this.SelectedColumn -lt @($columns).Count) {\r\n            $col = $columns[$this.SelectedColumn]\r\n        } else {\r\n            if (@($columns).Count -gt 0) { $col = $columns[0] }\r\n        }\r\n        if (-not $col) { return }\r\n        if ($this.SortColumn -ne $col) { $this.SortColumn = $col; $this.SortDirection = 'Asc' }\r\n        else {\r\n            switch ($this.SortDirection) {\r\n                'Asc'  { $this.SortDirection = 'Desc' }\r\n                'Desc' { $this.SortDirection = 'None' }\r\n                default { $this.SortDirection = 'Asc' }\r\n            }\r\n        }\r\n        $this.ApplyDoFilter(); $this.RefreshDisplay()\r\n    }\r\n\r\n    [void] PromptSaveView() {\r\n        $row = [PmcTerminalService]::GetHeight() - 2\r\n        Write-Host ([PmcVT]::MoveTo(0, $row) + [PmcVT]::ClearLine())\r\n        Write-Host -NoNewline \"Save view as: \"\r\n        $name = Read-Host\r\n        if ([string]::IsNullOrWhiteSpace($name)) { return }\r\n        $this.SavedViews[$name] = @{\r\n            Filters = $this.Filters.Clone()\r\n            Columns = $this.ColumnConfig.Clone()\r\n            Theme   = $this.ThemeConfig\r\n            Sort    = @{ Column=$this.SortColumn; Direction=$this.SortDirection }\r\n            Query   = $this.FilterQuery\r\n        }\r\n        $this.PersistSavedViews()\r\n        Write-Host ([PmcVT]::MoveTo(0, $row) + [PmcVT]::ClearLine())\r\n        Write-PmcStyled -Style 'Success' -Text (\"Saved view: {0}\" -f $name)\r\n    }\r\n\r\n    [void] PromptLoadView() {\r\n        if ($this.SavedViews.Keys.Count -eq 0) { return }\r\n        $row = [PmcTerminalService]::GetHeight() - 2\r\n        Write-Host ([PmcVT]::MoveTo(0, $row) + [PmcVT]::ClearLine())\r\n        Write-Host -NoNewline (\"Load view [{0}]: \" -f ($this.SavedViews.Keys -join ', '))\r\n        $name = Read-Host\r\n        if (-not $this.SavedViews.ContainsKey($name)) { return }\r\n        $v = $this.SavedViews[$name]\r\n        $this.Filters = $v.Filters\r\n        $this.ColumnConfig = $v.Columns\r\n        $this.ThemeConfig = $v.Theme\r\n        $this.SortColumn = $v.Sort.Column\r\n        $this.SortDirection = $v.Sort.Direction\r\n        $this.FilterQuery = $v.Query\r\n        $this.RefreshData()\r\n    }\r\n\r\n    [void] ListSavedViews() {\r\n        $row = [PmcTerminalService]::GetHeight() - 2\r\n        Write-Host ([PmcVT]::MoveTo(0, $row) + [PmcVT]::ClearLine())\r\n        if ($this.SavedViews.Keys.Count -eq 0) { Write-PmcStyled -Style 'Muted' -Text 'No saved views'; return }\r\n        Write-PmcStyled -Style 'Body' -Text (\"Saved views: {0}\" -f ($this.SavedViews.Keys -join ', '))\r\n    }\r\n\r\n    [void] LoadSavedViews() {\r\n        $cfg = Get-PmcConfig\r\n        if ($cfg -and $cfg.ContainsKey('Display') -and $cfg.Display -and $cfg.Display.ContainsKey('GridViews')) {\r\n            $views = $cfg.Display.GridViews\r\n            if ($views -is [hashtable]) { $this.SavedViews = $views }\r\n        }\r\n    }\r\n\r\n    [void] PersistSavedViews() {\r\n        $cfg = Get-PmcConfig\r\n        if (-not $cfg.ContainsKey('Display')) { $cfg['Display'] = @{} }\r\n        $cfg.Display['GridViews'] = $this.SavedViews\r\n        Save-PmcConfig $cfg\r\n    }\r\n\r\n    [void] ApplyDoFilter() {\r\n        if (-not $this.AllData) { $this.CurrentData = @(); return }\r\n        if ([string]::IsNullOrWhiteSpace($this.FilterQuery)) { $this.CurrentData = $this.AllData; return }\r\n        $q = $this.FilterQuery.ToLowerInvariant()\r\n        $isRegex = $false\r\n        $pattern = $null\r\n        if ($q.StartsWith('re:')) { $isRegex = $true; $pattern = $q.Substring(3) }\r\n        elseif ($this.FilterQuery.StartsWith('/') -and $this.FilterQuery.EndsWith('/')) { $isRegex = $true; $pattern = $this.FilterQuery.Trim('/') }\r\n        $filtered = @()\r\n        foreach ($it in $this.AllData) {\r\n            if ($it -eq $null) { continue }\r\n            $t = ''\r\n            if ($it.PSObject.Properties['text'] -and $it.text) { $t = [string]$it.text }\r\n            $p = ''\r\n            if ($it.PSObject.Properties['project'] -and $it.project) { $p = [string]$it.project }\r\n            $d = ''\r\n            if ($it.PSObject.Properties['due'] -and $it.due) { $d = [string]$it.due }\r\n            $hay = ($t + ' ' + $p + ' ' + $d).ToLowerInvariant()\r\n            if ($isRegex) {\r\n                if ($hay -match $pattern) { $filtered += $it }\r\n            } else {\r\n                if ($hay.Contains($q)) { $filtered += $it }\r\n            }\r\n        }\r\n        # Apply sorting to filtered results\r\n        if ($this.SortDirection -ne 'None' -and $this.SortColumn) {\r\n            $key = $this.SortColumn; $asc = ($this.SortDirection -eq 'Asc')\r\n            $filtered = @($filtered | Sort-Object -Property @{Expression={ if ($_.PSObject.Properties[$key]) { $_.$key } else { $null } }; Ascending=$asc})\r\n        }\r\n        $this.CurrentData = $filtered\r\n        if ($this.SelectedRow -ge @($this.CurrentData).Count) { $this.SelectedRow = [Math]::Max(0, @($this.CurrentData).Count - 1) }\r\n    }\r\n\r\n    [void] RenderStaticGrid([array]$Data) {\r\n        # Simple non-interactive grid rendering for compatibility\r\n        if (-not $Data -or @($Data).Count -eq 0) {\r\n            Write-PmcStyled -Style 'Muted' -Text \"No items to display\"\r\n            return\r\n        }\r\n\r\n        $this.AllData = $Data\r\n        $this.CurrentData = $Data\r\n        $widths = $this.GetColumnWidths($Data)\r\n\r\n        # Display header\r\n        $headerLine = $this.FormatRow($null, $widths, $true, -1, $false)\r\n        Write-Host $headerLine\r\n\r\n        # Display separator\r\n        $sepParts = @()\r\n        foreach ($col in $this.ColumnConfig.Keys) {\r\n            $sepParts += \"─\" * $widths[$col]\r\n        }\r\n        Write-Host (\"  \" + ($sepParts -join \"  \"))\r\n\r\n        # Display data rows\r\n        for ($i = 0; $i -lt @($Data).Count; $i++) {\r\n            $item = $Data[$i]\r\n            if ($item -ne $null) {\r\n                $line = $this.FormatRow($item, $widths, $false, $i, $false)\r\n                Write-Host $line\r\n            }\r\n        }\r\n    }\r\n\r\n    [void] StartInteractiveMode([hashtable]$Config) {\r\n        # Optional configurator compatible with plan terminology\r\n        if ($Config -and $Config.ContainsKey('AllowEditing')) { $this.LiveEditing = [bool]$Config.AllowEditing }\r\n        if ($Config -and $Config.ContainsKey('SaveCallback')) { $this.SaveCallback = [scriptblock]$Config.SaveCallback }\r\n        if ($this.CurrentData -and @($this.CurrentData).Count -gt 0) { $this.StartInteractive($this.CurrentData) }\r\n    }\r\n\r\n    [void] MoveToColumnStart() {\r\n        if ($this.NavigationMode -ne 'Cell') { return }\r\n        $this.SelectedColumn = 0\r\n        $this.RefreshDisplay()\r\n    }\r\n\r\n    [void] MoveToColumnDoEnd() {\r\n        if ($this.NavigationMode -ne 'Cell') { return }\r\n        $columns = @($this.ColumnConfig.Keys)\r\n        if ($columns.Count -gt 0) { $this.SelectedColumn = $columns.Count - 1 }\r\n        $this.RefreshDisplay()\r\n    }\r\n}\r\n\r\nfunction Get-PmcFilteredData {\r\n    param(\r\n        [string[]]$Domains,\r\n        [hashtable]$Filters\r\n    )\r\n\r\n    $data = Get-PmcDataAlias\r\n    $results = @()\r\n\r\n    foreach ($domain in $Domains) {\r\n        switch ($domain) {\r\n            \"task\" {\r\n                $items = $(if ($data.tasks) { @($data.tasks) } else { @() })\r\n\r\n                # Apply filters\r\n                if ($Filters.PSObject.Properties['status'] -and $Filters.status) {\r\n                    $items = @($items | Where-Object { $_.PSObject.Properties['status'] -and $_.status -eq $Filters.status })\r\n                }\r\n\r\n                if ($Filters.PSObject.Properties['due_range'] -and $Filters.due_range) {\r\n                    $today = (Get-Date).Date\r\n                    switch ($Filters.due_range) {\r\n                        \"overdue_and_today\" {\r\n                            $items = @($items | Where-Object {\r\n                                if (-not ($_.PSObject.Properties['due'] -and $_.due -and ($_.due -is [string]) -and $_.due -match '^\\d{4}-\\d{2}-\\d{2}$')) { return $false }\r\n                                $d = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)\r\n                                return ($d.Date -le $today)\r\n                            })\r\n                        }\r\n                        \"today\" {\r\n                            $items = @($items | Where-Object {\r\n                                if (-not ($_.PSObject.Properties['due'] -and $_.due -and ($_.due -is [string]) -and $_.due -match '^\\d{4}-\\d{2}-\\d{2}$')) { return $false }\r\n                                $d = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)\r\n                                return ($d.Date -eq $today)\r\n                            })\r\n                        }\r\n                        \"overdue\" {\r\n                            $items = @($items | Where-Object {\r\n                                if (-not ($_.PSObject.Properties['due'] -and $_.due -and ($_.due -is [string]) -and $_.due -match '^\\d{4}-\\d{2}-\\d{2}$')) { return $false }\r\n                                $d = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)\r\n                                return ($d.Date -lt $today)\r\n                            })\r\n                        }\r\n                        \"upcoming\" {\r\n                            $weekFromNow = $today.AddDays(7)\r\n                            $items = @($items | Where-Object {\r\n                                if (-not ($_.PSObject.Properties['due'] -and $_.due -and ($_.due -is [string]) -and $_.due -match '^\\d{4}-\\d{2}-\\d{2}$')) { return $false }\r\n                                $d = [datetime]::ParseExact([string]$_.due, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)\r\n                                return ($d.Date -gt $today -and $d.Date -le $weekFromNow)\r\n                            })\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if ($Filters.ContainsKey('project') -and $Filters.project) {\r\n                    $items = @($items | Where-Object { $_.PSObject.Properties['project'] -and $_.project -eq $Filters.project })\r\n                }\r\n\r\n                if ($Filters.PSObject.Properties['blocked'] -and $Filters.blocked) {\r\n                    $items = @($items | Where-Object { $_ -ne $null -and $_.PSObject.Properties['blocked'] -and $_.blocked })\r\n                }\r\n\r\n                if ($Filters.PSObject.Properties['no_due_date'] -and $Filters.no_due_date) {\r\n                    $items = @($items | Where-Object { $_ -ne $null -and (-not $_.PSObject.Properties['due'] -or -not $_.due -or $_.due -eq '') })\r\n                }\r\n\r\n                $results += $items\r\n            }\r\n            \"project\" {\r\n                $items = $(if ($data.projects) { @($data.projects) } else { @() })\r\n\r\n                # Apply project filters if any\r\n                if ($Filters.archived -eq $false) {\r\n                    $items = @($items | Where-Object { (-not (Pmc-HasProp $_ 'isArchived')) -or (-not $_.isArchived) })\r\n                }\r\n\r\n                $results += $items\r\n            }\r\n            \"timelog\" {\r\n                $items = $(if ($data.timelogs) { @($data.timelogs) } else { @() })\r\n                $results += $items\r\n            }\r\n        }\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nfunction Show-PmcDataGrid {\r\n    param(\r\n        [string[]]$Domains = @(\"task\"),\r\n        [hashtable]$Columns = @{},\r\n        [hashtable]$Filters = @{},\r\n        [string]$Title = \"\",\r\n        [hashtable]$Theme = @{},\r\n        [switch]$Interactive,\r\n        [string]$Sort,\r\n        [int]$RefreshIntervalMs,\r\n        [scriptblock]$OnSelectCallback,\r\n        [object[]]$Data\r\n    )\r\n\r\n    Write-PmcDebug -Level 2 -Category \"DataDisplay\" -Message \"Rendering data grid\" -Data @{\r\n        Domains = $Domains -join \",\"\r\n        ColumnCount = $Columns.Keys.Count\r\n        FilterCount = $Filters.Keys.Count\r\n    }\r\n\r\n    # Default column configuration derived from FieldSchemas for common data types\r\n    if ($Columns.Keys.Count -eq 0 -and $Domains -contains \"task\") {\r\n        $fs = Get-PmcFieldSchemasForDomain -Domain 'task'\r\n        $Columns = @{}\r\n        foreach ($name in @('id','text','project','due','priority')) {\r\n            $sch = $null\r\n            if ($fs.ContainsKey($name)) { $sch = $fs[$name] }\r\n            $h = switch ($name) { 'id' { '#'} 'text' { 'Task' } 'project' { 'Project' } 'due' { 'Due' } 'priority' { 'pri' } default { $name } }\r\n            $w = 35\r\n            if ($sch -and $sch.ContainsKey('DefaultWidth')) {\r\n                $w = [int]$sch.DefaultWidth\r\n            } else {\r\n                switch ($name) {\r\n                    'id' { $w = 4 }\r\n                    'priority' { $w = 3 }\r\n                    'due' { $w = 10 }\r\n                    'project' { $w = 12 }\r\n                }\r\n            }\r\n            $al = switch ($name) { 'id' { 'Right' } 'priority' { 'Center' } 'due' { 'Center' } default { 'Left' } }\r\n            $editable = $true\r\n            if ($sch -and $sch.ContainsKey('Editable')) { $editable = [bool]$sch.Editable }\r\n            $sensitive = $false\r\n            if ($sch -and $sch.ContainsKey('Sensitive')) { $sensitive = [bool]$sch.Sensitive }\r\n            $truncate = ($name -eq 'text' -or $name -eq 'project')\r\n            $Columns[$name] = @{ Header = $h; Width = $w; Alignment = $al; Editable = $editable; Sensitive = $sensitive; Truncate = $truncate }\r\n        }\r\n    }\r\n    elseif ($Columns.Keys.Count -eq 0 -and $Domains -contains \"project\") {\r\n        $fs = Get-PmcFieldSchemasForDomain -Domain 'project'\r\n        $Columns = @{}\r\n        foreach ($name in @('name','description','task_count','completion')) {\r\n            $sch = $null\r\n            if ($fs.ContainsKey($name)) { $sch = $fs[$name] }\r\n            $h = switch ($name) { 'name' { 'Project' } 'description' { 'Description' } 'task_count' { 'Tasks' } 'completion' { '%' } default { $name } }\r\n            $w = 30\r\n            if ($sch -and $sch.ContainsKey('DefaultWidth')) {\r\n                $w = [int]$sch.DefaultWidth\r\n            } else {\r\n                switch ($name) {\r\n                    'task_count' { $w = 6 }\r\n                    'completion' { $w = 6 }\r\n                    'name' { $w = 20 }\r\n                }\r\n            }\r\n            $al = switch ($name) { 'task_count' { 'Right' } 'completion' { 'Right' } default { 'Left' } }\r\n            $editable = $false\r\n            if ($sch -and $sch.ContainsKey('Editable')) { $editable = [bool]$sch.Editable }\r\n            $sensitive = $false\r\n            if ($sch -and $sch.ContainsKey('Sensitive')) { $sensitive = [bool]$sch.Sensitive }\r\n            $truncate = ($name -eq 'description')\r\n            $Columns[$name] = @{ Header = $h; Width = $w; Alignment = $al; Editable = $editable; Sensitive = $sensitive; Truncate = $truncate }\r\n        }\r\n    }\r\n    elseif ($Columns.Keys.Count -eq 0 -and $Domains -contains \"timelog\") {\r\n        $fs = Get-PmcFieldSchemasForDomain -Domain 'timelog'\r\n        $Columns = @{}\r\n        foreach ($name in @('date','project','duration','description')) {\r\n            $sch = $null\r\n            if ($fs.ContainsKey($name)) { $sch = $fs[$name] }\r\n            $h = switch ($name) { 'date' { 'Date' } 'project' { 'Project' } 'duration' { 'Duration' } 'description' { 'Description' } default { $name } }\r\n            $w = 35\r\n            if ($sch -and $sch.ContainsKey('DefaultWidth')) {\r\n                $w = [int]$sch.DefaultWidth\r\n            } else {\r\n                switch ($name) {\r\n                    'date' { $w = 10 }\r\n                    'project' { $w = 15 }\r\n                    'duration' { $w = 8 }\r\n                }\r\n            }\r\n            $al = switch ($name) { 'duration' { 'Right' } 'date' { 'Center' } default { 'Left' } }\r\n            $editable = $false\r\n            if ($sch -and $sch.ContainsKey('Editable')) { $editable = [bool]$sch.Editable }\r\n            $sensitive = $false\r\n            if ($sch -and $sch.ContainsKey('Sensitive')) { $sensitive = [bool]$sch.Sensitive }\r\n            $truncate = ($name -eq 'description')\r\n            $Columns[$name] = @{ Header = $h; Width = $w; Alignment = $al; Editable = $editable; Sensitive = $sensitive; Truncate = $truncate }\r\n        }\r\n    }\r\n\r\n    # Resolve data source (explicit data wins)\r\n    if ($PSBoundParameters.ContainsKey('Data')) {\r\n        $data = $Data\r\n    } else {\r\n        # Get filtered data - HACK for help domain\r\n        if ($Domains -contains \"help\") {\r\n            # Use Get-PmcHelpData function for consistent help data\r\n            $data = Get-PmcHelpData -Context $null\r\n            Write-PmcDebug -Level 2 -Category \"DataDisplay\" -Message \"Help data retrieved\" -Data @{ Count = @($data).Count }\r\n        } else {\r\n            $data = Get-PmcFilteredData -Domains $Domains -Filters $Filters\r\n        }\r\n    }\r\n\r\n    # Optional sorting for static mode\r\n    if (-not $Interactive.IsPresent -and $Sort) {\r\n        $sortText = [string]$Sort\r\n        $col = $null; $asc = $true\r\n        if ($sortText -match '^([-+]?)([A-Za-z0-9_:-]+)$') {\r\n            $sig = $matches[1]; $name = $matches[2]\r\n            $col = $name\r\n            if ($sig -eq '-') { $asc = $false }\r\n        } elseif ($sortText -match '^([^:]+):(asc|desc)$') {\r\n            $col = $matches[1]; $asc = ($matches[2].ToLower() -eq 'asc')\r\n        }\r\n        if ($col) {\r\n            $data = @($data | Sort-Object -Property @{Expression={ if ($_.PSObject.Properties[$col]) { $_.$col } else { $null } }; Ascending=$asc})\r\n        } else {\r\n            throw (\"Invalid Sort format: '{0}'\" -f $Sort)\r\n        }\r\n    }\r\n\r\n    # Display title if provided\r\n    if ($Title) {\r\n        Write-PmcStyled -Style 'Title' -Text \"`n$Title\"\r\n        Write-PmcStyled -Style 'Border' -Text (\"─\" * 50)\r\n        # Helpful hint for help-related views\r\n        $isHelp = $false\r\n        foreach ($d in $Domains) { if ($d -like 'help*') { $isHelp = $true; break } }\r\n        if ($isHelp) {\r\n            Write-PmcStyled -Style 'Muted' -Text 'Tip: / opens search • Ctrl+F filter • \"phrase\" matches • Enter inserts'\r\n        }\r\n    }\r\n\r\n    if (-not $data -or @($data).Count -eq 0) {\r\n        Write-PmcDebug -Level 2 -Category \"DataDisplay\" -Message \"No data found for display\" -Data @{\r\n            DataIsNull = ($data -eq $null)\r\n            DataCount = $(if ($data) { @($data).Count } else { \"null\" })\r\n            Domains = $Domains -join \",\"\r\n        }\r\n        Write-PmcStyled -Style 'Muted' -Text \"No items match the specified criteria\"\r\n        return\r\n    }\r\n\r\n    # Create and configure the grid renderer\r\n    $renderer = [PmcGridRenderer]::new($Columns, $Domains, $Filters)\r\n    $renderer.CurrentData = $data\r\n    $renderer.AllData = $data\r\n\r\n    # Apply theme configuration if provided\r\n    if ($Theme.Count -gt 0) {\r\n        $renderer.ThemeConfig = $renderer.InitializeTheme($Theme)\r\n    }\r\n\r\n    # Apply additional parameters\r\n    if ($OnSelectCallback) { $renderer.OnSelectCallback = $OnSelectCallback }\r\n\r\n    # Choose rendering mode\r\n    if ($Interactive) {\r\n        # Start interactive mode\r\n        if ($PSBoundParameters.ContainsKey('RefreshIntervalMs')) { $renderer.RefreshIntervalMs = [int]$RefreshIntervalMs }\r\n        $renderer.StartInteractive($data)\r\n    } else {\r\n        # Standard static rendering\r\n        $gridLines = $renderer.RenderGrid($data)\r\n        foreach ($line in $gridLines) {\r\n            Write-Host $line\r\n        }\r\n    }\r\n\r\n    Write-PmcDebug -Level 2 -Category \"DataDisplay\" -Message \"Grid rendering completed\" -Data @{\r\n        ItemCount = @($data).Count\r\n        Interactive = $Interactive.IsPresent\r\n    }\r\n}\r\n\r\n# Compatibility wrapper: Show-PmcCustomGrid → Show-PmcDataGrid\r\nfunction Show-PmcCustomGrid {\r\n    param(\r\n        [string]$Domain,\r\n        [hashtable]$Columns,\r\n        [object[]]$Data,\r\n        [string]$Title,\r\n        [string]$Group,\r\n        [string]$View,\r\n        [switch]$Interactive\r\n    )\r\n    try {\r\n        if (($View -and $View.ToLower() -eq 'kanban') -and (Get-Command -Name 'Show-PmcKanban' -ErrorAction SilentlyContinue)) {\r\n            # Delegate to Kanban renderer when requested\r\n            Show-PmcKanban -Domain $Domain -Data $Data -Columns $Columns -Title $Title -Interactive:$Interactive\r\n            return\r\n        }\r\n    } catch {}\r\n\r\n    $domains = @($Domain)\r\n    if (-not $Columns) { $Columns = @{} }\r\n    if ($Title) {\r\n        Write-PmcStyled -Style 'Title' -Text \"`n$Title\"\r\n        Write-PmcStyled -Style 'Border' -Text (\"─\" * 50)\r\n    }\r\n    Show-PmcDataGrid -Domains $domains -Columns $Columns -Data $Data -Interactive:$Interactive\r\n}\r\n\r\n# Export functions for module manifest\r\nExport-ModuleMember -Function Show-PmcDataGrid, Show-PmcCustomGrid"}, {"path": "module/Pmc.Strict/src/Debug.ps1", "content": "# Structured Debug Logging System for PMC\r\n# Multi-level debug output with file rotation and sensitive data redaction\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Debug system state - now managed by centralized state\r\n# State initialization moved to State.ps1\r\n\r\nfunction Initialize-PmcDebugSystem {\r\n    <#\r\n    .SYNOPSIS\r\n    Initializes the debug system based on configuration and command line arguments\r\n\r\n    .PARAMETER Level\r\n    Debug level (0=off, 1=basic, 2=detailed, 3=verbose)\r\n\r\n    .PARAMETER LogPath\r\n    Path to debug log file (relative to PMC root or absolute)\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [int]$Level = 0,\r\n        [string]$LogPath = 'debug.log'\r\n    )\r\n\r\n    # Defer config loading to avoid circular dependency during initialization\r\n    # Configuration will be applied later via Update-PmcDebugFromConfig\r\n\r\n    # Override with explicit parameters\r\n    if ($Level -gt 0) { Set-PmcState -Section 'Debug' -Key 'Level' -Value $Level }\r\n    if ($LogPath -ne 'debug.log') { Set-PmcState -Section 'Debug' -Key 'LogPath' -Value $LogPath }\r\n\r\n    # Check environment variables for debug settings\r\n    if ($env:PMC_DEBUG) {\r\n        try {\r\n            $envLevel = [int]$env:PMC_DEBUG\r\n            if ($envLevel -ge 1 -and $envLevel -le 3) {\r\n                Set-PmcState -Section 'Debug' -Key 'Level' -Value $envLevel\r\n            }\r\n        } catch {\r\n            # Environment variable parsing failed - skip environment override\r\n        }\r\n    }\r\n\r\n    # Check PowerShell debug preference\r\n    if ($DebugPreference -ne 'SilentlyContinue') {\r\n        $debugState = Get-PmcDebugState\r\n        Set-PmcState -Section 'Debug' -Key 'Level' -Value ([Math]::Max($debugState.Level, 1))\r\n    }\r\n\r\n    $debugState = Get-PmcDebugState\r\n    if ($debugState.Level -gt 0) {\r\n        Ensure-PmcDebugLogPath\r\n        Write-PmcDebug -Level 1 -Category 'SYSTEM' -Message \"Debug system initialized (Level=$($debugState.Level), Session=$($debugState.SessionId))\"\r\n    }\r\n}\r\n\r\nfunction Ensure-PmcDebugLogPath {\r\n    try {\r\n        $logPath = Get-PmcDebugLogPath\r\n        $dir = Split-Path $logPath -Parent\r\n        if (-not (Test-Path $dir)) {\r\n            New-Item -ItemType Directory -Path $dir -Force | Out-Null\r\n        }\r\n\r\n        # Rotate log if it's too large\r\n        if (Test-Path $logPath) {\r\n            $size = (Get-Item $logPath).Length\r\n            $debugState = Get-PmcDebugState\r\n            if ($size -gt $debugState.MaxSize) {\r\n                $oldPath = $logPath + '.old'\r\n                if (Test-Path $oldPath) { Remove-Item $oldPath -Force }\r\n                Move-Item $logPath $oldPath -Force\r\n            }\r\n        }\r\n    } catch {\r\n        # Debug log path setup failed - debug output may be unavailable\r\n        Write-PmcDebug -Level 1 -Category 'SYSTEM' -Message \"Debug log setup failed: $_\"\r\n    }\r\n}\r\n\r\nfunction Get-PmcDebugLogPath {\r\n    $debugState = Get-PmcDebugState\r\n    $logPath = $debugState.LogPath\r\n    if ([System.IO.Path]::IsPathRooted($logPath)) {\r\n        return $logPath\r\n    }\r\n\r\n    # Relative to PMC root directory (three levels up from src)\r\n    $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent\r\n    return Join-Path $root $logPath\r\n}\r\n\r\nfunction Write-PmcDebug {\r\n    <#\r\n    .SYNOPSIS\r\n    Writes a debug message with specified level and category\r\n\r\n    .PARAMETER Level\r\n    Debug level required for this message (1=basic, 2=detailed, 3=verbose)\r\n\r\n    .PARAMETER Category\r\n    Category/component name (e.g., COMMAND, COMPLETION, UI, STORAGE)\r\n\r\n    .PARAMETER Message\r\n    Debug message content\r\n\r\n    .PARAMETER Data\r\n    Optional structured data to include (hashtable/object)\r\n\r\n    .PARAMETER Timing\r\n    Optional timing information (milliseconds)\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [ValidateRange(1,3)]\r\n        [int]$Level,\r\n\r\n        [Parameter(Mandatory)]\r\n        [string]$Category,\r\n\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        [object]$Data = $null,\r\n\r\n        [int]$Timing = -1\r\n    )\r\n\r\n    # Skip if debug level is insufficient\r\n    $debugState = Get-PmcDebugState\r\n    if ($debugState.Level -lt $Level) { return }\r\n\r\n    try {\r\n        $timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss.fff')\r\n        $session = $debugState.SessionId\r\n        $levelName = @('', 'DBG1', 'DBG2', 'DBG3')[$Level]\r\n\r\n        # Build base log entry\r\n        $logEntry = \"[$timestamp] [$session] [$levelName] [$Category] $Message\"\r\n\r\n        # Add timing if provided and enabled\r\n        if ($Timing -ge 0 -and $debugState.IncludePerformance) {\r\n            $logEntry += \" (${Timing}ms)\"\r\n        }\r\n\r\n        # Add structured data if provided\r\n        if ($Data) {\r\n            try {\r\n                $dataJson = $Data | ConvertTo-Json -Compress -Depth 3\r\n                $logEntry += \" | Data: $dataJson\"\r\n            } catch {\r\n                $logEntry += \" | Data: [Serialization Error]\"\r\n            }\r\n        }\r\n\r\n        # Redact sensitive information if enabled\r\n        if ($debugState.RedactSensitive) {\r\n            $logEntry = Protect-PmcSensitiveData $logEntry\r\n        }\r\n\r\n        # Write to log file\r\n        $logPath = Get-PmcDebugLogPath\r\n        Add-Content -Path $logPath -Value $logEntry -Encoding UTF8\r\n\r\n    } catch {\r\n        # Silent failure - don't let debug logging break the application\r\n    }\r\n}\r\n\r\nfunction Protect-PmcSensitiveData {\r\n    param([string]$Text)\r\n\r\n    try {\r\n        # Redact common sensitive patterns\r\n        $protected = $Text\r\n\r\n        # API keys, tokens, secrets\r\n        $protected = $protected -replace '((?i)(token|secret|password|passwd|apikey|api_key|key|pwd)\\s*[:=]\\s*)(\\S+)', '$1****'\r\n\r\n        # Long hex strings (potential secrets/hashes)\r\n        $protected = $protected -replace '\\b[0-9a-fA-F]{32,}\\b', '****'\r\n\r\n        # Email addresses\r\n        $protected = $protected -replace '\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b', '****@****.***'\r\n\r\n        # File paths that might contain usernames\r\n        $protected = $protected -replace '([C-Z]:\\\\Users\\\\)([^\\\\]+)', '$1****'\r\n        $protected = $protected -replace '(/home/)([^/]+)', '$1****'\r\n\r\n        # Credit card numbers (basic pattern)\r\n        $protected = $protected -replace '\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b', '****-****-****-****'\r\n\r\n        # Social Security Numbers\r\n        $protected = $protected -replace '\\b\\d{3}-\\d{2}-\\d{4}\\b', '***-**-****'\r\n\r\n        return $protected\r\n    } catch {\r\n        return $Text\r\n    }\r\n}\r\n\r\nfunction Measure-PmcOperation {\r\n    <#\r\n    .SYNOPSIS\r\n    Measures execution time of a script block and logs performance data\r\n\r\n    .PARAMETER Name\r\n    Operation name for logging\r\n\r\n    .PARAMETER Category\r\n    Debug category\r\n\r\n    .PARAMETER ScriptBlock\r\n    Code to execute and measure\r\n\r\n    .PARAMETER Level\r\n    Debug level for performance logging (default 2)\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Name,\r\n\r\n        [string]$Category = 'PERF',\r\n\r\n        [Parameter(Mandatory)]\r\n        [scriptblock]$ScriptBlock,\r\n\r\n        [int]$Level = 2\r\n    )\r\n\r\n    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n\r\n    try {\r\n        $result = & $ScriptBlock\r\n        $stopwatch.Stop()\r\n\r\n        Write-PmcDebug -Level $Level -Category $Category -Message \"$Name completed\" -Timing $stopwatch.ElapsedMilliseconds\r\n\r\n        return $result\r\n    } catch {\r\n        $stopwatch.Stop()\r\n        Write-PmcDebug -Level 1 -Category $Category -Message \"$Name failed: $_\" -Timing $stopwatch.ElapsedMilliseconds\r\n        throw\r\n    }\r\n}\r\n\r\nfunction Write-PmcDebugCommand {\r\n    <#\r\n    .SYNOPSIS\r\n    Debug logging specifically for command execution (Level 1)\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [string]$Status = 'EXECUTE',\r\n\r\n        [object]$Context = $null,\r\n\r\n        [int]$Timing = -1\r\n    )\r\n\r\n    Write-PmcDebug -Level 1 -Category 'COMMAND' -Message \"$Status`: $Command\" -Data $Context -Timing $Timing\r\n}\r\n\r\nfunction Write-PmcDebugCompletion {\r\n    <#\r\n    .SYNOPSIS\r\n    Debug logging for completion system (Level 2)\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        [object]$Data = $null,\r\n\r\n        [int]$Timing = -1\r\n    )\r\n\r\n    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message $Message -Data $Data -Timing $Timing\r\n}\r\n\r\nfunction Write-PmcDebugUI {\r\n    <#\r\n    .SYNOPSIS\r\n    Debug logging for UI rendering (Level 3)\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        [object]$Data = $null,\r\n\r\n        [int]$Timing = -1\r\n    )\r\n\r\n    Write-PmcDebug -Level 3 -Category 'UI' -Message $Message -Data $Data -Timing $Timing\r\n}\r\n\r\nfunction Write-PmcDebugStorage {\r\n    <#\r\n    .SYNOPSIS\r\n    Debug logging for storage operations (Level 2)\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Operation,\r\n\r\n        [string]$File = '',\r\n\r\n        [object]$Data = $null,\r\n\r\n        [int]$Timing = -1\r\n    )\r\n\r\n    $message = $(if ($File) { \"$Operation`: $File\" } else { $Operation })\r\n    Write-PmcDebug -Level 2 -Category 'STORAGE' -Message $message -Data $Data -Timing $Timing\r\n}\r\n\r\nfunction Get-PmcDebugStatus {\r\n    <#\r\n    .SYNOPSIS\r\n    Returns current debug system status and configuration\r\n    ##CLOSEBRACKET##\r\n\r\n    $logPath = Get-PmcDebugLogPath\r\n    $logSize = $(if (Test-Path $logPath) { (Get-Item $logPath).Length } else { 0 })\r\n\r\n    $debugState = Get-PmcDebugState\r\n    return [PSCustomObject]@{\r\n        Enabled = ($debugState.Level -gt 0)\r\n        Level = $debugState.Level\r\n        LogPath = $logPath\r\n        LogSize = $logSize\r\n        MaxSize = $debugState.MaxSize\r\n        RedactSensitive = $debugState.RedactSensitive\r\n        IncludePerformance = $debugState.IncludePerformance\r\n        SessionId = $debugState.SessionId\r\n        Uptime = ((Get-Date) - $debugState.StartTime)\r\n    }\r\n}\r\n\r\nfunction Show-PmcDebugLog {\r\n    <#\r\n    .SYNOPSIS\r\n    Shows recent debug log entries\r\n\r\n    .PARAMETER Lines\r\n    Number of recent lines to show (default 50)\r\n\r\n    .PARAMETER Category\r\n    Filter by category (optional)\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [int]$Lines = 50,\r\n        [string]$Category = ''\r\n    )\r\n\r\n    $logPath = Get-PmcDebugLogPath\r\n    if (-not (Test-Path $logPath)) {\r\n        Write-Host \"No debug log found at: $logPath\" -ForegroundColor Yellow\r\n        return\r\n    }\r\n\r\n    try {\r\n        $content = Get-Content $logPath -Tail $Lines\r\n\r\n        if ($Category) {\r\n            $content = $content | Where-Object { $_ -match \"\\[$Category\\]\" }\r\n        }\r\n\r\n        foreach ($line in $content) {\r\n            # Color code by level and category\r\n            if ($line -match '\\[DBG1\\]') {\r\n                Write-Host $line -ForegroundColor Green\r\n            } elseif ($line -match '\\[DBG2\\]') {\r\n                Write-Host $line -ForegroundColor Yellow\r\n            } elseif ($line -match '\\[DBG3\\]') {\r\n                Write-Host $line -ForegroundColor Cyan\r\n            } elseif ($line -match '\\[ERROR\\]') {\r\n                Write-Host $line -ForegroundColor Red\r\n            } else {\r\n                Write-Host $line\r\n            }\r\n        }\r\n    } catch {\r\n        Write-Host \"Error reading debug log: $_\" -ForegroundColor Red\r\n    }\r\n}\r\n\r\nfunction Update-PmcDebugFromConfig {\r\n    <#\r\n    .SYNOPSIS\r\n    Updates debug settings from configuration after config provider is ready\r\n    ##CLOSEBRACKET##\r\n    try {\r\n        $cfg = Get-PmcConfig\r\n        if ($cfg.Debug) {\r\n            if ($cfg.Debug.Level -ne $null) { Set-PmcState -Section 'Debug' -Key 'Level' -Value ([int]$cfg.Debug.Level) }\r\n            if ($cfg.Debug.LogPath) { Set-PmcState -Section 'Debug' -Key 'LogPath' -Value ([string]$cfg.Debug.LogPath) }\r\n            if ($cfg.Debug.MaxSize) {\r\n                try {\r\n                    $maxSize = [int64]($cfg.Debug.MaxSize -replace '[^\\d]','') * 1MB\r\n                    Set-PmcState -Section 'Debug' -Key 'MaxSize' -Value $maxSize\r\n                } catch {\r\n                    # Configuration parsing failed - keep default MaxSize value\r\n                }\r\n            }\r\n            if ($cfg.Debug.RedactSensitive -ne $null) { Set-PmcState -Section 'Debug' -Key 'RedactSensitive' -Value ([bool]$cfg.Debug.RedactSensitive) }\r\n            if ($cfg.Debug.IncludePerformance -ne $null) { Set-PmcState -Section 'Debug' -Key 'IncludePerformance' -Value ([bool]$cfg.Debug.IncludePerformance) }\r\n        }\r\n    } catch {\r\n        # Configuration loading failed - debug system will use defaults\r\n    }\r\n}\r\n\r\n# Note: Debug system is initialized by the root orchestrator after config providers are set\r\n\r\n#Export-ModuleMember -Function Initialize-PmcDebugSystem, Ensure-PmcDebugLogPath, Get-PmcDebugLogPath, Write-PmcDebug, Protect-PmcSensitiveData, Measure-PmcOperation, Write-PmcDebugCommand, Write-PmcDebugCompletion, Write-PmcDebugUI, Write-PmcDebugStorage, Get-PmcDebugStatus, Show-PmcDebugLog, Update-PmcDebugFromConfig"}, {"path": "module/Pmc.Strict/src/Dependencies.ps1", "content": "# Dependencies System Implementation\r\n# Based on t2.ps1 dependencies functionality\r\n\r\nfunction Update-PmcBlockedStatus {\r\n    param($data = (Get-PmcDataAlias))\r\n\r\n    Write-PmcDebug -Level 3 -Category \"Dependencies\" -Message \"Updating blocked status for all tasks\"\r\n\r\n    # Clear all blocked status first\r\n    foreach ($task in @($data.tasks)) {\r\n        if ($null -eq $task) { continue }\r\n        if (Pmc-HasProp $task 'blocked') { $task.PSObject.Properties.Remove('blocked') }\r\n    }\r\n\r\n    # Set blocked status for tasks with pending dependencies\r\n    foreach ($task in @($data.tasks) | Where-Object {\r\n        $null -ne $_ -and\r\n        (Pmc-HasProp $_ 'depends') -and\r\n        $_.depends -and\r\n        $_.depends.Count -gt 0\r\n    }) {\r\n        $blockers = $data.tasks | Where-Object {\r\n            Pmc-HasProp $_ 'id' -and ($_.id -in $task.depends) -and (Pmc-HasProp $_ 'status') -and $_.status -eq 'pending'\r\n        }\r\n        $isBlocked = ($blockers.Count -gt 0)\r\n\r\n        if ($isBlocked) {\r\n            if (Pmc-HasProp $task 'blocked') { $task.blocked = $true } else { Add-Member -InputObject $task -MemberType NoteProperty -Name blocked -Value $true }\r\n        }\r\n    }\r\n\r\n    Write-PmcDebug -Level 3 -Category \"Dependencies\" -Message \"Blocked status update completed\"\r\n}\r\n\r\nfunction Add-PmcDependency {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"Dependencies\" -Message \"Starting dep add\" -Data @{ FreeText = $Context.FreeText }\r\n\r\n    $data = Get-PmcDataAlias\r\n    $ids = $Context.FreeText\r\n\r\n    if ($ids.Count -lt 2) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"Usage: dep add <task> <depends-on>\"\r\n        return\r\n    }\r\n\r\n    $taskId = $null\r\n    $dependsOnId = $null\r\n\r\n    # Resolve task IDs\r\n    if ($ids[0] -match '^\\d+$') { $taskId = [int]$ids[0] }\r\n    if ($ids[1] -match '^\\d+$') { $dependsOnId = [int]$ids[1] }\r\n\r\n    if (-not $taskId -or -not $dependsOnId) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Invalid task IDs\"\r\n        return\r\n    }\r\n\r\n    $task = $data.tasks | Where-Object { $_.id -eq $taskId } | Select-Object -First 1\r\n    $dependsOnTask = $data.tasks | Where-Object { $_.id -eq $dependsOnId } | Select-Object -First 1\r\n\r\n    if (-not $task) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Task #$taskId not found\"\r\n        return\r\n    }\r\n\r\n    if (-not $dependsOnTask) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Task #$dependsOnId not found\"\r\n        return\r\n    }\r\n\r\n    # Initialize depends array if needed\r\n    if (-not (Pmc-HasProp $task 'depends')) { $task | Add-Member -NotePropertyName depends -NotePropertyValue @() -Force }\r\n\r\n    # Check if dependency already exists\r\n    if ($task.depends -contains $dependsOnId) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"Dependency already exists\"\r\n        return\r\n    }\r\n\r\n    # Add dependency\r\n    $task.depends = @($task.depends + $dependsOnId)\r\n\r\n    # Update blocked status for all tasks\r\n    Update-PmcBlockedStatus -data $data\r\n\r\n    Save-StrictData $data 'dep add'\r\n    Write-PmcStyled -Style 'Success' -Text \"Added dependency: Task #$taskId depends on Task #$dependsOnId\"\r\n\r\n    Write-PmcDebug -Level 2 -Category \"Dependencies\" -Message \"Dependency added successfully\" -Data @{ TaskId = $taskId; DependsOn = $dependsOnId }\r\n}\r\n\r\nfunction Remove-PmcDependency {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"Dependencies\" -Message \"Starting dep remove\" -Data @{ FreeText = $Context.FreeText }\r\n\r\n    $data = Get-PmcDataAlias\r\n    $ids = $Context.FreeText\r\n\r\n    if ($ids.Count -lt 2) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"Usage: dep remove <task> <depends-on>\"\r\n        return\r\n    }\r\n\r\n    $taskId = $null\r\n    $dependsOnId = $null\r\n\r\n    # Resolve task IDs\r\n    if ($ids[0] -match '^\\d+$') { $taskId = [int]$ids[0] }\r\n    if ($ids[1] -match '^\\d+$') { $dependsOnId = [int]$ids[1] }\r\n\r\n    if (-not $taskId -or -not $dependsOnId) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Invalid task IDs\"\r\n        return\r\n    }\r\n\r\n    $task = $data.tasks | Where-Object { $_.id -eq $taskId } | Select-Object -First 1\r\n\r\n    if (-not $task -or -not (Pmc-HasProp $task 'depends') -or -not $task.depends) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"No such dependency found\"\r\n        return\r\n    }\r\n\r\n    # Remove dependency\r\n    $task.depends = @($task.depends | Where-Object { $_ -ne $dependsOnId })\r\n\r\n    # Clean up empty depends array\r\n    if ($task.depends.Count -eq 0) { try { $task.PSObject.Properties.Remove('depends') } catch {} }\r\n\r\n    # Update blocked status for all tasks\r\n    Update-PmcBlockedStatus -data $data\r\n\r\n    Save-StrictData $data 'dep remove'\r\n    Write-Host \"Removed dependency: Task #$taskId no longer depends on Task #$dependsOnId\" -ForegroundColor Green\r\n\r\n    Write-PmcDebug -Level 2 -Category \"Dependencies\" -Message \"Dependency removed successfully\" -Data @{ TaskId = $taskId; DependsOn = $dependsOnId }\r\n}\r\n\r\nfunction Show-PmcDependencies {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"Dependencies\" -Message \"Starting dep show\" -Data @{ FreeText = $Context.FreeText }\r\n\r\n    $data = Get-PmcDataAlias\r\n    $text = ($Context.FreeText -join ' ').Trim()\r\n\r\n    if (-not $text) {\r\n        Write-Host \"Usage: dep show <task>\" -ForegroundColor Yellow\r\n        return\r\n    }\r\n\r\n    $taskId = $null\r\n    if ($text -match '^\\d+$') { $taskId = [int]$text }\r\n\r\n    if (-not $taskId) {\r\n        Write-Host \"Invalid task ID\" -ForegroundColor Red\r\n        return\r\n    }\r\n\r\n    $task = $data.tasks | Where-Object { $_.id -eq $taskId } | Select-Object -First 1\r\n\r\n    if (-not $task) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Task #$taskId not found\"\r\n        return\r\n    }\r\n\r\n    Write-Host \"`nDEPENDENCIES for Task #$taskId\" -ForegroundColor Cyan\r\n    Write-Host (\"Task: {0}\" -f $task.text) -ForegroundColor White\r\n    Write-PmcStyled -Style 'Border' -Text \"─────────────────────────────────\"\r\n\r\n    $depends = $(if ((Pmc-HasProp $task 'depends') -and $task.depends) { $task.depends } else { @() })\r\n\r\n    if ($depends.Count -eq 0) {\r\n        Write-Host \"  No dependencies\" -ForegroundColor Gray\r\n        return\r\n    }\r\n\r\n    $rows = @()\r\n    foreach ($depId in $depends) {\r\n        $depTask = $data.tasks | Where-Object { $_.id -eq $depId } | Select-Object -First 1\r\n        $status = $(if ($depTask) { $depTask.status } else { 'missing' })\r\n        $text = $(if ($depTask) { $depTask.text } else { '(missing task)' })\r\n        $rows += @{ id = \"#$depId\"; status = $status; text = $text }\r\n    }\r\n\r\n    # Convert to universal display format\r\n    $columns = @{\r\n        \"id\" = @{ Header = \"ID\"; Width = 6; Alignment = \"Left\"; Editable = $false }\r\n        \"status\" = @{ Header = \"Status\"; Width = 10; Alignment = \"Center\"; Editable = $false }\r\n        \"text\" = @{ Header = \"Task\"; Width = 50; Alignment = \"Left\"; Editable = $false }\r\n    }\r\n\r\n    # Convert rows to PSCustomObject format\r\n    $dataObjects = @()\r\n    foreach ($row in $rows) {\r\n        $obj = New-Object PSCustomObject\r\n        foreach ($key in $row.Keys) {\r\n            $obj | Add-Member -NotePropertyName $key -NotePropertyValue $row[$key]\r\n        }\r\n        $dataObjects += $obj\r\n    }\r\n\r\n    # Use template display\r\n    $depTemplate = [PmcTemplate]::new('dependencies', @{\r\n        type = 'grid'\r\n        header = 'Task ID   Title                          Type        Status'\r\n        row = '{id,-9} {title,-30} {type,-10} {status}'\r\n    })\r\n    Write-PmcStyled -Style 'Header' -Text \"Dependencies for Task #$taskId\"\r\n    Render-GridTemplate -Data $dataObjects -Template $depTemplate\r\n\r\n    # Show if this task is blocked\r\n    if ($task.blocked) {\r\n        Write-Host \"`n[WARN]️  This task is BLOCKED by pending dependencies\" -ForegroundColor Red\r\n    } else {\r\n        Write-Host \"`n✅ This task is ready to work on\" -ForegroundColor Green\r\n    }\r\n\r\n    Write-PmcDebug -Level 2 -Category \"Dependencies\" -Message \"Dependencies shown successfully\" -Data @{ TaskId = $taskId; DependencyCount = $depends.Count }\r\n}\r\n\r\nfunction Show-PmcDependencyGraph {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"Dependencies\" -Message \"Starting dep graph\"\r\n\r\n    $data = Get-PmcDataAlias\r\n    $rows = @()\r\n\r\n    foreach ($task in $data.tasks) {\r\n        if ((Pmc-HasProp $task 'depends') -and @($task.depends).Count -gt 0) {\r\n            $dependsText = ($task.depends -join ', ')\r\n            $status = $(if ($task.blocked) { \"🔒 BLOCKED\" } else { \"✅ Ready\" })\r\n            $rows += @{\r\n                task = \"#$($task.id)\"\r\n                depends = $dependsText\r\n                status = $status\r\n                text = $task.text\r\n            }\r\n        }\r\n    }\r\n\r\n    if (@($rows).Count -eq 0) {\r\n        Write-Host \"`nDEPENDENCY GRAPH\" -ForegroundColor Cyan\r\n        Write-Host \"No task dependencies found\" -ForegroundColor Gray\r\n        return\r\n    }\r\n\r\n    # Convert to universal display format\r\n    $columns = @{\r\n        \"task\" = @{ Header = \"Task\"; Width = 8; Alignment = \"Left\"; Editable = $false }\r\n        \"depends\" = @{ Header = \"Depends On\"; Width = 15; Alignment = \"Left\"; Editable = $false }\r\n        \"status\" = @{ Header = \"Status\"; Width = 12; Alignment = \"Center\"; Editable = $false }\r\n        \"text\" = @{ Header = \"Description\"; Width = 40; Alignment = \"Left\"; Editable = $false }\r\n    }\r\n\r\n    # Convert rows to PSCustomObject format\r\n    $dataObjects = @()\r\n    foreach ($row in $rows) {\r\n        $obj = New-Object PSCustomObject\r\n        foreach ($key in $row.Keys) {\r\n            $obj | Add-Member -NotePropertyName $key -NotePropertyValue $row[$key]\r\n        }\r\n        $dataObjects += $obj\r\n    }\r\n\r\n    # Use template display\r\n    $depTemplate = [PmcTemplate]::new('dep-graph', @{\r\n        type = 'grid'\r\n        header = 'Task ID   Title                          Type        Status'\r\n        row = '{id,-9} {title,-30} {type,-10} {status}'\r\n    })\r\n    Write-PmcStyled -Style 'Header' -Text 'DEPENDENCY GRAPH'\r\n    Render-GridTemplate -Data $dataObjects -Template $depTemplate\r\n\r\n    # Summary statistics\r\n    $blockedCount = @($data.tasks | Where-Object { $_.blocked }).Count\r\n    $dependentCount = @($data.tasks | Where-Object { (Pmc-HasProp $_ 'depends') -and $_.depends }).Count\r\n\r\n    Write-Host \"`nSummary:\" -ForegroundColor Cyan\r\n    Write-Host \"  Tasks with dependencies: $dependentCount\" -ForegroundColor White\r\n    Write-Host \"  Currently blocked tasks: $blockedCount\" -ForegroundColor $(if ($blockedCount -gt 0) { 'Red' } else { 'Green' })\r\n\r\n    Write-PmcDebug -Level 2 -Category \"Dependencies\" -Message \"Dependency graph shown successfully\" -Data @{ DependentTasks = $dependentCount; BlockedTasks = $blockedCount }\r\n}\r\n\r\nExport-ModuleMember -Function Update-PmcBlockedStatus, Add-PmcDependency, Remove-PmcDependency, Show-PmcDependencies, Show-PmcDependencyGraph"}, {"path": "module/Pmc.Strict/src/Excel.ps1", "content": "# ExcelT2020.ps1 - Excel T2020 integration for PMC\r\n# Restored from working ExcelT2020.psm1 functionality\r\n\r\n# =============================\r\n# Editable Configuration Section\r\n# =============================\r\n\r\n# Global configuration variables (user-editable)\r\n$Global:ExcelT2020_SourceFolder = Join-Path $PSScriptRoot 'excel_input'\r\n$Global:ExcelT2020_DestinationPath = Join-Path $PSScriptRoot 'excel_output.xlsm'\r\n$Global:ExcelT2020_DestSheetName = 'Output'\r\n$Global:ExcelT2020_SourceSheetName = 'SVI-CAS'\r\n\r\n# Field mappings: copy from SourceSheet:SourceCell to DestSheet:DestCell\r\n$Global:ExcelT2020_Mappings = @(\r\n    @{ Field='RequestDate';    SourceCell='W23'; DestCell='B2'  }\r\n    @{ Field='AuditType';      SourceCell='W78'; DestCell='B3'  }\r\n    @{ Field='AuditorName';    SourceCell='W10'; DestCell='B4'  }\r\n    @{ Field='TPName';         SourceCell='W3';  DestCell='B5'  }\r\n    @{ Field='TPEmailAddress'; SourceCell='X3';  DestCell='B6'  }\r\n    @{ Field='TPPhoneNumber';  SourceCell='Y3';  DestCell='B7'  }\r\n    @{ Field='TaxID';          SourceCell='W13'; DestCell='B8'  }\r\n    @{ Field='CASNumber';      SourceCell='G17'; DestCell='B9'  }\r\n)\r\n\r\n# Logging and summary storage\r\n$Global:ExcelT2020_LogPath = Join-Path $PSScriptRoot 'excel_t2020.log'\r\n$Global:ExcelT2020_SummaryPath = Join-Path $PSScriptRoot 'excel_t2020_summary.json'\r\n\r\n# =============================\r\n# Excel COM Management\r\n# =============================\r\n\r\n$script:ExcelApp = $null\r\n\r\nfunction New-ExcelApp {\r\n    if ($script:ExcelApp -ne $null) { return $script:ExcelApp }\r\n    try {\r\n        $app = New-Object -ComObject Excel.Application\r\n        $app.Visible = $false\r\n        $app.DisplayAlerts = $false\r\n        $script:ExcelApp = $app\r\n        return $script:ExcelApp\r\n    } catch {\r\n        throw \"Excel COM is not available. Ensure Excel is installed. Error: $_\"\r\n    }\r\n}\r\n\r\nfunction Close-ExcelApp {\r\n    if ($script:ExcelApp -ne $null) {\r\n        try { $script:ExcelApp.Quit() } catch {}\r\n        try { [void][Runtime.InteropServices.Marshal]::ReleaseComObject($script:ExcelApp) } catch {}\r\n        $script:ExcelApp = $null\r\n    }\r\n}\r\n\r\nfunction Open-Workbook {\r\n    param(\r\n        [Parameter(Mandatory)] [string]$Path,\r\n        [switch]$ReadOnly\r\n    )\r\n    $app = New-ExcelApp\r\n    if (-not (Test-Path $Path)) { throw \"Workbook not found: $Path\" }\r\n    try { return $app.Workbooks.Open($Path, $false, [bool]$ReadOnly) } catch { throw \"Failed to open workbook '$Path': $_\" }\r\n}\r\n\r\nfunction Save-Workbook {\r\n    param([Parameter(Mandatory)] $Workbook)\r\n    try { $Workbook.Save() } catch { throw \"Failed to save workbook: $_\" }\r\n}\r\n\r\nfunction Close-Workbook {\r\n    param([Parameter(Mandatory)] $Workbook)\r\n    try { $Workbook.Close($false) } catch {}\r\n}\r\n\r\nfunction Get-Worksheet {\r\n    param(\r\n        [Parameter(Mandatory)] $Workbook,\r\n        [Parameter(Mandatory)] [string]$Name\r\n    )\r\n    try { return $Workbook.Worksheets.Item($Name) } catch { throw \"Worksheet '$Name' not found in '$($Workbook.Name)'.\" }\r\n}\r\n\r\n# =============================\r\n# Core T2020 Operations\r\n# =============================\r\n\r\nfunction Copy-CellValue {\r\n    param(\r\n        [Parameter(Mandatory)] $SourceSheet,\r\n        [Parameter(Mandatory)] [string]$SourceCell,\r\n        [Parameter(Mandatory)] $DestSheet,\r\n        [Parameter(Mandatory)] [string]$DestCell\r\n    )\r\n    $srcRange = $SourceSheet.Range($SourceCell)\r\n    $dstRange = $DestSheet.Range($DestCell)\r\n\r\n    $val = $srcRange.Value2\r\n    if ($null -eq $val -or $val -eq '') {\r\n        $dstRange.Value2 = ''\r\n    } else {\r\n        $srcRange.Copy() | Out-Null\r\n        $dstRange.PasteSpecial(-4163) | Out-Null  # xlPasteValues\r\n        (New-ExcelApp).CutCopyMode = 0\r\n    }\r\n}\r\n\r\nfunction Extract-T2020Fields {\r\n    param(\r\n        [Parameter(Mandatory)] [string]$SourcePath,\r\n        [string]$SourceSheetName = $Global:ExcelT2020_SourceSheetName,\r\n        [array] $Mappings        = $Global:ExcelT2020_Mappings\r\n    )\r\n    $srcWb = $null\r\n    try {\r\n        $srcWb = Open-Workbook -Path $SourcePath -ReadOnly\r\n        $wsSrc = Get-Worksheet -Workbook $srcWb -Name $SourceSheetName\r\n        $data = [ordered]@{}\r\n        foreach ($m in $Mappings) {\r\n            $val = $wsSrc.Range($m.SourceCell).Value2\r\n            $data[$m.Field] = $val\r\n        }\r\n        return @{ Success=$true; Data=$data }\r\n    } catch {\r\n        return @{ Success=$false; Error=\"Extract failed: $_\" }\r\n    } finally {\r\n        if ($srcWb) { Close-Workbook -Workbook $srcWb }\r\n    }\r\n}\r\n\r\nfunction Copy-T2020ForFile {\r\n    param(\r\n        [Parameter(Mandatory)] [string]$SourcePath,\r\n        [Parameter(Mandatory)] [string]$DestinationPath,\r\n        [string]$SourceSheetName = $Global:ExcelT2020_SourceSheetName,\r\n        [string]$DestSheetName   = $Global:ExcelT2020_DestSheetName,\r\n        [array] $Mappings        = $Global:ExcelT2020_Mappings\r\n    )\r\n    $srcWb = $null; $dstWb = $null\r\n    try {\r\n        $srcWb = Open-Workbook -Path $SourcePath -ReadOnly\r\n        $dstWb = Open-Workbook -Path $DestinationPath\r\n\r\n        $wsSrc = Get-Worksheet -Workbook $srcWb -Name $SourceSheetName\r\n        $wsDst = Get-Worksheet -Workbook $dstWb -Name $DestSheetName\r\n\r\n        foreach ($m in $Mappings) {\r\n            Copy-CellValue -SourceSheet $wsSrc -SourceCell $m.SourceCell -DestSheet $wsDst -DestCell $m.DestCell\r\n        }\r\n\r\n        Save-Workbook -Workbook $dstWb\r\n        return @{ Success=$true; Message=\"Copied $($Mappings.Count) fields from '$SourcePath' to '$DestinationPath'\" }\r\n    } catch {\r\n        return @{ Success=$false; Error=\"Copy failed: $_\" }\r\n    } finally {\r\n        if ($srcWb) { Close-Workbook -Workbook $srcWb }\r\n        if ($dstWb) { Close-Workbook -Workbook $dstWb }\r\n    }\r\n}\r\n\r\nfunction Invoke-T2020Batch {\r\n    param(\r\n        [string]$SourceFolder = $Global:ExcelT2020_SourceFolder,\r\n        [string]$DestinationPath = $Global:ExcelT2020_DestinationPath,\r\n        [string]$SourcePattern = '*.xlsm',\r\n        [switch]$WhatIf\r\n    )\r\n    if (-not (Test-Path $SourceFolder)) { throw \"Source folder not found: $SourceFolder\" }\r\n    $files = Get-ChildItem -Path $SourceFolder -Filter $SourcePattern -File | Sort-Object Name\r\n    if ($files.Count -eq 0) { return @{ Success=$true; Message='No files found'; Processed=0 } }\r\n\r\n    $processed = 0\r\n    $summary = @()\r\n    foreach ($f in $files) {\r\n        if ($WhatIf) {\r\n            Write-Host \"Would copy from '$($f.FullName)' to '$DestinationPath'\" -ForegroundColor Yellow\r\n            continue\r\n        }\r\n        $extract = Extract-T2020Fields -SourcePath $f.FullName\r\n        $res = Copy-T2020ForFile -SourcePath $f.FullName -DestinationPath $DestinationPath\r\n        $ok = ($res.Success -and $extract.Success)\r\n        $processed += [int]$ok\r\n        $record = [ordered]@{\r\n            Timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n            Source    = $f.FullName\r\n            Destination = $DestinationPath\r\n            Count     = $Global:ExcelT2020_Mappings.Count\r\n            Success   = $ok\r\n            Error     = $(if ($ok) { '' } else { $(if ($null -ne $res.Error) { $res.Error } else { $extract.Error }) })\r\n            Fields    = $(if ($extract.Success) { $extract.Data } else { @{} })\r\n        }\r\n        $summary += $record\r\n        try {\r\n            \"$($record.Timestamp) | $($record.Source) -> $($record.Destination) | Count=$($record.Count) | Success=$($record.Success) | $($record.Error)\" | Add-Content -Path $Global:ExcelT2020_LogPath -Encoding UTF8\r\n        } catch {}\r\n    }\r\n    # Persist JSON summary (append)\r\n    try {\r\n        $existing = @()\r\n        if (Test-Path $Global:ExcelT2020_SummaryPath) {\r\n            $existing = Get-Content $Global:ExcelT2020_SummaryPath -Raw | ConvertFrom-Json\r\n        }\r\n        $all = @()\r\n        if ($existing) { $all += $existing }\r\n        $all += $summary\r\n        ($all | ConvertTo-Json -Depth 10) | Set-Content -Path $Global:ExcelT2020_SummaryPath -Encoding UTF8\r\n    } catch {}\r\n    return @{ Success=$true; Processed=$processed; Summary=$summary }\r\n}\r\n\r\nfunction Set-ExcelT2020Config {\r\n    param(\r\n        [string]$SourceFolder,\r\n        [string]$DestinationPath,\r\n        [string]$SourceSheetName,\r\n        [string]$DestSheetName\r\n    )\r\n    if ($PSBoundParameters.ContainsKey('SourceFolder'))     { $Global:ExcelT2020_SourceFolder = $SourceFolder }\r\n    if ($PSBoundParameters.ContainsKey('DestinationPath'))  { $Global:ExcelT2020_DestinationPath = $DestinationPath }\r\n    if ($PSBoundParameters.ContainsKey('SourceSheetName'))  { $Global:ExcelT2020_SourceSheetName = $SourceSheetName }\r\n    if ($PSBoundParameters.ContainsKey('DestSheetName'))    { $Global:ExcelT2020_DestSheetName = $DestSheetName }\r\n}\r\n\r\n# =============================\r\n# PMC Excel Command Functions\r\n# =============================\r\n\r\nfunction Import-PmcFromExcel {\r\n    [CmdletBinding()]\r\n    param([PmcCommandContext]$Context)\r\n\r\n    try {\r\n        $result = Invoke-T2020Batch -WhatIf:$Context.Args.ContainsKey('whatif')\r\n\r\n        if (-not $result.Success) {\r\n            Write-PmcStyled -Style 'Error' -Text (\"Excel import failed: {0}\" -f $result.Error)\r\n            return\r\n        }\r\n\r\n        # Simple display\r\n        Write-PmcStyled -Style 'Success' -Text (\"Excel T2020 import completed: {0} files processed\" -f $result.Processed)\r\n\r\n        # Store import history\r\n        $data = Get-PmcData\r\n        if (-not $data.excelImports) {\r\n            $data | Add-Member -NotePropertyName excelImports -NotePropertyValue @() -Force\r\n        }\r\n        $data.excelImports += $result.Summary\r\n\r\n        # Keep only last 50 imports\r\n        if ($data.excelImports.Count -gt 50) {\r\n            $data.excelImports = $data.excelImports[-50..-1]\r\n        }\r\n\r\n        Save-PmcData -Data $data\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text (\"Excel import error: {0}\" -f $_)\r\n    } finally {\r\n        Close-ExcelApp\r\n    }\r\n}\r\n\r\n# Wrappers to align with CommandMap function names\r\nfunction Import-PmcExcelData { param([PmcCommandContext]$Context) Import-PmcFromExcel -Context $Context }\r\nfunction Show-PmcExcelPreview { param([PmcCommandContext]$Context) Show-PmcExcelData -Context $Context }\r\nfunction Get-PmcLatestExcelFile { param([PmcCommandContext]$Context) Get-PmcLatestExcelData -Context $Context }\r\n\r\nfunction Show-PmcExcelData {\r\n    param([PmcCommandContext]$Context)\r\n    try {\r\n        if (-not (Test-Path $Global:ExcelT2020_SourceFolder)) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Source folder not found: $Global:ExcelT2020_SourceFolder\"\r\n            return\r\n        }\r\n        $files = Get-ChildItem -Path $Global:ExcelT2020_SourceFolder -Filter '*.xlsm' -File\r\n        if ($files.Count -eq 0) {\r\n            Write-PmcStyled -Style 'Warning' -Text \"No Excel files found in: $Global:ExcelT2020_SourceFolder\"\r\n            return\r\n        }\r\n        $extract = Extract-T2020Fields -SourcePath $files[0].FullName\r\n        if ($extract.Success) {\r\n            Write-PmcStyled -Style 'Info' -Text \"Excel T2020 Preview ($($files.Count) files found):\"\r\n            foreach ($field in $extract.Data.GetEnumerator()) {\r\n                $value = $(if ($field.Value -and $field.Value.ToString().Length -gt 30) { $field.Value.ToString().Substring(0, 27) + \"...\" } else { $field.Value })\r\n                Write-Host \"  $($field.Key): $value\"\r\n            }\r\n        } else {\r\n            Write-PmcStyled -Style 'Error' -Text \"Failed to preview: $($extract.Error)\"\r\n        }\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Excel view error: $_\"\r\n    } finally {\r\n        Close-ExcelApp\r\n    }\r\n}\r\n\r\nfunction Get-PmcLatestExcelData {\r\n    param([PmcCommandContext]$Context)\r\n    try {\r\n        $data = Get-PmcData\r\n        $imports = @($data.excelImports)\r\n        if ($imports.Count -eq 0) {\r\n            Write-PmcStyled -Style 'Warning' -Text \"No Excel imports found. Run 'excel import' first.\"\r\n            return\r\n        }\r\n        $recent = $imports | Select-Object -Last 10\r\n        Write-PmcStyled -Style 'Info' -Text \"Recent Excel Imports:\"\r\n        foreach ($import in $recent) {\r\n            $status = $(if ($import.Success) { '[OK]' } else { '[ERROR]' })\r\n            Write-Host \"  $($import.Timestamp) $($import.Source) $status\"\r\n        }\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Excel latest error: $_\"\r\n    }\r\n}\r\n\r\n#Export-ModuleMember -Function New-ExcelApp, Close-ExcelApp, Open-Workbook, Save-Workbook, Close-Workbook, Get-Worksheet, Copy-CellValue, Extract-T2020Fields, Copy-T2020ForFile, Invoke-T2020Batch, Set-ExcelT2020Config, Import-PmcFromExcel, Import-PmcExcelData, Show-PmcExcelPreview, Get-PmcLatestExcelFile, Show-PmcExcelData, Get-PmcLatestExcelData"}, {"path": "module/Pmc.Strict/src/ExcelFlowLite.ps1", "content": "# ExcelFlowLite.ps1 - Minimal interactive path picker + config hooks for Excel flow\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nfunction Get-XFlowCfgVal {\r\n    param([object]$Cfg,[string]$Key,[object]$Default=$null)\r\n    if ($Cfg -is [hashtable]) { if ($Cfg.ContainsKey($Key)) { return $Cfg[$Key] } else { return $Default } }\r\n    if ($Cfg -is [pscustomobject]) { if ($Cfg.PSObject.Properties[$Key]) { return $Cfg.$Key } else { return $Default } }\r\n    return $Default\r\n}\r\n\r\nfunction Get-XFlowMapVal {\r\n    param([object]$Map,[string]$Key,[object]$Default=$null)\r\n    if ($Map -is [hashtable]) { if ($Map.ContainsKey($Key)) { return $Map[$Key] } else { return $Default } }\r\n    if ($Map -is [pscustomobject]) { if ($Map.PSObject.Properties[$Key]) { return $Map.$Key } else { return $Default } }\r\n    return $Default\r\n}\r\n\r\nfunction Get-PmcXFlowConfig {\r\n    $data = Get-PmcData\r\n    if (-not $data.PSObject.Properties['excelFlow']) {\r\n        $data | Add-Member -NotePropertyName excelFlow -NotePropertyValue @{ config=@{}; runs=@() } -Force\r\n    } else {\r\n        if (-not ($data.excelFlow -is [hashtable])) { try { $data.excelFlow = @{} + $data.excelFlow } catch { $data.excelFlow = @{} } }\r\n        if (-not $data.excelFlow.PSObject.Properties['config']) { $data.excelFlow['config'] = @{} }\r\n        if (-not $data.excelFlow.PSObject.Properties['runs']) { $data.excelFlow['runs'] = @() }\r\n    }\r\n    return $data\r\n}\r\n\r\nfunction Set-PmcXFlowConfigValue {\r\n    param(\r\n        [Parameter(Mandatory)] [string]$Key,\r\n        [Parameter(Mandatory)] [string]$Value\r\n    )\r\n    $data = Get-PmcXFlowConfig\r\n    $data.excelFlow.config[$Key] = $Value\r\n    Save-PmcData -Data $data -Action (\"xflow:set:{0}\" -f $Key)\r\n}\r\n\r\nfunction Invoke-PmcPathPicker {\r\n    param(\r\n        [string]$StartDir = '.',\r\n        [ValidateSet('File','Directory')] [string]$Pick = 'File',\r\n        [string[]]$Extensions = @(),\r\n        [string]$Title = 'Select Path'\r\n    )\r\n\r\n    # Resolve and validate starting directory\r\n    $current = $StartDir\r\n    try { if (-not (Test-Path $current)) { $current = (Get-Location).Path } } catch { $current = (Get-Location).Path }\r\n\r\n    while ($true) {\r\n        # Gather entries\r\n        $rows = @()\r\n\r\n        # Parent directory entry when possible\r\n        try {\r\n            $root = [System.IO.Path]::GetPathRoot([System.IO.Path]::GetFullPath($current))\r\n        } catch { $root = $current }\r\n        if ($current -ne $root) {\r\n            $parent = Split-Path $current -Parent\r\n            $rows += [pscustomobject]@{\r\n                Name = '..'\r\n                Type = 'Dir'\r\n                Size = ''\r\n                Modified = ''\r\n                Path = $parent\r\n            }\r\n        }\r\n\r\n        # Directories first\r\n        try {\r\n            $dirs = Get-ChildItem -LiteralPath $current -Directory -ErrorAction SilentlyContinue | Sort-Object Name\r\n            foreach ($d in $dirs) {\r\n                $rows += [pscustomobject]@{\r\n                    Name = $d.Name\r\n                    Type = 'Dir'\r\n                    Size = ''\r\n                    Modified = $d.LastWriteTime.ToString('yyyy-MM-dd HH:mm')\r\n                    Path = $d.FullName\r\n                }\r\n            }\r\n        } catch {}\r\n\r\n        # Files\r\n        try {\r\n            $files = Get-ChildItem -LiteralPath $current -File -ErrorAction SilentlyContinue\r\n            if ($Extensions -and @($Extensions).Count -gt 0) {\r\n                # Normalize extensions list to regex\r\n                $patterns = @()\r\n                foreach ($pat in $Extensions) {\r\n                    if ([string]::IsNullOrWhiteSpace($pat)) { continue }\r\n                    $esc = [Regex]::Escape($pat.Trim())\r\n                    $esc = $esc.Replace('\\\\*', '.*').Replace('\\\\?', '.')\r\n                    $patterns += \"^$esc$\"\r\n                }\r\n                $files = $files | Where-Object { $name = $_.Name; $patterns | Where-Object { $name -match $_ } }\r\n            }\r\n            $files = $files | Sort-Object Name\r\n            foreach ($f in $files) {\r\n                $rows += [pscustomobject]@{\r\n                    Name = $f.Name\r\n                    Type = 'File'\r\n                    Size = $f.Length\r\n                    Modified = $f.LastWriteTime.ToString('yyyy-MM-dd HH:mm')\r\n                    Path = $f.FullName\r\n                }\r\n            }\r\n        } catch {}\r\n\r\n        # Add a cancel row to allow exit without selection\r\n        $rows = ,([pscustomobject]@{ Name='[Cancel]'; Type='Action'; Size=''; Modified=''; Path='' }) + $rows\r\n\r\n        # Columns configuration\r\n        $cols = @{\r\n            Name     = @{ Header='Name';     Width=38; Alignment='Left' }\r\n            Type     = @{ Header='Type';     Width=6;  Alignment='Left' }\r\n            Size     = @{ Header='Size';     Width=10; Alignment='Right' }\r\n            Modified = @{ Header='Modified'; Width=16; Alignment='Center' }\r\n        }\r\n\r\n        # Render interactively using ScreenManager header + grid in navigation mode\r\n        $displayTitle = \"{0} — {1}\" -f $Title, $current\r\n        if (Get-Command Set-PmcHeader -ErrorAction SilentlyContinue) {\r\n            Set-PmcHeader -Title $displayTitle -Status 'Nav: ENTER select  •  Q exit'\r\n            if (Get-Command Clear-PmcContentArea -ErrorAction SilentlyContinue) { Clear-PmcContentArea }\r\n        } else {\r\n            Write-PmcStyled -Style 'Title' -Text (\"`n$displayTitle\")\r\n            $winW = [PmcTerminalService]::GetWidth()\r\n            Write-PmcStyled -Style 'Border' -Text (\"─\" * [Math]::Max(20, $winW))\r\n        }\r\n\r\n        $selectedIndex = 1\r\n        try {\r\n            $renderer = [PmcGridRenderer]::new($cols, @('file-browser'), @{})\r\n            $renderer.EditMode = $false  # Navigation mode\r\n            $script:_xflow_picker_selectedIndex = -1\r\n            $renderer.OnSelectCallback = { param($item, $row) $script:_xflow_picker_selectedIndex = $row; $renderer.Interactive = $false }\r\n            $renderer.StartInteractive($rows)\r\n            if ($script:_xflow_picker_selectedIndex -ge 0) { $selectedIndex = [int]$script:_xflow_picker_selectedIndex }\r\n            else { $selectedIndex = [int]$renderer.SelectedRow }\r\n        } catch {\r\n            $selectedIndex = 1\r\n        }\r\n\r\n        if ($selectedIndex -lt 0 -or $selectedIndex -ge @($rows).Count) { return '' }\r\n        $sel = $rows[$selectedIndex]\r\n        if ($sel.Name -eq '[Cancel]') { return '' }\r\n\r\n        if ($sel.Type -eq 'Dir') {\r\n            if ($Pick -eq 'Directory') { return [string]$sel.Path }\r\n            # Drill into directory and refresh\r\n            $current = [string]$sel.Path\r\n            continue\r\n        }\r\n\r\n        if ($sel.Type -eq 'File') {\r\n            if ($Pick -eq 'File') { return [string]$sel.Path }\r\n            # If picking a directory but file selected, stay in loop\r\n            continue\r\n        }\r\n    }\r\n}\r\n\r\nfunction Set-PmcXFlowSourcePathInteractive {\r\n    param([PmcCommandContext]$Context)\r\n    try {\r\n        $data = Get-PmcXFlowConfig\r\n        $start = (Get-Location).Path\r\n        if ($data.excelFlow.config.ContainsKey('SourceFile')) {\r\n            try { $start = Split-Path [string]$data.excelFlow.config['SourceFile'] -Parent } catch {}\r\n        }\r\n        $path = Invoke-PmcPathPicker -StartDir $start -Pick 'File' -Extensions @('*.xls','*.xlsx','*.xlsm') -Title 'Select Source Excel Workbook'\r\n        if ([string]::IsNullOrWhiteSpace($path)) {\r\n            Write-PmcStyled -Style 'Warning' -Text 'No source file selected.'\r\n            return\r\n        }\r\n        Set-PmcXFlowConfigValue -Key 'SourceFile' -Value $path\r\n        Write-PmcStyled -Style 'Success' -Text (\"SourceFile set: {0}\" -f $path)\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text (\"Source selection failed: {0}\" -f $_)\r\n    }\r\n}\r\n\r\nfunction Set-PmcXFlowDestPathInteractive {\r\n    param([PmcCommandContext]$Context)\r\n    try {\r\n        $data = Get-PmcXFlowConfig\r\n        $start = (Get-Location).Path\r\n        if ($data.excelFlow.config.ContainsKey('DestFile')) {\r\n            try { $start = Split-Path [string]$data.excelFlow.config['DestFile'] -Parent } catch {}\r\n        } elseif ($data.excelFlow.config.ContainsKey('SourceFile')) {\r\n            try { $start = Split-Path [string]$data.excelFlow.config['SourceFile'] -Parent } catch {}\r\n        }\r\n        $path = Invoke-PmcPathPicker -StartDir $start -Pick 'File' -Extensions @('*.xls','*.xlsx','*.xlsm') -Title 'Select Destination Excel Workbook'\r\n        if ([string]::IsNullOrWhiteSpace($path)) {\r\n            Write-PmcStyled -Style 'Warning' -Text 'No destination file selected.'\r\n            return\r\n        }\r\n        Set-PmcXFlowConfigValue -Key 'DestFile' -Value $path\r\n        Write-PmcStyled -Style 'Success' -Text (\"DestFile set: {0}\" -f $path)\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text (\"Destination selection failed: {0}\" -f $_)\r\n    }\r\n}\r\n\r\nfunction Get-PmcXFlowConfigData {\r\n    # Returns current config without inventing field mappings\r\n    $data = Get-PmcXFlowConfig\r\n    return $data.excelFlow.config\r\n}\r\n\r\nfunction Save-PmcXFlowConfigData {\r\n    param([hashtable]$Config)\r\n    $data = Get-PmcXFlowConfig\r\n    $data.excelFlow.config = $Config\r\n    Save-PmcData -Data $data -Action 'xflow:save-config'\r\n}\r\n\r\nfunction New-XFlowWorkbook {\r\n    param([string]$Path)\r\n    try {\r\n        $app = $null\r\n        try { $app = New-ExcelApp } catch { $app = $null }\r\n        if (-not $app) { $app = New-Object -ComObject Excel.Application }\r\n        $app.Visible = $false; $app.DisplayAlerts = $false\r\n        $wb = $app.Workbooks.Add()\r\n        $wb.SaveAs($Path)\r\n        return $wb\r\n    } catch { throw \"Failed to create workbook: $_\" }\r\n}\r\n\r\nfunction Get-OrAddWorksheet {\r\n    param([Parameter(Mandatory)] $Workbook,[Parameter(Mandatory)][string]$Name)\r\n    try { return $Workbook.Worksheets.Item($Name) } catch {\r\n        try { $ws = $Workbook.Worksheets.Add(); $ws.Name = $Name; return $ws } catch { throw \"Failed to get or create sheet '$Name': $_\" }\r\n    }\r\n}\r\n\r\nfunction Export-XFlowToJson {\r\n    param([hashtable]$Data,[string]$OutPath)\r\n    $obj = @{ ExportTimestamp=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss'); FieldCount=$Data.Count; Data=$Data }\r\n    $safe = Get-PmcSafePath $OutPath\r\n    $dir = Split-Path $safe -Parent; if ($dir -and -not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null }\r\n    $obj | ConvertTo-Json -Depth 10 | Set-Content -Path $safe -Encoding UTF8\r\n    return $safe\r\n}\r\n\r\nfunction Export-XFlowToCsv {\r\n    param([hashtable]$Data,[string]$OutPath)\r\n    $headers = $Data.Keys | Sort-Object\r\n    $vals = @(); foreach ($h in $headers) { $v = $(if ($Data[$h]) { $Data[$h].ToString() } else { '' }); if ($v -match ',|\"|`n') { $v = '\"' + $v.Replace('\"','\"\"') + '\"' }; $vals += $v }\r\n    $lines = @(); $lines += ($headers -join ','); $lines += ($vals -join ',')\r\n    $safe = Get-PmcSafePath $OutPath\r\n    $dir = Split-Path $safe -Parent; if ($dir -and -not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null }\r\n    $lines | Set-Content -Path $safe -Encoding UTF8\r\n    return $safe\r\n}\r\n\r\nfunction Show-PmcXFlowPreview {\r\n    param([PmcCommandContext]$Context)\r\n    $max = 10; try { if ($Context.Args.ContainsKey('max')) { $max = [int]$Context.Args['max'] } } catch {}\r\n    $dry = $false; try { $dry = $Context.Args.ContainsKey('dry') } catch {}\r\n    $cfg = Get-PmcXFlowConfigData\r\n    if (-not ($cfg -is [hashtable]) -or -not $cfg.ContainsKey('FieldMappings') -or @($cfg['FieldMappings'].Keys).Count -eq 0) { Write-PmcStyled -Style 'Warning' -Text 'No FieldMappings configured. Import mappings first.'; return }\r\n\r\n    if ($dry) {\r\n        Write-PmcStyled -Style 'Title' -Text 'XFlow Preview (dry)'\r\n        Write-PmcStyled -Style 'Border' -Text (\"─\" * 50)\r\n        $names = $cfg['FieldMappings'].Keys | Select-Object -First $max\r\n        foreach ($n in $names) {\r\n            $map = $cfg['FieldMappings'][$n]\r\n            $cell = [string](Get-XFlowMapVal $map 'Cell' '')\r\n            $srcSheet = [string](Get-XFlowMapVal $map 'Sheet' (Get-XFlowCfgVal $cfg 'SourceSheet' ''))\r\n            Write-Host (\"  {0,-20} {1,-12} {2,-10} {3}\" -f $n, $srcSheet, $cell, '(dry)')\r\n        }\r\n        return\r\n    }\r\n\r\n    $srcPath = [string](Get-XFlowCfgVal $cfg 'SourceFile' '')\r\n    if (-not $srcPath) { Write-PmcStyled -Style 'Warning' -Text 'No SourceFile configured. Use xflow browse-source.'; return }\r\n    if (-not (Test-Path $srcPath)) { Write-PmcStyled -Style 'Error' -Text (\"Source file not found: {0}\" -f $srcPath); return }\r\n\r\n    $srcWb = $null\r\n    try {\r\n        $srcWb = Open-Workbook -Path $cfg.SourceFile -ReadOnly\r\n        $sheetCache = @{}\r\n        $names = $cfg['FieldMappings'].Keys | Select-Object -First $max\r\n        Write-PmcStyled -Style 'Title' -Text (\"XFlow Preview - {0}\" -f (Split-Path $srcPath -Leaf))\r\n        Write-PmcStyled -Style 'Border' -Text (\"─\" * 50)\r\n        foreach ($n in $names) {\r\n            $map = $cfg['FieldMappings'][$n]\r\n            $cell = [string](Get-XFlowMapVal $map 'Cell' '')\r\n            $srcSheet = [string](Get-XFlowMapVal $map 'Sheet' (Get-XFlowCfgVal $cfg 'SourceSheet' ''))\r\n            if (-not $sheetCache.ContainsKey($srcSheet)) { $sheetCache[$srcSheet] = Get-Worksheet -Workbook $srcWb -Name $srcSheet }\r\n            $wsSrc = $sheetCache[$srcSheet]\r\n            $val = $null; try { $val = $wsSrc.Range($cell).Value2 } catch {}\r\n            $short = $(if ($val) { $s=$val.ToString(); if ($s.Length -gt 50) { $s.Substring(0,47)+'...' } else { $s } } else { '' })\r\n            Write-Host (\"  {0,-20} {1,-12} {2,-10} {3}\" -f $n, $srcSheet, $cell, $short)\r\n        }\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text (\"Preview failed: {0}\" -f $_)\r\n    } finally {\r\n        if ($srcWb) { Close-Workbook -Workbook $srcWb }\r\n        Close-ExcelApp\r\n    }\r\n}\r\n\r\nfunction Invoke-PmcXFlowRun {\r\n    param([PmcCommandContext]$Context)\r\n    $args = $Context.Args\r\n    $whatIf = $args.ContainsKey('whatif')\r\n    $noExcel = $args.ContainsKey('noexcel') -or $args.ContainsKey('noexcelexport')\r\n    $dry = $args.ContainsKey('dry')\r\n    $format = $null; if ($args.ContainsKey('format')) { $format = [string]$args['format'] }\r\n    $valuesPath = $null; if ($args.ContainsKey('values')) { $valuesPath = [string]$args['values'] }\r\n\r\n    $cfg = Get-PmcXFlowConfigData\r\n    if (-not ($cfg -is [hashtable]) -or -not $cfg.ContainsKey('FieldMappings') -or @($cfg['FieldMappings'].Keys).Count -eq 0) { Write-PmcStyled -Style 'Warning' -Text 'No FieldMappings configured. Import mappings first.'; return }\r\n\r\n    $start = Get-Date\r\n    $srcWb = $null; $dstWb = $null\r\n    $extracted = @{}\r\n    $errors = @()\r\n\r\n    try {\r\n        if ($dry) {\r\n            # Build synthetic extraction values\r\n            $provided = $null\r\n            if ($valuesPath -and (Test-Path $valuesPath)) {\r\n                try {\r\n                    $raw = Get-Content -Path $valuesPath -Raw | ConvertFrom-Json -AsHashtable\r\n                    if ($raw.ContainsKey('Data')) { $provided = $raw['Data'] } else { $provided = $raw }\r\n                } catch { $provided = $null; $errors += \"Failed to parse values file: $valuesPath\" }\r\n            }\r\n            foreach ($field in $cfg['FieldMappings'].Keys) {\r\n                if ($provided -and ($provided -is [hashtable]) -and $provided.ContainsKey($field)) {\r\n                    $extracted[$field] = $provided[$field]\r\n                } else {\r\n                    $m = $cfg['FieldMappings'][$field]\r\n                    $srcSheet = [string](Get-XFlowMapVal $m 'Sheet' (Get-XFlowCfgVal $cfg 'SourceSheet' ''))\r\n                    $cell = [string](Get-XFlowMapVal $m 'Cell' '')\r\n                    $extracted[$field] = (\"<{0}!{1}>\" -f $srcSheet, $cell)\r\n                }\r\n            }\r\n        } else {\r\n            $srcPath = [string](Get-XFlowCfgVal $cfg 'SourceFile' '')\r\n            if (-not $srcPath) { Write-PmcStyled -Style 'Warning' -Text 'No SourceFile configured. Use xflow browse-source.'; return }\r\n            if (-not (Test-Path $srcPath)) { Write-PmcStyled -Style 'Error' -Text (\"Source file not found: {0}\" -f $srcPath); return }\r\n            if ($whatIf) { Write-PmcStyled -Style 'Info' -Text 'WhatIf: extracting values (no writes).' }\r\n            $srcWb = Open-Workbook -Path $srcPath -ReadOnly\r\n            $srcSheets = @{}\r\n            foreach ($field in $cfg['FieldMappings'].Keys) {\r\n                $map = $cfg['FieldMappings'][$field]\r\n                $cell = [string](Get-XFlowMapVal $map 'Cell' '')\r\n                $srcSheet = [string](Get-XFlowMapVal $map 'Sheet' (Get-XFlowCfgVal $cfg 'SourceSheet' ''))\r\n                try {\r\n                    if (-not $srcSheets.ContainsKey($srcSheet)) { $srcSheets[$srcSheet] = Get-Worksheet -Workbook $srcWb -Name $srcSheet }\r\n                    $wsSrc = $srcSheets[$srcSheet]\r\n                    $val = $wsSrc.Range($cell).Value2\r\n                } catch { $val=$null; $errors += \"Read failed: $field $srcSheet!$cell\" }\r\n                $extracted[$field] = $val\r\n            }\r\n\r\n            $destPath = [string](Get-XFlowCfgVal $cfg 'DestFile' '')\r\n            if (-not $noExcel -and $destPath) {\r\n                if (-not $whatIf) {\r\n                    if (Test-Path $destPath) { $dstWb = Open-Workbook -Path $destPath } else { $dstWb = New-XFlowWorkbook -Path $destPath }\r\n                    $dstSheets = @{}\r\n                    foreach ($field in $cfg['FieldMappings'].Keys) {\r\n                        $map = $cfg['FieldMappings'][$field]\r\n                        $dest = [string](Get-XFlowMapVal $map 'DestCell' '')\r\n                        $dstSheetName = [string](Get-XFlowMapVal $map 'DestSheet' (Get-XFlowCfgVal $cfg 'DestSheet' ''))\r\n                        if ($dest -and $dest.Trim().Length -gt 0) {\r\n                            try {\r\n                                if (-not $dstSheets.ContainsKey($dstSheetName)) { $dstSheets[$dstSheetName] = Get-OrAddWorksheet -Workbook $dstWb -Name $dstSheetName }\r\n                                $wsDst = $dstSheets[$dstSheetName]\r\n                                $wsDst.Range($dest).Value2 = $extracted[$field]\r\n                            } catch { $errors += \"Write failed: $field $dstSheetName!$dest\" }\r\n                        }\r\n                    }\r\n                    try { Save-Workbook -Workbook $dstWb } catch { $errors += \"Save failed: $destPath\" }\r\n                } else {\r\n                    Write-PmcStyled -Style 'Info' -Text (\"WhatIf: would update destination workbook: {0}\" -f $destPath)\r\n                }\r\n            }\r\n        }\r\n\r\n        # Optional text export\r\n        $exportPath = $null\r\n        if ($format) {\r\n            $ts = (Get-Date).ToString('yyyyMMdd_HHmmss')\r\n            switch ($format.ToUpper()) {\r\n                'CSV' { $exportPath = Export-XFlowToCsv -Data $extracted -OutPath (\"exports/ExcelDataExport_{0}.csv\" -f $ts) }\r\n                'JSON' { $exportPath = Export-XFlowToJson -Data $extracted -OutPath (\"exports/ExcelDataExport_{0}.json\" -f $ts) }\r\n                default { Write-PmcStyled -Style 'Warning' -Text (\"Unsupported format: {0} (use csv|json)\" -f $format) }\r\n            }\r\n        }\r\n\r\n        # Record run\r\n        $data = Get-PmcXFlowConfig\r\n        $run = [ordered]@{\r\n            Timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n            SourceFile = (Get-XFlowCfgVal $cfg 'SourceFile' '(dry)')\r\n            DestFile = (Get-XFlowCfgVal $cfg 'DestFile' '')\r\n            FieldCount = @($cfg['FieldMappings'].Keys).Count\r\n            Success = ($errors.Count -eq 0)\r\n            Errors = $errors\r\n            DurationMs = [int]((Get-Date) - $start).TotalMilliseconds\r\n            ExportPath = $exportPath\r\n            DryRun = $dry\r\n        }\r\n        $data.excelFlow['latestExtract'] = $extracted\r\n        if (-not $data.excelFlow.PSObject.Properties['runs'] -or -not $data.excelFlow.runs) { $data.excelFlow['runs'] = @() }\r\n        $data.excelFlow.runs += $run\r\n        if (@($data.excelFlow.runs).Count -gt 20) { $data.excelFlow.runs = $data.excelFlow.runs[-20..-1] }\r\n        Save-PmcData -Data $data -Action 'xflow:run'\r\n\r\n        if ($run.Success) {\r\n            Write-PmcStyled -Style 'Success' -Text (\"XFlow {0} run completed. {1} fields.\" -f $(if ($dry) { 'dry' } else { 'live' }), $run.FieldCount)\r\n            if ($exportPath) { Write-PmcStyled -Style 'Info' -Text (\"Text export: {0}\" -f $exportPath) }\r\n        } else {\r\n            Write-PmcStyled -Style 'Warning' -Text (\"XFlow completed with errors: {0}\" -f ($errors -join '; '))\r\n        }\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text (\"Run failed: {0}\" -f $_)\r\n    } finally {\r\n        if ($srcWb) { try { Close-Workbook -Workbook $srcWb } catch {} }\r\n        if ($dstWb) { try { Close-Workbook -Workbook $dstWb } catch {} }\r\n        try { Close-ExcelApp } catch {}\r\n    }\r\n}\r\n\r\nfunction Import-PmcXFlowMappingsFromFile {\r\n    param([PmcCommandContext]$Context)\r\n    # Parse FreeText tokens like path:<file> or a single <file>\r\n    $path = $null\r\n    foreach ($t in $Context.FreeText) {\r\n        if ($t -match '^(?i)path:(.+)$') { $path = $matches[1]; break }\r\n        # If a token looks like a json file path and path: not used, take it\r\n        if ($t -match '\\.json$') { $path = $t; break }\r\n    }\r\n    if (-not $path) {\r\n        # No path provided: open interactive file picker for JSON\r\n        try {\r\n            $start = (Get-Location).Path\r\n            $picked = Invoke-PmcPathPicker -StartDir $start -Pick 'File' -Extensions @('*.json') -Title 'Select ExcelDataFlow settings.json'\r\n            if ($picked) { $path = $picked }\r\n        } catch { }\r\n    }\r\n    if (-not $path) { Write-PmcStyled -Style 'Info' -Text \"Usage: xflow import-mappings path:<settings.json> (or choose interactively)\"; return }\r\n    if (-not (Test-Path $path)) { Write-PmcStyled -Style 'Error' -Text (\"File not found: {0}\" -f $path); return }\r\n    try {\r\n        $json = Get-Content -Path $path -Raw | ConvertFrom-Json -AsHashtable\r\n        $spec = $null\r\n        if ($json.ContainsKey('ExcelMappings')) { $spec = $json['ExcelMappings'] }\r\n        else { $spec = $json }\r\n        if (-not $spec -or -not $spec.ContainsKey('FieldMappings')) { Write-PmcStyled -Style 'Error' -Text 'No FieldMappings section found.'; return }\r\n\r\n        $cfg = Get-PmcXFlowConfigData\r\n        # Copy top-level fields if available\r\n        foreach ($k in @('SourceFile','DestFile','SourceSheet','DestSheet')) { if ($spec.ContainsKey($k) -and $spec[$k]) { $cfg[$k] = [string]$spec[$k] } }\r\n\r\n        # Exact FieldMappings transfer (no invention)\r\n        $out = @{}\r\n        foreach ($fname in $spec.FieldMappings.Keys) {\r\n            $m = $spec.FieldMappings[$fname]\r\n            $entry = @{}\r\n            foreach ($mk in @('Sheet','Cell','DestCell','DestSheet')) {\r\n                if ($m.PSObject.Properties[$mk] -and $m[$mk]) { $entry[$mk] = [string]$m[$mk] }\r\n            }\r\n            $out[$fname] = $entry\r\n        }\r\n        $cfg['FieldMappings'] = $out\r\n        Save-PmcXFlowConfigData -Config $cfg\r\n        Write-PmcStyled -Style 'Success' -Text (\"Imported {0} field mappings from {1}\" -f $out.Keys.Count, $path)\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text (\"Import failed: {0}\" -f $_)\r\n    }\r\n}\r\n\r\nfunction Export-PmcXFlowText {\r\n    param([PmcCommandContext]$Context)\r\n    $format = 'CSV'; if ($Context.Args.ContainsKey('format')) { $format = [string]$Context.Args['format'] }\r\n    $data = Get-PmcXFlowConfig\r\n    if (-not $data.excelFlow.PSObject.Properties['latestExtract'] -or -not $data.excelFlow.latestExtract) { Write-PmcStyled -Style 'Warning' -Text 'No latest extract found. Run xflow run first.'; return }\r\n    $extracted = $data.excelFlow.latestExtract\r\n    $ts = (Get-Date).ToString('yyyyMMdd_HHmmss')\r\n    switch ($format.ToUpper()) {\r\n        'CSV'  { $out = Export-XFlowToCsv -Data $extracted -OutPath (\"exports/ExcelDataExport_{0}.csv\" -f $ts) }\r\n        'JSON' { $out = Export-XFlowToJson -Data $extracted -OutPath (\"exports/ExcelDataExport_{0}.json\" -f $ts) }\r\n        default { Write-PmcStyled -Style 'Warning' -Text (\"Unsupported format: {0} (use csv|json)\" -f $format); return }\r\n    }\r\n    Write-PmcStyled -Style 'Success' -Text (\"Exported {0} fields to {1}\" -f $extracted.Keys.Count, $out)\r\n}\r\n\r\nfunction Set-PmcXFlowLatestFromFile {\r\n    param([PmcCommandContext]$Context)\r\n    if (-not $Context.Args.ContainsKey('values')) { Write-PmcStyled -Style 'Info' -Text \"Usage: xflow set-latest values:<path.json>\"; return }\r\n    $path = [string]$Context.Args['values']\r\n    if (-not (Test-Path $path)) { Write-PmcStyled -Style 'Error' -Text (\"File not found: {0}\" -f $path); return }\r\n    try {\r\n        $raw = Get-Content -Path $path -Raw | ConvertFrom-Json -AsHashtable\r\n        $dict = $(if ($raw.ContainsKey('Data')) { $raw['Data'] } else { $raw })\r\n        if (-not ($dict -is [hashtable])) { Write-PmcStyled -Style 'Error' -Text 'Values JSON must be an object or contain a Data object.'; return }\r\n        $data = Get-PmcXFlowConfig\r\n        $data.excelFlow['latestExtract'] = $dict\r\n        Save-PmcData -Data $data -Action 'xflow:set-latest'\r\n        Write-PmcStyled -Style 'Success' -Text (\"latestExtract set from {0}. Fields: {1}\" -f $path, $dict.Keys.Count)\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text (\"Failed to set latest: {0}\" -f $_)\r\n    }\r\n}\r\n\r\nfunction Show-PmcXFlowConfig {\r\n    param([PmcCommandContext]$Context)\r\n    $cfg = Get-PmcXFlowConfigData\r\n    if (-not ($cfg -is [hashtable])) { Write-PmcStyled -Style 'Info' -Text 'No xflow config found.'; return }\r\n    $sf = [string](Get-XFlowCfgVal $cfg 'SourceFile' '')\r\n    $ss = [string](Get-XFlowCfgVal $cfg 'SourceSheet' '')\r\n    $df = [string](Get-XFlowCfgVal $cfg 'DestFile' '')\r\n    $ds = [string](Get-XFlowCfgVal $cfg 'DestSheet' '')\r\n    $fm = $null; if ($cfg.ContainsKey('FieldMappings')) { $fm = $cfg['FieldMappings'] } else { $fm = @{} }\r\n    $count = @($fm.Keys).Count\r\n    Write-PmcStyled -Style 'Title' -Text 'XFlow Configuration'\r\n    Write-Host (\"  SourceFile  : {0}\" -f $(if ($sf) { $sf } else { '(none)' }))\r\n    Write-Host (\"  SourceSheet : {0}\" -f $(if ($ss) { $ss } else { '(none)' }))\r\n    Write-Host (\"  DestFile    : {0}\" -f $(if ($df) { $df } else { '(none)' }))\r\n    Write-Host (\"  DestSheet   : {0}\" -f $(if ($ds) { $ds } else { '(none)' }))\r\n    Write-Host (\"  Fields      : {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        Write-PmcStyled -Style 'Border' -Text (\"─\" * 50)\r\n        $names = $fm.Keys | Sort-Object | Select-Object -First 10\r\n        foreach ($n in $names) {\r\n            $m = $fm[$n]\r\n            $sheet = [string](Get-XFlowMapVal $m 'Sheet' $ss)\r\n            $cell  = [string](Get-XFlowMapVal $m 'Cell' '')\r\n            $dsh   = [string](Get-XFlowMapVal $m 'DestSheet' $ds)\r\n            $dcl   = [string](Get-XFlowMapVal $m 'DestCell' '')\r\n            Write-Host (\"  {0,-20} {1,-12} {2,-8} -> {3,-12} {4}\" -f $n, $sheet, $cell, $dsh, $dcl)\r\n        }\r\n        if ($count -gt 10) { Write-PmcStyled -Style 'Muted' -Text (\"  ... and {0} more\" -f ($count - 10)) }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/src/Execution.ps1", "content": "# Execution pipeline for domain-action commands\r\n\r\nfunction Set-PmcContextDefaults {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    # Apply default values based on domain/action patterns\r\n    # This function sets defaults for common arguments to simplify command usage\r\n\r\n    if (-not $Context.Args) { $Context.Args = @{} }\r\n    if (-not $Context.FreeText) { $Context.FreeText = @() }\r\n\r\n    # Domain-specific defaults\r\n    switch ($Context.Domain) {\r\n        'task' {\r\n            # For task operations, ensure priority defaults exist\r\n            if ($Context.Action -in @('add', 'update', 'edit') -and -not $Context.Args.ContainsKey('priority')) {\r\n                $Context.Args['priority'] = 0  # Default priority\r\n            }\r\n        }\r\n        'project' {\r\n            # Project operations may need defaults\r\n            if ($Context.Action -eq 'add' -and -not $Context.Args.ContainsKey('status')) {\r\n                $Context.Args['status'] = 'active'  # Default status\r\n            }\r\n        }\r\n        'time' {\r\n            # Time logging defaults\r\n            if ($Context.Action -eq 'log' -and -not $Context.Args.ContainsKey('date')) {\r\n                $Context.Args['date'] = (Get-Date).ToString('yyyy-MM-dd')  # Default to today\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction Normalize-PmcContextFields {\r\n    param([PmcCommandContext]$Context)\r\n    if (-not $Context -or -not $Context.Domain) { return }\r\n    try {\r\n        $schemas = Get-PmcFieldSchemasForDomain -Domain $Context.Domain\r\n        foreach ($k in @($Context.Args.Keys)) {\r\n            if ($schemas.ContainsKey($k)) {\r\n                $sch = $schemas[$k]\r\n                if ($sch.ContainsKey('Normalize') -and $sch.Normalize) {\r\n                    try {\r\n                        $Context.Args[$k] = & $sch.Normalize ([string]$Context.Args[$k])\r\n                    } catch {\r\n                        # Leave raw value; validation will surface the error later\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch { }\r\n}\r\n\r\nfunction Resolve-PmcHandler {\r\n    param([string]$Domain,[string]$Action)\r\n    if (-not $Script:PmcCommandMap.ContainsKey($Domain)) { return $null }\r\n    $map = $Script:PmcCommandMap[$Domain]\r\n    if (-not $map.ContainsKey($Action)) { return $null }\r\n    return $map[$Action]\r\n}\r\n\r\nfunction Resolve-PmcProjectFromTokens {\r\n    param(\r\n        [string[]] $Tokens,\r\n        [int] $StartIndex\r\n    )\r\n    # Returns a hashtable: @{ Name = <string>; Consumed = <int> }\r\n    # If no resolution, returns @{ Name=$null; Consumed=1 } (consume only the '@...' token)\r\n    $result = @{ Name = $null; Consumed = 1 }\r\n    if ($StartIndex -lt 0 -or $StartIndex -ge $Tokens.Count) { return $result }\r\n    $first = $Tokens[$StartIndex]\r\n    if (-not ($first -match '^@(.+)$')) { return $result }\r\n\r\n    $initial = $matches[1]\r\n    $candidates = @()\r\n    try {\r\n        $data = Get-PmcDataAlias\r\n        $projects = @($data.projects | ForEach-Object { [string]$_.name })\r\n        if (-not $projects) { return $result }\r\n\r\n        # Greedily extend with following plain tokens (no prefixes, not '--')\r\n        $bestName = $null\r\n        $bestLen = 1\r\n        $current = $initial\r\n        if ($projects -contains $current) { $bestName = $current; $bestLen = 1 }\r\n\r\n        for ($i = $StartIndex + 1; $i -lt $Tokens.Count; $i++) {\r\n            $t = $Tokens[$i]\r\n            if ($t -eq '--' -or $t -match '^@' -or $t -match '^(p[1-3])$' -or $t -match '^due:' -or $t -match '^#' -or $t -match '^-#') {\r\n                break\r\n            }\r\n            $current = \"$current $t\"\r\n            if ($projects -contains $current) { $bestName = $current; $bestLen = ($i - $StartIndex + 1) }\r\n        }\r\n\r\n        if ($bestName) {\r\n            $result.Name = $bestName\r\n            $result.Consumed = $bestLen\r\n            return $result\r\n        }\r\n    } catch { }\r\n\r\n    return $result\r\n}\r\n\r\nfunction Parse-PmcArgsFromTokens {\r\n    param(\r\n        [string[]] $Tokens,\r\n        [int] $StartIndex = 0\r\n    )\r\n\r\n    $args = @{}\r\n    $free = @()\r\n    $seenPlain = $false\r\n    for ($i = $StartIndex; $i -lt $Tokens.Count; $i++) {\r\n        $t = $Tokens[$i]\r\n        if ($seenPlain) { $free += $t; continue }\r\n        if ($t -eq '--') { $seenPlain = $true; continue }\r\n        if ($t -match '^@') {\r\n            $res = Resolve-PmcProjectFromTokens -Tokens $Tokens -StartIndex $i\r\n            if ($res.Name) { $args['project'] = $res.Name; $i += ($res.Consumed - 1); continue }\r\n            if ($t -match '^@(.+)$') { $args['project'] = $matches[1]; continue }\r\n        }\r\n        if ($t -eq '-i') { $args['interactive'] = $true; continue }\r\n        if ($t -match '^(?i)task:(\\d+)$') { $args['taskId'] = [int]$matches[1]; continue }\r\n        if ($t -match '^(p[1-3])$') { $args['priority'] = $matches[1]; continue }\r\n        if ($t -match '^due:(.+)$') { $args['due'] = $matches[1]; continue }\r\n        if ($t -match '^#(.+)$' -or $t -match '^\\+(.+)$') { if (-not $args.ContainsKey('tags')) { $args['tags']=@() }; $args['tags'] += $matches[1]; continue }\r\n        if ($t -match '^-#?(.+)$') { if (-not $args.ContainsKey('removeTags')) { $args['removeTags']=@() }; $args['removeTags'] += $matches[1]; continue }\r\n        $seenPlain = $true\r\n        $free += $t\r\n    }\r\n    return @{ Args = $args; Free = $free }\r\n}\r\n\r\nfunction ConvertTo-PmcIdSet {\r\n    param([string]$text)\r\n    $ids = @()\r\n    foreach ($part in ($text -split ',')) {\r\n        $p = $part.Trim()\r\n        if ($p -match '^(\\d+)-(\\d+)$') { $a=[int]$matches[1]; $b=[int]$matches[2]; if ($a -le $b) { for ($i=$a; $i -le $b; $i++) { $ids += $i } } else { for ($i=$a; $i -ge $b; $i--) { $ids += $i } } }\r\n        elseif ($p -match '^\\d+$') { $ids += [int]$p }\r\n    }\r\n    return @($ids | Select-Object -Unique)\r\n}\r\n\r\nfunction ConvertTo-PmcContext {\r\n    param([string[]]$Tokens)\r\n    if ($Tokens.Count -lt 1) { return @{ Success=$false; Error='Empty command' } }\r\n\r\n    # Special handling for 'help' so users can type: 'help', 'help guide [topic]', 'help examples [topic]', 'help query', 'help domain <d>', 'help command <d> <a>'\r\n    if ($Tokens[0].ToLower() -eq 'help') {\r\n        if ($Tokens.Count -eq 1) {\r\n            $ctx = [PmcCommandContext]::new('help','show')\r\n            $ctx.Raw = 'help show'\r\n            return @{ Success=$true; Context=$ctx; Handler='Show-PmcSmartHelp' }\r\n        } elseif ($Tokens.Count -ge 2) {\r\n            $sub = $Tokens[1].ToLower()\r\n            switch ($sub) {\r\n                'guide' {\r\n                    $ctx = [PmcCommandContext]::new('help','guide')\r\n                    $ctx.Raw = ($Tokens -join ' ')\r\n                    if ($Tokens.Count -ge 3) { $ctx.FreeText = @($Tokens[2]) }\r\n                    return @{ Success=$true; Context=$ctx; Handler='Show-PmcHelpGuide' }\r\n                }\r\n                'search' {\r\n                    $ctx = [PmcCommandContext]::new('help','search')\r\n                    $ctx.Raw = ($Tokens -join ' ')\r\n                    if ($Tokens.Count -ge 3) { $ctx.FreeText = @(($Tokens[2..($Tokens.Count-1)] -join ' ')) }\r\n                    else { $ctx.FreeText = @('') }\r\n                    return @{ Success=$true; Context=$ctx; Handler='Show-PmcHelpSearch' }\r\n                }\r\n                'examples' {\r\n                    $ctx = [PmcCommandContext]::new('help','examples')\r\n                    $ctx.Raw = ($Tokens -join ' ')\r\n                    if ($Tokens.Count -ge 3) { $ctx.FreeText = @($Tokens[2]) }\r\n                    return @{ Success=$true; Context=$ctx; Handler='Show-PmcHelpExamples' }\r\n                }\r\n                'query' {\r\n                    $ctx = [PmcCommandContext]::new('help','query')\r\n                    $ctx.Raw = ($Tokens -join ' ')\r\n                    return @{ Success=$true; Context=$ctx; Handler='Show-PmcHelpQuery' }\r\n                }\r\n                'domain' {\r\n                    $ctx = [PmcCommandContext]::new('help','domain')\r\n                    $ctx.Raw = ($Tokens -join ' ')\r\n                    if ($Tokens.Count -ge 3) { $ctx.FreeText = @($Tokens[2]) }\r\n                    return @{ Success=$true; Context=$ctx; Handler='Show-PmcHelpDomain' }\r\n                }\r\n                'command' {\r\n                    $ctx = [PmcCommandContext]::new('help','command')\r\n                    $ctx.Raw = ($Tokens -join ' ')\r\n                    if ($Tokens.Count -ge 4) { $ctx.FreeText = @($Tokens[2], $Tokens[3]) }\r\n                    return @{ Success=$true; Context=$ctx; Handler='Show-PmcHelpCommand' }\r\n                }\r\n                default {\r\n                    if ($Tokens.Count -eq 2) {\r\n                        # Interpret as: help domain <domain>\r\n                        $ctx = [PmcCommandContext]::new('help','domain')\r\n                        $ctx.Raw = ($Tokens -join ' ')\r\n                        $ctx.FreeText = @($Tokens[1])\r\n                        return @{ Success=$true; Context=$ctx; Handler='Show-PmcHelpDomain' }\r\n                    } else {\r\n                        # Interpret as: help command <domain> <action>\r\n                        $ctx = [PmcCommandContext]::new('help','command')\r\n                        $ctx.Raw = ($Tokens -join ' ')\r\n                        $ctx.FreeText = @($Tokens[1], $Tokens[2])\r\n                        return @{ Success=$true; Context=$ctx; Handler='Show-PmcHelpCommand' }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    # Treat first token matching a shortcut as a shortcut command (with args)\r\n    $firstToken = $Tokens[0].ToLower()\r\n    if ($Script:PmcShortcutMap.ContainsKey($firstToken)) {\r\n        $fn = $Script:PmcShortcutMap[$firstToken]\r\n        $ctx = [PmcCommandContext]::new('shortcut', $firstToken)\r\n        $ctx.Raw = ($Tokens -join ' ')\r\n        $parsedArgs = Parse-PmcArgsFromTokens -Tokens $Tokens -StartIndex 1\r\n        $ctx.Args = $parsedArgs.Args\r\n        $ctx.FreeText = $parsedArgs.Free\r\n        return @{ Success=$true; Context=$ctx; Handler=$fn }\r\n    }\r\n\r\n    # No fallback here — shortcuts must be initialized by the module loader\r\n\r\n    # Standard domain-action parsing\r\n    if ($Tokens.Count -lt 2) {\r\n        return @{ Success=$false; Error='Missing action. Use: <domain> <action> [...] or use shortcuts like: add, done, list' }\r\n    }\r\n    $domain = $Tokens[0].ToLower()\r\n    $action = $Tokens[1].ToLower()\r\n    $fn = Resolve-PmcHandler -Domain $domain -Action $action\r\n    if (-not $fn) {\r\n        if (-not $Script:PmcCommandMap.ContainsKey($domain)) {\r\n            return @{ Success=$false; Error=\"Unknown domain '$domain'\" }\r\n        }\r\n        return @{ Success=$false; Error=\"Unknown action '$action' for domain '$domain'\" }\r\n    }\r\n    $ctx = [PmcCommandContext]::new($domain,$action)\r\n    $ctx.Raw = ($Tokens -join ' ')\r\n    # Use AST-based parsing instead of regex-heavy token parsing\r\n    $commandText = ($Tokens -join ' ')\r\n\r\n    # Try AST-based parsing first\r\n    try {\r\n        if (Get-Command ConvertTo-PmcCommandAst -ErrorAction SilentlyContinue) {\r\n            $astResult = ConvertTo-PmcCommandAst -CommandText $commandText\r\n            $ctx.Args = $astResult.Args\r\n            $ctx.FreeText = $astResult.FreeText\r\n            Write-PmcDebug -Level 2 -Category 'Execution' -Message \"Using AST-based argument parsing\"\r\n        } else {\r\n            # Fallback to legacy parsing if AST not available\r\n            $rest = @($Tokens | Select-Object -Skip 2)\r\n            $parsed = Parse-PmcArgsFromTokens -Tokens $rest -StartIndex 0\r\n            $ctx.Args = $parsed.Args\r\n            $ctx.FreeText = $parsed.Free\r\n            Write-PmcDebug -Level 2 -Category 'Execution' -Message \"Using legacy token parsing\"\r\n        }\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'Execution' -Message \"AST parsing failed, using legacy: $_\"\r\n        # Fallback to legacy parsing\r\n        $rest = @($Tokens | Select-Object -Skip 2)\r\n        $parsed = Parse-PmcArgsFromTokens -Tokens $rest -StartIndex 0\r\n        $ctx.Args = $parsed.Args\r\n        $ctx.FreeText = $parsed.Free\r\n    }\r\n    # Normalize known field values using Field Schemas\r\n    Normalize-PmcContextFields -Context $ctx\r\n    return @{ Success=$true; Context=$ctx; Handler=$fn }\r\n}\r\n\r\nfunction Invoke-PmcCommand {\r\n    param([Parameter(Mandatory=$true)][string]$Buffer)\r\n\r\n    Write-PmcDebugCommand -Command $Buffer -Status 'START'\r\n\r\n    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n\r\n    try {\r\n        # Expand user-defined aliases before tokenization\r\n        # Check for alias expansion\r\n        if (Get-Command Expand-PmcUserAliases -ErrorAction SilentlyContinue) {\r\n            $Buffer = Expand-PmcUserAliases -Buffer $Buffer\r\n        }\r\n\r\n        $tokens = ConvertTo-PmcTokens $Buffer\r\n        Write-PmcDebug -Level 2 -Category 'PARSER' -Message \"Tokenized command\" -Data @{ TokenCount = $tokens.Count; Tokens = $tokens }\r\n\r\n        $parsed = ConvertTo-PmcContext $tokens\r\n        if (-not $parsed.Success) {\r\n            Write-PmcDebugCommand -Command $Buffer -Status 'PARSE_ERROR' -Context @{ Error = $parsed.Error } -Timing $stopwatch.ElapsedMilliseconds\r\n            Write-PmcStyled -Style 'Error' -Text \"Error: $($parsed.Error)\"\r\n            return\r\n        }\r\n\r\n        $fn = $parsed.Handler\r\n        $ctx = $parsed.Context\r\n\r\n        Write-PmcDebug -Level 2 -Category 'PARSER' -Message \"Context parsed\" -Data @{ Domain = $ctx.Domain; Action = $ctx.Action; ArgCount = $ctx.Args.Count; Handler = $fn }\r\n\r\n        try {\r\n            Set-PmcContextDefaults -Context $ctx\r\n            Write-PmcDebug -Level 3 -Category 'COERCION' -Message \"Context coerced\" -Data @{ Args = $ctx.Args }\r\n        } catch {\r\n            Write-PmcDebug -Level 1 -Category 'COERCION' -Message \"Coercion failed: $_\"\r\n        }\r\n\r\n        try {\r\n            $ok = Test-PmcContext -Context $ctx\r\n            if (-not $ok) {\r\n                Write-PmcDebugCommand -Command $Buffer -Status 'VALIDATION_ERROR' -Context @{ Domain = $ctx.Domain; Action = $ctx.Action } -Timing $stopwatch.ElapsedMilliseconds\r\n                return\r\n            }\r\n            Write-PmcDebug -Level 3 -Category 'VALIDATION' -Message \"Context validated successfully\"\r\n        } catch {\r\n            Write-PmcDebug -Level 1 -Category 'VALIDATION' -Message \"Validation failed: $_\"\r\n        }\r\n\r\n        if (Get-Command -Name $fn -ErrorAction SilentlyContinue) {\r\n            Write-PmcDebug -Level 2 -Category 'Execution' -Message \"About to execute function: $fn\"\r\n            $cmdInfo = Get-Command -Name $fn -ErrorAction SilentlyContinue\r\n            $srcFile = $null\r\n            try { if ($cmdInfo -and $cmdInfo.CommandType -eq 'Function' -and $cmdInfo.ScriptBlock) { $srcFile = $cmdInfo.ScriptBlock.File } } catch { }\r\n            $sourceInfo = $(if ($null -ne $srcFile) { $srcFile } else { '(unknown)' })\r\n            Write-PmcDebug -Level 2 -Category 'EXECUTION' -Message \"Invoking handler: $fn\" -Data @{ Source = $sourceInfo }\r\n\r\n            & $fn -Context $ctx\r\n\r\n            $stopwatch.Stop()\r\n            Write-PmcDebugCommand -Command $Buffer -Status 'SUCCESS' -Context @{ Domain = $ctx.Domain; Action = $ctx.Action; Handler = $fn } -Timing $stopwatch.ElapsedMilliseconds\r\n        } else {\r\n            Write-PmcDebugCommand -Command $Buffer -Status 'NO_HANDLER' -Context @{ Domain = $ctx.Domain; Action = $ctx.Action; Handler = $fn } -Timing $stopwatch.ElapsedMilliseconds\r\n            Write-PmcStyled -Style 'Warning' -Text \"Not implemented: $($ctx.Domain) $($ctx.Action)\"\r\n        }\r\n\r\n    } catch {\r\n        $stopwatch.Stop()\r\n        Write-PmcDebugCommand -Command $Buffer -Status 'ERROR' -Context @{ Error = $_.ToString(); Exception = $_.Exception.GetType().Name } -Timing $stopwatch.ElapsedMilliseconds\r\n        Write-PmcStyled -Style 'Error' -Text \"Command execution failed: $_\"\r\n    }\r\n}\r\n\r\nfunction ConvertTo-PmcContextType {\r\n    param([PmcCommandContext]$Context)\r\n    if (-not $Context) { return }\r\n    $key = \"$($Context.Domain) $($Context.Action)\".ToLower()\r\n    $schema = $(if ($Script:PmcParameterMap.ContainsKey($key)) { $Script:PmcParameterMap[$key] } else { @() })\r\n    if (-not $schema -or @($schema).Count -eq 0) { return }\r\n    # TaskID: parse first free text token to ids if applicable\r\n    $needsId = $false\r\n    foreach ($def in $schema) { if ($def['Type'] -eq 'TaskID') { $needsId = $true; break } }\r\n    if ($needsId -and @($Context.FreeText).Count -ge 1) {\r\n        $t0 = $Context.FreeText[0]\r\n        if ($t0 -match '^[0-9,\\-]+$') {\r\n            $set = ConvertTo-PmcIdSet $t0\r\n            if (@($set).Count -gt 0) { $Context.Args['ids'] = $set }\r\n        }\r\n        elseif ($t0 -match '^\\d+$') {\r\n            # list index handled in handlers via map; still pass as singleton id candidate\r\n            $Context.Args['ids'] = @([int]$t0)\r\n        }\r\n    }\r\n    # Normalize priority string to int for convenience (add priorityInt) after schema normalization\r\n    if ($Context.Args.ContainsKey('priority')) {\r\n        $pv = [string]$Context.Args['priority']\r\n        if ($pv -match '^[1-3]$') { $Context.Args['priorityInt'] = [int]$pv }\r\n    }\r\n    # Due already normalized by schema; add convenience dueIso if matches ISO\r\n    if ($Context.Args.ContainsKey('due')) {\r\n        $dv = [string]$Context.Args['due']\r\n        if ($dv -match '^\\d{4}-\\d{2}-\\d{2}$') { $Context.Args['dueIso'] = $dv }\r\n    }\r\n\r\n    # Resolve project names when schema expects a ProjectName\r\n    $needsProject = $false\r\n    foreach ($def in $schema) { if ($def['Type'] -eq 'ProjectName') { $needsProject = $true; break } }\r\n    if ($needsProject -and $Context.Args.ContainsKey('project')) {\r\n        try { $data = Get-PmcDataAlias; $p = Resolve-Project -Data $data -Name $Context.Args['project']; if ($p) { $Context.Args['projectNameResolved'] = $p.name } } catch {\r\n            # Project resolution failed - continue without resolved name\r\n        }\r\n    }\r\n\r\n    # Parse duration tokens for commands that expect Duration\r\n    $needsDuration = $false\r\n    foreach ($def in $schema) { if ($def['Type'] -eq 'Duration') { $needsDuration = $true; break } }\r\n    if ($needsDuration) {\r\n        $durTok = $null\r\n        foreach ($t in $Context.FreeText) {\r\n            if ($t -match '^\\d+(?:\\.\\d+)?$' -or $t -match '^\\d+(?:\\.\\d+)?h$' -or $t -match '^\\d+m$') { $durTok = $t; break }\r\n        }\r\n        if ($durTok) {\r\n            try { $mins = ConvertTo-PmcDurationMinutes $durTok; if ($mins -gt 0) { $Context.Args['durationMinutes'] = $mins } } catch {\r\n                # Duration parsing failed - continue without duration\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-PmcContext {\r\n    param([PmcCommandContext]$Context)\r\n    $key = \"$($Context.Domain) $($Context.Action)\".ToLower()\r\n    $schema = $(if ($Script:PmcParameterMap.ContainsKey($key)) { $Script:PmcParameterMap[$key] } else { @() })\r\n    if (-not $schema -or @($schema).Count -eq 0) { return $true }\r\n    $errors = @()\r\n    # Check required schema elements\r\n    foreach ($def in $schema) {\r\n        $name = [string]$def['Name']\r\n        $type = [string]$def['Type']\r\n        $required = $false; try { $required = [bool]$def['Required'] } catch {\r\n            # Schema definition access failed - assume not required\r\n        }\r\n        if (-not $required) { continue }\r\n        switch ($type) {\r\n            'FreeText' {\r\n                if (-not $Context.FreeText -or @($Context.FreeText).Count -eq 0) { $errors += \"Missing required text\" }\r\n            }\r\n            'TaskID' {\r\n                $hasIds = ($Context.Args.ContainsKey('ids') -and @($Context.Args['ids']).Count -gt 0)\r\n                $hasToken = (@($Context.FreeText).Count -ge 1)\r\n                if (-not $hasIds -and -not $hasToken) { $errors += \"Missing required id(s)\" }\r\n            }\r\n            'ProjectName' {\r\n                if (-not $Context.Args.ContainsKey('project')) { $errors += \"Missing required @project\" }\r\n            }\r\n            'Priority' {\r\n                if (-not $Context.Args.ContainsKey('priority') -and -not $Context.Args.ContainsKey('priorityInt')) { $errors += \"Missing required priority (p1/p2/p3)\" }\r\n            }\r\n            'DateString' {\r\n                if (-not $Context.Args.ContainsKey('due') -and -not $Context.Args.ContainsKey('dueIso')) { $errors += \"Missing required date\" }\r\n            }\r\n            'DateRange' {\r\n                # If required, ensure at least one recognizable token exists\r\n                $has = $false\r\n                foreach ($t in $Context.FreeText) {\r\n                    if ($t -match '^(?i)today|yesterday|week$' -or $t -match '^\\d{4}-\\d{2}-\\d{2}$') { $has=$true; break }\r\n                }\r\n                if (-not $has) { $errors += \"Missing required date range\" }\r\n            }\r\n            'Duration' {\r\n                if (-not $Context.Args.ContainsKey('durationMinutes')) {\r\n                    $hasLike = $false\r\n                    foreach ($t in $Context.FreeText) { if ($t -match '^\\d+(?:\\.\\d+)?$' -or $t -match '^\\d+(?:\\.\\d+)?h$' -or $t -match '^\\d+m$') { $hasLike=$true; break } }\r\n                    if (-not $hasLike) { $errors += \"Missing required duration (e.g., 1.5 hours or 90m)\" }\r\n                }\r\n            }\r\n            default { }\r\n        }\r\n    }\r\n    # Field-level validation via Field Schemas\r\n    try {\r\n        $schemas = Get-PmcFieldSchemasForDomain -Domain $Context.Domain\r\n        foreach ($k in @($Context.Args.Keys)) {\r\n            if ($schemas.ContainsKey($k)) {\r\n                $sch = $schemas[$k]\r\n                if ($sch.ContainsKey('Validate') -and $sch.Validate) {\r\n                    try { & $sch.Validate ([string]$Context.Args[$k]) | Out-Null } catch { $errors += $_.Exception.Message }\r\n                }\r\n            }\r\n        }\r\n    } catch { }\r\n\r\n    # Basic tag validation if tags present\r\n    if ($Context.Args.ContainsKey('tags')) {\r\n        foreach ($tag in @($Context.Args['tags'])) { if (-not $tag -or ($tag -match '\\s')) { $errors += (\"Invalid tag '{0}'\" -f $tag) } }\r\n    }\r\n    if (@($errors).Count -gt 0) {\r\n        foreach ($e in $errors) { Write-PmcStyled -Style 'Error' -Text (\"Error: {0}\" -f $e) }\r\n        return $false\r\n    }\r\n    return $true\r\n}\r\n\r\nExport-ModuleMember -Function Set-PmcContextDefaults, Normalize-PmcContextFields, Resolve-PmcHandler, Resolve-PmcProjectFromTokens, Parse-PmcArgsFromTokens, ConvertTo-PmcIdSet, ConvertTo-PmcContext, Invoke-PmcCommand, ConvertTo-PmcContextType, Test-PmcContext"}, {"path": "module/Pmc.Strict/src/FieldSchemas.ps1", "content": "# Domain Field Schemas for PMC (authoritative field rules)\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nfunction Get-PmcFieldSchemasForDomain {\r\n    param([Parameter(Mandatory=$true)][string]$Domain)\r\n\r\n    switch ($Domain.ToLower()) {\r\n        'task' {\r\n            return @{\r\n                'id' = @{\r\n                    Name = 'id'\r\n                    Editable = $false\r\n                    Sensitive = $true\r\n                    Hint = '#'\r\n                    DefaultWidth = 4\r\n                    MinWidth = 3\r\n                    DisplayFormat = { param($val) if ($null -ne $val) { [string]$val } else { '' } }\r\n                }\r\n                'text' = @{\r\n                    Name = 'text'\r\n                    Editable = $true\r\n                    Sensitive = $false\r\n                    Hint = 'task text'\r\n                    DefaultWidth = 40\r\n                    MinWidth = 20\r\n                    Normalize = { param([string]$v) return $(if ($null -ne $v) { $v } else { '' }) }\r\n                    Validate = { param([string]$v) return $true }\r\n                    DisplayFormat = { param($val) if ($null -ne $val) { [string]$val } else { '' } }\r\n                }\r\n                'project' = @{\r\n                    Name = 'project'\r\n                    Editable = $false\r\n                    Sensitive = $true\r\n                    Hint = '@project'\r\n                    DefaultWidth = 12\r\n                    MinWidth = 10\r\n                    Normalize = { param([string]$v) return ($v.TrimStart('@').Trim()) }\r\n                    Validate = { param([string]$v) return $true }\r\n                    DisplayFormat = { param($val) if ($null -ne $val) { [string]$val } else { '' } }\r\n                }\r\n                'due' = @{\r\n                    Name = 'due'\r\n                    Editable = $true\r\n                    Sensitive = $false\r\n                    Hint = 'Many formats: yyyymmdd, mmdd, today, eow, eom, +3, 1m, yyyy/mm/dd, etc.'\r\n                    DefaultWidth = 10\r\n                    MinWidth = 8\r\n                    Normalize = {\r\n                        param([string]$v)\r\n                        $x = $(if ($null -ne $v) { $v } else { '' }).Trim()\r\n                        if ($x -eq '') { return '' }\r\n\r\n                        # Already correct format\r\n                        if ($x -match '^\\d{4}-\\d{2}-\\d{2}$') { return $x }\r\n\r\n                        $today = Get-Date\r\n                        $currentYear = $today.Year\r\n\r\n                        # Special keywords\r\n                        switch -Regex ($x) {\r\n                            '^(?i)today$' { return $today.Date.ToString('yyyy-MM-dd') }\r\n                            '^(?i)tomorrow$' { return $today.Date.AddDays(1).ToString('yyyy-MM-dd') }\r\n                            '^(?i)eow$' {\r\n                                # End of week (Sunday)\r\n                                $daysUntilSunday = (7 - [int]$today.DayOfWeek) % 7\r\n                                if ($daysUntilSunday -eq 0) { $daysUntilSunday = 7 }\r\n                                return $today.Date.AddDays($daysUntilSunday).ToString('yyyy-MM-dd')\r\n                            }\r\n                            '^(?i)eom$' {\r\n                                # End of month\r\n                                $lastDay = [DateTime]::DaysInMonth($today.Year, $today.Month)\r\n                                return (New-Object DateTime($today.Year, $today.Month, $lastDay)).ToString('yyyy-MM-dd')\r\n                            }\r\n                            '^[+-]\\d+$' {\r\n                                # +3, -5 (days from today)\r\n                                $days = [int]$x\r\n                                return $today.Date.AddDays($days).ToString('yyyy-MM-dd')\r\n                            }\r\n                            '^(\\d+)[dmwy]$' {\r\n                                # 1d, 2w, 3m, 1y (relative from today)\r\n                                $matches = [regex]::Match($x, '^(\\d+)([dmwy])$')\r\n                                $num = [int]$matches.Groups[1].Value\r\n                                $unit = $matches.Groups[2].Value.ToLower()\r\n                                $targetDate = switch ($unit) {\r\n                                    'd' { $today.AddDays($num) }\r\n                                    'w' { $today.AddDays($num * 7) }\r\n                                    'm' { $today.AddMonths($num) }\r\n                                    'y' { $today.AddYears($num) }\r\n                                }\r\n                                return $targetDate.Date.ToString('yyyy-MM-dd')\r\n                            }\r\n                            '^(\\d{1,2})(\\d{2})$' {\r\n                                # mmdd format (current year assumed)\r\n                                $matches = [regex]::Match($x, '^(\\d{1,2})(\\d{2})$')\r\n                                $month = [int]$matches.Groups[1].Value\r\n                                $day = [int]$matches.Groups[2].Value\r\n                                if ($month -lt 1 -or $month -gt 12) { throw \"Invalid month: $month\" }\r\n                                if ($day -lt 1 -or $day -gt 31) { throw \"Invalid day: $day\" }\r\n                                return (New-Object DateTime($currentYear, $month, $day)).ToString('yyyy-MM-dd')\r\n                            }\r\n                            '^(\\d{4})(\\d{2})(\\d{2})$' {\r\n                                # yyyymmdd format\r\n                                $matches = [regex]::Match($x, '^(\\d{4})(\\d{2})(\\d{2})$')\r\n                                $year = [int]$matches.Groups[1].Value\r\n                                $month = [int]$matches.Groups[2].Value\r\n                                $day = [int]$matches.Groups[3].Value\r\n                                if ($month -lt 1 -or $month -gt 12) { throw \"Invalid month: $month\" }\r\n                                if ($day -lt 1 -or $day -gt 31) { throw \"Invalid day: $day\" }\r\n                                return (New-Object DateTime($year, $month, $day)).ToString('yyyy-MM-dd')\r\n                            }\r\n                        }\r\n\r\n                        # Try standard date parsing (yyyy/mm/dd, yy-mm-dd, etc.)\r\n                        $dt = $null\r\n                        if ([DateTime]::TryParse($x, [Globalization.CultureInfo]::CurrentCulture, [Globalization.DateTimeStyles]::None, [ref]$dt)) {\r\n                            return $dt.ToString('yyyy-MM-dd')\r\n                        }\r\n\r\n                        throw \"Date format not recognized. Try: yyyymmdd, mmdd, today, eow, eom, +3, 1m, or standard formats like yyyy/mm/dd\"\r\n                    }\r\n                    Validate = {\r\n                        param([string]$v)\r\n                        if ($v -eq '') { return $true }\r\n                        if ($v -match '^\\d{4}-\\d{2}-\\d{2}$') { return $true }\r\n                        throw \"Due must be yyyy-MM-dd\"\r\n                    }\r\n                    DisplayFormat = {\r\n                        param($val)\r\n                        $s = [string]$val\r\n                        if (-not $s) { return '' }\r\n                        try { $d=[datetime]::ParseExact($s,'yyyy-MM-dd',[Globalization.CultureInfo]::InvariantCulture); return $d.ToString('MM/dd') } catch { return $s }\r\n                    }\r\n                }\r\n                'priority' = @{\r\n                    Name = 'priority'\r\n                    Editable = $true\r\n                    Sensitive = $false\r\n                    Hint = '1..3 (e.g., 2 or P2)'\r\n                    DefaultWidth = 3\r\n                    MinWidth = 3\r\n                    Normalize = {\r\n                        param([string]$v)\r\n                        $x = $(if ($null -ne $v) { $v } else { '' }).Trim()\r\n                        if ($x -eq '') { return '' }\r\n                        if ($x -match '^[Pp]([1-3])$') { return $matches[1] }\r\n                        if ($x -match '^[1-3]$') { return $x }\r\n                        throw \"Priority must be 1..3 (e.g., 2 or P2)\"\r\n                    }\r\n                    Validate = {\r\n                        param([string]$v)\r\n                        if ($v -eq '') { return $true }\r\n                        if ($v -match '^[1-3]$') { return $true }\r\n                        throw \"Priority must be 1..3\"\r\n                    }\r\n                    DisplayFormat = { param($val) if ($val) { 'P' + [string]$val } else { '' } }\r\n                }\r\n            }\r\n        }\r\n        'project' {\r\n            return @{\r\n                'name' = @{\r\n                    Name='name'; Editable=$false; Sensitive=$false; Hint='project name'; DefaultWidth=20; MinWidth=12\r\n                    DisplayFormat = { param($v) if ($null -ne $v) { [string]$v } else { '' } }\r\n                }\r\n                'description' = @{\r\n                    Name='description'; Editable=$false; Sensitive=$false; Hint='description'; DefaultWidth=30; MinWidth=15\r\n                    DisplayFormat = { param($v) if ($null -ne $v) { [string]$v } else { '' } }\r\n                }\r\n                'task_count' = @{\r\n                    Name='task_count'; Editable=$false; Sensitive=$false; Hint='tasks'; DefaultWidth=6; MinWidth=4\r\n                    DisplayFormat = { param($v) if ($v -ne $null) { [string]$v } else { '' } }\r\n                }\r\n                'completion' = @{\r\n                    Name='completion'; Editable=$false; Sensitive=$false; Hint='% done'; DefaultWidth=6; MinWidth=3\r\n                    Normalize = { param([string]$v) $(if ($null -ne $v) { $v } else { '' }).Trim('%') }\r\n                    Validate = { param([string]$v) if ($v -eq '' -or $v -match '^\\d{1,3}$') { return $true } throw 'completion must be 0..100' }\r\n                    DisplayFormat = { param($v) if ($v -ne $null -and $v -ne '') { ([string]$v).Trim('%') + '%' } else { '' } }\r\n                }\r\n            }\r\n        }\r\n        'timelog' {\r\n            return @{\r\n                'date' = @{\r\n                    Name='date'; Editable=$true; Sensitive=$false; Hint='yyyy-MM-dd'; DefaultWidth=10; MinWidth=8\r\n                    Normalize = {\r\n                        param([string]$v)\r\n                        $x = $(if ($null -ne $v) { $v } else { '' }).Trim(); if ($x -eq '') { return '' }\r\n                        if ($x -match '^\\d{4}-\\d{2}-\\d{2}$') { return $x }\r\n                        $dt = $null\r\n                        if ([DateTime]::TryParse($x, [Globalization.CultureInfo]::CurrentCulture, [Globalization.DateTimeStyles]::None, [ref]$dt)) { return $dt.ToString('yyyy-MM-dd') }\r\n                        throw 'Date must be yyyy-MM-dd'\r\n                    }\r\n                    Validate = { param([string]$v) if ($v -eq '' -or $v -match '^\\d{4}-\\d{2}-\\d{2}$') { return $true } throw 'Date must be yyyy-MM-dd' }\r\n                    DisplayFormat = { param($v) if ($v) { try { ([datetime]::ParseExact([string]$v,'yyyy-MM-dd',[Globalization.CultureInfo]::InvariantCulture)).ToString('MM/dd') } catch { [string]$v } } else { '' } }\r\n                }\r\n                'project' = @{\r\n                    Name='project'; Editable=$false; Sensitive=$true; Hint='@project'; DefaultWidth=15; MinWidth=10\r\n                    DisplayFormat = { param($v) if ($null -ne $v) { [string]$v } else { '' } }\r\n                }\r\n                'duration' = @{\r\n                    Name='duration'; Editable=$true; Sensitive=$false; Hint='minutes or h/m (e.g., 1.5h, 90m)'; DefaultWidth=8; MinWidth=6\r\n                    Normalize = {\r\n                        param([string]$v)\r\n                        $x = $(if ($null -ne $v) { $v } else { '' }).Trim(); if ($x -eq '') { return '' }\r\n                        if ($x -match '^(\\d+(?:\\.\\d+)?)h$') { return ([int]([double]$matches[1] * 60)).ToString() }\r\n                        if ($x -match '^(\\d+)m$') { return $matches[1] }\r\n                        if ($x -match '^(\\d+)$') { return $x }\r\n                        throw 'Duration must be minutes or h/m format'\r\n                    }\r\n                    Validate = { param([string]$v) if ($v -eq '' -or $v -match '^\\d+$') { return $true } throw 'Duration must be whole minutes' }\r\n                    DisplayFormat = { param($v)\r\n                        if ($v -match '^\\d+$') {\r\n                            $mins=[int]$v\r\n                            if ($mins -ge 60) {\r\n                                return '{0}h {1}m' -f ([int]($mins/60)), ($mins%60)\r\n                            } else {\r\n                                return $mins.ToString() + 'm'\r\n                            }\r\n                        } else {\r\n                            return [string]$v\r\n                        }\r\n                    }\r\n                }\r\n                'description' = @{\r\n                    Name='description'; Editable=$true; Sensitive=$false; Hint='description'; DefaultWidth=35; MinWidth=15\r\n                    DisplayFormat = { param($v) if ($null -ne $v) { [string]$v } else { '' } }\r\n                }\r\n            }\r\n        }\r\n        default {\r\n            return @{}\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-PmcFieldSchema {\r\n    param(\r\n        [Parameter(Mandatory=$true)][string]$Domain,\r\n        [Parameter(Mandatory=$true)][string]$Field\r\n    )\r\n    $all = Get-PmcFieldSchemasForDomain -Domain $Domain\r\n    if ($all.ContainsKey($Field)) { return $all[$Field] }\r\n    return $null\r\n}\r\n\r\n#Export-ModuleMember -Function Get-PmcFieldSchemasForDomain, Get-PmcFieldSchema"}, {"path": "module/Pmc.Strict/src/Focus.ps1", "content": "# Focus/Context System Implementation\r\n# Based on t2.ps1 focus functionality\r\n\r\n# State-only: no global context initialization\r\n\r\nfunction Set-PmcFocus {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"Focus\" -Message \"Starting focus set\" -Data @{ FreeText = $Context.FreeText }\r\n\r\n    $data = Get-PmcDataAlias\r\n    $focusText = ($Context.FreeText -join ' ').Trim()\r\n\r\n    if ([string]::IsNullOrWhiteSpace($focusText)) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"Usage: focus set <project-name>\"\r\n        return\r\n    }\r\n\r\n    # Find matching project\r\n    $project = $data.projects | Where-Object { $_.name -and ($_.name.ToLower() -eq $focusText.ToLower()) } | Select-Object -First 1\r\n\r\n    if (-not $project) {\r\n        Write-PmcStyled -Style 'Warning' -Text (\"Project '{0}' not found. Creating new project context.\" -f $focusText)\r\n        # Auto-create project if it doesn't exist\r\n        $project = [pscustomobject]@{\r\n            name = $focusText\r\n            description = \"Auto-created via focus $(Get-Date -Format yyyy-MM-dd)\"\r\n            created = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n        }\r\n        $data.projects += $project\r\n    }\r\n\r\n    # Persist context in data\r\n    if (-not $data.PSObject.Properties['currentContext']) {\r\n        $data | Add-Member -NotePropertyName currentContext -NotePropertyValue $project.name -Force\r\n    } else {\r\n        $data.currentContext = $project.name\r\n    }\r\n\r\n    # Mirror to centralized state\r\n    Set-PmcState -Section 'Focus' -Key 'Current' -Value $project.name\r\n\r\n    Save-StrictData $data 'focus set'\r\n\r\n    Write-PmcStyled -Style 'Success' -Text (\"🎯 Focus set to: '{0}'\" -f $project.name)\r\n\r\n    # Show context summary\r\n    $contextTasks = @($data.tasks | Where-Object {\r\n        $_ -ne $null -and (Pmc-HasProp $_ 'project') -and $_.project -eq $project.name -and (Pmc-HasProp $_ 'status') -and $_.status -eq 'pending'\r\n    })\r\n\r\n    Write-PmcStyled -Style 'Info' -Text (\"   Pending tasks: {0}\" -f $contextTasks.Count)\r\n\r\n    if ($contextTasks.Count -gt 0) {\r\n        $overdue = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'due') -and $_.due -and ([datetime]$_.due) -lt (Get-Date).Date })\r\n        $today = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'due') -and $_.due -and ([datetime]$_.due) -eq (Get-Date).Date })\r\n\r\n        if ($overdue.Count -gt 0) { Write-PmcStyled -Style 'Error' -Text (\"   [WARN]️  Overdue: {0}\" -f $overdue.Count) }\r\n        if ($today.Count -gt 0)   { Write-PmcStyled -Style 'Warning' -Text (\"   📅 Due today: {0}\" -f $today.Count) }\r\n    }\r\n\r\n    Write-PmcDebug -Level 2 -Category \"Focus\" -Message \"Focus set successfully\" -Data @{ Project = $project.name; PendingTasks = $contextTasks.Count }\r\n}\r\n\r\nfunction Clear-PmcFocus {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"Focus\" -Message \"Starting focus clear\"\r\n\r\n    $data = Get-PmcDataAlias\r\n\r\n    # Clear persisted context\r\n    if ($data.PSObject.Properties['currentContext']) {\r\n        $data.currentContext = 'inbox'\r\n    }\r\n\r\n    # Mirror to centralized state\r\n    Set-PmcState -Section 'Focus' -Key 'Current' -Value 'inbox'\r\n\r\n    Save-StrictData $data 'focus clear'\r\n\r\n    Write-PmcStyled -Style 'Success' -Text \"🎯 Project focus cleared. Back to inbox.\"\r\n\r\n    Write-PmcDebug -Level 2 -Category \"Focus\" -Message \"Focus cleared successfully\"\r\n}\r\n\r\nfunction Get-PmcFocusStatus {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"Focus\" -Message \"Starting focus status\"\r\n\r\n    $data = Get-PmcDataAlias\r\n\r\n    Write-PmcStyled -Style 'Info' -Text \"`nℹ️  CURRENT CONTEXT\"\r\n    Write-PmcStyled -Style 'Border' -Text \"─────────────────────\"\r\n\r\n    # Resolve context via helper (handles uninitialized global state)\r\n    $currentContext = Get-PmcCurrentContext\r\n\r\n    if (-not $currentContext -or $currentContext -eq 'inbox') {\r\n        Write-PmcStyled -Style 'Muted' -Text \"  No active focus (inbox mode)\"\r\n\r\n        # Show inbox summary\r\n    $inboxTasks = @($data.tasks | Where-Object {\r\n            $_ -ne $null -and ((-not (Pmc-HasProp $_ 'project')) -or $_.project -eq 'inbox') -and (Pmc-HasProp $_ 'status') -and $_.status -eq 'pending'\r\n        })\r\n        Write-PmcStyled -Style 'Body' -Text (\"  Inbox tasks: {0}\" -f $inboxTasks.Count)\r\n        return\r\n    }\r\n\r\n    Write-PmcStyled -Style 'Warning' -Text (\"  Active Focus: {0}\" -f $currentContext)\r\n\r\n    # Find the project\r\n    $project = $data.projects | Where-Object { $_.name -eq $currentContext } | Select-Object -First 1\r\n\r\n    if ($project) {\r\n        $desc = $(if ((Pmc-HasProp $project 'description') -and $project.description) { [string]$project.description } else { 'None' })\r\n        Write-PmcStyled -Style 'Muted' -Text (\"  Description: {0}\" -f $desc)\r\n    }\r\n\r\n    # Show context statistics\r\n    $contextTasks = @($data.tasks | Where-Object { (Pmc-HasProp $_ 'project') -and $_.project -eq $currentContext -and (Pmc-HasProp $_ 'status') -and $_.status -eq 'pending' })\r\n\r\n    Write-PmcStyled -Style 'Body' -Text (\"  Pending Tasks: {0}\" -f $contextTasks.Count)\r\n\r\n    if ($contextTasks.Count -gt 0) {\r\n        $overdue = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'due') -and $_.due -and [datetime]$_.due -lt (Get-Date).Date })\r\n        $today = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'due') -and $_.due -and ([datetime]$_.due) -eq (Get-Date).Date })\r\n        $upcoming = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'due') -and $_.due -and ([datetime]$_.due) -gt (Get-Date).Date -and ([datetime]$_.due) -le (Get-Date).Date.AddDays(7) })\r\n        $nodue = @($contextTasks | Where-Object { -not (Pmc-HasProp $_ 'due') -or -not $_.due })\r\n\r\n        Write-PmcStyled -Style 'Info' -Text \"`n  Task Breakdown:\"\r\n        if ($overdue.Count -gt 0)  { Write-PmcStyled -Style 'Error'   -Text (\"    [WARN]️  Overdue: {0}\" -f $overdue.Count) }\r\n        if ($today.Count -gt 0)    { Write-PmcStyled -Style 'Warning' -Text (\"    📅 Due today: {0}\" -f $today.Count) }\r\n        if ($upcoming.Count -gt 0) { Write-PmcStyled -Style 'Success' -Text (\"    📋 Upcoming (7d): {0}\" -f $upcoming.Count) }\r\n        if ($nodue.Count -gt 0)    { Write-PmcStyled -Style 'Muted'   -Text (\"    📝 No due date: {0}\" -f $nodue.Count) }\r\n\r\n        # Show blocked tasks in context\r\n        $blocked = @($contextTasks | Where-Object { (Pmc-HasProp $_ 'blocked') -and $_.blocked })\r\n        if ($blocked.Count -gt 0) { Write-PmcStyled -Style 'Error' -Text (\"    🔒 Blocked: {0}\" -f $blocked.Count) }\r\n\r\n        # Show high priority tasks\r\n        $highPriority = @($contextTasks | Where-Object { $_.priority -and $_.priority -le 2 })\r\n        if ($highPriority.Count -gt 0) { Write-PmcStyled -Style 'Highlight' -Text (\"    ⭐ High priority: {0}\" -f $highPriority.Count) }\r\n    }\r\n\r\n    # Show recent activity in context\r\n    $recentLogs = @($data.timelogs | Where-Object {\r\n        $_.project -eq $currentContext -and\r\n        [datetime]$_.date -ge (Get-Date).Date.AddDays(-7)\r\n    })\r\n\r\n    if ($recentLogs.Count -gt 0) {\r\n        $totalMinutes = ($recentLogs | Measure-Object minutes -Sum).Sum\r\n        $totalHours = [Math]::Round($totalMinutes / 60, 1)\r\n        Write-PmcStyled -Style 'Info' -Text (\"  Recent time (7d): {0} hours\" -f $totalHours)\r\n    }\r\n\r\n    Write-PmcStyled -Style 'Muted' -Text (\"`nTip: Use 'task list @{0}' to see all tasks in this context\" -f $currentContext)\r\n\r\n    Write-PmcDebug -Level 2 -Category \"Focus\" -Message \"Focus status shown successfully\" -Data @{ Context = $currentContext; TaskCount = $contextTasks.Count }\r\n}\r\n\r\n# Helper function to get current context\r\nfunction Get-PmcCurrentContext {\r\n    # State-only source of truth\r\n    $cur = Get-PmcState -Section 'Focus' -Key 'Current'\r\n    if ($null -eq $cur -or [string]::IsNullOrWhiteSpace([string]$cur)) { return 'inbox' }\r\n    return $cur\r\n}\r\n\r\n# Helper function to filter tasks by current context\r\nfunction Get-PmcContextTasks {\r\n    param([switch]$PendingOnly)\r\n\r\n    $data = Get-PmcDataAlias\r\n    $context = Get-PmcCurrentContext\r\n\r\n    $tasks = $data.tasks\r\n\r\n    if ($context -ne 'inbox') {\r\n        $tasks = $tasks | Where-Object { $_.project -eq $context }\r\n    } else {\r\n        $tasks = $tasks | Where-Object { -not $_.project -or $_.project -eq 'inbox' }\r\n    }\r\n\r\n    if ($PendingOnly) {\r\n        $tasks = $tasks | Where-Object { $_.status -eq 'pending' }\r\n    }\r\n\r\n    return @($tasks)\r\n}\r\n\r\nExport-ModuleMember -Function Set-PmcFocus, Clear-PmcFocus, Get-PmcFocusStatus, Get-PmcCurrentContext, Get-PmcContextTasks"}, {"path": "module/Pmc.Strict/src/Help.ps1", "content": "function Get-PmcSchema {\r\n    param([string]$Domain,[string]$Action)\r\n    $key = \"$($Domain.ToLower()) $($Action.ToLower())\"\r\n    if ($Script:PmcParameterMap.ContainsKey($key)) { return $Script:PmcParameterMap[$key] }\r\n    return @()\r\n}\r\n\r\nfunction Get-PmcHelp {\r\n    param([PmcCommandContext]$Context)\r\n    # Route to clean help system\r\n    Show-PmcSmartHelp -Context $Context\r\n}\r\n\r\n# Static domain help (non-interactive)\r\nfunction Show-PmcHelpDomain {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    # Use AST parsing to better understand domain query\r\n    $domain = $null\r\n\r\n    if ($Context -and $Context.FreeText.Count -ge 1) {\r\n        # Try AST parsing first\r\n        try {\r\n            $helpQuery = $Context.FreeText -join ' '\r\n            if (Get-Command ConvertTo-PmcCommandAst -ErrorAction SilentlyContinue) {\r\n                $ast = ConvertTo-PmcCommandAst -CommandText $helpQuery\r\n                if ($ast.Domain) { $domain = $ast.Domain.ToLower() }\r\n            }\r\n        } catch {\r\n            Write-PmcDebug -Level 2 -Category 'Help' -Message \"AST parsing failed for domain help query\"\r\n        }\r\n\r\n        # Fallback to simple token parsing\r\n        if (-not $domain) { $domain = $Context.FreeText[0].ToLower() }\r\n    }\r\n\r\n    if (-not $domain) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"Usage: help domain <domain> (e.g., help domain task)\"\r\n        return\r\n    }\r\n    if (-not $Script:PmcCommandMap.ContainsKey($domain)) { Write-PmcStyled -Style 'Error' -Text (\"Unknown domain '{0}'\" -f $domain); return }\r\n\r\n    Write-PmcStyled -Style 'Title' -Text (\"\\nHELP — {0}\" -f $domain.ToUpper())\r\n    Write-PmcStyled -Style 'Border' -Text (\"─\" * 80)\r\n\r\n    $rows = @()\r\n    foreach ($a in ($Script:PmcCommandMap[$domain].Keys | Sort-Object)) {\r\n        $key = \"$domain $a\"\r\n        $desc = ''\r\n        try { if ($Script:PmcCommandMeta.ContainsKey($key)) { $desc = [string]$Script:PmcCommandMeta[$key].Desc } } catch {}\r\n        $rows += [pscustomobject]@{ Action=$a; Description=$desc }\r\n    }\r\n    foreach ($row in $rows) {\r\n        $act = $row.Action.PadRight(18).Substring(0,18)\r\n        $desc = $(if ($row.Description) { $row.Description } else { '' })\r\n        Write-Host (\"  {0} {1}\" -f $act, $desc)\r\n    }\r\n}\r\n\r\n# Static command help (arguments, usage)\r\nfunction Show-PmcHelpCommand {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    # Use AST parsing to better understand help command structure\r\n    $domain = $null\r\n    $action = $null\r\n\r\n    if ($Context -and $Context.FreeText.Count -ge 1) {\r\n        # Try AST parsing first for better command understanding\r\n        try {\r\n            $helpQuery = $Context.FreeText -join ' '\r\n            if (Get-Command ConvertTo-PmcCommandAst -ErrorAction SilentlyContinue) {\r\n                $ast = ConvertTo-PmcCommandAst -CommandText $helpQuery\r\n                if ($ast.Domain) { $domain = $ast.Domain.ToLower() }\r\n                if ($ast.Action) { $action = $ast.Action.ToLower() }\r\n            }\r\n        } catch {\r\n            Write-PmcDebug -Level 2 -Category 'Help' -Message \"AST parsing failed for help query, using fallback\"\r\n        }\r\n\r\n        # Fallback to simple token parsing\r\n        if (-not $domain -and $Context.FreeText.Count -ge 1) { $domain = $Context.FreeText[0].ToLower() }\r\n        if (-not $action -and $Context.FreeText.Count -ge 2) { $action = $Context.FreeText[1].ToLower() }\r\n    }\r\n\r\n    if (-not $domain -or -not $action) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"Usage: help command <domain> <action> (e.g., help command task add)\"\r\n        return\r\n    }\r\n    if (-not $Script:PmcCommandMap.ContainsKey($domain)) { Write-PmcStyled -Style 'Error' -Text (\"Unknown domain '{0}'\" -f $domain); return }\r\n    if (-not $Script:PmcCommandMap[$domain].ContainsKey($action)) { Write-PmcStyled -Style 'Error' -Text (\"Unknown action '{0}' for domain '{1}'\" -f $action,$domain); return }\r\n\r\n    $title = \"HELP — {0} {1}\" -f $domain.ToUpper(), $action\r\n    Write-PmcStyled -Style 'Title' -Text (\"\\n{0}\" -f $title)\r\n    Write-PmcStyled -Style 'Border' -Text (\"─\" * 80)\r\n\r\n    # Description (if available)\r\n    $key = \"$domain $action\"\r\n    $desc = ''\r\n    try { if ($Script:PmcCommandMeta.ContainsKey($key)) { $desc = [string]$Script:PmcCommandMeta[$key].Desc } } catch {}\r\n    if ($desc) { Write-PmcStyled -Style 'Info' -Text (\"  {0}\" -f $desc) }\r\n\r\n    # Schema\r\n    $schema = Get-PmcSchema -Domain $domain -Action $action\r\n    if (-not $schema -or @($schema).Count -eq 0) { Write-PmcStyled -Style 'Muted' -Text '  (no arguments)'; return }\r\n\r\n    Write-PmcStyled -Style 'Header' -Text \"\\n  Args:\"\r\n    foreach ($def in $schema) {\r\n        $name = [string]$def['Name']\r\n        $pref = $(if ($def['Prefix']) { [string]$def['Prefix'] } else { '' })\r\n        $type = $(if ($def['Type']) { [string]$def['Type'] } else { 'Text' })\r\n        $req  = $(if ($def['Required']) { 'required' } else { '' })\r\n        $help = $(if ($def['Description']) { [string]$def['Description'] } else { '' })\r\n        $left = $(if ($pref) { \"$pref$name\" } else { $name }).PadRight(18).Substring(0,18)\r\n        $right = (\"[{0}] {1}\" -f $type,$help)\r\n        if ($req) { $right = \"$right (required)\" }\r\n        Write-Host (\"  {0} {1}\" -f $left, $right)\r\n    }\r\n\r\n    # Usage hint\r\n    $usage = \"{0} {1}\" -f $domain, $action\r\n    foreach ($def in $schema) {\r\n        $token = $(if ($def['Prefix']) { \"\" + [string]$def['Prefix'] + [string]$def['Name'] } elseif ($def['Name'] -match '^(?i)text$') { '<text>' } else { \"<\" + [string]$def['Name'] + \">\" })\r\n        if (-not $def['Required']) { $token = \"[$token]\" }\r\n        $usage += \" $token\"\r\n    }\r\n    Write-PmcStyled -Style 'Border' -Text (\"\\n{0}\" -f $usage)\r\n}\r\n\r\n# Dedicated query help (static)\r\nfunction Show-PmcHelpQuery {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcStyled -Style 'Title' -Text \"\\nQUERY LANGUAGE\"\r\n    Write-PmcStyled -Style 'Border' -Text (\"─\" * 80)\r\n\r\n    # Try to load reference doc and print key sections\r\n    $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent\r\n    $ref = Join-Path $root 'PMC_QUERY_LANGUAGE_REFERENCE.md'\r\n    if (-not (Test-Path $ref)) { Write-PmcStyled -Style 'Warning' -Text 'Reference file not found.'; return }\r\n    $content = Get-Content $ref -Raw\r\n\r\n    # Extract top sections by headings\r\n    $sections = @()\r\n    $pattern = \"(?ms)^##\\s+(.+?)\\n(.*?)(?=\\n##\\s+|\\Z)\"\r\n    $matches = [regex]::Matches($content, $pattern)\r\n    foreach ($m in $matches) {\r\n        $sections += @{ Title=$m.Groups[1].Value.Trim(); Body=$m.Groups[2].Value.Trim() }\r\n    }\r\n\r\n    $wanted = @('Overview','Core Syntax','Filters','Operators','Grouping & Sorting','Views','Examples')\r\n    foreach ($w in $wanted) {\r\n        $sec = $sections | Where-Object { $_.Title -like \"$w*\" } | Select-Object -First 1\r\n        if ($sec) {\r\n            Write-PmcStyled -Style 'Header' -Text (\"\\n  {0}\" -f $sec.Title)\r\n            $lines = ($sec.Body -split \"`n\") | Where-Object { $_.Trim() -ne '' } | Select-Object -First 12\r\n            foreach ($ln in $lines) { Write-Host (\"    {0}\" -f $ln.TrimDoEnd()) }\r\n        }\r\n    }\r\n    Write-PmcStyled -Style 'Muted' -Text (\"\\nSee: {0}\" -f $ref)\r\n    Write-PmcStyled -Style 'Info' -Text \"\\nRelated help:\"\r\n    Write-Host \"  help guide query      — Guided tour of filters and views\"\r\n    Write-Host \"  help examples query   — Practical, copyable query examples\"\r\n}\r\n\r\n# Search across commands and help content\r\nfunction Show-PmcHelpSearch {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    # Use AST parsing to better understand search query\r\n    $q = ''\r\n    if ($Context -and $Context.FreeText -and $Context.FreeText.Count -gt 0) {\r\n        # Try AST parsing first for complex queries\r\n        try {\r\n            $searchQuery = $Context.FreeText -join ' '\r\n            if (Get-Command ConvertTo-PmcCommandAst -ErrorAction SilentlyContinue) {\r\n                $ast = ConvertTo-PmcCommandAst -CommandText $searchQuery\r\n                # For search, we want the full free text, not just structured parts\r\n                $q = $searchQuery\r\n            } else {\r\n                $q = $searchQuery\r\n            }\r\n        } catch {\r\n            $q = ($Context.FreeText[0] + '')\r\n        }\r\n    }\r\n\r\n    $q = $q.Trim()\r\n    if (-not $q) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"Usage: help search <text> (e.g., help search 'task add')\"\r\n        return\r\n    }\r\n\r\n    $rows = @()\r\n    # Search domain/actions with descriptions\r\n    foreach ($domain in ($Script:PmcCommandMap.Keys)) {\r\n        foreach ($action in ($Script:PmcCommandMap[$domain].Keys)) {\r\n            $cmd = (\"{0} {1}\" -f $domain, $action)\r\n            $desc = ''\r\n            try { if ($Script:PmcCommandMeta.ContainsKey($cmd)) { $desc = [string]$Script:PmcCommandMeta[$cmd].Desc } } catch {}\r\n            $rows += [pscustomobject]@{ Type='Command'; Text=$cmd; Description=$desc; Source=$domain }\r\n        }\r\n    }\r\n    # Search curated help content\r\n    try {\r\n        if ($Script:PmcHelpContent) {\r\n            foreach ($kv in $Script:PmcHelpContent.GetEnumerator()) {\r\n                $cat = [string]$kv.Key\r\n                foreach ($it in $kv.Value.Items) {\r\n                    $text = $(if ($it.PSObject.Properties['Command']) { [string]$it.Command } elseif ($it.PSObject.Properties['Item']) { [string]$it.Item } else { '' })\r\n                    $desc = $(if ($it.PSObject.Properties['Description']) { [string]$it.Description } else { '' })\r\n                    if ($text -or $desc) { $rows += [pscustomobject]@{ Type='Guide'; Text=$text; Description=$desc; Source=$cat } }\r\n                }\r\n            }\r\n        }\r\n    } catch {}\r\n\r\n    # Parse quoted phrases and remaining terms\r\n    $phraseRegex = '\"([^\"]+)\"'\r\n    $phrases = @()\r\n    $m = [regex]::Matches($q, $phraseRegex)\r\n    foreach ($mm in $m) { $phrases += ($mm.Groups[1].Value + '').ToLowerInvariant() }\r\n    $rest = ([regex]::Replace($q, $phraseRegex, ' ')).Trim()\r\n    $terms = @()\r\n    foreach ($t in ($rest -split '\\s+')) { if (-not [string]::IsNullOrWhiteSpace($t)) { $terms += $t.ToLowerInvariant() } }\r\n    if ($phrases.Count -eq 0 -and $terms.Count -eq 0) { $terms = @($q.ToLowerInvariant()) }\r\n\r\n    $normalizedQuery = $q.ToLowerInvariant()\r\n\r\n    # Scoring:\r\n    # - Exact full command match: +10 (commands only)\r\n    # - Phrase match in Text: +6 if startswith; +5 if contains; +4 if in Description\r\n    # - Term match: Text startswith +3; word-boundary +3; contains +2; Description/Source +1\r\n    # - Commands get +1 baseline\r\n    $scored = @()\r\n    foreach ($row in $rows) {\r\n        if ($null -eq $row) { continue }\r\n        $text = ([string]$row.Text)\r\n        $desc = ([string]$row.Description)\r\n        $src  = ([string]$row.Source)\r\n        $lt = $text.ToLowerInvariant()\r\n        $ld = $desc.ToLowerInvariant()\r\n        $ls = $src.ToLowerInvariant()\r\n        $score = 0\r\n        $ok = $true\r\n\r\n        # Require each phrase to appear somewhere\r\n        foreach ($p in $phrases) {\r\n            $phraseHit = $false\r\n            if ($lt.StartsWith($p)) { $score += 6; $phraseHit = $true }\r\n            elseif ($lt.Contains($p)) { $score += 5; $phraseHit = $true }\r\n            elseif ($ld.Contains($p)) { $score += 4; $phraseHit = $true }\r\n            elseif ($ls.Contains($p)) { $score += 3; $phraseHit = $true }\r\n            if (-not $phraseHit) { $ok = $false; break }\r\n        }\r\n        if (-not $ok) { continue }\r\n\r\n        # Terms (AND logic)\r\n        foreach ($term in $terms) {\r\n            $termScore = 0\r\n            if ($lt -eq $term) { $termScore = [Math]::Max($termScore, 4) }\r\n            if ($lt.StartsWith($term)) { $termScore = [Math]::Max($termScore, 3) }\r\n            $wb = \"\\\\b\" + [regex]::Escape($term) + \"\\\\b\"\r\n            if ([regex]::IsMatch($lt, $wb)) { $termScore = [Math]::Max($termScore, 3) }\r\n            if ($lt.Contains($term)) { $termScore = [Math]::Max($termScore, 2) }\r\n            if ($ld.Contains($term)) { $termScore = [Math]::Max($termScore, 1) }\r\n            if ($ls.Contains($term)) { $termScore = [Math]::Max($termScore, 1) }\r\n            if ($termScore -eq 0) { $ok = $false; break }\r\n            $score += $termScore\r\n        }\r\n        if (-not $ok) { continue }\r\n\r\n        # Bonuses\r\n        if ($row.Type -eq 'Command') {\r\n            $score += 1\r\n            if ($lt -eq $normalizedQuery) { $score += 10 }\r\n            elseif ($phrases.Count -eq 1 -and $lt -eq $phrases[0]) { $score += 8 }\r\n        }\r\n\r\n        $scored += [pscustomobject]@{ Score=$score; Type=$row.Type; Text=$text; Description=$desc; Source=$src }\r\n    }\r\n\r\n    $matches = @($scored | Sort-Object -Property @{Expression='Score';Descending=$true}, @{Expression='Type';Descending=$false}, @{Expression='Text';Descending=$false})\r\n\r\n    if ($matches.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Muted' -Text (\"No help results for: '{0}'\" -f $q)\r\n        return\r\n    }\r\n\r\n    $cols = @{\r\n        Type=@{ Header='Type'; Width=8; Alignment='Left' }\r\n        Text=@{ Header='Text'; Width=32; Alignment='Left' }\r\n        Description=@{ Header='Description'; Width=0; Alignment='Left' }\r\n        Source=@{ Header='Source'; Width=14; Alignment='Left' }\r\n    }\r\n\r\n    Show-PmcDataGrid -Domains @('help-search') -Columns $cols -Data $matches -Title (\"Help Search — {0}\" -f $q) -Interactive -OnSelectCallback {\r\n        param($item)\r\n        try { if ($item -and $item.PSObject.Properties['Text'] -and $item.Text) { Pmc-InsertAtCursor (([string]$item.Text) + ' ') } } catch {}\r\n    }\r\n}\r\n\r\n# Interactive examples for common tasks and query/kanban\r\nfunction Show-PmcHelpExamples {\r\n    param([PmcCommandContext]$Context)\r\n    $topic = $(if ($Context -and $Context.FreeText.Count -gt 0) { ($Context.FreeText[0] + '').ToLower() } else { '' })\r\n\r\n    switch ($topic) {\r\n        'query' {\r\n            $rows = @(\r\n                [pscustomobject]@{ Category='🎯 PRIORITY'; Command='q tasks p1'; Description='Only high priority tasks' }\r\n                [pscustomobject]@{ Category='🎯 PRIORITY'; Command='q tasks p<=2'; Description='High and medium priority' }\r\n                [pscustomobject]@{ Category='📅 DATE'; Command='q tasks due:today'; Description='Due today' }\r\n                [pscustomobject]@{ Category='📅 DATE'; Command='q tasks overdue'; Description='Past due' }\r\n                [pscustomobject]@{ Category='🏷️ PROJECT'; Command='q tasks @work'; Description='Project filter' }\r\n                [pscustomobject]@{ Category='🏷️ TAG'; Command='q tasks #urgent'; Description='Tagged urgent' }\r\n                [pscustomobject]@{ Category='📊 VIEW'; Command='q tasks group:status'; Description='Kanban by status' }\r\n                [pscustomobject]@{ Category='⚡ COMBO'; Command='q tasks p<=2 @work due>=today'; Description='Combined filters' }\r\n            )\r\n\r\n            $cols = @{\r\n                Category=@{ Header='Category'; Width=14; Alignment='Left' }\r\n                Command=@{ Header='Command'; Width=28; Alignment='Left' }\r\n                Description=@{ Header='Description'; Width=0; Alignment='Left' }\r\n            }\r\n            Show-PmcDataGrid -Domains @('help-examples') -Columns $cols -Data $rows -Title 'Query Language Examples' -Interactive\r\n            return\r\n        }\r\n        'kanban' {\r\n            $rows = @(\r\n                [pscustomobject]@{ Category='🎯 ACCESS'; Command='q tasks group:status'; Description='Auto-kanban by status' }\r\n                [pscustomobject]@{ Category='🎯 ACCESS'; Command='q tasks view:kanban'; Description='Force kanban view' }\r\n                [pscustomobject]@{ Category='🎮 KEYS'; Command='←/→'; Description='Move between lanes' }\r\n                [pscustomobject]@{ Category='🎮 KEYS'; Command='↑/↓'; Description='Move between cards' }\r\n                [pscustomobject]@{ Category='🎮 KEYS'; Command='Space'; Description='Start/complete move' }\r\n                [pscustomobject]@{ Category='🎮 KEYS'; Command='Enter'; Description='Open details/editor' }\r\n                [pscustomobject]@{ Category='🎮 KEYS'; Command='Esc'; Description='Exit or cancel' }\r\n            )\r\n            $cols = @{\r\n                Category=@{ Header='Category'; Width=14; Alignment='Left' }\r\n                Command=@{ Header='Command/Key'; Width=20; Alignment='Left' }\r\n                Description=@{ Header='Description'; Width=0; Alignment='Left' }\r\n            }\r\n            Show-PmcDataGrid -Domains @('help-examples') -Columns $cols -Data $rows -Title 'Kanban Workflow Examples' -Interactive\r\n            return\r\n        }\r\n        default {\r\n            $rows = @(\r\n                [pscustomobject]@{ Category='🚀 QUICK START'; Command='today'; Description='Tasks due today' }\r\n                [pscustomobject]@{ Category='🚀 QUICK START'; Command='add \"New task\" @work p1 due:today'; Description='Add new task' }\r\n                [pscustomobject]@{ Category='🔎 QUERY'; Command='help examples query'; Description='See query examples' }\r\n                [pscustomobject]@{ Category='📋 KANBAN'; Command='help examples kanban'; Description='See kanban examples' }\r\n            )\r\n            $cols = @{\r\n                Category=@{ Header='Category'; Width=16; Alignment='Left' }\r\n                Command=@{ Header='Command'; Width=32; Alignment='Left' }\r\n                Description=@{ Header='Description'; Width=0; Alignment='Left' }\r\n            }\r\n            Show-PmcDataGrid -Domains @('help-examples') -Columns $cols -Data $rows -Title 'PMC Examples — Quick Start' -Interactive\r\n        }\r\n    }\r\n}\r\n\r\n# Focused guides for important features\r\nfunction Show-PmcHelpGuide {\r\n    param([PmcCommandContext]$Context)\r\n    $topic = $(if ($Context -and $Context.FreeText.Count -gt 0) { ($Context.FreeText[0] + '').ToLower() } else { '' })\r\n\r\n    switch ($topic) {\r\n        'query' {\r\n            $rows = @(\r\n                [pscustomobject]@{ Section='🚀 BASICS'; Item='q tasks'; Description='Show all tasks' }\r\n                [pscustomobject]@{ Section='🎯 PRIORITY'; Item='q tasks p1'; Description='High priority' }\r\n                [pscustomobject]@{ Section='📅 DATES'; Item='q tasks due:today'; Description='Due today' }\r\n                [pscustomobject]@{ Section='🏷️ PROJECT'; Item='q tasks @work'; Description='Project filter' }\r\n                [pscustomobject]@{ Section='📊 DISPLAY'; Item='q tasks cols:id,text,due'; Description='Choose columns' }\r\n                [pscustomobject]@{ Section='📊 VIEWS'; Item='q tasks group:status'; Description='Kanban by status' }\r\n                [pscustomobject]@{ Section='🔗 COMBINE'; Item='q tasks p<=2 @work due>today'; Description='Multiple filters' }\r\n                [pscustomobject]@{ Section='💡 TIPS'; Item='Tab completion'; Description='Complete filters and values' }\r\n            )\r\n            $cols = @{\r\n                Section=@{ Header='Category'; Width=14; Alignment='Left' }\r\n                Item=@{ Header='Filter/Command'; Width=28; Alignment='Left' }\r\n                Description=@{ Header='Description'; Width=0; Alignment='Left' }\r\n            }\r\n            Show-PmcDataGrid -Domains @('help-guide') -Columns $cols -Data $rows -Title 'Query Language Guide' -Interactive\r\n            return\r\n        }\r\n        'kanban' {\r\n            $rows = @(\r\n                [pscustomobject]@{ Category='🎯 ACCESS'; Item='q tasks group:status'; Description='Auto-enable kanban' }\r\n                [pscustomobject]@{ Category='🎮 NAV'; Item='←/→, ↑/↓'; Description='Move lanes/cards' }\r\n                [pscustomobject]@{ Category='🎮 NAV'; Item='Space'; Description='Start/complete move' }\r\n                [pscustomobject]@{ Category='🎮 NAV'; Item='Enter'; Description='Open/edit task' }\r\n                [pscustomobject]@{ Category='🎮 NAV'; Item='Esc'; Description='Exit/cancel' }\r\n                [pscustomobject]@{ Category='🎨 VISUAL'; Item='🔴🟡🟢'; Description='Priority indicators' }\r\n                [pscustomobject]@{ Category='🎨 VISUAL'; Item='[WARN]️📅'; Description='Due indicators' }\r\n            )\r\n            $cols = @{\r\n                Category=@{ Header='Category'; Width=14; Alignment='Left' }\r\n                Item=@{ Header='Command/Key'; Width=22; Alignment='Left' }\r\n                Description=@{ Header='Description'; Width=0; Alignment='Left' }\r\n            }\r\n            Show-PmcDataGrid -Domains @('help-guide') -Columns $cols -Data $rows -Title 'Kanban View Guide' -Interactive\r\n            return\r\n        }\r\n        default {\r\n            $rows = @(\r\n                [pscustomobject]@{ Topic='help guide query'; Description='Query language & filtering guide' }\r\n                [pscustomobject]@{ Topic='help guide kanban'; Description='Kanban navigation and usage' }\r\n                [pscustomobject]@{ Topic='help examples'; Description='Practical, copyable examples' }\r\n            )\r\n            $cols = @{\r\n                Topic=@{ Header='Command'; Width=26; Alignment='Left' }\r\n                Description=@{ Header='Description'; Width=0; Alignment='Left' }\r\n            }\r\n            Show-PmcDataGrid -Domains @('help-guide') -Columns $cols -Data $rows -Title 'PMC Help Guide — Topics' -Interactive\r\n        }\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/src/HelpUI.ps1", "content": "function Show-PmcHelpCategories {\r\n    param($Context)\r\n\r\n    Write-PmcDebug -Level 1 -Category 'HELP' -Message 'Show-PmcHelpCategories START'\r\n\r\n    # Build help categories data\r\n    $rows = @()\r\n    $useCurated = ($Script:PmcHelpContent -and $Script:PmcHelpContent.Count -gt 0)\r\n    if ($useCurated) {\r\n        foreach ($entry in $Script:PmcHelpContent.GetEnumerator()) {\r\n            $rows += [pscustomobject]@{\r\n                category = [string]$entry.Key\r\n                items = @($entry.Value.Items).Count\r\n                description = [string]$entry.Value.Description\r\n            }\r\n        }\r\n    } else {\r\n        # Fallback to domain listing from CommandMap\r\n        foreach ($domain in ($Script:PmcCommandMap.Keys | Sort-Object)) {\r\n            $actions = 0\r\n            try { $actions = @($Script:PmcCommandMap[$domain].Keys).Count } catch { $actions = 0 }\r\n            $desc = switch ($domain) {\r\n                'task' { 'Task management commands' }\r\n                'project' { 'Project management commands' }\r\n                'time' { 'Time tracking commands' }\r\n                'view' { 'Data viewing commands' }\r\n                'help' { 'Help system commands' }\r\n                'config' { 'Configuration commands' }\r\n                default { 'Domain commands' }\r\n            }\r\n            $rows += [pscustomobject]@{\r\n                category = $domain\r\n                items = $actions\r\n                description = $desc\r\n            }\r\n        }\r\n    }\r\n\r\n    # Use template display system\r\n    $helpTemplate = [PmcTemplate]::new('help-categories', @{\r\n        type = 'grid'\r\n        header = 'Category          Items  Description'\r\n        row = '{category,-16} {items,6}  {description}'\r\n        settings = @{ separator = '─'; minWidth = 60 }\r\n    })\r\n\r\n    Write-PmcStyled -Style 'Header' -Text \"`n📚 PMC HELP — CATEGORIES`n\"\r\n    Render-GridTemplate -Data $rows -Template $helpTemplate\r\n    Write-PmcStyled -Style 'Info' -Text \"`nUse: help domain <category> (e.g., 'help domain task')\"\r\n}\r\n\r\nfunction Show-PmcHelpCommands {\r\n    param($Context,[string]$Domain)\r\n\r\n    Write-PmcDebug -Level 1 -Category 'HELP' -Message 'Show-PmcHelpCommands START' -Data @{ Domain = $Domain }\r\n\r\n    if ([string]::IsNullOrWhiteSpace($Domain)) { return }\r\n\r\n    # Build rows from domain actions\r\n    $rows = @()\r\n    $map = $null\r\n    try { $map = $Script:PmcCommandMap[$Domain] } catch { $map = $null }\r\n\r\n    if ($map) {\r\n        foreach ($action in ($map.Keys | Sort-Object)) {\r\n            $full = \"{0} {1}\" -f $Domain, $action\r\n            $desc = ''\r\n            try {\r\n                if ($Script:PmcCommandMeta.ContainsKey($full)) {\r\n                    $desc = [string]$Script:PmcCommandMeta[$full].Desc\r\n                }\r\n            } catch {}\r\n            $rows += [pscustomobject]@{\r\n                command = $action\r\n                full = $full\r\n                description = $desc\r\n            }\r\n        }\r\n    } else {\r\n        Write-PmcStyled -Style 'Error' -Text \"Domain '$Domain' not found.\"\r\n        return\r\n    }\r\n\r\n    # Use template display system\r\n    $helpTemplate = [PmcTemplate]::new('help-commands', @{\r\n        type = 'grid'\r\n        header = 'Command           Description'\r\n        row = '{command,-18} {description}'\r\n        settings = @{ separator = '─'; minWidth = 50 }\r\n    })\r\n\r\n    Write-PmcStyled -Style 'Header' -Text \"`n📚 PMC HELP — $($Domain.ToUpper())`n\"\r\n    Render-GridTemplate -Data $rows -Template $helpTemplate\r\n    Write-PmcStyled -Style 'Info' -Text \"`nUse: help command <domain> <action> (e.g., 'help command task add')\"\r\n}\r\n\r\n# Show help topic content using template display\r\nfunction Show-PmcHelpTopic {\r\n    param($Context,[string]$Topic)\r\n    Write-PmcDebug -Level 1 -Category 'HELP' -Message 'Show-PmcHelpTopic START' -Data @{ Topic=$Topic }\r\n\r\n    Write-PmcStyled -Style 'Header' -Text \"`n📚 HELP — $($Topic.ToUpper())`n\"\r\n\r\n    $topicLC = ($Topic + '').ToLower().Trim()\r\n    switch ($topicLC) {\r\n        'query' {\r\n            Write-PmcStyled -Style 'Subheader' -Text 'PMC Query Language'\r\n            Write-PmcStyled -Style 'Info' -Text 'Basic query syntax:'\r\n            Write-PmcStyled -Style 'Code' -Text '  task list status:pending'\r\n            Write-PmcStyled -Style 'Code' -Text '  task list due:today'\r\n            Write-PmcStyled -Style 'Code' -Text '  task list project:work'\r\n            Write-PmcStyled -Style 'Info' -Text '`nOperators: =, !=, <, >, contains, startswith, endswith'\r\n            Write-PmcStyled -Style 'Info' -Text 'Logical: and, or, not'\r\n        }\r\n        'examples' {\r\n            Write-PmcStyled -Style 'Subheader' -Text 'Common PMC Examples'\r\n            Write-PmcStyled -Style 'Info' -Text 'Add a task:'\r\n            Write-PmcStyled -Style 'Code' -Text '  task add \"Fix login bug\" project:web due:2024-01-15'\r\n            Write-PmcStyled -Style 'Info' -Text '`nList overdue tasks:'\r\n            Write-PmcStyled -Style 'Code' -Text '  view overdue'\r\n            Write-PmcStyled -Style 'Info' -Text '`nStart time tracking:'\r\n            Write-PmcStyled -Style 'Code' -Text '  timer start'\r\n        }\r\n        default {\r\n            Write-PmcStyled -Style 'Warning' -Text \"No detailed help available for topic: $Topic\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Show-PmcSmartHelp {\r\n    param($Context)\r\n    # Show main help categories with template display\r\n    Show-PmcHelpCategories -Context $Context\r\n}\r\n\r\n# Show help for a specific domain (static display)\r\nfunction Show-PmcHelpDomain {\r\n    param($Context, [string]$Domain)\r\n    if ($Context.Args.ContainsKey('domain')) {\r\n        $Domain = $Context.Args['domain']\r\n    }\r\n    if ([string]::IsNullOrWhiteSpace($Domain)) {\r\n        Write-PmcStyled -Style 'Warning' -Text 'Usage: help domain <domain_name>'\r\n        return\r\n    }\r\n    Show-PmcHelpCommands -Context $Context -Domain $Domain\r\n}\r\n\r\n# Show help for a specific command (static display)\r\nfunction Show-PmcHelpCommand {\r\n    param($Context, [string]$Command)\r\n    if ($Context.Args.ContainsKey('command')) {\r\n        $Command = $Context.Args['command']\r\n    }\r\n    if ([string]::IsNullOrWhiteSpace($Command)) {\r\n        Write-PmcStyled -Style 'Warning' -Text 'Usage: help command <command_name>'\r\n        return\r\n    }\r\n\r\n    Write-PmcStyled -Style 'Header' -Text \"`n📚 COMMAND HELP: $($Command.ToUpper())\"\r\n\r\n    # Try to find command info\r\n    $found = $false\r\n    foreach ($domain in $Script:PmcCommandMap.Keys) {\r\n        foreach ($action in $Script:PmcCommandMap[$domain].Keys) {\r\n            $fullCmd = \"$domain $action\"\r\n            if ($fullCmd -eq $Command) {\r\n                $func = $Script:PmcCommandMap[$domain][$action]\r\n                $desc = $(if ($Script:PmcCommandMeta.ContainsKey($fullCmd)) { $Script:PmcCommandMeta[$fullCmd].Desc } else { 'No description available' })\r\n\r\n                Write-PmcStyled -Style 'Info' -Text \"`nCommand: $fullCmd\"\r\n                Write-PmcStyled -Style 'Info' -Text \"Function: $func\"\r\n                Write-PmcStyled -Style 'Info' -Text \"Description: $desc\"\r\n                $found = $true\r\n                break\r\n            }\r\n        }\r\n        if ($found) { break }\r\n    }\r\n\r\n    if (-not $found) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"Command '$Command' not found.\"\r\n    }\r\n}\r\n\r\n# Show query language help\r\nfunction Show-PmcHelpQuery {\r\n    param($Context)\r\n    Show-PmcHelpTopic -Context $Context -Topic 'query'\r\n}\r\n\r\n# Show help examples\r\nfunction Show-PmcHelpExamples {\r\n    param($Context)\r\n    Show-PmcHelpTopic -Context $Context -Topic 'examples'\r\n}\r\n\r\n# Show interactive help guide\r\nfunction Show-PmcHelpGuide {\r\n    param($Context)\r\n    Write-PmcStyled -Style 'Header' -Text \"`n📚 PMC HELP GUIDE`n\"\r\n    Write-PmcStyled -Style 'Subheader' -Text 'Getting Started:'\r\n    Write-PmcStyled -Style 'Info' -Text '• help show - Browse all help categories'\r\n    Write-PmcStyled -Style 'Info' -Text '• help domain <name> - Show commands for a domain'\r\n    Write-PmcStyled -Style 'Info' -Text '• help command <cmd> - Show detailed command help'\r\n    Write-PmcStyled -Style 'Info' -Text '• help query - Learn the query language'\r\n    Write-PmcStyled -Style 'Info' -Text '• help examples - See practical examples'\r\n    Write-PmcStyled -Style 'Subheader' -Text '`nQuick Start:'\r\n    Write-PmcStyled -Style 'Code' -Text '  task add \"My first task\"'\r\n    Write-PmcStyled -Style 'Code' -Text '  task list'\r\n    Write-PmcStyled -Style 'Code' -Text '  view today'\r\n}\r\n\r\n# Search help content and commands\r\nfunction Show-PmcHelpSearch {\r\n    param($Context, [string]$Query)\r\n    if ($Context.Args.ContainsKey('query')) {\r\n        $Query = $Context.Args['query']\r\n    }\r\n    if ([string]::IsNullOrWhiteSpace($Query)) {\r\n        Write-PmcStyled -Style 'Warning' -Text 'Usage: help search <search_term>'\r\n        return\r\n    }\r\n\r\n    Write-PmcStyled -Style 'Header' -Text \"`n🔍 HELP SEARCH: $Query`n\"\r\n\r\n    $results = @()\r\n    $queryLower = $Query.ToLower()\r\n\r\n    # Search command descriptions\r\n    foreach ($domain in $Script:PmcCommandMap.Keys) {\r\n        foreach ($action in $Script:PmcCommandMap[$domain].Keys) {\r\n            $fullCmd = \"$domain $action\"\r\n            $desc = $(if ($Script:PmcCommandMeta.ContainsKey($fullCmd)) { $Script:PmcCommandMeta[$fullCmd].Desc } else { '' })\r\n\r\n            if ($fullCmd.ToLower().Contains($queryLower) -or $desc.ToLower().Contains($queryLower)) {\r\n                $results += [pscustomobject]@{\r\n                    command = $fullCmd\r\n                    description = $desc\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if ($results.Count -gt 0) {\r\n        $searchTemplate = [PmcTemplate]::new('help-search', @{\r\n            type = 'grid'\r\n            header = 'Command              Description'\r\n            row = '{command,-20} {description}'\r\n            settings = @{ separator = '─'; minWidth = 50 }\r\n        })\r\n        Render-GridTemplate -Data $results -Template $searchTemplate\r\n    } else {\r\n        Write-PmcStyled -Style 'Warning' -Text \"No help results found for: $Query\"\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Show-PmcSmartHelp, Show-PmcHelpCategories, Show-PmcHelpCommands, Show-PmcHelpDomain, Show-PmcHelpCommand, Show-PmcHelpQuery, Show-PmcHelpExamples, Show-PmcHelpGuide, Show-PmcHelpSearch"}, {"path": "module/Pmc.Strict/src/ImportExport.ps1", "content": "# Generic import/export of tasks (CSV/JSON)\r\n\r\nfunction Export-PmcTasks {\r\n    param(\r\n        $Context,\r\n        [string]$Path\r\n    )\r\n\r\n    # Handle both Context and direct -Path parameter calls\r\n    $outCsv = $null; $outJson = $null\r\n\r\n    if ($Path) {\r\n        # Direct path parameter provided\r\n        if ($Path -match '\\.json$') { $outJson = $Path }\r\n        else { $outCsv = $Path }\r\n    } elseif ($Context) {\r\n        # Parse tokens from context like out:foo.csv json:bar.json\r\n        foreach ($t in $Context.FreeText) {\r\n            if ($t -match '^(?i)out:(.+)$') { $outCsv = $matches[1] }\r\n            elseif ($t -match '^(?i)csv:(.+)$') { $outCsv = $matches[1] }\r\n            elseif ($t -match '^(?i)json:(.+)$') { $outJson = $matches[1] }\r\n        }\r\n        if (-not $outCsv -and -not $outJson) { $outCsv = 'exports/tasks.csv' }\r\n    } else {\r\n        $outCsv = 'exports/tasks.csv'\r\n    }\r\n\r\n    $data = Get-PmcDataAlias\r\n\r\n    $tasks = @($data.tasks)\r\n    if ($outCsv) {\r\n        try {\r\n            $path = Get-PmcSafePath $outCsv\r\n            if (-not (Test-Path (Split-Path $path -Parent))) { New-Item -ItemType Directory -Path (Split-Path $path -Parent) -Force | Out-Null }\r\n            $rows = @()\r\n            foreach ($t in $tasks) {\r\n                $rows += [pscustomobject]@{\r\n                    ID = $t.id\r\n                    Text = $t.text\r\n                    Project = $(if ($t.project) { $t.project } else { 'inbox' })\r\n                    Priority = $(if ($t.priority) { $t.priority } else { 0 })\r\n                    Due = $(if ($t.due) { $t.due } else { '' })\r\n                    Status = $(if ($t.status) { $t.status } else { 'pending' })\r\n                    Created = $(if ($t.created) { $t.created } else { '' })\r\n                }\r\n            }\r\n            $rows | Export-Csv -Path $path -NoTypeInformation -Encoding UTF8\r\n            Show-PmcSuccess (\"Exported CSV: {0}\" -f $path)\r\n        } catch { Show-PmcError (\"CSV export failed: {0}\" -f $_) }\r\n    }\r\n    if ($outJson) {\r\n        try {\r\n            $path = Get-PmcSafePath $outJson\r\n            if (-not (Test-Path (Split-Path $path -Parent))) { New-Item -ItemType Directory -Path (Split-Path $path -Parent) -Force | Out-Null }\r\n            $tasks | ConvertTo-Json -Depth 8 | Set-Content -Path $path -Encoding UTF8\r\n            Show-PmcSuccess (\"Exported JSON: {0}\" -f $path)\r\n        } catch { Show-PmcError (\"JSON export failed: {0}\" -f $_) }\r\n    }\r\n}\r\n\r\nfunction Import-PmcTasks {\r\n    param([PmcCommandContext]$Context)\r\n    $pathArg = ($Context.FreeText -join ' ').Trim()\r\n    if ([string]::IsNullOrWhiteSpace($pathArg)) { Write-PmcStyled -Style 'Warning' -Text \"Usage: import tasks <path.csv|path.json>\"; return }\r\n    $path = Get-PmcSafePath $pathArg\r\n    if (-not (Test-Path $path)) { Show-PmcError (\"File not found: {0}\" -f $path); return }\r\n    $data = Get-PmcDataAlias\r\n    $added = 0\r\n    if ($path -match '\\.json$') {\r\n        try { $items = Get-Content $path -Raw | ConvertFrom-Json } catch { Show-PmcError \"Invalid JSON\"; return }\r\n        foreach ($r in $items) {\r\n            $text = $(if ($r.PSObject.Properties['text'] -and $r.text) { $r.text } elseif ($r.PSObject.Properties['Text'] -and $r.Text) { $r.Text } else { $null })\r\n            if (-not $text) { continue }\r\n            $id = Get-PmcNextTaskId $data\r\n            $projVal = $(if ($r.PSObject.Properties['project'] -and $r.project) { $r.project } elseif ($r.PSObject.Properties['Project'] -and $r.Project) { $r.Project } else { 'inbox' })\r\n            $priVal = $(if ($r.PSObject.Properties['priority'] -and $r.priority) { $r.priority } elseif ($r.PSObject.Properties['Priority'] -and $r.Priority) { $r.Priority } else { 0 })\r\n            $t = @{ id=$id; text=$text; project=$projVal; priority=$priVal; status='pending'; created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss') }\r\n            if (($r.PSObject.Properties['due'] -and $r.due) -or ($r.PSObject.Properties['Due'] -and $r.Due)) { try { $t.due = ([datetime]($(if ($r.due) { $r.due } else { $r.Due }))).ToString('yyyy-MM-dd') } catch {\r\n                # Date parsing failed - skip due date assignment\r\n            } }\r\n            $data.tasks += $t; $added++\r\n        }\r\n        Save-StrictData $data 'import tasks'\r\n        Show-PmcSuccess (\"Imported {0} task(s) from JSON\" -f $added)\r\n        return\r\n    }\r\n    if ($path -match '\\.csv$') {\r\n        $rows = @(); try { $rows = Import-Csv -Path $path } catch { Show-PmcError (\"Failed to read CSV: {0}\" -f $_); return }\r\n        foreach ($r in $rows) {\r\n            $text = $(if ($r.PSObject.Properties['Text'] -and $r.Text) { $r.Text } elseif ($r.PSObject.Properties['Task'] -and $r.Task) { $r.Task } else { $null })\r\n            if (-not $text) { continue }\r\n            $proj = $(if ($r.PSObject.Properties['Project'] -and $r.Project) { $r.Project } else { 'inbox' })\r\n            $pri = try { [int]$r.Priority } catch { 0 }\r\n            $due = $null; try { if ($r.Due) { $due = [datetime]$r.Due } } catch {\r\n                # Date parsing failed - due will remain null\r\n            }\r\n            $id = Get-PmcNextTaskId $data\r\n            $task = @{ id=$id; text=$text; project=$proj; priority=$pri; status='pending'; created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss') }\r\n            if ($due) { $task.due = $due.ToString('yyyy-MM-dd') }\r\n            $data.tasks += $task; $added++\r\n        }\r\n        Save-StrictData $data 'import tasks'\r\n        Show-PmcSuccess (\"Imported {0} task(s) from CSV\" -f $added)\r\n        return\r\n    }\r\n    Show-PmcWarning 'Unsupported file type (use .csv or .json)'\r\n}\r\n\r\nExport-ModuleMember -Function Export-PmcTasks, Import-PmcTasks"}, {"path": "module/Pmc.Strict/src/Interactive.ps1", "content": "# t2.ps1-Style Interactive Engine for PMC\r\n# Complete implementation with inline cycling, history, undo/redo, and comprehensive instrumentation\r\n# IMPORTANT: Completions MUST be plain strings. PSObjects/PSCustomObject and\r\n# PSReadLine-style completion objects are not supported by this custom Console.ReadKey\r\n# engine. Using objects breaks input flow and causes type/serialization errors.\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Completions are simple strings throughout the system\r\n# Classes remain defined in the main .psm1 file if needed elsewhere\r\n\r\n# Centralized interactive state accessors (state-only)\r\nfunction Pmc-GetEditor { $e = Get-PmcState -Section 'Interactive' -Key 'Editor'; if ($null -eq $e) { $e = [PmcEditorState]::new(); Set-PmcState -Section 'Interactive' -Key 'Editor' -Value $e }; return $e }\r\nfunction Pmc-SetEditor($e) { Set-PmcState -Section 'Interactive' -Key 'Editor' -Value $e }\r\nfunction Pmc-GetCache { $c = Get-PmcState -Section 'Interactive' -Key 'CompletionCache'; if ($null -eq $c) { $c=@{}; Set-PmcState -Section 'Interactive' -Key 'CompletionCache' -Value $c }; return $c }\r\nfunction Pmc-SetCache($c) { Set-PmcState -Section 'Interactive' -Key 'CompletionCache' -Value $c }\r\nfunction Pmc-ClearCache { $c = Pmc-GetCache; $c.Clear() | Out-Null; Pmc-SetCache $c }\r\nfunction Pmc-GetGhost { $g = Get-PmcState -Section 'Interactive' -Key 'GhostTextEnabled'; if ($null -eq $g) { $g=$false; Set-PmcState -Section 'Interactive' -Key 'GhostTextEnabled' -Value $g }; return [bool]$g }\r\nfunction Pmc-SetGhost([bool]$g) { Set-PmcState -Section 'Interactive' -Key 'GhostTextEnabled' -Value $g }\r\nfunction Pmc-GetInfoMap { $m = Get-PmcState -Section 'Interactive' -Key 'CompletionInfoMap'; if ($null -eq $m) { $m=@{}; Set-PmcState -Section 'Interactive' -Key 'CompletionInfoMap' -Value $m }; return $m }\r\nfunction Pmc-SetInfoMap($m) { Set-PmcState -Section 'Interactive' -Key 'CompletionInfoMap' -Value $m }\r\n\r\n# Insert literal text at cursor and re-render input line\r\nfunction Pmc-InsertAtCursor {\r\n    param([Parameter(Mandatory=$true)][string]$Text)\r\n    try {\r\n        $ed = Pmc-GetEditor\r\n        $before = $ed.Buffer\r\n        $pos = [Math]::Max(0, [Math]::Min($ed.CursorPos, $before.Length))\r\n        $ed.Buffer = $before.Substring(0, $pos) + $Text + $before.Substring($pos)\r\n        $ed.CursorPos = $pos + $Text.Length\r\n        Render-Interactive -Buffer $ed.Buffer -CursorPos $ed.CursorPos -InCompletion $false\r\n    } catch {}\r\n}\r\n\r\n# Fuzzy matching utilities (subsequence with ranking)\r\nfunction Invoke-PmcFuzzyFilter {\r\n    param(\r\n        [string[]] $Items,\r\n        [string] $Query\r\n    )\r\n    if (-not $Items) { return @() }\r\n    if ([string]::IsNullOrWhiteSpace($Query)) { return ,@($Items) }\r\n\r\n    $q = $Query.ToLowerInvariant()\r\n    $scored = @()\r\n    foreach ($it in $Items) {\r\n        $s = [string]$it\r\n        $t = $s.ToLowerInvariant()\r\n        $rank = $null\r\n        if ($t.StartsWith($q)) { $rank = 0 }\r\n        elseif ($t.Contains($q)) { $rank = 1 }\r\n        elseif (Test-PmcSubsequence -Haystack $t -Needle $q) { $rank = 2 }\r\n        if ($rank -ne $null) { $scored += [pscustomobject]@{ Item=$s; Rank=$rank } }\r\n    }\r\n    $ordered = $scored | Sort-Object Rank, @{Expression={$_.Item.Length}; Ascending=$true}, Item\r\n    return @($ordered | Select-Object -ExpandProperty Item)\r\n}\r\n\r\nfunction Test-PmcSubsequence {\r\n    param([string] $Haystack, [string] $Needle)\r\n    if ([string]::IsNullOrEmpty($Needle)) { return $true }\r\n    $i = 0; $j = 0\r\n    while ($i -lt $Haystack.Length -and $j -lt $Needle.Length) {\r\n        if ($Haystack[$i] -eq $Needle[$j]) { $j++ }\r\n        $i++\r\n    }\r\n    return ($j -eq $Needle.Length)\r\n}\r\n\r\nfunction Initialize-PmcCompletionInfoMap {\r\n    $map = @{}\r\n\r\n    # Domain descriptions\r\n    $map['task']      = @{ Description = 'Task management';       Category = 'Domain' }\r\n    $map['project']   = @{ Description = 'Project management';     Category = 'Domain' }\r\n    $map['time']      = @{ Description = 'Time logging/reporting'; Category = 'Domain' }\r\n    $map['timer']     = @{ Description = 'Timers';                 Category = 'Domain' }\r\n    $map['view']      = @{ Description = 'Predefined views';       Category = 'Domain' }\r\n    $map['focus']     = @{ Description = 'Focus mode';             Category = 'Domain' }\r\n    $map['system']    = @{ Description = 'System ops';             Category = 'Domain' }\r\n    $map['config']    = @{ Description = 'Configuration';          Category = 'Domain' }\r\n    $map['excel']     = @{ Description = 'Excel I/O';              Category = 'Domain' }\r\n    $map['theme']     = @{ Description = 'Theme settings';         Category = 'Domain' }\r\n    $map['activity']  = @{ Description = 'Activity log';           Category = 'Domain' }\r\n    $map['template']  = @{ Description = 'Templates';              Category = 'Domain' }\r\n    $map['recurring'] = @{ Description = 'Recurring rules';        Category = 'Domain' }\r\n    $map['alias']     = @{ Description = 'Aliases';                Category = 'Domain' }\r\n    $map['dep']       = @{ Description = 'Dependencies';           Category = 'Domain' }\r\n    $map['import']    = @{ Description = 'Import data';            Category = 'Domain' }\r\n    $map['export']    = @{ Description = 'Export data';            Category = 'Domain' }\r\n    $map['show']      = @{ Description = 'Show info';              Category = 'Domain' }\r\n    $map['interactive']= @{ Description = 'Interactive mode';      Category = 'Domain' }\r\n    $map['help']      = @{ Description = 'Help';                   Category = 'Domain' }\r\n\r\n    # Domain:Action descriptions (keyed as \"domain:action\")\r\n    $pairs = @(\r\n        'task:add=Add new task','task:list=List tasks','task:done=Mark task done','task:edit=Edit task','task:delete=Delete task','task:view=View task','task:search=Search tasks',\r\n        'project:add=Add project','project:list=List projects','project:view=View project','project:update=Update project','project:rename=Rename project','project:delete=Delete project','project:archive=Archive project','project:set-fields=Set custom fields','project:show-fields=Show custom fields','project:stats=Project statistics','project:info=Project info','project:recent=Recent projects',\r\n        'time:log=Log time','time:list=List entries','time:report=Report','time:edit=Edit entries',\r\n        'timer:start=Start timer','timer:stop=Stop timer','timer:status=Timer status',\r\n        'view:today=Today view','view:tomorrow=Tomorrow view','view:overdue=Overdue tasks','view:upcoming=Upcoming','view:blocked=Blocked','view:noduedate=No due date','view:projects=Projects overview','view:next=Next actions',\r\n        'focus:set=Set focus','focus:clear=Clear focus','focus:status=Focus status',\r\n        'system:undo=Undo last action','system:redo=Redo last action','system:backup=Create backup','system:clean=Clean data',\r\n        'config:show=Show config','config:edit=Edit config','config:set=Set config','config:icons=Icon config',\r\n        'excel:import=Import from Excel','excel:view=View excel output','excel:export=Export to Excel',\r\n        'theme:set=Set theme','theme:list=List themes','theme:create=Create theme','theme:edit=Edit theme',\r\n        'activity:log=Log activity','activity:list=List activity','activity:report=Activity report',\r\n        'template:create=Create template','template:list=List templates','template:apply=Apply template','template:edit=Edit template','template:delete=Delete template',\r\n        'recurring:add=Add recurring rule','recurring:list=List recurring rules','recurring:edit=Edit recurring rule','recurring:delete=Delete recurring rule','recurring:process=Process recurring',\r\n        'alias:add=Add alias','alias:list=List aliases','alias:edit=Edit alias','alias:delete=Delete alias',\r\n        'dep:add=Add dependency','dep:list=List dependencies','dep:remove=Remove dependency','dep:check=Check dependencies',\r\n        'import:excel=Import from Excel','import:csv=Import from CSV','import:json=Import from JSON','import:outlook=Import from Outlook',\r\n        'export:excel=Export to Excel','export:csv=Export to CSV','export:json=Export to JSON','export:ical=Export to iCal',\r\n        'show:status=Show status','show:config=Show config','show:help=Show help','show:version=Show version',\r\n        'interactive:enable=Enable interactive','interactive:disable=Disable interactive','interactive:status=Interactive status',\r\n        'help:commands=Help commands','help:examples=Help examples','help:guide=Help guide','help:quick=Quick help'\r\n    )\r\n    foreach ($pair in $pairs) {\r\n        $kv = $pair.Split('=')\r\n        $map[$kv[0]] = @{ Description = $kv[1]; Category = 'Action' }\r\n    }\r\n\r\n    # Common argument suggestions\r\n    $map['due:today'] = @{ Description = 'Due today';    Category = 'Argument' }\r\n    $map['due:tomorrow'] = @{ Description = 'Due tomorrow'; Category = 'Argument' }\r\n    $map['due:friday'] = @{ Description = 'Due Friday';  Category = 'Argument' }\r\n    $map['due:+1w'] = @{ Description = 'Due +1 week';    Category = 'Argument' }\r\n    $map['due:+1m'] = @{ Description = 'Due +1 month';   Category = 'Argument' }\r\n    $map['p1'] = @{ Description = 'Priority 1'; Category = 'Argument' }\r\n    $map['p2'] = @{ Description = 'Priority 2'; Category = 'Argument' }\r\n    $map['p3'] = @{ Description = 'Priority 3'; Category = 'Argument' }\r\n    $map['#urgent'] = @{ Description = 'Urgent tag'; Category = 'Argument' }\r\n    $map['#bug']    = @{ Description = 'Bug tag'; Category = 'Argument' }\r\n    $map['#feature']= @{ Description = 'Feature tag'; Category = 'Argument' }\r\n    $map['#review'] = @{ Description = 'Review tag'; Category = 'Argument' }\r\n\r\n    Pmc-SetInfoMap $map\r\n}\r\n\r\nfunction Get-PmcCompletionInfo {\r\n    param(\r\n        [string] $Domain,\r\n        [string] $Action,\r\n        [string] $Text\r\n    )\r\n    if ($Action) {\r\n        $d = $null\r\n        if ($Domain) { $d = $Domain.ToLower() }\r\n        $a = $Action.ToLower()\r\n        $key = \"${d}:${a}\"\r\n        return (Pmc-GetInfoMap)[$key]\r\n    }\r\n    if ($Text) { return (Pmc-GetInfoMap)[$Text.ToLower()] }\r\n    return $null\r\n}\r\n\r\n# High-level renderer that computes transient help text before delegating to Render-Line\r\nfunction Render-Interactive {\r\n    param(\r\n        [string] $Buffer,\r\n        [int] $CursorPos,\r\n        [int] $IndicatorIndex = 0,\r\n        [int] $IndicatorCount = 0,\r\n        [bool] $InCompletion = $false\r\n    )\r\n\r\n    $helpText = $null\r\n    $ghostText = \"\"\r\n    if (-not $InCompletion) {\r\n        try {\r\n            $ctx = Parse-CompletionContext -Buffer $Buffer -CursorPos $CursorPos\r\n            if ($ctx.Mode -eq [PmcCompletionMode]::Domain) {\r\n                if ($ctx.CurrentToken) {\r\n                    $info = Get-PmcCompletionInfo -Text $ctx.CurrentToken\r\n                    if ($info) { $helpText = $info.Description }\r\n                }\r\n            } elseif ($ctx.Mode -eq [PmcCompletionMode]::Action) {\r\n                if ($ctx.Tokens.Count -gt 0 -and $ctx.CurrentToken) {\r\n                    $info = Get-PmcCompletionInfo -Domain $ctx.Tokens[0] -Action $ctx.CurrentToken\r\n                    $summary = Pmc-FormatSchemaSummary -Domain $ctx.Tokens[0] -Action $ctx.CurrentToken\r\n                    if ($summary) { $helpText = $summary }\r\n                    elseif ($info) { $helpText = $info.Description }\r\n                }\r\n            } elseif ($ctx.Mode -eq [PmcCompletionMode]::Arguments) {\r\n                $dom = $null; if ($ctx.Tokens.Count -gt 0) { $dom = $ctx.Tokens[0] }\r\n                $act = $null; if ($ctx.Tokens.Count -gt 1) { $act = $ctx.Tokens[1] }\r\n                if ($dom -and $act) {\r\n                    $summary = Pmc-FormatSchemaSummary -Domain $dom -Action $act\r\n                    if ($summary) { $helpText = $summary }\r\n                } elseif ($ctx.CurrentToken) {\r\n                    $info = Get-PmcCompletionInfo -Text $ctx.CurrentToken\r\n                    if ($info) { $helpText = $info.Description }\r\n                }\r\n            }\r\n            # Compute ghost text (inline suggestion) - DISABLED\r\n            $ghostText = \"\"\r\n\r\n            # No numeric suggestion line; keep help minimal and passive\r\n        } catch {}\r\n    }\r\n\r\n    Render-Line -Buffer $Buffer -CursorPos $CursorPos -IndicatorIndex $IndicatorIndex -IndicatorCount $IndicatorCount -InCompletion $InCompletion -HelpText $helpText -GhostText $ghostText\r\n}\r\n\r\n# Build a compact argument summary from schema for inline guidance\r\nfunction Pmc-FormatSchemaSummary {\r\n    param([string]$Domain,[string]$Action)\r\n    if (-not $Domain -or -not $Action) { return $null }\r\n    try {\r\n        $schema = Get-PmcSchema -Domain $Domain -Action $Action\r\n        if (-not $schema -or @($schema).Count -eq 0) { return $null }\r\n        $parts = @()\r\n        foreach ($def in $schema) {\r\n            $name = [string]$def['Name']\r\n            $type = [string]$def['Type']\r\n            $prefix = [string]$def['Prefix']\r\n            $req = [bool]$def['Required']\r\n            $allowsMulti = [bool]$def['AllowsMultiple']\r\n\r\n            $token = $null\r\n            switch ($type) {\r\n                'ProjectName' { $token = '@project' }\r\n                'Priority'    { $token = 'p1|p2|p3' }\r\n                'DateString'  { $token = 'due:YYYY-MM-DD' }\r\n                'TagName'     { if ($allowsMulti) { $token = '#tag...' } else { $token = '#tag' } }\r\n                'TaskID'      { $token = '<id>' }\r\n                'Duration'    { $token = '<duration>' }\r\n                'DateRange'   { $token = '<range>' }\r\n                default {\r\n                    if ($prefix) { $token = \"$prefix$name\" }\r\n                    elseif ($name -match '^(?i)text$') { $token = '<text>' }\r\n                    else { $token = \"<$name>\" }\r\n                }\r\n            }\r\n\r\n            if (-not $req) { $token = \"[$token]\" }\r\n            $parts += $token\r\n        }\r\n        if ($parts.Count -gt 0) { return ('Args: ' + ($parts -join ' ')) }\r\n    } catch {}\r\n    return $null\r\n}\r\n\r\n# Helper function removed - we now use simple strings instead of PSCustomObjects\r\n# This eliminates the dual completion path issue where PSCustomObjects were being created\r\n\r\n# Debug helper: log state transitions at Debug2\r\nfunction Write-StateChange {\r\n    param(\r\n        [string] $KeyName,\r\n        [hashtable] $BeforeCtx,\r\n        [bool] $BeforeInCompletion\r\n    )\r\n    try {\r\n        $ed = Pmc-GetEditor\r\n        $afterCtx = Parse-CompletionContext -Buffer $ed.Buffer -CursorPos $ed.CursorPos\r\n        $afterIn = $ed.InCompletion\r\n        Write-PmcDebug -Level 2 -Category 'STATE' -Message \"Key=$KeyName InCompletion: $BeforeInCompletion->$afterIn Mode: $($BeforeCtx.Mode)->$($afterCtx.Mode) BufferLen=$($ed.Buffer.Length) Cursor=$($ed.CursorPos)\"\r\n    } catch {\r\n        # Ghost text computation failed - return empty string\r\n    }\r\n}\r\n\r\n# Compute ghost hint text based on current context (pure)\r\nfunction Compute-GhostText {\r\n    param(\r\n        [string] $Buffer,\r\n        [hashtable] $Context\r\n    )\r\n\r\n    if (-not (Pmc-GetGhost)) { return \"\" }\r\n\r\n    try {\r\n        $ghost = \"\"\r\n        $hasTrailingSpace = $Buffer.EndsWith(' ')\r\n\r\n        if ($Context.Mode -eq [PmcCompletionMode]::Domain) {\r\n            # Show domain hints when starting or when current token is incomplete\r\n            if ([string]::IsNullOrEmpty($Context.CurrentToken) -or -not $hasTrailingSpace) {\r\n                $ghost = \" task|project|time...\"\r\n            }\r\n        } elseif ($Context.Mode -eq [PmcCompletionMode]::Action) {\r\n            # Show action hints when we have a domain and are ready for action\r\n            if ($Context.Tokens.Count -ge 1 -and $hasTrailingSpace) {\r\n                $domain = $Context.Tokens[0].ToLower()\r\n                switch ($domain) {\r\n                    'task' { $ghost = \" add|list|done|edit\" }\r\n                    'project' { $ghost = \" add|list|view|edit\" }\r\n                    'time' { $ghost = \" log|report|list\" }\r\n                    'timer' { $ghost = \" start|stop|status\" }\r\n                    'view' { $ghost = \" today|tomorrow|overdue\" }\r\n                    'focus' { $ghost = \" set|clear|status\" }\r\n                    'system' { $ghost = \" undo|redo|backup\" }\r\n                    'config' { $ghost = \" show|edit|set\" }\r\n                    default { $ghost = \" help\" }\r\n                }\r\n            }\r\n        } elseif ($Context.Mode -eq [PmcCompletionMode]::Arguments) {\r\n            # Show argument hints when we have domain and action\r\n            if ($Context.Tokens.Count -ge 2 -and $hasTrailingSpace) {\r\n                $ghost = \" @project due:date p1-3 #tags\"\r\n            }\r\n        }\r\n\r\n        Write-PmcDebug -Level 3 -Category 'GHOST' -Message \"Ghost computation: Mode=$($Context.Mode), Tokens=[$($Context.Tokens -join ', ')], HasTrailingSpace=$hasTrailingSpace, Ghost='$ghost'\"\r\n        return $(if ($null -ne $ghost) { $ghost } else { \"\" })\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'GHOST' -Message \"Ghost computation error: $_\"\r\n        return \"\"\r\n    }\r\n}\r\n\r\n# Get terminal dimensions for TUI layout\r\nfunction Get-TerminalSize {\r\n    return [PmcTerminalService]::GetDimensions()\r\n}\r\n\r\n# Clear screen and position cursor for command output\r\nfunction Clear-CommandOutput {\r\n    [Console]::Write(\"`e[2J`e[H\")  # Clear screen + move to top\r\n    [Console]::Out.Flush()\r\n}\r\n\r\n# Simplified inline renderer for compatibility\r\nfunction Render-Line {\r\n    param(\r\n        [string] $Buffer,\r\n        [int] $CursorPos,\r\n        [int] $IndicatorIndex = 0,\r\n        [int] $IndicatorCount = 0,\r\n        [bool] $InCompletion = $false,\r\n        [string] $HelpText = $null,\r\n        [string] $GhostText = $null\r\n    )\r\n\r\n    $prompt = \"pmc> \"\r\n    $promptLen = $prompt.Length\r\n\r\n    # Compute indicator text\r\n    $indicatorText = ''\r\n    if ($IndicatorCount -gt 1) {\r\n        $displayIndex = [Math]::Max(1, $IndicatorIndex)\r\n        $indicatorText = \" ($displayIndex/$IndicatorCount)\"\r\n    }\r\n\r\n    # Two-line HUD: input at last-1 row, help at last row\r\n    $term = Get-TerminalSize\r\n    $inputRow = [Math]::Max(1, $term.Height - 1)\r\n    $helpRow = $term.Height\r\n\r\n    # Compute visible input line (truncate to width)\r\n    $lineCore = \"$prompt$Buffer$indicatorText\"\r\n    if ($lineCore.Length -gt $term.Width) {\r\n        # Prefer to keep cursor region visible; simple right-trim for now\r\n        $lineCore = $lineCore.Substring(0, $term.Width)\r\n    }\r\n\r\n    # Compute help line (truncate to width)\r\n    $helpOut = ''\r\n    if ($HelpText -and $HelpText.Trim().Length -gt 0) {\r\n        $helpOut = $HelpText.Trim()\r\n        if ($helpOut.Length -gt $term.Width) { $helpOut = $helpOut.Substring(0, $term.Width) }\r\n    }\r\n\r\n    # Clear the two bottom lines and render\r\n    [Console]::Write(\"`e[${inputRow};1H`e[2K\")\r\n    [Console]::Write($lineCore)\r\n\r\n    # Ghost text rendering disabled\r\n    [Console]::Write(\"`e[${helpRow};1H`e[2K\")\r\n    if ($helpOut) { [Console]::Write($helpOut) }\r\n    [Console]::Out.Flush()\r\n\r\n    # Restore cursor to input line/column\r\n    # Place caret at the insertion point (after the last typed character)\r\n    $targetCol = [Math]::Min($term.Width, $promptLen + $CursorPos + 1)\r\n    if ($targetCol -lt 1) { $targetCol = 1 }\r\n    [Console]::Write(\"`e[${inputRow};${targetCol}H\")\r\n    [Console]::Out.Flush()\r\n\r\n    Write-PmcDebug -Level 2 -Category 'RENDER' -Message \"Bottom HUD render: bufferLen=$($Buffer.Length), cursorPos=$CursorPos, width=$($term.Width)\"\r\n}\r\n\r\n# No conversion factory: completions are plain strings by design\r\n\r\n# Tokenization: compute current token boundaries for replacement\r\nfunction Get-TokenBoundaries {\r\n    param(\r\n        [string] $Buffer,\r\n        [int] $CursorPos\r\n    )\r\n\r\n    if ([string]::IsNullOrEmpty($Buffer)) {\r\n        return @{ Start = 0; End = 0; Token = \"\" }\r\n    }\r\n\r\n    # Find token boundaries around cursor\r\n    $start = $CursorPos\r\n    $end = $CursorPos\r\n\r\n    # Move start backward to beginning of current token\r\n    while ($start -gt 0 -and $Buffer[$start - 1] -ne ' ') {\r\n        $start--\r\n    }\r\n\r\n    # Move end forward to end of current token\r\n    while ($end -lt $Buffer.Length -and $Buffer[$end] -ne ' ') {\r\n        $end++\r\n    }\r\n\r\n    $token = $(if ($start -lt $Buffer.Length -and $end -gt $start) {\r\n        $Buffer.Substring($start, $end - $start)\r\n    } else {\r\n        \"\"\r\n    })\r\n\r\n    return @{\r\n        Start = $start\r\n        End = $end\r\n        Token = $token\r\n    }\r\n}\r\n\r\n# Parse buffer to determine completion mode and context\r\nfunction Parse-CompletionContext {\r\n    param(\r\n        [string] $Buffer,\r\n        [int] $CursorPos\r\n    )\r\n\r\n    # Use the same tokenizer as the rest of the system for consistency\r\n    $tokens = ConvertTo-PmcTokens $Buffer\r\n    $tokenInfo = Get-TokenBoundaries -Buffer $Buffer -CursorPos $CursorPos\r\n\r\n    $mode = [PmcCompletionMode]::Domain\r\n    $currentToken = $tokenInfo.Token\r\n\r\n    # Determine completion mode based on token position and trailing space\r\n    $hasTrailingSpace = $Buffer.EndsWith(' ')\r\n\r\n    if ($tokens.Count -eq 0) {\r\n        $mode = [PmcCompletionMode]::Domain\r\n    } elseif ($tokens.Count -eq 1 -and -not $hasTrailingSpace) {\r\n        # Still typing first token (domain)\r\n        $mode = [PmcCompletionMode]::Domain\r\n    } elseif ($tokens.Count -eq 1 -and $hasTrailingSpace) {\r\n        # First token complete, ready for action\r\n        $mode = [PmcCompletionMode]::Action\r\n    } elseif ($tokens.Count -eq 2 -and -not $hasTrailingSpace) {\r\n        # Still typing second token (action)\r\n        $mode = [PmcCompletionMode]::Action\r\n    } elseif ($tokens.Count -eq 2 -and $hasTrailingSpace) {\r\n        # Domain and action complete, ready for arguments\r\n        $mode = [PmcCompletionMode]::Arguments\r\n    } elseif ($tokens.Count -ge 3) {\r\n        # In arguments phase\r\n        $mode = [PmcCompletionMode]::Arguments\r\n    } else {\r\n        $mode = [PmcCompletionMode]::FreeText\r\n    }\r\n\r\n    Write-PmcDebug -Level 3 -Category 'COMPLETION' -Message \"Parsed context: Tokens=[$($tokens -join ', ')], Mode=$mode (tokenCount=$($tokens.Count), hasTrailingSpace=$hasTrailingSpace)\"\r\n\r\n    return @{\r\n        Mode = $mode\r\n        CurrentToken = $currentToken\r\n        TokenStart = $tokenInfo.Start\r\n        TokenEnd = $tokenInfo.End\r\n        Tokens = $tokens\r\n    }\r\n}\r\n\r\n# Domain completion provider\r\nfunction Get-PmcDomainCompletions {\r\n    param(\r\n        [string] $Filter = \"\"\r\n    )\r\n\r\n    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Getting domain completions for filter='$Filter'\"\r\n\r\n    try {\r\n        # Simple string array - no objects, no type conversion issues\r\n        $domains = @(\r\n            \"task\", \"project\", \"time\", \"timer\", \"view\", \"focus\",\r\n            \"system\", \"config\", \"excel\", \"theme\", \"activity\",\r\n            \"template\", \"recurring\", \"alias\", \"dep\", \"import\",\r\n            \"export\", \"show\", \"interactive\", \"help\"\r\n        )\r\n\r\n        # Add shortcut commands from the shortcut map\r\n        $shortcuts = @()\r\n        if ($Script:PmcShortcutMap -and $Script:PmcShortcutMap.Keys) {\r\n            $shortcuts = @($Script:PmcShortcutMap.Keys)\r\n        }\r\n\r\n        # Combine domains and shortcuts\r\n        $allCompletions = $domains + $shortcuts\r\n\r\n        $result = Invoke-PmcFuzzyFilter -Items $allCompletions -Query $Filter\r\n        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Domain completions: found $(@($result).Count) items\"\r\n        return ,@($result)\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'COMPLETION' -Message \"Domain completion error: $_\"\r\n        return @()\r\n    }\r\n}\r\n\r\n# Action completion provider\r\nfunction Get-PmcActionCompletions {\r\n    param([string] $Domain = \"\", [string] $Filter = \"\")\r\n\r\n    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Getting action completions for domain='$Domain', filter='$Filter'\"\r\n\r\n    try {\r\n        $actions = @()\r\n\r\n        switch ($Domain.ToLower()) {\r\n            'task' {\r\n                $actions = @(\"add\", \"list\", \"done\", \"edit\", \"delete\", \"view\", \"search\")\r\n            }\r\n            'project' {\r\n                $actions = @(\"add\", \"list\", \"view\", \"update\", \"rename\", \"delete\", \"archive\", \"set-fields\", \"show-fields\", \"stats\", \"info\", \"recent\")\r\n            }\r\n            'time' {\r\n                $actions = @(\"log\", \"list\", \"report\", \"edit\")\r\n            }\r\n            'timer' {\r\n                $actions = @(\"start\", \"stop\", \"status\")\r\n            }\r\n            'view' {\r\n                $actions = @(\"today\", \"tomorrow\", \"overdue\", \"upcoming\", \"blocked\", \"noduedate\", \"projects\", \"next\")\r\n            }\r\n            'focus' {\r\n                $actions = @(\"set\", \"clear\", \"status\")\r\n            }\r\n            'system' {\r\n                $actions = @(\"undo\", \"redo\", \"backup\", \"clean\")\r\n            }\r\n            'config' {\r\n                $actions = @(\"show\", \"edit\", \"set\", \"icons\")\r\n            }\r\n            'excel' {\r\n                $actions = @(\"import\", \"view\", \"export\")\r\n            }\r\n            'theme' {\r\n                $actions = @(\"set\", \"list\", \"create\", \"edit\")\r\n            }\r\n            'activity' {\r\n                $actions = @(\"log\", \"list\", \"report\")\r\n            }\r\n            'template' {\r\n                $actions = @(\"create\", \"list\", \"apply\", \"edit\", \"delete\")\r\n            }\r\n            'recurring' {\r\n                $actions = @(\"add\", \"list\", \"edit\", \"delete\", \"process\")\r\n            }\r\n            'alias' {\r\n                $actions = @(\"add\", \"list\", \"edit\", \"delete\")\r\n            }\r\n            'dep' {\r\n                $actions = @(\"add\", \"list\", \"remove\", \"check\")\r\n            }\r\n            'import' {\r\n                $actions = @(\"excel\", \"csv\", \"json\", \"outlook\")\r\n            }\r\n            'export' {\r\n                $actions = @(\"excel\", \"csv\", \"json\", \"ical\")\r\n            }\r\n            'show' {\r\n                $actions = @(\"status\", \"config\", \"help\", \"version\")\r\n            }\r\n            'interactive' {\r\n                $actions = @(\"enable\", \"disable\", \"status\")\r\n            }\r\n            'help' {\r\n                $actions = @(\"commands\", \"examples\", \"guide\", \"quick\")\r\n            }\r\n            default {\r\n                return @()\r\n            }\r\n        }\r\n\r\n        $result = Invoke-PmcFuzzyFilter -Items $actions -Query $Filter\r\n        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Action completions: found $(@($result).Count) items\"\r\n        return ,@($result)\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'COMPLETION' -Message \"Error in Get-PmcActionCompletions: $_\"\r\n        return @()\r\n    }\r\n}\r\n\r\n# Argument completion provider (projects, dates, priorities, etc.)\r\nfunction Get-PmcArgumentCompletions {\r\n    param(\r\n        [string] $Domain,\r\n        [string] $Action,\r\n        [string] $Filter = \"\"\r\n    )\r\n\r\n    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Getting argument completions for domain='$Domain' action='$Action' filter='$Filter'\"\r\n\r\n    try {\r\n        $completions = @()\r\n\r\n        # Project completions (@project)\r\n        if ($Filter.StartsWith('@') -or [string]::IsNullOrEmpty($Filter)) {\r\n            try {\r\n                $data = Get-PmcData\r\n                $projects = @($data.projects)\r\n                $all = @()\r\n                foreach ($project in $projects) { $all += (\"@\" + [string]$project.name) }\r\n                $needle = $(if ($Filter -like '@*') { $Filter } else { '@' + $Filter })\r\n                $filtered = Invoke-PmcFuzzyFilter -Items $all -Query $needle\r\n                $completions += $filtered\r\n            } catch {\r\n                Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Project loading error: $_\"\r\n            }\r\n        }\r\n\r\n        # Date completions (due:)\r\n        if ($Filter.StartsWith('due') -or [string]::IsNullOrWhiteSpace($Filter)) {\r\n            $dates = @(\"due:today\", \"due:tomorrow\", \"due:friday\", \"due:+1w\", \"due:+1m\", \"due>today\", \"due<today\", \"due>=today\", \"due<=today\", \"due>2024-12-31\", \"due<2024-12-31\")\r\n            $completions += (Invoke-PmcFuzzyFilter -Items $dates -Query $Filter)\r\n        }\r\n\r\n        # Priority completions\r\n        if ($Filter.StartsWith('p') -or [string]::IsNullOrWhiteSpace($Filter)) {\r\n            $priorities = @(\"p1\", \"p2\", \"p3\", \"p<=1\", \"p<=2\", \"p<=3\", \"p>=1\", \"p>=2\", \"p>=3\", \"p>1\", \"p>2\", \"p<2\", \"p<3\")\r\n            $completions += (Invoke-PmcFuzzyFilter -Items $priorities -Query $Filter)\r\n        }\r\n\r\n        # '#' handling: for time log, '#' means ID1 time codes (2-5 digits).\r\n        # Otherwise, '#' is tag completion.\r\n        if ($Filter.StartsWith('#') -or [string]::IsNullOrWhiteSpace($Filter)) {\r\n            if (($Domain -eq 'time') -and ($Action -eq 'log')) {\r\n                try {\r\n                    $data = Get-PmcDataAlias\r\n                    $codes = @()\r\n                    foreach ($l in $data.timelogs) {\r\n                        try { if ($l.PSObject.Properties['id1'] -and $l.id1 -match '^\\d{2,5}$') { $codes += ('#' + [string]$l.id1) } } catch {}\r\n                    }\r\n                    $codes = @($codes | Select-Object -Unique)\r\n                    if ($codes.Count -gt 0) { $completions += (Invoke-PmcFuzzyFilter -Items $codes -Query $Filter) }\r\n                } catch {}\r\n            } else {\r\n                $tags = @()\r\n                try {\r\n                    $data = Get-PmcDataAlias\r\n                    foreach ($t in $data.tasks) {\r\n                        try {\r\n                            if ($t -and $t.PSObject.Properties['tags']) {\r\n                                foreach ($tg in @($t.tags)) { if ($tg) { $tags += (\"#\" + [string]$tg) } }\r\n                            }\r\n                        } catch {}\r\n                    }\r\n                } catch {}\r\n                if ($tags.Count -eq 0) { $tags = @(\"#urgent\", \"#todo\", \"#review\") }\r\n                $tags = @($tags | Select-Object -Unique)\r\n                $completions += (Invoke-PmcFuzzyFilter -Items $tags -Query $Filter)\r\n            }\r\n        }\r\n\r\n        # Add query history suggestions if no specific prefix\r\n        if ([string]::IsNullOrWhiteSpace($Filter) -or ($Filter.Length -eq 1 -and $Filter -match '^[a-z]$')) {\r\n            try {\r\n                $history = Get-PmcQueryHistory -Last 5\r\n                $historyCompletions = @()\r\n                foreach ($h in $history) {\r\n                    if ($h -and $h.Trim() -ne '' -and $h -notlike \"*$Filter*\") { continue }\r\n                    $historyCompletions += \"◄ $h\"\r\n                }\r\n                $completions += $historyCompletions\r\n            } catch {\r\n                Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"History loading error: $_\"\r\n            }\r\n        }\r\n\r\n        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Argument completions: found $(@($completions).Count) items\"\r\n        return ,@($completions)\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'COMPLETION' -Message \"Argument completion error: $_\"\r\n        return @()\r\n    }\r\n}\r\n\r\n# Get completions with caching and comprehensive instrumentation\r\nfunction Get-CompletionsForState {\r\n    param(\r\n        [hashtable] $Context\r\n    )\r\n\r\n    # Try AST-based completion first\r\n    try {\r\n        if (Get-Command Get-PmcCompletionsFromAst -ErrorAction SilentlyContinue) {\r\n            $buffer = $(if ($Context.Buffer) { $Context.Buffer } else { ($Context.Tokens -join ' ') + $Context.CurrentToken })\r\n            $cursorPos = $(if ($Context.CursorPos) { $Context.CursorPos } else { $buffer.Length })\r\n\r\n            $astCompletions = Get-PmcCompletionsFromAst -Buffer $buffer -CursorPos $cursorPos\r\n\r\n            if ($astCompletions.Count -gt 0) {\r\n                Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Using AST completions: found $($astCompletions.Count) items\"\r\n                return $astCompletions\r\n            }\r\n        }\r\n    } catch {\r\n        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"AST completion failed: $_, falling back to legacy\"\r\n    }\r\n\r\n    # Fallback to legacy completion system\r\n    $cacheKey = \"$($Context.Mode):$($Context.CurrentToken):$($Context.Tokens -join ' ')\"\r\n\r\n    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Start Tab cycle (legacy): state=$($Context.Mode), token='$($Context.CurrentToken)', tokens=$($Context.Tokens.Count)\"\r\n\r\n    # Check cache first for performance\r\n    $cache = Pmc-GetCache\r\n    if ($cache.ContainsKey($cacheKey)) {\r\n        $cached = $cache[$cacheKey]\r\n        # Cache hit - reduced verbosity\r\n        return $cached\r\n    }\r\n\r\n    try {\r\n        $completions = @()\r\n\r\n        # Force argument completions when token starts with well-known prefixes\r\n        $tok = $Context.CurrentToken\r\n        $forceArg = ($tok -and ($tok.StartsWith('@') -or $tok.StartsWith('p') -or $tok.StartsWith('due:') -or $tok.StartsWith('#')))\r\n        if ($forceArg) {\r\n            $dom = $(if ($Context.Tokens.Count -gt 0) { $Context.Tokens[0] } else { '' })\r\n            $act = $(if ($Context.Tokens.Count -gt 1) { $Context.Tokens[1] } else { '' })\r\n            $completions = Get-PmcArgumentCompletions -Domain $dom -Action $act -Filter $tok\r\n        } else {\r\n            switch ($Context.Mode) {\r\n                ([PmcCompletionMode]::Domain) {\r\n                    $completions = Get-PmcDomainCompletions -Filter $Context.CurrentToken\r\n                }\r\n                ([PmcCompletionMode]::Action) {\r\n                    if ($Context.Tokens.Count -gt 0) {\r\n                        $completions = Get-PmcActionCompletions -Domain $Context.Tokens[0] -Filter $Context.CurrentToken\r\n                    }\r\n                }\r\n                ([PmcCompletionMode]::Arguments) {\r\n                    if ($Context.Tokens.Count -ge 2) {\r\n                        $completions = Get-PmcArgumentCompletions -Domain $Context.Tokens[0] -Action $Context.Tokens[1] -Filter $Context.CurrentToken\r\n                    }\r\n                }\r\n                default {\r\n                    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Unknown completion mode: $($Context.Mode)\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # No type conversion needed - strings are stable\r\n\r\n        # Cache results for performance\r\n        $cache[$cacheKey] = $completions\r\n\r\n        # Clean cache if it gets too large (simple LRU)\r\n        if ($cache.Keys.Count -gt 100) { $cache.Clear() }\r\n        Pmc-SetCache $cache\r\n\r\n        $safeCount = $(if ($completions -is [array]) { $completions.Count } elseif ($completions) { 1 } else { 0 })\r\n        $safeFirst3 = try { ($completions | Select-Object -First 3) -join ', ' } catch { 'N/A' }\r\n        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Provider outputs: type=string[], length=$safeCount, first3=$safeFirst3\"\r\n\r\n        return $completions\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'COMPLETION' -Message \"Completion provider error: $_ | StackTrace: $($_.ScriptStackTrace)\"\r\n        return @()\r\n    }\r\n}\r\n\r\n# Replace token in buffer with inline replacement\r\nfunction Replace-TokenInBuffer {\r\n    param(\r\n        [string] $Buffer,\r\n        [int] $TokenStart,\r\n        [int] $TokenEnd,\r\n        [string] $Replacement\r\n    )\r\n\r\n    if ($TokenStart -eq $TokenEnd) {\r\n        # Insert at cursor position\r\n        return $Buffer.Substring(0, $TokenStart) + $Replacement + $Buffer.Substring($TokenStart)\r\n    } else {\r\n        # Replace existing token\r\n        return $Buffer.Substring(0, $TokenStart) + $Replacement + $Buffer.Substring($TokenEnd)\r\n    }\r\n}\r\n\r\n# Ghost text system with inline positioning\r\n# Clear ghost text (no-op with overlay model; kept for compatibility)\r\nfunction Clear-GhostText { Write-Host -NoNewline \"`e[0K\" }\r\n\r\n# History management\r\nfunction Add-ToHistory {\r\n    param([string] $Command)\r\n\r\n    if ([string]::IsNullOrWhiteSpace($Command)) { return }\r\n\r\n    # Don't add duplicate consecutive entries\r\n    if ((Pmc-GetEditor).History.Count -gt 0 -and (Pmc-GetEditor).History[-1] -eq $Command) {\r\n        return\r\n    }\r\n\r\n    (Pmc-GetEditor).History += $Command\r\n\r\n    # Trim history if too long\r\n    if ((Pmc-GetEditor).History.Count -gt (Pmc-GetEditor).MaxHistoryItems) {\r\n        (Pmc-GetEditor).History = (Pmc-GetEditor).History[-(Pmc-GetEditor).MaxHistoryItems..-1]\r\n    }\r\n\r\n    (Pmc-GetEditor).HistoryIndex = (Pmc-GetEditor).History.Count\r\n}\r\n\r\n# Undo/Redo system\r\nfunction Add-ToUndoStack {\r\n    param([string] $State)\r\n\r\n    (Pmc-GetEditor).UndoStack += $State\r\n    (Pmc-GetEditor).RedoStack = @()  # Clear redo stack on new action\r\n\r\n    if ((Pmc-GetEditor).UndoStack.Count -gt (Pmc-GetEditor).MaxUndoItems) {\r\n        (Pmc-GetEditor).UndoStack = (Pmc-GetEditor).UndoStack[-(Pmc-GetEditor).MaxUndoItems..-1]\r\n    }\r\n}\r\n\r\n# State snapshot for debugging exceptions\r\nfunction Get-EditorStateSnapshot {\r\n    $ed = Pmc-GetEditor\r\n    return @{\r\n        Buffer = $ed.Buffer\r\n        CursorPos = $ed.CursorPos\r\n        InCompletion = $ed.InCompletion\r\n        CompletionCount = $ed.Completions.Count\r\n        CompletionIndex = $ed.CompletionIndex\r\n        Mode = $ed.Mode\r\n        Timestamp = Get-Date\r\n        CompletionDetails = ($ed.Completions | ForEach-Object { \"$($_.GetType().Name):$($_)\" }) -join '; '\r\n    }\r\n}\r\n\r\n# Main command reader with comprehensive instrumentation\r\nfunction Read-PmcCommand {\r\n    Write-PmcDebug -Level 2 -Category 'INPUT' -Message \"Starting Read-PmcCommand session\"\r\n\r\n    # Initialize or reset only the current line state (preserve history across prompts)\r\n    $ed = Pmc-GetEditor\r\n    if ($null -eq $ed) {\r\n        $ed = [PmcEditorState]::new()\r\n        Pmc-SetEditor $ed\r\n    }\r\n    $ed.Buffer = ''\r\n    $ed.CursorPos = 0\r\n    $ed.InCompletion = $false\r\n    $ed.OriginalBuffer = ''\r\n    $ed.Completions = @()\r\n    $ed.CompletionIndex = -1\r\n    $ed.Mode = [PmcCompletionMode]::Domain\r\n    $ed.CurrentToken = ''\r\n    $ed.TokenStart = 0\r\n    $ed.TokenEnd = 0\r\n    Pmc-SetEditor $ed\r\n\r\n    # Initial prompt render\r\n    try { Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false } catch {}\r\n\r\n    while ($true) {\r\n        try {\r\n            # Defensive I/O: verify Console.ReadKey is available\r\n\r\n            $key = [Console]::ReadKey($true)\r\n            # Key press details reduced to completion/input summaries only\r\n\r\n        } catch {\r\n            Write-PmcStyled -Style 'Error' -Text \"Console.ReadKey failed: $_\"\r\n            Write-PmcStyled -Style 'Warning' -Text \"Interactive mode not available (input redirected or no TTY)\"\r\n            break\r\n        }\r\n\r\n        # Save state for undo before major changes\r\n        if ($key.Key -in @('Spacebar', 'Enter', 'Delete', 'Backspace')) {\r\n            Add-ToUndoStack -State (Pmc-GetEditor).Buffer\r\n        }\r\n\r\n        try {\r\n            switch ($key.Key) {\r\n                'LeftArrow' {\r\n                    if ((Pmc-GetEditor).CursorPos -gt 0) {\r\n                        (Pmc-GetEditor).CursorPos--\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    }\r\n                    continue\r\n                }\r\n                'RightArrow' {\r\n                    if ((Pmc-GetEditor).CursorPos -lt (Pmc-GetEditor).Buffer.Length) {\r\n                        (Pmc-GetEditor).CursorPos++\r\n                    }\r\n                    Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    continue\r\n                }\r\n                'Home' {\r\n                    (Pmc-GetEditor).CursorPos = 0\r\n                    Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    continue\r\n                }\r\n                'End' {\r\n                    (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length\r\n                    Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    continue\r\n                }\r\n                'Delete' {\r\n                    if ((Pmc-GetEditor).CursorPos -lt (Pmc-GetEditor).Buffer.Length) {\r\n                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).Buffer.Remove((Pmc-GetEditor).CursorPos, 1)\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    }\r\n                    continue\r\n                }\r\n                # Removed Alt+1/2/3 quick-accept bindings to avoid input interference\r\n                'Tab' {\r\n                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos\r\n                    $beforeIn = (Pmc-GetEditor).InCompletion\r\n                    $isShiftTab = ($key.Modifiers -band [ConsoleModifiers]::Shift) -eq [ConsoleModifiers]::Shift\r\n                    $direction = $(if ($isShiftTab) { \"reverse\" } else { \"forward\" })\r\n                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message \"Tab key pressed (Shift=$isShiftTab): buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), inCompletion=$((Pmc-GetEditor).InCompletion)\"\r\n                    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Tab cycle start: buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), mode=initial, direction=$direction\"\r\n\r\n                    if (-not (Pmc-GetEditor).InCompletion) {\r\n                        # First Tab: initialize completion cycling\r\n                        (Pmc-GetEditor).OriginalBuffer = (Pmc-GetEditor).Buffer\r\n                        $context = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos\r\n                        (Pmc-GetEditor).Mode = $context.Mode\r\n                        (Pmc-GetEditor).CurrentToken = $context.CurrentToken\r\n                        (Pmc-GetEditor).TokenStart = $context.TokenStart\r\n                        (Pmc-GetEditor).TokenEnd = $context.TokenEnd\r\n\r\n                        # Use unified completion system\r\n                        (Pmc-GetEditor).Completions = Get-CompletionsForState -Context $context\r\n                        $safeCompletionCount = $(if ((Pmc-GetEditor).Completions -is [array]) { (Pmc-GetEditor).Completions.Count } elseif ((Pmc-GetEditor).Completions) { 1 } else { 0 })\r\n                        $safeCompletionFirst3 = try { ((Pmc-GetEditor).Completions | Select-Object -First 3) -join ', ' } catch { 'N/A' }\r\n                        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Provider outputs: type=string[], length=$safeCompletionCount, first3=$safeCompletionFirst3\"\r\n\r\n                        if ($safeCompletionCount -gt 0) {\r\n                            (Pmc-GetEditor).InCompletion = $true\r\n                            # For Shift+Tab on first press, start at the end\r\n                            (Pmc-GetEditor).CompletionIndex = $(if ($isShiftTab) { $safeCompletionCount - 1 } else { 0 })\r\n\r\n                            # Replace token with selected completion\r\n                            $firstCompletion = (Pmc-GetEditor).Completions[(Pmc-GetEditor).CompletionIndex]\r\n                            (Pmc-GetEditor).Buffer = Replace-TokenInBuffer -Buffer (Pmc-GetEditor).Buffer -TokenStart (Pmc-GetEditor).TokenStart -TokenDoEnd (Pmc-GetEditor).TokenEnd -Replacement $firstCompletion\r\n                            (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).TokenStart + $firstCompletion.Length\r\n\r\n                            # Render with indicator and transient help from aux map\r\n                            $helpInfo = $null\r\n                            if ((Pmc-GetEditor).Mode -eq [PmcCompletionMode]::Action -and $context.Tokens.Count -gt 0) {\r\n                                $helpInfo = Get-PmcCompletionInfo -Domain $context.Tokens[0] -Action $firstCompletion\r\n                            } else {\r\n                                $helpInfo = Get-PmcCompletionInfo -Text $firstCompletion\r\n                            }\r\n                            $helpText = $(if ($helpInfo) { $helpInfo.Description } else { $null })\r\n                            Render-Line -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -IndicatorIndex 1 -IndicatorCount $safeCompletionCount -InCompletion $true -HelpText $helpText\r\n\r\n                            Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Before Tab accept: index=0, selected item type=$($firstCompletion.GetType().Name), text='$($firstCompletion)'\"\r\n                            Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"After Tab accept: new buffer='$((Pmc-GetEditor).Buffer)', phase=cycling (1/$safeCompletionCount)\"\r\n                        } else {\r\n                        Write-Host \"`r`e[0Kpmc> $((Pmc-GetEditor).Buffer) [no completions]\" -NoNewline\r\n                        Start-Sleep -Milliseconds 350\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                            Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"No completions found for context: $($context | ConvertTo-Json -Compress)\"\r\n                        }\r\n                    } else {\r\n                        # Cycle to next/previous completion based on direction\r\n                        $safeCurrentCount = $(if ((Pmc-GetEditor).Completions -is [array]) { (Pmc-GetEditor).Completions.Count } elseif ((Pmc-GetEditor).Completions) { 1 } else { 0 })\r\n                        if ($safeCurrentCount -gt 0) {\r\n                        if ($isShiftTab) {\r\n                            # Reverse direction (Shift+Tab)\r\n                            (Pmc-GetEditor).CompletionIndex = ((Pmc-GetEditor).CompletionIndex - 1 + $safeCurrentCount) % $safeCurrentCount\r\n                        } else {\r\n                            # Forward direction (Tab)\r\n                            (Pmc-GetEditor).CompletionIndex = ((Pmc-GetEditor).CompletionIndex + 1) % $safeCurrentCount\r\n                        }\r\n                    } else {\r\n                        (Pmc-GetEditor).CompletionIndex = 0\r\n                    }\r\n                    $selectedCompletion = (Pmc-GetEditor).Completions[(Pmc-GetEditor).CompletionIndex]\r\n\r\n                        # Replace token with cycled completion\r\n                    (Pmc-GetEditor).Buffer = Replace-TokenInBuffer -Buffer (Pmc-GetEditor).OriginalBuffer -TokenStart (Pmc-GetEditor).TokenStart -TokenDoEnd (Pmc-GetEditor).TokenEnd -Replacement $selectedCompletion\r\n                    (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).TokenStart + $selectedCompletion.Length\r\n\r\n                        # Render with indicator and transient help from aux map\r\n                    $ctxForHelp = Parse-CompletionContext -Buffer (Pmc-GetEditor).OriginalBuffer -CursorPos (Pmc-GetEditor).TokenStart\r\n                        $helpInfo = $null\r\n                    if ((Pmc-GetEditor).Mode -eq [PmcCompletionMode]::Action -and $ctxForHelp.Tokens.Count -gt 0) {\r\n                        $helpInfo = Get-PmcCompletionInfo -Domain $ctxForHelp.Tokens[0] -Action $selectedCompletion\r\n                    } else {\r\n                        $helpInfo = Get-PmcCompletionInfo -Text $selectedCompletion\r\n                    }\r\n                    $helpText = $(if ($helpInfo) { $helpInfo.Description } else { $null })\r\n                    Render-Line -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -IndicatorIndex ((Pmc-GetEditor).CompletionIndex + 1) -IndicatorCount $safeCurrentCount -InCompletion $true -HelpText $helpText\r\n\r\n                    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Before Tab cycle ($direction): index=$((Pmc-GetEditor).CompletionIndex), selected item type=$($selectedCompletion.GetType().Name), text='$($selectedCompletion)'\"\r\n                    Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"After Tab cycle ($direction): new buffer='$((Pmc-GetEditor).Buffer)', phase=cycling ($((Pmc-GetEditor).CompletionIndex + 1)/$safeCurrentCount)\"\r\n                    }\r\n                    Write-StateChange -KeyName 'Tab' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn\r\n                    continue\r\n                }\r\n\r\n                'Spacebar' {\r\n                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos\r\n                    $beforeIn = (Pmc-GetEditor).InCompletion\r\n                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message \"Space key pressed: buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), inCompletion=$((Pmc-GetEditor).InCompletion)\"\r\n\r\n                    if ((Pmc-GetEditor).InCompletion) {\r\n                        # Accept current completion, add space, reset for next state\r\n                        $selectedCompletion = (Pmc-GetEditor).Completions[(Pmc-GetEditor).CompletionIndex]\r\n                        (Pmc-GetEditor).Buffer = Replace-TokenInBuffer -Buffer (Pmc-GetEditor).OriginalBuffer -TokenStart (Pmc-GetEditor).TokenStart -TokenDoEnd (Pmc-GetEditor).TokenEnd -Replacement $selectedCompletion\r\n\r\n                        if (-not (Pmc-GetEditor).Buffer.EndsWith(' ')) {\r\n                            (Pmc-GetEditor).Buffer += ' '\r\n                        }\r\n                        (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length\r\n\r\n                        # Reset completion state\r\n                        (Pmc-GetEditor).InCompletion = $false\r\n                        (Pmc-GetEditor).Completions = @()\r\n                        (Pmc-GetEditor).CompletionIndex = -1\r\n\r\n                        # Get new context after state change for logging\r\n                        $afterCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos\r\n\r\n                        # Redraw and show ghost for next phase\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n\r\n                        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Before Space accept: index=$((Pmc-GetEditor).CompletionIndex), selected item type=$($selectedCompletion.GetType().Name), text='$($selectedCompletion)'\"\r\n                        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"After Space accept: new buffer='$((Pmc-GetEditor).Buffer)', phase=domain/action/prefix, nextState=$($afterCtx.Mode)\"\r\n                    } else {\r\n                        # Insert space normally\r\n                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).Buffer.Substring(0, (Pmc-GetEditor).CursorPos) + ' ' + (Pmc-GetEditor).Buffer.Substring((Pmc-GetEditor).CursorPos)\r\n                        (Pmc-GetEditor).CursorPos++\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    }\r\n                    Write-StateChange -KeyName 'Space' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn\r\n                    continue\r\n                }\r\n\r\n                'Enter' {\r\n                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos\r\n                    $beforeIn = (Pmc-GetEditor).InCompletion\r\n                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message \"Enter key pressed: buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), inCompletion=$((Pmc-GetEditor).InCompletion)\"\r\n\r\n                    if ((Pmc-GetEditor).InCompletion) {\r\n                        # Accept completion then submit\r\n                        $selectedCompletion = (Pmc-GetEditor).Completions[(Pmc-GetEditor).CompletionIndex]\r\n                        (Pmc-GetEditor).Buffer = Replace-TokenInBuffer -Buffer (Pmc-GetEditor).OriginalBuffer -TokenStart (Pmc-GetEditor).TokenStart -TokenDoEnd (Pmc-GetEditor).TokenEnd -Replacement $selectedCompletion\r\n                        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"Before Enter accept: index=$((Pmc-GetEditor).CompletionIndex), selected item type=$($selectedCompletion.GetType().Name), text='$($selectedCompletion)'\"\r\n                        Write-PmcDebug -Level 2 -Category 'COMPLETION' -Message \"After Enter accept: final buffer='$((Pmc-GetEditor).Buffer)', phase=submit\"\r\n                    }\r\n\r\n                    Clear-GhostText\r\n\r\n                    if (-not [string]::IsNullOrWhiteSpace((Pmc-GetEditor).Buffer)) {\r\n                        Add-ToHistory -Command (Pmc-GetEditor).Buffer\r\n                    }\r\n\r\n                    Write-StateChange -KeyName 'Enter' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn\r\n                    return (Pmc-GetEditor).Buffer\r\n                }\r\n\r\n                'Escape' {\r\n                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos\r\n                    $beforeIn = (Pmc-GetEditor).InCompletion\r\n                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message \"Escape key pressed: buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), inCompletion=$((Pmc-GetEditor).InCompletion)\"\r\n\r\n                    if ((Pmc-GetEditor).InCompletion) {\r\n                        # Cancel completion, restore original buffer\r\n                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).OriginalBuffer\r\n                        (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).OriginalBuffer.Length\r\n                        (Pmc-GetEditor).InCompletion = $false\r\n                        (Pmc-GetEditor).Completions = @()\r\n                        (Pmc-GetEditor).CompletionIndex = -1\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    } else {\r\n                        # Clear entire line\r\n                        (Pmc-GetEditor).Buffer = \"\"\r\n                        (Pmc-GetEditor).CursorPos = 0\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    }\r\n                    Write-StateChange -KeyName 'Escape' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn\r\n                    continue\r\n                }\r\n\r\n                'Backspace' {\r\n                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos\r\n                    $beforeIn = (Pmc-GetEditor).InCompletion\r\n                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message \"Backspace key pressed: buffer='$((Pmc-GetEditor).Buffer)', cursor=$((Pmc-GetEditor).CursorPos), inCompletion=$((Pmc-GetEditor).InCompletion)\"\r\n                    if ((Pmc-GetEditor).CursorPos -gt 0) {\r\n                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).Buffer.Substring(0, (Pmc-GetEditor).CursorPos - 1) + (Pmc-GetEditor).Buffer.Substring((Pmc-GetEditor).CursorPos)\r\n                        (Pmc-GetEditor).CursorPos--\r\n\r\n                        # Exit completion mode when editing\r\n                        if ((Pmc-GetEditor).InCompletion) {\r\n                            (Pmc-GetEditor).InCompletion = $false\r\n                            (Pmc-GetEditor).Completions = @()\r\n                            (Pmc-GetEditor).CompletionIndex = -1\r\n                        }\r\n\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    }\r\n                    Write-StateChange -KeyName 'Backspace' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn\r\n                    continue\r\n                }\r\n\r\n                'UpArrow' {\r\n                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos\r\n                    $beforeIn = (Pmc-GetEditor).InCompletion\r\n                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message \"UpArrow key pressed: buffer='$((Pmc-GetEditor).Buffer)', historyIndex=$((Pmc-GetEditor).HistoryIndex), historySize=$((Pmc-GetEditor).History.Count)\"\r\n\r\n                    if ((Pmc-GetEditor).History.Count -gt 0) {\r\n                        if ((Pmc-GetEditor).HistoryIndex -gt 0) { (Pmc-GetEditor).HistoryIndex-- }\r\n                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).History[(Pmc-GetEditor).HistoryIndex]\r\n                        (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length\r\n                        (Pmc-GetEditor).InCompletion = $false\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    }\r\n                    Write-StateChange -KeyName 'UpArrow' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn\r\n                    continue\r\n                }\r\n\r\n                'DownArrow' {\r\n                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos\r\n                    $beforeIn = (Pmc-GetEditor).InCompletion\r\n                    Write-PmcDebug -Level 2 -Category 'INPUT' -Message \"DownArrow key pressed: buffer='$((Pmc-GetEditor).Buffer)', historyIndex=$((Pmc-GetEditor).HistoryIndex), historySize=$((Pmc-GetEditor).History.Count)\"\r\n\r\n                    if ((Pmc-GetEditor).History.Count -gt 0) {\r\n                        if ((Pmc-GetEditor).HistoryIndex -lt ((Pmc-GetEditor).History.Count - 1)) {\r\n                            (Pmc-GetEditor).HistoryIndex++\r\n                            (Pmc-GetEditor).Buffer = (Pmc-GetEditor).History[(Pmc-GetEditor).HistoryIndex]\r\n                        } else {\r\n                            (Pmc-GetEditor).HistoryIndex = (Pmc-GetEditor).History.Count\r\n                            (Pmc-GetEditor).Buffer = \"\"\r\n                        }\r\n                        (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length\r\n                        (Pmc-GetEditor).InCompletion = $false\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    }\r\n                    Write-StateChange -KeyName 'DownArrow' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn\r\n                    continue\r\n                }\r\n\r\n                'R' {\r\n                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {\r\n                        Write-PmcDebug -Level 2 -Category 'INPUT' -Message \"Ctrl+R key pressed: reverse history search initiated, historySize=$((Pmc-GetEditor).History.Count)\"\r\n\r\n                        Write-Host \"`r`e[0K(reverse-i-search): \" -NoNewline\r\n                        $searchTerm = \"\"\r\n                    $searchResults = @()\r\n                    $searchIndex = 0\r\n\r\n                    while ($true) {\r\n                        $searchKey = [Console]::ReadKey($true)\r\n\r\n                        if ($searchKey.Key -eq 'Enter' -or $searchKey.Key -eq 'Escape') {\r\n                            if ($searchKey.Key -eq 'Enter' -and $searchResults.Count -gt 0) {\r\n                                (Pmc-GetEditor).Buffer = $searchResults[$searchIndex]\r\n                                (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length\r\n                            }\r\n                            Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                            break\r\n                        } elseif ($searchKey.Key -eq 'Backspace' -and $searchTerm.Length -gt 0) {\r\n                            $searchTerm = $searchTerm.Substring(0, $searchTerm.Length - 1)\r\n                        } elseif ($searchKey.Key -eq 'R' -and $searchKey.Modifiers -eq 'Control') {\r\n                            # Next search result\r\n                            if ($searchResults.Count -gt 1) {\r\n                                $searchIndex = ($searchIndex + 1) % $searchResults.Count\r\n                            }\r\n                        } elseif (-not [char]::IsControl($searchKey.KeyChar)) {\r\n                            $searchTerm += $searchKey.KeyChar\r\n                        }\r\n\r\n                        # Update search results\r\n                        if ($searchTerm.Length -gt 0) {\r\n                            $searchResults = @((Pmc-GetEditor).History | Where-Object { $_ -like \"*$searchTerm*\" } | Select-Object -Last 10)\r\n                            if ($searchResults.Count -eq 0) {\r\n                                $searchResults = @()\r\n                                $searchIndex = 0\r\n                            } elseif ($searchIndex -ge $searchResults.Count) {\r\n                                $searchIndex = 0\r\n                            }\r\n                        }\r\n\r\n                        # Display search state\r\n                        $displayText = $(if ($searchResults.Count -gt 0) { $searchResults[$searchIndex] } else { \"\" })\r\n                        Write-Host \"`r`e[0K(reverse-i-search)'$searchTerm': $displayText\" -NoNewline\r\n                    }\r\n\r\n                        continue\r\n                    } else {\r\n                        # Regular 'R' character input\r\n                        $editor = Pmc-GetEditor\r\n                        $editor.Buffer = $editor.Buffer.Insert($editor.CursorPos, $key.KeyChar)\r\n                        $editor.CursorPos++\r\n                        Pmc-SetEditor $editor\r\n                        Render-Interactive -Buffer $editor.Buffer -CursorPos $editor.CursorPos -InCompletion $false\r\n                    }\r\n                    continue\r\n                }\r\n\r\n                'Z' {\r\n                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {\r\n                        Write-PmcDebug -Level 2 -Category 'INPUT' -Message \"Ctrl+Z key pressed: undo, undoStackSize=$((Pmc-GetEditor).UndoStack.Count), redoStackSize=$((Pmc-GetEditor).RedoStack.Count)\"\r\n\r\n                        if ((Pmc-GetEditor).UndoStack.Count -gt 0) {\r\n                            (Pmc-GetEditor).RedoStack += (Pmc-GetEditor).Buffer\r\n                            (Pmc-GetEditor).Buffer = (Pmc-GetEditor).UndoStack[-1]\r\n                            (Pmc-GetEditor).UndoStack = (Pmc-GetEditor).UndoStack[0..((Pmc-GetEditor).UndoStack.Count - 2)]\r\n                            (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length\r\n                            (Pmc-GetEditor).InCompletion = $false\r\n                            Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                        }\r\n                        continue\r\n                    } else {\r\n                        # Regular 'Z' character input\r\n                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).Buffer.Insert((Pmc-GetEditor).CursorPos, $key.KeyChar)\r\n                        (Pmc-GetEditor).CursorPos++\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    }\r\n                    continue\r\n                }\r\n\r\n                'Y' {\r\n                    if (($key.Modifiers -band [ConsoleModifiers]::Control) -ne 0) {\r\n                        Write-PmcDebug -Level 2 -Category 'INPUT' -Message \"Ctrl+Y key pressed: redo, undoStackSize=$((Pmc-GetEditor).UndoStack.Count), redoStackSize=$((Pmc-GetEditor).RedoStack.Count)\"\r\n\r\n                        if ((Pmc-GetEditor).RedoStack.Count -gt 0) {\r\n                            (Pmc-GetEditor).UndoStack += (Pmc-GetEditor).Buffer\r\n                            (Pmc-GetEditor).Buffer = (Pmc-GetEditor).RedoStack[-1]\r\n                            (Pmc-GetEditor).RedoStack = (Pmc-GetEditor).RedoStack[0..((Pmc-GetEditor).RedoStack.Count - 2)]\r\n                            (Pmc-GetEditor).CursorPos = (Pmc-GetEditor).Buffer.Length\r\n                            (Pmc-GetEditor).InCompletion = $false\r\n                            Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                        }\r\n                        continue\r\n                    } else {\r\n                        # Regular 'Y' character input\r\n                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).Buffer.Insert((Pmc-GetEditor).CursorPos, $key.KeyChar)\r\n                        (Pmc-GetEditor).CursorPos++\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    }\r\n                    continue\r\n                }\r\n\r\n                default {\r\n                    $beforeCtx = Parse-CompletionContext -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos\r\n                    $beforeIn = (Pmc-GetEditor).InCompletion\r\n                    # Regular character input\r\n                    if (-not [char]::IsControl($key.KeyChar)) {\r\n                        # Character input reduced verbosity\r\n                        # Exit completion mode when typing new characters\r\n                        if ((Pmc-GetEditor).InCompletion) {\r\n                            (Pmc-GetEditor).InCompletion = $false\r\n                            (Pmc-GetEditor).Completions = @()\r\n                            (Pmc-GetEditor).CompletionIndex = -1\r\n                        }\r\n\r\n                        (Pmc-GetEditor).Buffer = (Pmc-GetEditor).Buffer.Substring(0, (Pmc-GetEditor).CursorPos) + $key.KeyChar + (Pmc-GetEditor).Buffer.Substring((Pmc-GetEditor).CursorPos)\r\n                        (Pmc-GetEditor).CursorPos++\r\n                        Render-Interactive -Buffer (Pmc-GetEditor).Buffer -CursorPos (Pmc-GetEditor).CursorPos -InCompletion $false\r\n                    }\r\n                    Write-StateChange -KeyName 'Char' -BeforeCtx $beforeCtx -BeforeInCompletion $beforeIn\r\n                    continue\r\n                }\r\n            }\r\n\r\n        } catch {\r\n            $snapshot = Get-EditorStateSnapshot\r\n            Write-PmcDebug -Level 1 -Category 'INPUT' -Message \"EXCEPTION: Input processing error: $_ | FULL STATE DUMP: $($snapshot | ConvertTo-Json -Depth 5 -Compress) | StackTrace: $($_.ScriptStackTrace)\"\r\n            Write-PmcDebug -Level 1 -Category 'INPUT' -Message \"EXCEPTION CONTEXT: Key=$($key.Key), KeyChar='$($key.KeyChar)', Modifiers=$($key.Modifiers)\"\r\n            Write-PmcStyled -Style 'Error' -Text \"Input processing failed: $_\"\r\n            break\r\n        }\r\n    }\r\n}\r\n\r\n# Initialize interactive mode\r\nfunction Enable-PmcInteractiveMode {\r\n    Write-PmcDebug -Level 1 -Category 'INTERACTIVE' -Message \"Enabling PMC interactive mode with full t2.ps1 feature set\"\r\n\r\n    try {\r\n        try { if (Get-Module PSReadLine -ErrorAction SilentlyContinue) { Remove-Module PSReadLine -Force -ErrorAction SilentlyContinue } } catch {}\r\n        try { [Console]::OutputEncoding = [System.Text.Encoding]::UTF8 } catch {}\r\n        try { [Console]::CursorVisible = $true } catch {}\r\n        # Clear completion cache\r\n        Pmc-ClearCache\r\n\r\n        # Initialize auxiliary completion info map (idempotent)\r\n        $iMap = Pmc-GetInfoMap\r\n        if (-not $iMap -or $iMap.Keys.Count -eq 0) {\r\n            Initialize-PmcCompletionInfoMap\r\n        }\r\n\r\n        # Initialize editor state\r\n        Pmc-SetEditor ([PmcEditorState]::new())\r\n\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Interactive mode enabled (Console.ReadKey)\"\r\n        return $true\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'INTERACTIVE' -Message \"Failed to enable interactive mode: $_\"\r\n        Write-PmcStyled -Style 'Error' -Text (\"Failed to enable interactive mode: {0}\" -f $_)\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Disable-PmcInteractiveMode {\r\n    Write-PmcDebug -Level 1 -Category 'INTERACTIVE' -Message \"Disabling PMC interactive mode\"\r\n\r\n    try {\r\n        Pmc-ClearCache\r\n        Pmc-SetEditor ([PmcEditorState]::new())\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Interactive mode disabled\"\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'INTERACTIVE' -Message \"Error disabling interactive mode: $_\"\r\n        Write-PmcStyled -Style 'Error' -Text (\"Error disabling interactive mode: {0}\" -f $_)\r\n    }\r\n}\r\n\r\nfunction Get-PmcInteractiveStatus {\r\n    return @{\r\n        Enabled = $true\r\n        GhostTextEnabled = (Pmc-GetGhost)\r\n        CacheSize = (Pmc-GetCache).Keys.Count\r\n        HistorySize = (Pmc-GetEditor).History.Count\r\n        UndoStackSize = (Pmc-GetEditor).UndoStack.Count\r\n        Features = @(\"InlineCycling\", \"GhostText\", \"History\", \"CtrlR\", \"UndoRedo\", \"ErrorRecovery\")\r\n    }\r\n}\r\n\r\n# Export functions\r\nExport-ModuleMember -Function Enable-PmcInteractiveMode, Disable-PmcInteractiveMode, Get-PmcInteractiveStatus, Read-PmcCommand, Pmc-InsertAtCursor"}, {"path": "module/Pmc.Strict/src/PraxisFrameRenderer.ps1", "content": "# Frame-based rendering system - stolen from Praxis ScreenManager and adapted for PMC\r\n\r\nclass PraxisFrameRenderer {\r\n    # Double buffering\r\n    hidden [string]$_lastFrame = \"\"\r\n    hidden [bool]$_needsRender = $true\r\n    hidden [int]$_frameCount = 0\r\n\r\n    # Performance tracking\r\n    hidden [System.Diagnostics.Stopwatch]$_renderTimer\r\n    hidden [double]$_lastRenderTime = 0\r\n\r\n    PraxisFrameRenderer() {\r\n        $this._renderTimer = [System.Diagnostics.Stopwatch]::new()\r\n    }\r\n\r\n    # Main render method - stolen from Praxis ScreenManager\r\n    [void] RenderFrame([string]$content) {\r\n        $this._renderTimer.Restart()\r\n\r\n        # Only render if content changed (Praxis optimization)\r\n        if ($this._lastFrame -ne $content -or $this._needsRender) {\r\n\r\n            # Clear screen only on first render or significant changes\r\n            if ($this._lastFrame -eq \"\" -or $this._frameCount -eq 0) {\r\n                [Console]::Write([PraxisVT]::Clear())\r\n            }\r\n\r\n            # Single atomic write - the Praxis way\r\n            [Console]::CursorVisible = $false\r\n            [Console]::SetCursorPosition(0, 0)\r\n            [Console]::Write($content)\r\n\r\n            # Store for next comparison\r\n            $this._lastFrame = $content\r\n            $this._needsRender = $false\r\n        }\r\n\r\n        $this._renderTimer.Stop()\r\n        $this._frameCount++\r\n        $this._lastRenderTime = $this._renderTimer.ElapsedMilliseconds\r\n    }\r\n\r\n    # Force next render (for resize, data changes, etc.)\r\n    [void] Invalidate() {\r\n        $this._needsRender = $true\r\n        $this._lastFrame = \"\"  # Force full redraw\r\n    }\r\n\r\n    # Get performance info\r\n    [hashtable] GetStats() {\r\n        return @{\r\n            FrameCount = $this._frameCount\r\n            LastRenderTime = $this._lastRenderTime\r\n            NeedsRender = $this._needsRender\r\n        }\r\n    }\r\n}\r\n\r\n# Grid frame builder - adapts Praxis CleanRender concepts for PMC grids\r\nclass PraxisGridFrameBuilder {\r\n    static [string] BuildGridFrame([array]$data, [hashtable]$columns, [string]$title, [int]$selectedRow, [hashtable]$theme, [object]$renderer) {\r\n        return [PraxisStringBuilderPool]::Build({\r\n            param($sb)\r\n\r\n            # Title\r\n            if ($title) {\r\n                $sb.AppendLine($title)\r\n                $sb.AppendLine(\"─\" * 50)  # Simple separator\r\n            }\r\n\r\n            # Use PMC's intelligent column width calculation\r\n            $widths = $renderer.GetColumnWidths($data)\r\n\r\n            # Column headers\r\n            $headerParts = @()\r\n            $separatorParts = @()\r\n            $colNames = @($columns.Keys)\r\n            foreach ($col in $colNames) {\r\n                $config = $columns[$col]\r\n                $width = $widths[$col]\r\n                $header = $col\r\n                if ($config -and $config.PSObject.Properties['Header'] -and $config.Header) { $header = $config.Header }\r\n\r\n                $headerParts += [PraxisMeasure]::Pad($header, $width, \"Left\")\r\n                $separatorParts += \"─\" * $width\r\n            }\r\n            $sb.AppendLine(($headerParts -join \"  \"))\r\n            $sb.AppendLine(($separatorParts -join \"  \"))\r\n\r\n            # Data rows\r\n            for ($i = 0; $i -lt $data.Count; $i++) {\r\n                $item = $data[$i]\r\n                $isSelected = ($i -eq $selectedRow)\r\n                $prefix = \" \"\r\n                if ($isSelected) { $prefix = \"►\" }\r\n\r\n                $rowParts = @()\r\n                foreach ($col in $colNames) {\r\n                    $width = $widths[$col]\r\n                    # Prefer renderer's item value logic\r\n                    $value = $renderer.GetItemValue($item, $col)\r\n                    # If selected row is being actively edited, show live EditingValue\r\n                    if ($isSelected -and $renderer.InlineEditMode -and $renderer.EditingColumn -eq $col) {\r\n                        $value = [string]$renderer.EditingValue\r\n                    }\r\n                    # Otherwise, if selected row has a staged edit, show it\r\n                    elseif ($isSelected -and $renderer.PendingEdits.ContainsKey($col)) {\r\n                        $value = [string]$renderer.PendingEdits[$col]\r\n                    }\r\n\r\n                    # Show inline edit mode with background highlight (themeable)\r\n                    $padded = [PraxisMeasure]::Pad($value, $width, \"Left\")\r\n                    if ($isSelected -and $renderer.InlineEditMode -and $renderer.EditingColumn -eq $col) {\r\n                        $editStyle = Get-PmcStyle 'Editing'\r\n                        $padded = $renderer.ConvertPmcStyleToAnsi($padded, $editStyle, @{})\r\n                    } elseif ($isSelected) {\r\n                        # Apply selection highlight\r\n                        $applyCell = $true\r\n                        if ($renderer.NavigationMode -eq 'Cell') {\r\n                            # Only highlight the selected column in Cell mode\r\n                            $selIdx = [Math]::Min($colNames.Count-1, [Math]::Max(0, $renderer.SelectedColumn))\r\n                            if ($col -ne $colNames[$selIdx]) { $applyCell = $false }\r\n                        }\r\n                        if ($applyCell) {\r\n                            $selStyle = Get-PmcStyle 'Selected'\r\n                            $padded = $renderer.ConvertPmcStyleToAnsi($padded, $selStyle, @{})\r\n                        }\r\n                    }\r\n                    $rowParts += $padded\r\n                }\r\n\r\n                $sb.Append($prefix)\r\n                $sb.AppendLine(($rowParts -join \"  \"))\r\n            }\r\n\r\n            # Status line (move to bottom)\r\n            $consoleHeight = [PmcTerminalService]::GetHeight()\r\n            $currentLine = $data.Count + 5  # Approximate current line\r\n            $bottomLine = $consoleHeight - 1\r\n\r\n            # Determine footer lines: optional error, optional hint, plus status\r\n            $footerCount = 1\r\n            $hasError = ($renderer.LastErrorMessage -and $renderer.LastErrorMessage.Length -gt 0)\r\n            $hasHint = $renderer.InlineEditMode\r\n            if ($hasError) { $footerCount++ }\r\n            if ($hasHint) { $footerCount++ }\r\n\r\n            if ($currentLine -lt $bottomLine) {\r\n                # Add spacing to push footers to bottom\r\n                $spacingNeeded = $bottomLine - $currentLine - $footerCount\r\n                for ($i = 0; $i -lt $spacingNeeded; $i++) { $sb.AppendLine(\"\") }\r\n            }\r\n\r\n            # Error line (highlighted)\r\n            if ($hasError) {\r\n                $err = $renderer.StyleText('Error', (\"ERROR: {0}\" -f $renderer.LastErrorMessage))\r\n                $sb.AppendLine($err)\r\n            }\r\n\r\n            # Hint line during editing\r\n            if ($hasHint) {\r\n                $col = $renderer.EditingColumn\r\n                $hint = $renderer.GetFieldHint($col)\r\n                if (-not $hint) { $hint = 'Enter: Save, Esc: Cancel, Tab: Next, Shift+Tab: Prev' }\r\n                $hintLine = $renderer.StyleText('Info', (\"Editing {0} — {1}\" -f $col, $hint))\r\n                $sb.AppendLine($hintLine)\r\n            }\r\n\r\n            # Status line\r\n            $statusText = \"ROW [$($selectedRow + 1)/$($data.Count)] | Arrow keys: Navigate | Enter: Edit | Q: Exit\"\r\n            $sb.Append($statusText)\r\n        })\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/src/PraxisStringBuilder.ps1", "content": "# StringBuilder pooling system - stolen directly from Praxis\r\n\r\nclass PraxisStringBuilderPool {\r\n    static [System.Collections.Generic.Queue[System.Text.StringBuilder]]$_pool = [System.Collections.Generic.Queue[System.Text.StringBuilder]]::new()\r\n    static [int]$_maxPoolSize = 20\r\n    static [int]$_defaultCapacity = 1024\r\n\r\n    static [System.Text.StringBuilder] Get([int]$initialCapacity = 1024) {\r\n        if ([PraxisStringBuilderPool]::_pool.Count -gt 0) {\r\n            $sb = [PraxisStringBuilderPool]::_pool.Dequeue()\r\n            $sb.Clear()\r\n            if ($sb.Capacity -lt $initialCapacity) {\r\n                $sb.Capacity = $initialCapacity\r\n            }\r\n            return $sb\r\n        }\r\n        return [System.Text.StringBuilder]::new($initialCapacity)\r\n    }\r\n\r\n    static [void] Recycle([System.Text.StringBuilder]$sb) {\r\n        if ($sb -and [PraxisStringBuilderPool]::_pool.Count -lt [PraxisStringBuilderPool]::_maxPoolSize) {\r\n            $sb.Clear()\r\n            [PraxisStringBuilderPool]::_pool.Enqueue($sb)\r\n        }\r\n    }\r\n\r\n    static [string] Build([scriptblock]$buildAction) {\r\n        $sb = [PraxisStringBuilderPool]::Get(1024)\r\n        try {\r\n            & $buildAction $sb\r\n            return $sb.ToString()\r\n        } finally {\r\n            [PraxisStringBuilderPool]::Recycle($sb)\r\n        }\r\n    }\r\n}\r\n\r\n# Convenience functions\r\nfunction Get-PooledStringBuilder([int]$capacity = 1024) {\r\n    return [PraxisStringBuilderPool]::Get($capacity)\r\n}\r\n\r\nfunction Return-PooledStringBuilder([System.Text.StringBuilder]$sb) {\r\n    [PraxisStringBuilderPool]::Recycle($sb)\r\n}\r\n\r\n#Export-ModuleMember -Function Get-PooledStringBuilder, Return-PooledStringBuilder"}, {"path": "module/Pmc.Strict/src/PraxisVT.ps1", "content": "# VT100/ANSI Core - Stolen directly from Praxis with minimal changes for PMC\r\n\r\nclass PraxisVT {\r\n    # Cursor movement\r\n    static [string] MoveTo([int]$x, [int]$y) {\r\n        return \"`e[$($y+1);$($x+1)H\"  # Convert 0-based to 1-based for ANSI\r\n    }\r\n    static [string] SavePos() { return \"`e[s\" }\r\n    static [string] RestorePos() { return \"`e[u\" }\r\n\r\n    # Cursor visibility\r\n    static [string] Hide() { return \"`e[?25l\" }\r\n    static [string] Show() { return \"`e[?25h\" }\r\n    static [string] HideCursor() { return \"`e[?25l\" }\r\n    static [string] ShowCursor() { return \"`e[?25h\" }\r\n\r\n    # Cursor movement methods\r\n    static [string] MoveUp([int]$n) { return \"`e[$($n)A\" }\r\n    static [string] MoveDown([int]$n) { return \"`e[$($n)B\" }\r\n    static [string] MoveRight([int]$n) { return \"`e[$($n)C\" }\r\n    static [string] MoveLeft([int]$n) { return \"`e[$($n)D\" }\r\n\r\n    # Screen control\r\n    static [string] Clear() { return \"`e[2J`e[H\" }  # Clear screen and home\r\n    static [string] ClearLine() { return \"`e[2K\" }  # Clear entire line\r\n    static [string] Home() { return \"`e[H\" }      # Just home position\r\n    static [string] ClearToDoEnd() { return \"`e[J\" }  # Clear from cursor to end\r\n\r\n    # Basic styles\r\n    static [string] Reset() { return \"`e[0m\" }\r\n    static [string] Bold() { return \"`e[1m\" }\r\n    static [string] Dim() { return \"`e[2m\" }\r\n    static [string] Italic() { return \"`e[3m\" }\r\n    static [string] Underline() { return \"`e[4m\" }\r\n    static [string] NoUnderline() { return \"`e[24m\" }\r\n\r\n    # 24-bit True Color\r\n    static [string] RGB([int]$r, [int]$g, [int]$b) {\r\n        return \"`e[38;2;$r;$g;$($b)m\"\r\n    }\r\n    static [string] RGBBG([int]$r, [int]$g, [int]$b) {\r\n        return \"`e[48;2;$r;$g;$($b)m\"\r\n    }\r\n\r\n    # 256-color support\r\n    static [string] Color256Fg([int]$color) {\r\n        return \"`e[38;5;$($color)m\"\r\n    }\r\n    static [string] Color256Bg([int]$color) {\r\n        return \"`e[48;5;$($color)m\"\r\n    }\r\n\r\n    # Box drawing - single lines for speed\r\n    static [string] TL() { return \"┌\" }     # Top left\r\n    static [string] TR() { return \"┐\" }     # Top right\r\n    static [string] BL() { return \"└\" }     # Bottom left\r\n    static [string] BR() { return \"┘\" }     # Bottom right\r\n    static [string] H() { return \"─\" }      # Horizontal\r\n    static [string] V() { return \"│\" }      # Vertical\r\n    static [string] Cross() { return \"┼\" }  # Cross\r\n    static [string] T() { return \"┬\" }      # T down\r\n    static [string] B() { return \"┴\" }      # T up\r\n    static [string] L() { return \"├\" }      # T right\r\n    static [string] R() { return \"┤\" }      # T left\r\n}\r\n\r\n# Layout measurement helpers - stolen from Praxis\r\nclass PraxisMeasure {\r\n    static [int] TextWidth([string]$text) {\r\n        # Remove ANSI sequences for accurate measurement\r\n        $clean = $text -replace '\\x1b\\[[0-9;]*m', ''\r\n        return $clean.Length\r\n    }\r\n\r\n    static [string] Truncate([string]$text, [int]$maxWidth) {\r\n        $clean = $text -replace '\\x1b\\[[0-9;]*m', ''\r\n        if ($clean.Length -le $maxWidth) { return $text }\r\n        return $clean.Substring(0, $maxWidth - 3) + \"...\"\r\n    }\r\n\r\n    static [string] Pad([string]$text, [int]$width, [string]$align = \"Left\") {\r\n        $textWidth = [PraxisMeasure]::TextWidth($text)\r\n        if ($textWidth -ge $width) { return [PraxisMeasure]::Truncate($text, $width) }\r\n\r\n        $padding = $width - $textWidth\r\n        switch ($align) {\r\n            \"Left\" { return $text + (' ' * $padding) }\r\n            \"Right\" { return (' ' * $padding) + $text }\r\n            \"Center\" {\r\n                $left = [int]($padding / 2)\r\n                $right = $padding - $left\r\n                return (' ' * $left) + $text + (' ' * $right)\r\n            }\r\n        }\r\n        return $text\r\n    }\r\n}\r\n\r\n# String cache for performance - stolen from Praxis\r\nclass PraxisStringCache {\r\n    static [hashtable]$_cache = @{}\r\n\r\n    static [string] GetSpaces([int]$count) {\r\n        if ($count -le 0) { return \"\" }\r\n        if (-not [PraxisStringCache]::_cache.ContainsKey($count)) {\r\n            [PraxisStringCache]::_cache[$count] = ' ' * $count\r\n        }\r\n        return [PraxisStringCache]::_cache[$count]\r\n    }\r\n\r\n    static [string] GetChar([char]$c, [int]$count) {\r\n        $key = \"$c-$count\"\r\n        if (-not [PraxisStringCache]::_cache.ContainsKey($key)) {\r\n            [PraxisStringCache]::_cache[$key] = [string]$c * $count\r\n        }\r\n        return [PraxisStringCache]::_cache[$key]\r\n    }\r\n}"}, {"path": "module/Pmc.Strict/src/Projects.ps1", "content": "# Projects.ps1 - Project management functions\r\n# Core project CRUD operations for PMC\r\n\r\nfunction Invoke-PmcCreateProjectCore {\r\n    param(\r\n        [Parameter(Mandatory=$true)][string]$Name,\r\n        [string]$Description = ''\r\n    )\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n\r\n        if (-not $allData.projects) { $allData.projects = @() }\r\n\r\n        # Normalize any string entries to objects to ensure consistent checks\r\n        try {\r\n            $normalized = @()\r\n            foreach ($p in @($allData.projects)) {\r\n                if ($p -is [string]) {\r\n                    $normalized += [pscustomobject]@{\r\n                        id = [guid]::NewGuid().ToString()\r\n                        name = $p\r\n                        description = ''\r\n                        created = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n                        status = 'active'\r\n                        tags = @()\r\n                    }\r\n                } else {\r\n                    $normalized += $p\r\n                }\r\n            }\r\n            $allData.projects = $normalized\r\n        } catch {}\r\n\r\n        # Duplicate check (case-sensitive to match prior behavior)\r\n        $existing = @($allData.projects | Where-Object { $_.PSObject.Properties['name'] -and $_.name -eq $Name })\r\n        if ($existing.Count -gt 0) {\r\n            return @{ Type='error'; Message=(\"Project '{0}' already exists\" -f $Name) }\r\n        }\r\n\r\n        # Build new record matching CLI shape\r\n        $newProject = [pscustomobject]@{\r\n            id = [guid]::NewGuid().ToString()\r\n            name = $Name\r\n            description = $Description\r\n            created = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n            status = 'active'\r\n            tags = @()\r\n        }\r\n\r\n        $allData.projects += $newProject\r\n        Set-PmcAllData $allData\r\n\r\n        return @{ Type='success'; Message=(\"Project '{0}' created\" -f $Name); Data=$newProject }\r\n    } catch {\r\n        return @{ Type='error'; Message=(\"Error creating project: {0}\" -f $_) }\r\n    }\r\n}\r\n\r\nfunction Add-PmcProject {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    # If no arguments provided, launch the full wizard\r\n    if (-not $Context -or $Context.FreeText.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Info' -Text \"Launching Project Creation Wizard...\"\r\n        Start-PmcProjectWizard -Context $Context\r\n        return\r\n    }\r\n\r\n    # If arguments provided, do quick project creation\r\n    $projectName = $Context.FreeText[0]\r\n    $description = $(if ($Context.FreeText.Count -gt 1) { ($Context.FreeText[1..($Context.FreeText.Count-1)] -join ' ') } else { \"\" })\r\n\r\n    $result = Invoke-PmcCreateProjectCore -Name $projectName -Description $description\r\n    if ($result -is [hashtable] -and $result.ContainsKey('Type') -and $result['Type'] -eq 'success') {\r\n        Write-PmcStyled -Style 'Success' -Text (\"Project '{0}' created\" -f $projectName)\r\n    } else {\r\n        $msg = $(if ($result -is [hashtable] -and $result.ContainsKey('Message')) { [string]$result['Message'] } else { [string]$result })\r\n        if (-not $msg) { $msg = \"Failed to create project\" }\r\n        Write-PmcStyled -Style 'Error' -Text $msg\r\n    }\r\n}\r\n\r\nfunction Show-PmcProject {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: project view <name>\"\r\n        return\r\n    }\r\n\r\n    $projectName = $Context.FreeText[0]\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $project = $allData.projects | Where-Object { $_.name -eq $projectName }\r\n\r\n        if (-not $project) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Project '$projectName' not found\"\r\n            return\r\n        }\r\n\r\n        Write-PmcStyled -Style 'Header' -Text \"`nProject: $($project.name)\"\r\n        Write-PmcStyled -Style 'Body' -Text \"Description: $($project.description)\"\r\n        Write-PmcStyled -Style 'Body' -Text \"Created: $($project.created)\"\r\n        Write-PmcStyled -Style 'Body' -Text \"Status: $($project.status)\"\r\n\r\n        # Show related tasks\r\n        $tasks = $allData.tasks | Where-Object { $_.project -eq $projectName }\r\n        if ($tasks) {\r\n            Write-PmcStyled -Style 'Header' -Text \"`nTasks:\"\r\n            foreach ($task in $tasks) {\r\n                $status = $(if ($task.completed) { \"[OK]\" } else { \"○\" })\r\n                Write-PmcStyled -Style 'Body' -Text \"  $status $($task.text)\"\r\n            }\r\n        }\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error viewing project: $_\"\r\n    }\r\n}\r\n\r\nfunction Set-PmcProject {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -lt 2) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: project update <name> <field> <value>\"\r\n        return\r\n    }\r\n\r\n    $projectName = $Context.FreeText[0]\r\n    $field = $Context.FreeText[1]\r\n    $value = $(if ($Context.FreeText.Count -gt 2) { ($Context.FreeText[2..($Context.FreeText.Count-1)] -join ' ') } else { \"\" })\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $project = $allData.projects | Where-Object { $_.name -eq $projectName }\r\n\r\n        if (-not $project) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Project '$projectName' not found\"\r\n            return\r\n        }\r\n\r\n        switch ($field.ToLower()) {\r\n            'description' { $project.description = $value }\r\n            'status' { $project.status = $value }\r\n            default {\r\n                Write-PmcStyled -Style 'Error' -Text \"Unknown field '$field'. Available: description, status\"\r\n                return\r\n            }\r\n        }\r\n\r\n        Set-PmcAllData $allData\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Project '$projectName' updated\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error updating project: $_\"\r\n    }\r\n}\r\n\r\nfunction Edit-PmcProject {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: project edit <name>\"\r\n        return\r\n    }\r\n\r\n    $projectName = $Context.FreeText[0]\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $project = $allData.projects | Where-Object { $_.name -eq $projectName }\r\n\r\n        if (-not $project) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Project '$projectName' not found\"\r\n            return\r\n        }\r\n\r\n        # Create editable project data\r\n        $editableProject = [pscustomobject]@{\r\n            Name = $project.name\r\n            Description = $project.description\r\n            Status = $project.status\r\n        }\r\n\r\n        $columns = @{\r\n            Name = @{ Header='Project Name'; Width=25; Alignment='Left'; Editable=$true }\r\n            Description = @{ Header='Description'; Width=45; Alignment='Left'; Editable=$true }\r\n            Status = @{ Header='Status'; Width=15; Alignment='Left'; Editable=$true }\r\n        }\r\n\r\n        Write-PmcStyled -Style 'Info' -Text \"Edit project details. Press Enter to save changes, Q to finish.\"\r\n\r\n        Show-PmcDataGrid -Domains @('project-edit') -Columns $columns -Data @($editableProject) -Title \"Edit Project: $projectName\" -Interactive -OnSelectCallback {\r\n            param($item)\r\n            if ($item) {\r\n                # Update project with edited values\r\n                $project.name = [string]$item.Name\r\n                $project.description = [string]$item.Description\r\n                $project.status = [string]$item.Status\r\n\r\n                Set-PmcAllData $allData\r\n                Write-PmcStyled -Style 'Success' -Text \"[OK] Project '$projectName' updated\"\r\n            }\r\n        }\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error editing project: $_\"\r\n    }\r\n}\r\n\r\nfunction Rename-PmcProject {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -lt 2) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: project rename <old-name> <new-name>\"\r\n        return\r\n    }\r\n\r\n    $oldName = $Context.FreeText[0]\r\n    $newName = $Context.FreeText[1]\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $project = $allData.projects | Where-Object { $_.name -eq $oldName }\r\n\r\n        if (-not $project) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Project '$oldName' not found\"\r\n            return\r\n        }\r\n\r\n        # Check if new name already exists\r\n        $existing = $allData.projects | Where-Object { $_.name -eq $newName }\r\n        if ($existing) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Project '$newName' already exists\"\r\n            return\r\n        }\r\n\r\n        # Update project name\r\n        $project.name = $newName\r\n\r\n        # Update all tasks with this project\r\n        $allData.tasks | Where-Object { $_.project -eq $oldName } | ForEach-Object { $_.project = $newName }\r\n\r\n        Set-PmcAllData $allData\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Project renamed from '$oldName' to '$newName'\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error renaming project: $_\"\r\n    }\r\n}\r\n\r\nfunction Remove-PmcProject {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: project remove <name>\"\r\n        return\r\n    }\r\n\r\n    $projectName = $Context.FreeText[0]\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $project = $allData.projects | Where-Object { $_.name -eq $projectName }\r\n\r\n        if (-not $project) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Project '$projectName' not found\"\r\n            return\r\n        }\r\n\r\n        # Check for tasks in this project\r\n        $tasks = $allData.tasks | Where-Object { $_.project -eq $projectName }\r\n        if ($tasks) {\r\n            Write-PmcStyled -Style 'Warning' -Text \"Project '$projectName' has $($tasks.Count) tasks. Remove tasks first or use project archive.\"\r\n            return\r\n        }\r\n\r\n        # Remove project\r\n        $allData.projects = $allData.projects | Where-Object { $_.name -ne $projectName }\r\n\r\n        Set-PmcAllData $allData\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Project '$projectName' removed\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error removing project: $_\"\r\n    }\r\n}\r\n\r\nfunction Set-PmcProjectArchived {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: project archive <name>\"\r\n        return\r\n    }\r\n\r\n    $projectName = $Context.FreeText[0]\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $project = $allData.projects | Where-Object { $_.name -eq $projectName }\r\n\r\n        if (-not $project) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Project '$projectName' not found\"\r\n            return\r\n        }\r\n\r\n        $project.status = 'archived'\r\n\r\n        Set-PmcAllData $allData\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Project '$projectName' archived\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error archiving project: $_\"\r\n    }\r\n}\r\n\r\nfunction Set-PmcProjectFields {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcStyled -Style 'Info' -Text \"Project fields: name, description, status, created, tags\"\r\n}\r\n\r\nfunction Show-PmcProjectFields {\r\n    param([PmcCommandContext]$Context)\r\n    Set-PmcProjectFields -Context $Context\r\n}\r\n\r\nfunction Get-PmcProjectStats {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $projects = $allData.projects\r\n        $tasks = $allData.tasks\r\n\r\n        if (-not $projects) {\r\n            Write-PmcStyled -Style 'Info' -Text \"No projects found\"\r\n            return\r\n        }\r\n\r\n        Write-PmcStyled -Style 'Header' -Text \"`nProject Statistics\"\r\n        Write-PmcStyled -Style 'Body' -Text \"Total Projects: $($projects.Count)\"\r\n\r\n        $active = $projects | Where-Object { $_.status -eq 'active' }\r\n        $archived = $projects | Where-Object { $_.status -eq 'archived' }\r\n\r\n        Write-PmcStyled -Style 'Body' -Text \"Active: $($active.Count)\"\r\n        Write-PmcStyled -Style 'Body' -Text \"Archived: $($archived.Count)\"\r\n\r\n        if ($tasks) {\r\n            Write-PmcStyled -Style 'Header' -Text \"`nTask Distribution\"\r\n            foreach ($project in $projects) {\r\n                $projectTasks = $tasks | Where-Object { $_.project -eq $project.name }\r\n                if ($projectTasks) {\r\n                    Write-PmcStyled -Style 'Body' -Text \"$($project.name): $($projectTasks.Count) tasks\"\r\n                }\r\n            }\r\n        }\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error getting project stats: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcProjectInfo {\r\n    param([PmcCommandContext]$Context)\r\n    Show-PmcProject -Context $Context\r\n}\r\n\r\nfunction Get-PmcRecentProjects {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $projects = $allData.projects | Sort-Object created -Descending | Select-Object -First 5\r\n\r\n        if (-not $projects) {\r\n            Write-PmcStyled -Style 'Info' -Text \"No projects found\"\r\n            return\r\n        }\r\n\r\n        Write-PmcStyled -Style 'Header' -Text \"`nRecent Projects\"\r\n        foreach ($project in $projects) {\r\n            Write-PmcStyled -Style 'Body' -Text \"$($project.name) - $($project.created)\"\r\n        }\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error getting recent projects: $_\"\r\n    }\r\n}\r\n\r\n# Export all project functions\r\nExport-ModuleMember -Function Invoke-PmcCreateProjectCore, Add-PmcProject, Show-PmcProject, Set-PmcProject, Edit-PmcProject, Rename-PmcProject, Remove-PmcProject, Set-PmcProjectArchived, Set-PmcProjectFields, Show-PmcProjectFields, Get-PmcProjectStats, Show-PmcProjectInfo, Get-PmcRecentProjects"}, {"path": "module/Pmc.Strict/src/ProjectWizard.ps1", "content": "# ProjectWizard.ps1 - Modern guided project creation wizard\n# Updated to use current PMC display standards (PmcGridRenderer, Show-PmcDataGrid)\n\nclass PmcProjectWizard {\n    [hashtable]$ProjectData\n    [hashtable]$Templates\n    [string]$CurrentStep\n    [bool]$IsComplete\n\n    PmcProjectWizard() {\n        $this.InitializeWizard()\n    }\n\n    [void] InitializeWizard() {\n        $this.IsComplete = $false\n        $this.CurrentStep = 'template'\n\n        $this.ProjectData = @{\n            name = \"\"\n            description = \"\"\n            ID1 = \"\"\n            ID2 = \"\"\n            ProjFolder = \"\"\n            AssignedDate = \"\"\n            DueDate = \"\"\n            BFDate = \"\"\n            CAAName = \"\"\n            RequestName = \"\"\n            T2020 = \"\"\n            icon = \"📁\"\n            sortOrder = 0\n            aliases = @()\n            color = \"Gray\"\n            isArchived = $false\n            created = \"\"\n        }\n\n        $this.InitializeTemplates()\n    }\n\n    [void] InitializeTemplates() {\n        $this.Templates = @{\n            'software' = @{\n                Name = 'Software Development'\n                Description = 'Full-stack development project with phases'\n                Goals = @('Requirements Analysis', 'Design & Architecture', 'Development', 'Testing', 'Deployment')\n                TimelineWeeks = 12\n                SuggestedTools = @('IDE', 'Version Control', 'Issue Tracker', 'CI/CD')\n                DefaultTags = @('development', 'software')\n            }\n            'marketing' = @{\n                Name = 'Marketing Campaign'\n                Description = 'Comprehensive marketing campaign planning'\n                Goals = @('Market Research', 'Strategy Development', 'Content Creation', 'Campaign Launch', 'Analytics')\n                TimelineWeeks = 8\n                SuggestedTools = @('Analytics', 'Social Media Tools', 'Design Software', 'Email Platform')\n                DefaultTags = @('marketing', 'campaign')\n            }\n            'research' = @{\n                Name = 'Research Project'\n                Description = 'Academic or business research initiative'\n                Goals = @('Literature Review', 'Methodology Design', 'Data Collection', 'Analysis', 'Report Writing')\n                TimelineWeeks = 16\n                SuggestedTools = @('Research Database', 'Survey Tools', 'Statistical Software', 'Writing Tools')\n                DefaultTags = @('research', 'analysis')\n            }\n            'event' = @{\n                Name = 'Event Planning'\n                Description = 'Conference, meeting, or event organization'\n                Goals = @('Planning & Budget', 'Venue & Logistics', 'Speaker Coordination', 'Marketing', 'Execution')\n                TimelineWeeks = 6\n                SuggestedTools = @('Event Platform', 'Registration System', 'Communication Tools', 'Budget Tracker')\n                DefaultTags = @('event', 'planning')\n            }\n            'custom' = @{\n                Name = 'Custom Project'\n                Description = 'Build your project from scratch'\n                Goals = @()\n                TimelineWeeks = 4\n                SuggestedTools = @()\n                DefaultTags = @()\n            }\n        }\n    }\n\n    [void] Start() {\n        try {\n            Write-PmcStyled -Style 'Header' -Text \"`n🚀 PMC Project Creation Wizard\"\n            Write-PmcStyled -Style 'Body' -Text \"This wizard will guide you through creating a project with your actual fields.`n\"\n\n            # Step 1: Basic Info (Name, Description, IDs, Folder)\n            $this.EditBasicInfo()\n            if (-not $this.ProjectData.name) { return }\n\n            # Step 2: Project Dates\n            $this.EditDates()\n\n            # Step 3: Review & Create\n            $this.ReviewAndCreate()\n\n        } catch {\n            Write-PmcStyled -Style 'Error' -Text \"Wizard error: $_\"\n        }\n    }\n\n    [void] SelectTemplate() {\n        Write-PmcStyled -Style 'Info' -Text \"📋 Step 1: Select Project Template\"\n\n        # Build template selection data\n        $templateRows = @()\n        foreach ($key in $this.Templates.Keys) {\n            $template = $this.Templates[$key]\n            $templateRows += [pscustomobject]@{\n                Key = $key\n                Name = $template.Name\n                Description = $template.Description\n                Timeline = \"$($template.TimelineWeeks) weeks\"\n                Tools = ($template.SuggestedTools -join ', ').Substring(0, [Math]::Min(40, ($template.SuggestedTools -join ', ').Length))\n            }\n        }\n\n        $columns = @{\n            Name = @{ Header='Template'; Width=20; Alignment='Left' }\n            Description = @{ Header='Description'; Width=35; Alignment='Left' }\n            Timeline = @{ Header='Timeline'; Width=12; Alignment='Left' }\n            Tools = @{ Header='Suggested Tools'; Width=0; Alignment='Left' }\n        }\n\n        $selectedTemplate = $null\n        Show-PmcDataGrid -Domains @('wizard-template') -Columns $columns -Data $templateRows -Title 'Project Templates' -Interactive -OnSelectCallback {\n            param($item)\n            if ($item -and $item.PSObject.Properties['Key']) {\n                $selectedTemplate = [string]$item.Key\n                Write-PmcStyled -Style 'Success' -Text \"[OK] Selected: $($item.Name)\"\n            }\n        }\n\n        $this.ProjectData.template = $selectedTemplate\n        if ($selectedTemplate -and $this.Templates.ContainsKey($selectedTemplate)) {\n            $template = $this.Templates[$selectedTemplate]\n            $this.ProjectData.goals = $template.Goals\n            $this.ProjectData.tools = $template.SuggestedTools\n            $this.ProjectData.tags = $template.DefaultTags\n\n            # Set suggested timeline\n            $suggestedEnd = (Get-Date).AddDays($template.TimelineWeeks * 7).ToString(\"yyyy-MM-dd\")\n            $this.ProjectData.start_date = (Get-Date).ToString(\"yyyy-MM-dd\")\n            $this.ProjectData.deadline = $suggestedEnd\n        }\n    }\n\n    [void] EditBasicInfo() {\n        Write-PmcStyled -Style 'Info' -Text \"`n📝 Step 2: Project Details\"\n\n        # Create editable project info with ALL your actual fields\n        $projectInfo = [pscustomobject]@{\n            Name = $this.ProjectData.name\n            Description = $this.ProjectData.description\n            ID1 = $this.ProjectData.ID1\n            ID2 = $this.ProjectData.ID2\n            ProjFolder = $this.ProjectData.ProjFolder\n            CAAName = $this.ProjectData.CAAName\n            RequestName = $this.ProjectData.RequestName\n            T2020 = $this.ProjectData.T2020\n        }\n\n        $columns = @{\n            Name = @{ Header='Project Name'; Width=15; Alignment='Left'; Editable=$true }\n            Description = @{ Header='Description'; Width=20; Alignment='Left'; Editable=$true }\n            ID1 = @{ Header='ID1'; Width=10; Alignment='Left'; Editable=$true }\n            ID2 = @{ Header='ID2'; Width=10; Alignment='Left'; Editable=$true }\n            ProjFolder = @{ Header='Project Folder'; Width=15; Alignment='Left'; Editable=$true }\n            CAAName = @{ Header='CAA Name'; Width=12; Alignment='Left'; Editable=$true }\n            RequestName = @{ Header='Request Name'; Width=15; Alignment='Left'; Editable=$true }\n            T2020 = @{ Header='T2020'; Width=10; Alignment='Left'; Editable=$true }\n        }\n\n        Write-PmcStyled -Style 'Body' -Text \"Edit your project fields. Press Enter to save changes, Q to continue.\"\n\n        Show-PmcDataGrid -Domains @('wizard-info') -Columns $columns -Data @($projectInfo) -Title 'Project Information' -Interactive -OnSelectCallback {\n            param($item)\n            if ($item) {\n                $this.ProjectData.name = [string]$item.Name\n                $this.ProjectData.description = [string]$item.Description\n                $this.ProjectData.ID1 = [string]$item.ID1\n                $this.ProjectData.ID2 = [string]$item.ID2\n                $this.ProjectData.ProjFolder = [string]$item.ProjFolder\n                $this.ProjectData.CAAName = [string]$item.CAAName\n                $this.ProjectData.RequestName = [string]$item.RequestName\n                $this.ProjectData.T2020 = [string]$item.T2020\n                Write-PmcStyled -Style 'Success' -Text \"[OK] Project details saved\"\n            }\n        }\n    }\n\n    [void] EditGoals() {\n        Write-PmcStyled -Style 'Info' -Text \"`n🎯 Step 3: Project Goals\"\n\n        if ($this.ProjectData.goals -and $this.ProjectData.goals.Count -gt 0) {\n            Write-PmcStyled -Style 'Body' -Text \"Template suggested goals (edit as needed):\"\n        } else {\n            Write-PmcStyled -Style 'Body' -Text \"Add your project goals:\"\n        }\n\n        # Convert goals to editable format\n        $goalRows = @()\n        $goalIndex = 1\n        foreach ($goal in $this.ProjectData.goals) {\n            $goalRows += [pscustomobject]@{\n                Index = $goalIndex\n                Goal = $goal\n                Status = 'pending'\n            }\n            $goalIndex++\n        }\n\n        # Add empty row for new goal\n        $goalRows += [pscustomobject]@{\n            Index = $goalIndex\n            Goal = \"\"\n            Status = 'pending'\n        }\n\n        $columns = @{\n            Index = @{ Header='#'; Width=3; Alignment='Right'; Editable=$false }\n            Goal = @{ Header='Goal/Milestone'; Width=50; Alignment='Left'; Editable=$true }\n            Status = @{ Header='Status'; Width=10; Alignment='Left'; Editable=$false }\n        }\n\n        Write-PmcStyled -Style 'Body' -Text \"Edit goals below. Add new goals in empty rows. Q to continue.\"\n\n        Show-PmcDataGrid -Domains @('wizard-goals') -Columns $columns -Data $goalRows -Title 'Project Goals' -Interactive -OnSelectCallback {\n            param($item)\n            # Extract non-empty goals\n            $updatedGoals = @()\n            foreach ($row in $goalRows) {\n                if ($row.Goal -and $row.Goal.Trim()) {\n                    $updatedGoals += $row.Goal.Trim()\n                }\n            }\n            $this.ProjectData.goals = $updatedGoals\n            Write-PmcStyled -Style 'Success' -Text \"[OK] Goals updated ($($updatedGoals.Count) goals)\"\n        }\n    }\n\n    [void] EditDates() {\n        Write-PmcStyled -Style 'Info' -Text \"`n📅 Step 4: Project Dates\"\n\n        $dateData = [pscustomobject]@{\n            AssignedDate = $this.ProjectData.AssignedDate\n            DueDate = $this.ProjectData.DueDate\n            BFDate = $this.ProjectData.BFDate\n        }\n\n        $columns = @{\n            AssignedDate = @{ Header='Assigned Date'; Width=20; Alignment='Left'; Editable=$true }\n            DueDate = @{ Header='Due Date'; Width=20; Alignment='Left'; Editable=$true }\n            BFDate = @{ Header='BF Date'; Width=20; Alignment='Left'; Editable=$true }\n        }\n\n        Write-PmcStyled -Style 'Body' -Text \"Set your project dates. Q to continue.\"\n\n        Show-PmcDataGrid -Domains @('wizard-dates') -Columns $columns -Data @($dateData) -Title 'Project Dates' -Interactive -OnSelectCallback {\n            param($item)\n            if ($item) {\n                $this.ProjectData.AssignedDate = [string]$item.AssignedDate\n                $this.ProjectData.DueDate = [string]$item.DueDate\n                $this.ProjectData.BFDate = [string]$item.BFDate\n                Write-PmcStyled -Style 'Success' -Text \"[OK] Dates updated\"\n            }\n        }\n    }\n\n    [void] EditResources() {\n        Write-PmcStyled -Style 'Info' -Text \"`n💼 Step 5: Resources\"\n\n        $resourceData = [pscustomobject]@{\n            Budget = $this.ProjectData.budget\n            Team = ($this.ProjectData.team -join ', ')\n            Tools = ($this.ProjectData.tools -join ', ')\n            Tags = ($this.ProjectData.tags -join ', ')\n        }\n\n        $columns = @{\n            Budget = @{ Header='Budget'; Width=15; Alignment='Left'; Editable=$true }\n            Team = @{ Header='Team (comma separated)'; Width=25; Alignment='Left'; Editable=$true }\n            Tools = @{ Header='Tools (comma separated)'; Width=25; Alignment='Left'; Editable=$true }\n            Tags = @{ Header='Tags (comma separated)'; Width=20; Alignment='Left'; Editable=$true }\n        }\n\n        Write-PmcStyled -Style 'Body' -Text \"Edit project resources. Q to continue.\"\n\n        Show-PmcDataGrid -Domains @('wizard-resources') -Columns $columns -Data @($resourceData) -Title 'Project Resources' -Interactive -OnSelectCallback {\n            param($item)\n            if ($item) {\n                $this.ProjectData.budget = [string]$item.Budget\n                $this.ProjectData.team = @(([string]$item.Team).Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ })\n                $this.ProjectData.tools = @(([string]$item.Tools).Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ })\n                $this.ProjectData.tags = @(([string]$item.Tags).Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ })\n                Write-PmcStyled -Style 'Success' -Text \"[OK] Resources updated\"\n            }\n        }\n    }\n\n    [void] ReviewAndCreate() {\n        Write-PmcStyled -Style 'Info' -Text \"`n📋 Step 3: Review & Create\"\n\n        # Build review summary using ALL actual PMC fields\n        $reviewRows = @(\n            [pscustomobject]@{ Field='Name'; Value=$this.ProjectData.name }\n            [pscustomobject]@{ Field='Description'; Value=$this.ProjectData.description }\n            [pscustomobject]@{ Field='ID1'; Value=$this.ProjectData.ID1 }\n            [pscustomobject]@{ Field='ID2'; Value=$this.ProjectData.ID2 }\n            [pscustomobject]@{ Field='Project Folder'; Value=$this.ProjectData.ProjFolder }\n            [pscustomobject]@{ Field='CAA Name'; Value=$this.ProjectData.CAAName }\n            [pscustomobject]@{ Field='Request Name'; Value=$this.ProjectData.RequestName }\n            [pscustomobject]@{ Field='T2020'; Value=$this.ProjectData.T2020 }\n            [pscustomobject]@{ Field='Assigned Date'; Value=$this.ProjectData.AssignedDate }\n            [pscustomobject]@{ Field='Due Date'; Value=$this.ProjectData.DueDate }\n            [pscustomobject]@{ Field='BF Date'; Value=$this.ProjectData.BFDate }\n        )\n\n        $columns = @{\n            Field = @{ Header='Field'; Width=15; Alignment='Left'; Editable=$false }\n            Value = @{ Header='Value'; Width=0; Alignment='Left'; Editable=$false }\n        }\n\n        Write-PmcStyled -Style 'Body' -Text \"Review your project details. Press Enter to create the project.\"\n\n        Show-PmcDataGrid -Domains @('wizard-review') -Columns $columns -Data $reviewRows -Title 'Project Review' -Interactive -OnSelectCallback {\n            param($item)\n            $this.CreateProject()\n        }\n    }\n\n    [void] CreateProject() {\n        Write-PmcStyled -Style 'Info' -Text \"`n🚀 Creating project...\"\n\n        try {\n            # Create the project directly through data system\n            $projectName = $this.ProjectData.name\n            Write-PmcStyled -Style 'Body' -Text \"Creating project: $projectName\"\n\n            # Load existing data\n            $allData = Get-PmcAllData\n\n            # Create new project using ALL actual PMC fields\n            $newProject = @{\n                name = $projectName\n                description = $this.ProjectData.description\n                ID1 = $this.ProjectData.ID1\n                ID2 = $this.ProjectData.ID2\n                ProjFolder = $this.ProjectData.ProjFolder\n                AssignedDate = $this.ProjectData.AssignedDate\n                DueDate = $this.ProjectData.DueDate\n                BFDate = $this.ProjectData.BFDate\n                CAAName = $this.ProjectData.CAAName\n                RequestName = $this.ProjectData.RequestName\n                T2020 = $this.ProjectData.T2020\n                icon = $this.ProjectData.icon\n                color = $this.ProjectData.color\n                sortOrder = $this.ProjectData.sortOrder\n                aliases = $this.ProjectData.aliases\n                isArchived = $this.ProjectData.isArchived\n                created = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\n            }\n\n            # Add to data\n            if (-not $allData.projects) { $allData.projects = @() }\n            $allData.projects += $newProject\n\n\n            # Save all data\n            Set-PmcAllData $allData\n\n            $this.IsComplete = $true\n\n            Write-PmcStyled -Style 'Success' -Text \"`n[OK] Project '$projectName' created successfully!\"\n            Write-PmcStyled -Style 'Body' -Text \"`nUse 'projects' to view your new project.\"\n\n        } catch {\n            Write-PmcStyled -Style 'Error' -Text \"[ERROR] Error creating project: $_\"\n        }\n    }\n}\n\n# Export the wizard function for PMC command integration\nfunction Start-PmcProjectWizard {\n    param([PmcCommandContext]$Context)\n\n    $wizard = [PmcProjectWizard]::new()\n    $wizard.Start()\n}\n\n# Export module member\nExport-ModuleMember -Function Start-PmcProjectWizard"}, {"path": "module/Pmc.Strict/src/Query.ps1", "content": "# PMC Query Language implementation and command processors\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nfunction Invoke-PmcQuery {\r\n    param($Context)\r\n\r\n    # Handle both string and PmcCommandContext parameters for backward compatibility\r\n    if ($Context -is [string]) {\r\n        $tokens = ConvertTo-PmcTokens $Context\r\n        Write-PmcDebug -Level 1 -Category 'Query' -Message 'Invoke-PmcQuery START (string input)' -Data @{ TokenCount=@($tokens).Count }\r\n    } else {\r\n        Write-PmcDebug -Level 1 -Category 'Query' -Message 'Invoke-PmcQuery START' -Data @{ FreeTextCount=@($Context.FreeText).Count }\r\n        if (-not $Context -or $Context.FreeText.Count -lt 1) {\r\n            Write-PmcStyled -Style 'Warning' -Text \"Usage: q <tasks|projects|timelogs> [filters/directives]\"\r\n            return\r\n        }\r\n        $tokens = @($Context.FreeText)\r\n    }\r\n\r\n    # Try enhanced query engine first (Core/EnhancedQueryEngine.ps1)\r\n    if (Get-Command Invoke-PmcEnhancedQuery -ErrorAction SilentlyContinue) {\r\n        try {\r\n            Write-PmcDebug -Level 2 -Category 'Query' -Message 'Attempting enhanced query execution'\r\n            $result = Invoke-PmcEnhancedQuery -Tokens $tokens\r\n            if ($result -and $result.Success -ne $false) {\r\n                Write-PmcDebug -Level 1 -Category 'Query' -Message 'Enhanced query execution successful'\r\n                return $result\r\n            } else {\r\n                Write-PmcDebug -Level 2 -Category 'Query' -Message 'Enhanced query failed, falling back to legacy'\r\n            }\r\n        } catch {\r\n            Write-PmcDebug -Level 1 -Category 'Query' -Message \"Enhanced query error: $_, falling back to legacy\"\r\n        }\r\n    }\r\n\r\n    # Usage: pmc q <tasks|projects|timelogs> [tokens ...]\r\n    if (-not $tokens -or @($tokens).Count -lt 1) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"Usage: q <tasks|projects|timelogs> [filters/directives]\"\r\n        return\r\n    }\r\n    $interactive = $false\r\n    # Detect short interactive flag and strip it from tokens\r\n    if ($tokens -contains '-i') {\r\n        $interactive = $true\r\n        $tokens = @($tokens | Where-Object { $_ -ne '-i' })\r\n    }\r\n\r\n    # Handle load: alias early\r\n    $loadAlias = $tokens | Where-Object { $_ -match '^(?i)load:(.+)$' } | Select-Object -First 1\r\n    if ($loadAlias) {\r\n        $aliasName = ($loadAlias -replace '^(?i)load:','')\r\n        $loaded = Get-PmcQueryAlias -Name $aliasName\r\n        if ($loaded) { $tokens = @($loaded) } else { Write-PmcStyled -Style 'Error' -Text (\"Unknown query alias '{0}'\" -f $aliasName); return }\r\n    }\r\n    $domTok = [string]$tokens[0]\r\n    $rest = @($tokens | Select-Object -Skip 1)\r\n\r\n    # Normalize domain token to singular\r\n    switch ($domTok.ToLower()) {\r\n        'task' { $domain = 'task' }\r\n        'tasks' { $domain = 'task' }\r\n        'project' { $domain = 'project' }\r\n        'projects' { $domain = 'project' }\r\n        'timelog' { $domain = 'timelog' }\r\n        'timelogs' { $domain = 'timelog' }\r\n        default { Write-PmcStyled -Style 'Error' -Text (\"Unknown domain '{0}'. Use tasks|projects|timelogs\" -f $domTok); return }\r\n    }\r\n\r\n    $spec = [PmcQuerySpec]::new()\r\n    $spec.Domain = $domain\r\n    $spec.RawTokens = $rest\r\n\r\n    # Parse directives: cols:, metrics:, sort:, with:, group:, view:\r\n    $colsList = @()\r\n    $metricsList = @()\r\n    $sortList = @()\r\n    $withList = @()\r\n    $groupField = ''\r\n    $textTerms = @()\r\n    $viewType = ''\r\n    foreach ($t in $rest) {\r\n        if ($t -match '^(?i)cols:(.+)$') {\r\n            $list = $matches[1]\r\n            foreach ($c in ($list -split ',')) { $cv = $c.Trim(); if ($cv) { $colsList += $cv } }\r\n        }\r\n        elseif ($t -match '^(?i)metrics:(.+)$') {\r\n            $list = $matches[1]\r\n            foreach ($m in ($list -split ',')) { $mv = $m.Trim(); if ($mv) { $metricsList += $mv } }\r\n        }\r\n        elseif ($t -match '^(?i)sort:(.+)$') {\r\n            $list = $matches[1]\r\n            foreach ($s in ($list -split ',')) {\r\n                $sv = $s.Trim(); if (-not $sv) { continue }\r\n                $dir = 'Asc'; $field = $sv\r\n                if ($sv.EndsWith('+')) { $field = $sv.Substring(0, $sv.Length-1); $dir='Asc' }\r\n                elseif ($sv.EndsWith('-')) { $field = $sv.Substring(0, $sv.Length-1); $dir='Desc' }\r\n                if ($field) { $sortList += @{ Field=$field; Dir=$dir } }\r\n            }\r\n        }\r\n        elseif ($t -match '^(?i)with:(.+)$') {\r\n            $val = $matches[1].ToLower()\r\n            if ($val) { $withList += $val }\r\n        }\r\n        elseif ($t -match '^(?i)group:(.+)$') {\r\n            $groupField = $matches[1]\r\n        }\r\n        elseif ($t -match '^(?i)view:(.+)$') {\r\n            $v = $matches[1].ToLower()\r\n            if ($v -in @('list','kanban')) { $viewType = $v }\r\n        }\r\n        elseif ($t -match '^@(.+)$') { $spec.Filters['project'] = $matches[1] }\r\n        elseif ($t -match '^(?i)overdue$') { $spec.Filters['overdue'] = $true }\r\n        elseif ($t -match '^(?i)due:(.+)$') {\r\n            $dv = $matches[1]\r\n            $spec.Filters['due'] = $dv\r\n        }\r\n        elseif ($t -match '^(?i)due:(\\d{4}-\\d{2}-\\d{2})\\.\\.(\\d{4}-\\d{2}-\\d{2})$') {\r\n            $spec.Filters['due_range'] = @{ Start=$matches[1]; End=$matches[2] }\r\n        }\r\n        elseif ($t -match '^(?i)p:([1-3])\\.\\.([1-3])$') { $spec.Filters['p_range'] = @{ Min=[int]$matches[1]; Max=[int]$matches[2] } }\r\n        elseif ($t -match '^(?i)status:(pending|done)$') { $spec.Filters['status'] = $matches[1].ToLower() }\r\n        elseif ($t -match '^(?i)archived:(true|false)$') { $spec.Filters['archived'] = ([bool]::Parse($matches[1])) }\r\n        elseif ($t -match '^(?i)date:(.+)$') { $spec.Filters['date'] = $matches[1] }\r\n        elseif ($t -match '^(?i)task:(\\d+)$') { $spec.Filters['taskId'] = [int]$matches[1] }\r\n        elseif ($t -match '^(?i)p<=([1-3])$') { $spec.Filters['p_le'] = [int]$matches[1] }\r\n        elseif ($t -match '^(?i)p_le=([1-3])$') { $spec.Filters['p_le'] = [int]$matches[1] }\r\n        elseif ($t -match '^(?i)p>=([1-3])$') { $spec.Filters['p_ge'] = [int]$matches[1] }\r\n        elseif ($t -match '^(?i)p_ge=([1-3])$') { $spec.Filters['p_ge'] = [int]$matches[1] }\r\n        elseif ($t -match '^(?i)p>([1-3])$') { $spec.Filters['p_gt'] = [int]$matches[1] }\r\n        elseif ($t -match '^(?i)p_gt=([1-3])$') { $spec.Filters['p_gt'] = [int]$matches[1] }\r\n        elseif ($t -match '^(?i)p<([1-3])$') { $spec.Filters['p_lt'] = [int]$matches[1] }\r\n        elseif ($t -match '^(?i)p_lt=([1-3])$') { $spec.Filters['p_lt'] = [int]$matches[1] }\r\n        elseif ($t -match '^(?i)p([1-3])$') { $spec.Filters['p_eq'] = [int]$matches[1] }\r\n        elseif ($t -match '^(?i)due>(.+)$') { $spec.Filters['due_gt'] = $matches[1] }\r\n        elseif ($t -match '^(?i)due<(.+)$') { $spec.Filters['due_lt'] = $matches[1] }\r\n        elseif ($t -match '^(?i)due>=(.+)$') { $spec.Filters['due_ge'] = $matches[1] }\r\n        elseif ($t -match '^(?i)due<=(.+)$') { $spec.Filters['due_le'] = $matches[1] }\r\n        elseif ($t -match '^#(.+)$') {\r\n            if (-not $spec.Filters.ContainsKey('tags_in')) { $spec.Filters['tags_in'] = @() }\r\n            $spec.Filters['tags_in'] += $matches[1]\r\n        }\r\n        elseif ($t -match '^-(?:tag:)?(.+)$') {\r\n            if (-not $spec.Filters.ContainsKey('tags_out')) { $spec.Filters['tags_out'] = @() }\r\n            $spec.Filters['tags_out'] += $matches[1]\r\n        }\r\n        elseif ($t -match '^\"(.+)\"$') { $textTerms += $matches[1] }\r\n        else { if ($t) { $textTerms += $t } }\r\n    }\r\n    if (@($colsList).Count -gt 0) { $spec.Columns = $colsList }\r\n    if (@($metricsList).Count -gt 0) { $spec.Metrics = $metricsList }\r\n    if (@($sortList).Count -gt 0) { $spec.Sort = $sortList }\r\n    if (@($withList).Count -gt 0) { $spec.With = $withList }\r\n    if ($groupField) { $spec.Group = $groupField }\r\n    if (@($textTerms).Count -gt 0) { $spec.Filters['text'] = ($textTerms -join ' ') }\r\n    if ($viewType) { $spec.View = $viewType }\r\n\r\n    # Smart defaults: Auto-sort by due date if filtering by due\r\n    if ($spec.Filters.ContainsKey('due') -and @($spec.Sort).Count -eq 0) {\r\n        $spec.Sort = @(@{ Field='due'; Dir='Asc' })\r\n        Write-PmcDebug -Level 2 -Category 'Query' -Message 'Auto-sorting by due date'\r\n    }\r\n\r\n    # Smart defaults: Auto-sort by priority if filtering by priority\r\n    if (($spec.Filters.ContainsKey('p_le') -or $spec.Filters.ContainsKey('p_eq') -or $spec.Filters.ContainsKey('p_range')) -and @($spec.Sort).Count -eq 0) {\r\n        $spec.Sort = @(@{ Field='priority'; Dir='Asc' })\r\n        Write-PmcDebug -Level 2 -Category 'Query' -Message 'Auto-sorting by priority'\r\n    }\r\n\r\n    # Smart defaults: Enable kanban view if grouping by status\r\n    if ($spec.Group -eq 'status' -and $spec.View -eq 'list') {\r\n        $spec.View = 'kanban'\r\n        Write-PmcDebug -Level 2 -Category 'Query' -Message 'Auto-switching to kanban view for status grouping'\r\n    }\r\n\r\n    # Validate filter values\r\n    $priorityFilters = @('p_le', 'p_ge', 'p_gt', 'p_lt', 'p_eq')\r\n    foreach ($pf in $priorityFilters) {\r\n        if ($spec.Filters.ContainsKey($pf)) {\r\n            $val = $spec.Filters[$pf]\r\n            if ($val -lt 1 -or $val -gt 3) {\r\n                Write-PmcStyled -Style 'Warning' -Text \"Warning: Priority value '$val' should be between 1-3\"\r\n            }\r\n        }\r\n    }\r\n\r\n    # Validate date filters\r\n    $dateFilters = @('due', 'due_gt', 'due_lt', 'due_ge', 'due_le')\r\n    foreach ($df in $dateFilters) {\r\n        if ($spec.Filters.ContainsKey($df)) {\r\n            $dateTok = $spec.Filters[$df]\r\n            $isValid = $false\r\n            try {\r\n                if ($dateTok -match '^(?i)today$') { $isValid = $true }\r\n                elseif ($dateTok -match '^\\d{4}-\\d{2}-\\d{2}$') {\r\n                    try { [datetime]$dateTok | Out-Null; $isValid = $true } catch { $isValid = $false }\r\n                }\r\n                else {\r\n                    $schemas = Get-PmcFieldSchemasForDomain -Domain 'task'\r\n                    if ($schemas.ContainsKey('due') -and $schemas.due.ContainsKey('Normalize')) {\r\n                        $normalizedDate = & $schemas.due.Normalize $dateTok\r\n                        if ($normalizedDate) { $isValid = $true }\r\n                    }\r\n                }\r\n            } catch { $isValid = $false }\r\n\r\n            if (-not $isValid) {\r\n                Write-PmcStyled -Style 'Warning' -Text \"Warning: Invalid date format '$dateTok'. Use YYYY-MM-DD, 'today', or relative dates like '+1d'\"\r\n            }\r\n        }\r\n    }\r\n\r\n    # Build Columns hashtable if cols provided; else use defaults\r\n    $columns = @{}\r\n    if (@($spec.Columns).Count -gt 0) {\r\n        $fs = Get-PmcFieldSchemasForDomain -Domain $spec.Domain\r\n        foreach ($name in $spec.Columns) {\r\n            if (-not $fs.ContainsKey($name)) { Write-PmcStyled -Style 'Warning' -Text (\"Unknown column '{0}' for {1}\" -f $name, $spec.Domain); continue }\r\n            $sch = $fs[$name]\r\n            $w = $(if ($sch.ContainsKey('DefaultWidth')) { [int]$sch.DefaultWidth } else { 12 })\r\n            $al = 'Left'\r\n            switch ($name) { 'id' { $al='Right' } 'priority' { $al='Center' } 'due' { $al='Center' } default { } }\r\n            $columns[$name] = @{ Header = ($name); Width = $w; Alignment = $al }\r\n        }\r\n    } else {\r\n        # Default columns based on domain\r\n        if ($spec.Domain -eq 'task') {\r\n            $columns = @{\r\n                'id' = @{ Header = 'ID'; Width = 4; Alignment = 'Right' }\r\n                'text' = @{ Header = 'Task'; Width = 0; Alignment = 'Left' }\r\n                'priority' = @{ Header = 'pri'; Width = 3; Alignment = 'Center' }\r\n                'due' = @{ Header = 'Due'; Width = 12; Alignment = 'Center' }\r\n                'status' = @{ Header = 'Status'; Width = 10; Alignment = 'Left' }\r\n            }\r\n        } elseif ($spec.Domain -eq 'project') {\r\n            $columns = @{\r\n                'name' = @{ Header = 'Name'; Width = 0; Alignment = 'Left' }\r\n                'description' = @{ Header = 'Description'; Width = 0; Alignment = 'Left' }\r\n            }\r\n        } elseif ($spec.Domain -eq 'timelog') {\r\n            $columns = @{\r\n                'date' = @{ Header = 'Date'; Width = 12; Alignment = 'Center' }\r\n                'project' = @{ Header = 'Project'; Width = 15; Alignment = 'Left' }\r\n                'notes' = @{ Header = 'Notes'; Width = 0; Alignment = 'Left' }\r\n            }\r\n        }\r\n    }\r\n\r\n    # Validate metrics before evaluating\r\n    if (@($spec.Metrics).Count -gt 0) {\r\n        $validMetrics = Get-PmcMetricsForDomain -Domain $spec.Domain\r\n        $invalidMetrics = @($spec.Metrics | Where-Object { -not $validMetrics.ContainsKey($_) })\r\n        if (@($invalidMetrics).Count -gt 0) {\r\n            Write-PmcStyled -Style 'Warning' -Text (\"Unknown metrics for {0}: {1}\" -f $spec.Domain, ($invalidMetrics -join ', '))\r\n            Write-PmcStyled -Style 'Muted' -Text (\"Available metrics: {0}\" -f ($validMetrics.Keys -join ', '))\r\n        }\r\n    }\r\n\r\n    # Evaluate\r\n    try {\r\n        $result = Evaluate-PmcQuery -Spec $spec\r\n        Write-PmcDebug -Level 2 -Category 'Query' -Message 'Query evaluation completed' -Data @{ RowCount=@($result.Rows).Count }\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Query evaluation failed: $($_.Exception.Message)\"\r\n        Write-PmcDebug -Level 1 -Category 'Query' -Message 'Query evaluation failed' -Data @{ Error=$_.Exception.Message }\r\n        return\r\n    }\r\n\r\n    # Append to history\r\n    Write-PmcDebug -Level 2 -Category 'Query' -Message 'Adding to query history'\r\n    try { Add-PmcQueryHistory -Args ($Context.FreeText -join ' ') } catch {}\r\n\r\n    # If metrics requested and not in columns, append them to columns end\r\n    Write-PmcDebug -Level 2 -Category 'Query' -Message 'Processing metrics' -Data @{ MetricsCount=@($spec.Metrics).Count }\r\n    if (@($spec.Metrics).Count -gt 0) {\r\n        foreach ($m in $spec.Metrics) {\r\n            if (-not $columns.ContainsKey($m)) {\r\n                $columns[$m] = @{ Header = $m; Width = 10; Alignment = 'Right' }\r\n            }\r\n        }\r\n    }\r\n\r\n    # Show custom grid with evaluated rows\r\n    Write-PmcDebug -Level 2 -Category \"Query\" -Message \"About to call Show-PmcCustomGrid with $(@($result.Rows).Count) rows\"\r\n    Write-PmcDebug -Level 2 -Category 'Query' -Message 'Calling Show-PmcCustomGrid' -Data @{ Domain=$spec.Domain; RowCount=@($result.Rows).Count; ColumnCount=@($columns.Keys).Count }\r\n    try {\r\n        if ($interactive) {\r\n            Show-PmcCustomGrid -Domain $spec.Domain -Columns $columns -Data $result.Rows -Group $spec.Group -View $spec.View -Interactive\r\n        } else {\r\n            Show-PmcCustomGrid -Domain $spec.Domain -Columns $columns -Data $result.Rows -Group $spec.Group -View $spec.View\r\n        }\r\n        Write-PmcDebug -Level 2 -Category \"Query\" -Message \"Show-PmcCustomGrid completed successfully\"\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category \"Query\" -Message \"Show-PmcCustomGrid failed: $($_.Exception.Message)\"\r\n        Write-PmcDebug -Level 1 -Category 'Query' -Message 'Show-PmcCustomGrid failed' -Data @{ Error=$_.Exception.Message }\r\n    }\r\n    Write-PmcDebug -Level 2 -Category 'Query' -Message 'Show-PmcCustomGrid completed'\r\n\r\n    # Save alias if requested\r\n    $saveAlias = $rest | Where-Object { $_ -match '^(?i)save:(.+)$' } | Select-Object -First 1\r\n    if ($saveAlias) {\r\n        $aliasName = ($saveAlias -replace '^(?i)save:','')\r\n        try { Set-PmcQueryAlias -Name $aliasName -Args ($Context.FreeText -join ' ') } catch {}\r\n    }\r\n}\r\n\r\n# Simple completer scaffold for q (progressively enhance later)\r\nfunction Register-PmcQueryCompleter {\r\n    try {\r\n        Register-ArgumentCompleter -CommandName q -ScriptBlock {\r\n            param($wordToComplete, $commandAst, $cursorPosition)\r\n\r\n            function New-CR([string]$text,[string]$tooltip=$text) { [System.Management.Automation.CompletionResult]::new($text,$text,'ParameterValue',$tooltip) }\r\n\r\n            $line = $commandAst.ToString()\r\n            $tokens = [regex]::Split($line.Trim(), '\\s+')\r\n            # tokens[0] = 'q'\r\n            if ($tokens.Count -le 1) { return @( New-CR 'tasks' ; New-CR 'projects' ; New-CR 'timelogs' ) }\r\n\r\n            # Domain candidates (second token)\r\n            if ($tokens.Count -eq 2) {\r\n                $doms = @('tasks','projects','timelogs')\r\n                return @($doms | Where-Object { $_ -like \"$wordToComplete*\" } | ForEach-Object { New-CR $_ })\r\n            }\r\n\r\n            # Determine domain\r\n            $domTok = $tokens[1].ToLower()\r\n            $domain = switch ($domTok) { 'tasks' {'task'} 'task' {'task'} 'projects' {'project'} 'project' {'project'} 'timelogs' {'timelog'} 'timelog' {'timelog'} default { '' } }\r\n\r\n            # Completers for prefixes\r\n            $results = @()\r\n\r\n            # Directives starter\r\n            $directiveStarters = @('with:','metrics:','cols:','sort:','group:','view:','limit:','offset:')\r\n            foreach ($d in $directiveStarters) { if ($d -like \"$wordToComplete*\") { $results += (New-CR $d) } }\r\n\r\n            # Helper for comma-separated lists\r\n            function Complete-CommaList([string]$word,[string]$prefix,[string[]]$candidates) {\r\n                $out = @()\r\n                if (-not ($word -like \"$prefix*\")) { return $out }\r\n                $tail = $word.Substring($prefix.Length)\r\n                $parts = @($tail -split ',')\r\n                if ($parts.Count -eq 0) { $parts = @('') }\r\n                $existing = @()\r\n                if ($parts.Count -gt 1) { $existing = $parts[0..($parts.Count-2)] }\r\n                $partial = $parts[$parts.Count-1]\r\n                foreach ($cand in $candidates) {\r\n                    if ($cand -like \"$partial*\") {\r\n                        $newList = @($existing + $cand) -join ','\r\n                        $out += (New-CR (\"$prefix$newList\"))\r\n                    }\r\n                }\r\n                return $out\r\n            }\r\n\r\n            # with: completions\r\n            if ($wordToComplete -like 'with:*') {\r\n                $rels = @()\r\n                switch ($domain) {\r\n                    'task'    { $rels = @('project','time') }\r\n                    'project' { $rels = @('tasks','time') }\r\n                    'timelog' { $rels = @('project','task') }\r\n                    default { $rels = @() }\r\n                }\r\n                $results += Complete-CommaList -word $wordToComplete -prefix 'with:' -candidates $rels\r\n                return $results\r\n            }\r\n\r\n            # metrics: completions\r\n            if ($wordToComplete -like 'metrics:*') {\r\n                $met = Get-PmcMetricsForDomain -Domain $domain\r\n                $results += Complete-CommaList -word $wordToComplete -prefix 'metrics:' -candidates (@($met.Keys))\r\n                return $results\r\n            }\r\n\r\n            # cols: completions\r\n            if ($wordToComplete -like 'cols:*') {\r\n                $fs = Get-PmcFieldSchemasForDomain -Domain $domain\r\n                $all = @($fs.Keys)\r\n                $met = Get-PmcMetricsForDomain -Domain $domain\r\n                $all += @($met.Keys)\r\n                $results += Complete-CommaList -word $wordToComplete -prefix 'cols:' -candidates $all\r\n                return $results\r\n            }\r\n\r\n            # sort: completions\r\n            if ($wordToComplete -like 'sort:*') {\r\n                $fs = Get-PmcFieldSchemasForDomain -Domain $domain\r\n                $items = @()\r\n                foreach ($k in $fs.Keys) { $items += @(\"$k+\",\"$k-\") }\r\n                $met = Get-PmcMetricsForDomain -Domain $domain\r\n                foreach ($k in $met.Keys) { $items += @(\"$k+\",\"$k-\") }\r\n                $results += Complete-CommaList -word $wordToComplete -prefix 'sort:' -candidates $items\r\n                return $results\r\n            }\r\n\r\n            # group: completions (include relation-derived if with:project present)\r\n            if ($wordToComplete -like 'group:*') {\r\n                $fs = Get-PmcFieldSchemasForDomain -Domain $domain\r\n                foreach ($k in $fs.Keys) { $txt = \"group:$k\"; if ($txt -like \"$wordToComplete*\") { $results += (New-CR $txt) } }\r\n                $hasWithProject = ($tokens -match '^with:project(,|$)').Count -gt 0\r\n                if ($hasWithProject) { foreach ($k in @('project_name')) { $txt = \"group:$k\"; if ($txt -like \"$wordToComplete*\") { $results += (New-CR $txt) } } }\r\n                return $results\r\n            }\r\n\r\n            # view: completions\r\n            if ($wordToComplete -like 'view:*') {\r\n                foreach ($v in @('list','kanban')) { $txt = \"view:$v\"; if ($txt -like \"$wordToComplete*\") { $results += (New-CR $txt) } }\r\n                return $results\r\n            }\r\n\r\n            # @project completion\r\n            if ($wordToComplete -like '@*') {\r\n                try {\r\n                    $data = Get-PmcDataAlias\r\n                    $projects = @($data.projects | ForEach-Object { try { [string]$_.name } catch { $null } } | Where-Object { $_ })\r\n                    foreach ($p in $projects) { $txt = \"@$p\"; if ($txt -like \"$wordToComplete*\") { $results += (New-CR $txt) } }\r\n                } catch {}\r\n                return $results\r\n            }\r\n\r\n            # priority suggestions\r\n            foreach ($p in @('p1','p2','p3','p<=1','p<=2','p<=3','p:1..2','p:2..3')) { if ($p -like \"$wordToComplete*\") { $results += (New-CR $p) } }\r\n\r\n            # due suggestions\r\n            foreach ($d in @('due:today','due:tomorrow','due:+7','date:today','date:tomorrow')) { if ($d -like \"$wordToComplete*\") { $results += (New-CR $d) } }\r\n\r\n            # status / archived starters\r\n            foreach ($s in @('status:pending','status:done','archived:true','archived:false','task:')) { if ($s -like \"$wordToComplete*\") { $results += (New-CR $s) } }\r\n\r\n            # tags suggestion starter\r\n            if ($wordToComplete -eq '#' -or $wordToComplete -like '#*' -or $wordToComplete -like '-tag:*') {\r\n                try {\r\n                    $data = Get-PmcDataAlias\r\n                    $tags = @()\r\n                    foreach ($t in @($data.tasks)) { try { if ($t -and $t.PSObject.Properties['tags']) { $tags += @($t.tags) } } catch {} }\r\n                    $tags = @($tags | Where-Object { $_ } | Select-Object -Unique | Sort-Object)\r\n                    foreach ($tg in $tags) {\r\n                        $cand1 = \"#$tg\"; if ($cand1 -like \"$wordToComplete*\") { $results += (New-CR $cand1) }\r\n                        $cand2 = \"-tag:$tg\"; if ($cand2 -like \"$wordToComplete*\") { $results += (New-CR $cand2) }\r\n                    }\r\n                } catch {}\r\n                return $results\r\n            }\r\n\r\n            # Default: show directive starters and a few filter hints\r\n            $base = @('with:','metrics:','cols:','sort:','group:','@','p1','p2','p3','due:today','#')\r\n            foreach ($b in $base) { if ($b -like \"$wordToComplete*\") { $results += (New-CR $b) } }\r\n            return $results\r\n        } | Out-Null\r\n    } catch { }\r\n}\r\n\r\n# Register on import\r\nRegister-PmcQueryCompleter\r\n\r\n# Query alias/history helpers\r\nfunction Get-PmcQueryStoreDir {\r\n    try { $root = Get-PmcRootPath } catch { $root = (Get-Location).Path }\r\n    $dir = Join-Path $root '.pmc'\r\n    if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null }\r\n    return $dir\r\n}\r\n\r\nfunction Get-PmcQueryAliasPath { param([string]$Name)\r\n    $dir = Get-PmcQueryStoreDir\r\n    return (Join-Path $dir 'query_aliases.json')\r\n}\r\n\r\nfunction Get-PmcQueryHistoryPath {\r\n    $dir = Get-PmcQueryStoreDir\r\n    return (Join-Path $dir 'query_history.log')\r\n}\r\n\r\nfunction Get-PmcQueryAlias { param([string]$Name)\r\n    $path = Get-PmcQueryAliasPath -Name $Name\r\n    if (-not (Test-Path $path)) { return $null }\r\n    try {\r\n        $json = Get-Content $path -Raw -Encoding UTF8 | ConvertFrom-Json\r\n        if ($json.PSObject.Properties[$Name]) { return @([string]$json.$Name) }\r\n    } catch {}\r\n    return $null\r\n}\r\n\r\nfunction Set-PmcQueryAlias { param([string]$Name,[string]$Args)\r\n    if ([string]::IsNullOrWhiteSpace($Name)) { return }\r\n    $path = Get-PmcQueryAliasPath -Name $Name\r\n    $map = @{}\r\n    if (Test-Path $path) { try { $map = Get-Content $path -Raw -Encoding UTF8 | ConvertFrom-Json } catch { $map=@{} } }\r\n    $map[$Name] = $Args\r\n    try { ($map | ConvertTo-Json -Depth 5) | Set-Content -Path $path -Encoding UTF8 } catch {}\r\n}\r\n\r\nfunction Add-PmcQueryHistory { param([string]$Args)\r\n    $path = Get-PmcQueryHistoryPath\r\n    $line = \"$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') | q $Args\"\r\n    try { Add-Content -Path $path -Value $line -Encoding UTF8 } catch {}\r\n}\r\n\r\nfunction Get-PmcQueryHistory { param([int]$Last = 10)\r\n    $path = Get-PmcQueryHistoryPath\r\n    if (-not (Test-Path $path)) { return @() }\r\n    try {\r\n        $lines = Get-Content -Path $path -Encoding UTF8 -ErrorAction SilentlyContinue\r\n        $queries = @()\r\n        foreach ($line in ($lines | Select-Object -Last $Last)) {\r\n            if ($line -match '^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2} \\| q (.+)$') {\r\n                $queries += $matches[1]\r\n            }\r\n        }\r\n        return $queries\r\n    } catch { return @() }\r\n}\r\n\r\n#Export-ModuleMember -Function Invoke-PmcQuery, Register-PmcQueryCompleter, Get-PmcQueryStoreDir, Get-PmcQueryAliasPath, Get-PmcQueryHistoryPath, Get-PmcQueryAlias, Set-PmcQueryAlias, Add-PmcQueryHistory, Get-PmcQueryHistory"}, {"path": "module/Pmc.Strict/src/QueryEvaluator.ps1", "content": "# Query evaluation engine for the PMC query language system\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nfunction Evaluate-PmcQuery {\r\n    param([PmcQuerySpec]$Spec)\r\n    if (-not $Spec -or -not $Spec.Domain) { throw 'Evaluate-PmcQuery: Spec/Domain required' }\r\n\r\n    Write-PmcDebug -Level 2 -Category 'QueryEvaluator' -Message 'Starting query evaluation' -Data @{ Domain=$Spec.Domain }\r\n\r\n    $data = Get-PmcDataAlias\r\n    $rows = @()\r\n    switch ($Spec.Domain) {\r\n        'task'    { $rows = $(if ($data.tasks) { @($data.tasks | Where-Object { $_ -ne $null }) } else { @() }) }\r\n        'project' { $rows = $(if ($data.projects) { @($data.projects | Where-Object { $_ -ne $null }) } else { @() }) }\r\n        'timelog' { $rows = $(if ($data.timelogs) { @($data.timelogs | Where-Object { $_ -ne $null }) } else { @() }) }\r\n        default   { $rows = @() }\r\n    }\r\n\r\n    # Apply basic filters (task domain)\r\n    if ($Spec.Domain -eq 'task' -and $Spec.Filters) {\r\n        $proj = $(if ($Spec.Filters.ContainsKey('project')) { [string]$Spec.Filters['project'] } else { $null })\r\n        $overdue = ($Spec.Filters.ContainsKey('overdue'))\r\n        $dueTok = $(if ($Spec.Filters.ContainsKey('due')) { [string]$Spec.Filters['due'] } else { $null })\r\n        $due_gt = $(if ($Spec.Filters.ContainsKey('due_gt')) { [string]$Spec.Filters['due_gt'] } else { $null })\r\n        $due_lt = $(if ($Spec.Filters.ContainsKey('due_lt')) { [string]$Spec.Filters['due_lt'] } else { $null })\r\n        $due_ge = $(if ($Spec.Filters.ContainsKey('due_ge')) { [string]$Spec.Filters['due_ge'] } else { $null })\r\n        $due_le = $(if ($Spec.Filters.ContainsKey('due_le')) { [string]$Spec.Filters['due_le'] } else { $null })\r\n        $p_le = $(if ($Spec.Filters.ContainsKey('p_le')) { [int]$Spec.Filters['p_le'] } else { 0 })\r\n        $p_ge = $(if ($Spec.Filters.ContainsKey('p_ge')) { [int]$Spec.Filters['p_ge'] } else { 0 })\r\n        $p_gt = $(if ($Spec.Filters.ContainsKey('p_gt')) { [int]$Spec.Filters['p_gt'] } else { 0 })\r\n        $p_lt = $(if ($Spec.Filters.ContainsKey('p_lt')) { [int]$Spec.Filters['p_lt'] } else { 0 })\r\n        $p_eq = $(if ($Spec.Filters.ContainsKey('p_eq')) { [int]$Spec.Filters['p_eq'] } else { 0 })\r\n        $tagsIn = $(if ($Spec.Filters.ContainsKey('tags_in')) { @($Spec.Filters['tags_in']) } else { @() })\r\n        $tagsOut = $(if ($Spec.Filters.ContainsKey('tags_out')) { @($Spec.Filters['tags_out']) } else { @() })\r\n        $textQ = $(if ($Spec.Filters.ContainsKey('text')) { [string]$Spec.Filters['text'] } else { '' })\r\n\r\n        $rows = @($rows | Where-Object {\r\n            $ok = $true\r\n            if ($proj) { $ok = $ok -and ($_.PSObject.Properties['project'] -and [string]$_.project -eq $proj) }\r\n            if ($Spec.Filters.ContainsKey('status')) {\r\n                $sts = [string]$Spec.Filters['status']\r\n                $ok = $ok -and ($_.PSObject.Properties['status'] -and ([string]$_.status).ToLower() -eq $sts)\r\n            }\r\n            if ($p_le -gt 0) {\r\n                $v = $(if ($_.PSObject.Properties['priority']) { try { [int]$_.priority } catch { 0 } } else { 0 })\r\n                $ok = $ok -and ($v -gt 0 -and $v -le $p_le)\r\n            }\r\n            if ($p_ge -gt 0) {\r\n                $v = $(if ($_.PSObject.Properties['priority']) { try { [int]$_.priority } catch { 0 } } else { 0 })\r\n                $ok = $ok -and ($v -gt 0 -and $v -ge $p_ge)\r\n            }\r\n            if ($p_gt -gt 0) {\r\n                $v = $(if ($_.PSObject.Properties['priority']) { try { [int]$_.priority } catch { 0 } } else { 0 })\r\n                $ok = $ok -and ($v -gt $p_gt)\r\n            }\r\n            if ($p_lt -gt 0) {\r\n                $v = $(if ($_.PSObject.Properties['priority']) { try { [int]$_.priority } catch { 0 } } else { 0 })\r\n                $ok = $ok -and ($v -gt 0 -and $v -lt $p_lt)\r\n            }\r\n            if ($p_eq -gt 0) {\r\n                $v = $(if ($_.PSObject.Properties['priority']) { try { [int]$_.priority } catch { 0 } } else { 0 })\r\n                $ok = $ok -and ($v -eq $p_eq)\r\n            }\r\n            if ($Spec.Filters.ContainsKey('p_range')) {\r\n                $min = [int]$Spec.Filters['p_range'].Min; $max=[int]$Spec.Filters['p_range'].Max\r\n                $v = $(if ($_.PSObject.Properties['priority']) { try { [int]$_.priority } catch { 0 } } else { 0 })\r\n                $ok = $ok -and ($v -ge $min -and $v -le $max)\r\n            }\r\n            if ($overdue) {\r\n                if ($_.PSObject.Properties['due']) {\r\n                    try { $ok = $ok -and (([datetime]$_.due).Date -lt (Get-Date).Date) } catch { $ok = $false }\r\n                }\r\n            }\r\n            if ($dueTok) {\r\n                $d = $null\r\n                try {\r\n                    # Use flexible date parsing logic from FieldSchemas\r\n                    $schemas = Get-PmcFieldSchemasForDomain -Domain 'task'\r\n                    if ($schemas.ContainsKey('due') -and $schemas.due.ContainsKey('Normalize')) {\r\n                        $normalizedDate = & $schemas.due.Normalize $dueTok\r\n                        if ($normalizedDate) { $d = [datetime]$normalizedDate }\r\n                    }\r\n                } catch {\r\n                    # Fallback to basic parsing\r\n                    if ($dueTok -match '^(?i)today$') { $d = (Get-Date).Date }\r\n                    elseif ($dueTok -match '^\\d{4}-\\d{2}-\\d{2}$') { try { $d = [datetime]$dueTok } catch { $d=$null } }\r\n                }\r\n                if ($d -ne $null -and $_.PSObject.Properties['due']) {\r\n                    try { $ok = $ok -and (([datetime]$_.due).Date -eq $d.Date) } catch { $ok = $false }\r\n                }\r\n            }\r\n            if ($Spec.Filters.ContainsKey('due_range')) {\r\n                $startTok = [string]$Spec.Filters['due_range'].Start; $endTok=[string]$Spec.Filters['due_range'].End\r\n                try { $start=[datetime]$startTok; $end=[datetime]$endTok } catch { $start=$null; $end=$null }\r\n                if ($start -ne $null -and $end -ne $null -and $_.PSObject.Properties['due']) {\r\n                    try { $dd=[datetime]$_.due; $ok = $ok -and ($dd -ge $start -and $dd -le $end) } catch { $ok = $false }\r\n                }\r\n            }\r\n            if ($due_gt -and $_.PSObject.Properties['due']) {\r\n                $d = $null\r\n                try {\r\n                    $schemas = Get-PmcFieldSchemasForDomain -Domain 'task'\r\n                    if ($schemas.ContainsKey('due') -and $schemas.due.ContainsKey('Normalize')) {\r\n                        $normalizedDate = & $schemas.due.Normalize $due_gt\r\n                        if ($normalizedDate) { $d = [datetime]$normalizedDate }\r\n                    }\r\n                } catch {\r\n                    if ($due_gt -match '^(?i)today$') { $d = (Get-Date).Date }\r\n                    elseif ($due_gt -match '^\\d{4}-\\d{2}-\\d{2}$') { try { $d = [datetime]$due_gt } catch { $d=$null } }\r\n                }\r\n                if ($d -ne $null) {\r\n                    try { $ok = $ok -and (([datetime]$_.due).Date -gt $d.Date) } catch { $ok = $false }\r\n                }\r\n            }\r\n            if ($due_lt -and $_.PSObject.Properties['due']) {\r\n                $d = $null\r\n                try {\r\n                    $schemas = Get-PmcFieldSchemasForDomain -Domain 'task'\r\n                    if ($schemas.ContainsKey('due') -and $schemas.due.ContainsKey('Normalize')) {\r\n                        $normalizedDate = & $schemas.due.Normalize $due_lt\r\n                        if ($normalizedDate) { $d = [datetime]$normalizedDate }\r\n                    }\r\n                } catch {\r\n                    if ($due_lt -match '^(?i)today$') { $d = (Get-Date).Date }\r\n                    elseif ($due_lt -match '^\\d{4}-\\d{2}-\\d{2}$') { try { $d = [datetime]$due_lt } catch { $d=$null } }\r\n                }\r\n                if ($d -ne $null) {\r\n                    try { $ok = $ok -and (([datetime]$_.due).Date -lt $d.Date) } catch { $ok = $false }\r\n                }\r\n            }\r\n            if ($due_ge -and $_.PSObject.Properties['due']) {\r\n                $d = $null\r\n                try {\r\n                    $schemas = Get-PmcFieldSchemasForDomain -Domain 'task'\r\n                    if ($schemas.ContainsKey('due') -and $schemas.due.ContainsKey('Normalize')) {\r\n                        $normalizedDate = & $schemas.due.Normalize $due_ge\r\n                        if ($normalizedDate) { $d = [datetime]$normalizedDate }\r\n                    }\r\n                } catch {\r\n                    if ($due_ge -match '^(?i)today$') { $d = (Get-Date).Date }\r\n                    elseif ($due_ge -match '^\\d{4}-\\d{2}-\\d{2}$') { try { $d = [datetime]$due_ge } catch { $d=$null } }\r\n                }\r\n                if ($d -ne $null) {\r\n                    try { $ok = $ok -and (([datetime]$_.due).Date -ge $d.Date) } catch { $ok = $false }\r\n                }\r\n            }\r\n            if ($due_le -and $_.PSObject.Properties['due']) {\r\n                $d = $null\r\n                try {\r\n                    $schemas = Get-PmcFieldSchemasForDomain -Domain 'task'\r\n                    if ($schemas.ContainsKey('due') -and $schemas.due.ContainsKey('Normalize')) {\r\n                        $normalizedDate = & $schemas.due.Normalize $due_le\r\n                        if ($normalizedDate) { $d = [datetime]$normalizedDate }\r\n                    }\r\n                } catch {\r\n                    if ($due_le -match '^(?i)today$') { $d = (Get-Date).Date }\r\n                    elseif ($due_le -match '^\\d{4}-\\d{2}-\\d{2}$') { try { $d = [datetime]$due_le } catch { $d=$null } }\r\n                }\r\n                if ($d -ne $null) {\r\n                    try { $ok = $ok -and (([datetime]$_.due).Date -le $d.Date) } catch { $ok = $false }\r\n                }\r\n            }\r\n            if (@($tagsIn).Count -gt 0) {\r\n                if ($_.PSObject.Properties['tags']) {\r\n                    try { $ok = $ok -and (@($tagsIn | Where-Object { $($_) -in $_.tags }).Count -eq @($tagsIn).Count) } catch { $ok = $false }\r\n                }\r\n            }\r\n            if (@($tagsOut).Count -gt 0) {\r\n                if ($_.PSObject.Properties['tags']) {\r\n                    try { $ok = $ok -and -not (@($tagsOut | Where-Object { $($_) -in $_.tags }).Count -gt 0) } catch { $ok = $true }\r\n                }\r\n            }\r\n            if ($textQ) {\r\n                if ($_.PSObject.Properties['text']) {\r\n                    try { $ok = $ok -and ([string]$_.text).ToLower().Contains($textQ.ToLower()) } catch { $ok = $false }\r\n                }\r\n            }\r\n            $ok\r\n        })\r\n    }\r\n\r\n    # Apply basic filters (project domain)\r\n    if ($Spec.Domain -eq 'project' -and $Spec.Filters) {\r\n        $textQ = $(if ($Spec.Filters.ContainsKey('text')) { [string]$Spec.Filters['text'] } else { '' })\r\n        $arch = $null; if ($Spec.Filters.ContainsKey('archived')) { $arch = [bool]$Spec.Filters['archived'] }\r\n        if ($textQ) {\r\n            $rows = @($rows | Where-Object {\r\n                try {\r\n                    ($_.PSObject.Properties['name'] -and ([string]$_.name).ToLower().Contains($textQ.ToLower())) -or\r\n                    ($_.PSObject.Properties['description'] -and ([string]$_.description).ToLower().Contains($textQ.ToLower()))\r\n                } catch { $false }\r\n            })\r\n        }\r\n        if ($arch -ne $null) {\r\n            $rows = @($rows | Where-Object { $_.PSObject.Properties['isArchived'] -and [bool]$_.isArchived -eq $arch })\r\n        }\r\n    }\r\n\r\n    # Apply basic filters (timelog domain)\r\n    if ($Spec.Domain -eq 'timelog' -and $Spec.Filters) {\r\n        $proj = $(if ($Spec.Filters.ContainsKey('project')) { [string]$Spec.Filters['project'] } else { $null })\r\n        $dateTok = $(if ($Spec.Filters.ContainsKey('date')) { [string]$Spec.Filters['date'] } elseif ($Spec.Filters.ContainsKey('due')) { [string]$Spec.Filters['due'] } else { $null })\r\n        $textQ = $(if ($Spec.Filters.ContainsKey('text')) { [string]$Spec.Filters['text'] } else { '' })\r\n        $taskId = $(if ($Spec.Filters.ContainsKey('taskId')) { [int]$Spec.Filters['taskId'] } else { 0 })\r\n        $rows = @($rows | Where-Object {\r\n            $ok = $true\r\n            if ($proj) { $ok = $ok -and ($_.PSObject.Properties['project'] -and [string]$_.project -eq $proj) }\r\n            if ($dateTok) {\r\n                if ($dateTok -match '^\\d{4}-\\d{2}-\\d{2}\\.\\.\\d{4}-\\d{2}-\\d{2}$') {\r\n                    $parts = $dateTok -split '\\.\\.'\r\n                    try { $ds=[datetime]$parts[0]; $de=[datetime]$parts[1] } catch { $ds=$null; $de=$null }\r\n                    if ($ds -ne $null -and $de -ne $null -and $_.PSObject.Properties['date']) {\r\n                        try { $dd=[datetime]$_.date; $ok = $ok -and ($dd -ge $ds -and $dd -le $de) } catch { $ok = $false }\r\n                    }\r\n                } else {\r\n                    $d = $null\r\n                    if ($dateTok -match '^(?i)today$') { $d = (Get-Date).Date }\r\n                    elseif ($dateTok -match '^\\d{4}-\\d{2}-\\d{2}$') { try { $d = [datetime]$dateTok } catch { $d=$null } }\r\n                    if ($d -ne $null -and $_.PSObject.Properties['date']) {\r\n                        try { $ok = $ok -and (([datetime]$_.date).Date -eq $d.Date) } catch { $ok = $false }\r\n                    }\r\n                }\r\n            }\r\n            if ($taskId -gt 0 -and $_.PSObject.Properties['taskId']) {\r\n                try { $ok = $ok -and ([int]$_.taskId -eq $taskId) } catch { $ok = $false }\r\n            }\r\n            if ($textQ -and $_.PSObject.Properties['notes']) {\r\n                try { $ok = $ok -and ([string]$_.notes).ToLower().Contains($textQ.ToLower()) } catch { $ok = $false }\r\n            }\r\n            $ok\r\n        })\r\n    }\r\n\r\n    # Relations (attach derived fields)\r\n    Write-PmcDebug -Level 3 -Category 'QueryEvaluator' -Message 'Checking relations' -Data @{ With=$Spec.With; WithType=($Spec.With).GetType().Name }\r\n    if ($Spec.With -and @($Spec.With).Count -gt 0) {\r\n        foreach ($rel in $Spec.With) {\r\n            foreach ($row in $rows) {\r\n                $rels = Get-PmcRelationResolvers -Domain $Spec.Domain -Relation $rel\r\n                foreach ($key in $rels.Keys) {\r\n                    try { $val = & $rels[$key] $row $data } catch { $val = $null }\r\n                    try { if ($row.PSObject.Properties[$key]) { $row.$key = $val } else { Add-Member -InputObject $row -MemberType NoteProperty -Name $key -NotePropertyValue $val -Force } } catch {}\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    # Compute requested metrics and attach as NoteProperties\r\n    Write-PmcDebug -Level 3 -Category 'QueryEvaluator' -Message 'Checking metrics' -Data @{ Metrics=$Spec.Metrics; MetricsType=($Spec.Metrics).GetType().Name }\r\n    if ($Spec.Metrics -and @($Spec.Metrics).Count -gt 0) {\r\n        $metrics = Get-PmcMetricsForDomain -Domain $Spec.Domain\r\n        foreach ($row in $rows) {\r\n            foreach ($m in $Spec.Metrics) {\r\n                if (-not $metrics.ContainsKey($m)) { continue }\r\n                $def = $metrics[$m]\r\n                try {\r\n                    $val = & $def.Resolver $row $data\r\n                } catch { $val = $null }\r\n                    try { if ($row.PSObject.Properties[$m]) { $row.$m = $val } else { Add-Member -InputObject $row -MemberType NoteProperty -Name $m -NotePropertyValue $val -Force } } catch {}\r\n            }\r\n        }\r\n    }\r\n\r\n    # Apply group pre-sort (simple group ascending)\r\n    if ($Spec.Group -and $Spec.Group.Trim()) {\r\n        $g = $Spec.Group.Trim()\r\n        $rows = @($rows | Sort-Object -Property $g)\r\n    }\r\n\r\n    # Apply sort if specified\r\n    Write-PmcDebug -Level 3 -Category 'QueryEvaluator' -Message 'Checking sort' -Data @{ Sort=$Spec.Sort; SortType=($Spec.Sort).GetType().Name }\r\n    if ($Spec.Sort -and @($Spec.Sort).Count -gt 0) {\r\n        $props = @()\r\n        foreach ($s in $Spec.Sort) {\r\n            $f = [string]$s.Field; if (-not $f) { continue }\r\n            $asc = ($s.Dir -ne 'Desc')\r\n            $props += @{ Expression = $f; Ascending = $asc }\r\n        }\r\n        if (@($props).Count -gt 0) { $rows = @($rows | Sort-Object -Property $props) }\r\n    }\r\n\r\n    return @{ Domain=$Spec.Domain; Rows=$rows }\r\n}\r\n\r\nExport-ModuleMember -Function Evaluate-PmcQuery"}, {"path": "module/Pmc.Strict/src/QuerySpec.ps1", "content": "# Query specification classes for the PMC query language system\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass PmcQuerySpec {\r\n    [string] $Domain = ''       # task|project|timelog\r\n    [string[]] $Columns = @()   # visible columns in order\r\n    [string[]] $RawTokens = @() # raw query tokens (post 'q')\r\n    [string[]] $Metrics = @()\r\n    [hashtable[]] $Sort = @()   # e.g., @{ Field='due'; Dir='Asc' }\r\n    [string[]] $With = @()\r\n    [string] $Group = ''\r\n    [hashtable] $Filters = @{}\r\n    [string] $View = 'list'     # list | kanban (future)\r\n\r\n    PmcQuerySpec() {\r\n        $this.Columns = @()\r\n        $this.RawTokens = @()\r\n        $this.Metrics = @()\r\n        $this.Sort = @()\r\n        $this.With = @()\r\n        $this.Filters = @{}\r\n    }\r\n}\r\n\r\n# QuerySpec.ps1 contains only classes, no functions to export"}, {"path": "module/Pmc.Strict/src/Resolvers.ps1", "content": "# Project and argument resolvers for strict engine\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nfunction Resolve-Project {\r\n    param(\r\n        [Parameter(Mandatory=$true)] $Data,\r\n        [Parameter(Mandatory=$true)][string] $Name\r\n    )\r\n    if ([string]::IsNullOrWhiteSpace($Name)) { return $null }\r\n    $q = $Name.Trim(); if ($q.StartsWith('@')) { $q = $q.Substring(1) }\r\n    # Exact name match (case-insensitive)\r\n    $p = $Data.projects | Where-Object { try { $_.name -and ($_.name.ToLower() -eq $q.ToLower()) } catch { $false } } | Select-Object -First 1\r\n    if ($p) { return $p }\r\n    # Alias match (case-insensitive)\r\n    foreach ($proj in $Data.projects) {\r\n        try {\r\n            if (Pmc-HasProp $proj 'aliases' -and $proj.aliases) {\r\n                foreach ($alias in $proj.aliases) {\r\n                    if ([string]::IsNullOrWhiteSpace($alias)) { continue }\r\n                    if ($alias.ToLower() -eq $q.ToLower()) { return $proj }\r\n                }\r\n            }\r\n        } catch {\r\n            # Project alias property access failed - skip this project\r\n        }\r\n    }\r\n    return $null\r\n}\r\n\r\n#Export-ModuleMember -Function Resolve-Project"}, {"path": "module/Pmc.Strict/src/Review.ps1", "content": "# Weekly Review workflow\r\n\r\nfunction Start-PmcReview {\r\n    param([PmcCommandContext]$Context)\r\n    Write-Host ([PraxisVT]::ClearScreen())\r\n    Show-PmcHeader -Title 'WEEKLY REVIEW' -Icon '🗓'\r\n    Show-PmcTip 'Walk through overdue, today/tomorrow, upcoming, blocked, and projects.'\r\n\r\n    $sections = @(\r\n        @{ title='Overdue';        action={ param($ctx) Show-PmcOverdueTasks -Context $ctx } },\r\n        @{ title='Today & Tomorrow'; action={ param($ctx) Show-PmcTodayTasks -Context $ctx; Show-PmcTomorrowTasks -Context $ctx } },\r\n        @{ title='Upcoming (7d)'; action={ param($ctx) Show-PmcUpcomingTasks -Context $ctx } },\r\n        @{ title='Blocked';       action={ param($ctx) Show-PmcBlockedTasks -Context $ctx } },\r\n        @{ title='Next Actions';  action={ param($ctx) Show-PmcNextTasks -Context $ctx } },\r\n        @{ title='Projects';      action={ param($ctx) Show-PmcProjectsView -Context $ctx } }\r\n    )\r\n\r\n    foreach ($s in $sections) {\r\n        Show-PmcSeparator -Width 60\r\n        Show-PmcNotice (\"Section: {0}\" -f $s.title)\r\n        & $s.action $Context\r\n        $resp = Read-Host \"Press Enter to continue, or 'q' to quit review\"\r\n        if ($resp -match '^(?i)q$') { break }\r\n    }\r\n\r\n    Show-PmcSeparator -Width 60\r\n    Show-PmcSuccess 'Review complete.'\r\n}\r\n\r\n#Export-ModuleMember -Function Start-PmcReview"}, {"path": "module/Pmc.Strict/src/Schemas.ps1", "content": "# Parameter schemas for strict commands (subset to start)\r\n\r\n# Each entry uses a simple schema array: ordered hints and prefixes\r\n$Script:PmcParameterMap = @{\r\n    'task add' = @(\r\n        @{ Name='Text'; Type='FreeText'; Required=$true; Description='Task description' },\r\n        @{ Name='Project'; Prefix='@'; Type='ProjectName' },\r\n        @{ Name='Priority'; Prefix='p'; Type='Priority'; Pattern='^p[1-3]$' },\r\n        @{ Name='Due'; Prefix='due:'; Type='DateString' },\r\n        @{ Name='Tags'; Prefix='#'; Type='TagName'; AllowsMultiple=$true }\r\n    )\r\n    'task done' = @(\r\n        @{ Name='Id'; Type='TaskID'; Required=$true; Pattern='^\\d+$' }\r\n    )\r\n    'task list' = @()\r\n    'task delete' = @()\r\n    'task view' = @(\r\n        @{ Name='Id'; Type='TaskID'; Required=$true }\r\n    )\r\n    'task agenda' = @()\r\n    'task week' = @()\r\n    'task month' = @()\r\n    'time log' = @(\r\n        @{ Name='Project'; Prefix='@'; Type='ProjectName' },\r\n        @{ Name='TaskId'; Prefix='task:'; Type='TaskID' },\r\n        @{ Name='Date'; Type='DateString' },\r\n        @{ Name='Duration'; Type='Duration' },\r\n        @{ Name='Description'; Type='FreeText' }\r\n    )\r\n    'time report' = @(\r\n        @{ Name='Range'; Type='DateRange' },\r\n        @{ Name='Project'; Prefix='@'; Type='ProjectName' }\r\n    )\r\n    'time list' = @()\r\n    'time edit' = @(\r\n        @{ Name='Id'; Type='FreeText'; Required=$true }\r\n    )\r\n    'time delete' = @(\r\n        @{ Name='Id'; Type='FreeText'; Required=$true }\r\n    )\r\n    'timer start' = @(\r\n        @{ Name='Project'; Prefix='@'; Type='ProjectName' },\r\n        @{ Name='Description'; Type='FreeText' }\r\n    )\r\n    'timer stop' = @()\r\n    'timer status' = @()\r\n    'task update' = @(\r\n        @{ Name='Id'; Type='TaskID'; Required=$true },\r\n        @{ Name='Project'; Prefix='@'; Type='ProjectName' },\r\n        @{ Name='Priority'; Prefix='p'; Type='Priority' },\r\n        @{ Name='Due'; Prefix='due:'; Type='DateString' },\r\n        @{ Name='Tags'; Prefix='#'; Type='TagName'; AllowsMultiple=$true },\r\n        @{ Name='Text'; Type='FreeText' }\r\n    )\r\n    'task move' = @(\r\n        @{ Name='Id'; Type='TaskID'; Required=$true },\r\n        @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true }\r\n    )\r\n    'task postpone' = @(\r\n        @{ Name='Id'; Type='TaskID'; Required=$true },\r\n        @{ Name='Delta'; Type='FreeText'; Required=$true }\r\n    )\r\n    'task duplicate' = @(\r\n        @{ Name='Id'; Type='TaskID'; Required=$true }\r\n    )\r\n    'task note' = @(\r\n        @{ Name='Id'; Type='TaskID'; Required=$true },\r\n        @{ Name='Note'; Type='FreeText'; Required=$true }\r\n    )\r\n    'task edit' = @(\r\n        @{ Name='Id'; Type='TaskID'; Required=$true }\r\n    )\r\n    'task search' = @(\r\n        @{ Name='Query'; Type='FreeText'; Required=$true }\r\n    )\r\n    'task priority' = @(\r\n        @{ Name='Level'; Type='FreeText'; Required=$true }\r\n    )\r\n\r\n    # Project advanced\r\n    'project add' = @(\r\n        # Name is optional to allow launching the Project Wizard when omitted\r\n        @{ Name='Name'; Type='FreeText'; Required=$false }\r\n    )\r\n    'project list' = @()\r\n    'project stats' = @()\r\n    'project info' = @()\r\n    'project recent' = @()\r\n    'project view' = @(\r\n        @{ Name='Name'; Type='FreeText'; Required=$true }\r\n    )\r\n    'project rename' = @(\r\n        @{ Name='Old'; Type='FreeText'; Required=$true },\r\n        @{ Name='New'; Type='FreeText'; Required=$true }\r\n    )\r\n    'project delete' = @(\r\n        @{ Name='Name'; Type='FreeText'; Required=$true }\r\n    )\r\n    'project archive' = @(\r\n        @{ Name='Name'; Type='FreeText'; Required=$true }\r\n    )\r\n    'project set-fields' = @(\r\n        @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true },\r\n        @{ Name='Fields'; Type='FreeText' }\r\n    )\r\n    'project show-fields' = @(\r\n        @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true }\r\n    )\r\n    'project update' = @(\r\n        @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true },\r\n        @{ Name='Fields'; Type='FreeText' }\r\n    )\r\n    'project edit' = @(\r\n        @{ Name='Project'; Prefix='@'; Type='ProjectName'; Required=$true }\r\n    )\r\n\r\n    # Config / Template / Recurring\r\n    'config show' = @()\r\n    'config icons' = @()\r\n    'config set' = @(\r\n        @{ Name='Path'; Type='FreeText'; Required=$true },\r\n        @{ Name='Value'; Type='FreeText'; Required=$true }\r\n    )\r\n    'config edit' = @()\r\n\r\n    'template save' = @(\r\n        @{ Name='Name'; Type='FreeText'; Required=$true },\r\n        @{ Name='Body'; Type='FreeText' }\r\n    )\r\n    'template apply' = @(\r\n        @{ Name='Name'; Type='FreeText'; Required=$true }\r\n    )\r\n    'template list' = @()\r\n    'template remove' = @(\r\n        @{ Name='Name'; Type='FreeText'; Required=$true }\r\n    )\r\n\r\n    'recurring add' = @(\r\n        @{ Name='Pattern'; Type='FreeText'; Required=$true },\r\n        @{ Name='Body'; Type='FreeText' }\r\n    )\r\n    'recurring list' = @()\r\n\r\n    # Dependencies\r\n    'dep add' = @(\r\n        @{ Name='Id'; Type='TaskID'; Required=$true },\r\n        @{ Name='Requires'; Type='FreeText'; Required=$true }\r\n    )\r\n    'dep remove' = @(\r\n        @{ Name='Id'; Type='TaskID'; Required=$true },\r\n        @{ Name='Requires'; Type='FreeText'; Required=$true }\r\n    )\r\n    'dep show' = @(\r\n        @{ Name='Id'; Type='TaskID'; Required=$true }\r\n    )\r\n    'dep graph' = @()\r\n\r\n    # Activity / System\r\n    'activity list' = @()\r\n    'system undo' = @()\r\n    'system redo' = @()\r\n    'system backup' = @()\r\n    'system clean' = @()\r\n    'theme reset' = @()\r\n    'theme adjust' = @()\r\n\r\n    # Theme management (complete)\r\n    'theme list' = @()\r\n    'theme apply' = @(\r\n        @{ Name='ColorOrPreset'; Type='FreeText'; Required=$true; Description='Color #RRGGBB or preset name' }\r\n    )\r\n    'theme info' = @()\r\n    'excel import' = @()\r\n    'excel bind' = @()\r\n    'excel view' = @()\r\n    'excel latest' = @()\r\n    'import tasks' = @()\r\n    'export tasks' = @()\r\n    'focus set' = @(\r\n        @{ Name='Project'; Type='FreeText'; Required=$true }\r\n    )\r\n    'focus clear' = @()\r\n    'focus status' = @()\r\n    'interactive status' = @()\r\n    'show aliases' = @()\r\n    'show commands' = @()\r\n    'alias add' = @(\r\n        @{ Name='NameAndExpansion'; Type='FreeText'; Required=$true }\r\n    )\r\n    'alias remove' = @(\r\n        @{ Name='Name'; Type='FreeText'; Required=$true }\r\n    )\r\n    'help all' = @()\r\n    'help show' = @()\r\n    'help commands' = @()\r\n    'help examples' = @()\r\n    'help guide' = @()\r\n    'help domain' = @(\r\n        @{ Name='Domain'; Type='FreeText'; Required=$true; Description='Domain name (e.g., task, project, time)' }\r\n    )\r\n    'help command' = @(\r\n        @{ Name='Domain'; Type='FreeText'; Required=$true; Description='Domain name' },\r\n        @{ Name='Action'; Type='FreeText'; Required=$true; Description='Action name' }\r\n    )\r\n\r\n    # Views\r\n    'view today' = @()\r\n    'view tomorrow' = @()\r\n    'view overdue' = @()\r\n    'view upcoming' = @()\r\n    'view blocked' = @()\r\n    'view noduedate' = @()\r\n    'view projects' = @()\r\n    'view next' = @()\r\n}\r\n\r\n# Schemas.ps1 contains only data structures, no functions to export"}, {"path": "module/Pmc.Strict/src/ScreenManager.ps1", "content": "# PMC Screen Management System\r\n# Adapted from praxis-main/Core patterns for persistent screen layout\r\n\r\nclass PmcScreenBounds {\r\n    [int]$X = 0\r\n    [int]$Y = 0\r\n    [int]$Width = 0\r\n    [int]$Height = 0\r\n\r\n    PmcScreenBounds([int]$x, [int]$y, [int]$width, [int]$height) {\r\n        $this.X = $x\r\n        $this.Y = $y\r\n        $this.Width = $width\r\n        $this.Height = $height\r\n    }\r\n\r\n    [string] ToString() {\r\n        return \"($($this.X),$($this.Y) $($this.Width)x$($this.Height))\"\r\n    }\r\n}\r\n\r\nclass PmcScreenRegions {\r\n    [PmcScreenBounds]$Header\r\n    [PmcScreenBounds]$Content\r\n    [PmcScreenBounds]$Status\r\n    [PmcScreenBounds]$Input\r\n    [PmcScreenBounds]$Full\r\n\r\n    PmcScreenRegions([int]$terminalWidth, [int]$terminalHeight) {\r\n        # Calculate regions based on terminal size\r\n        $this.Full = [PmcScreenBounds]::new(0, 0, $terminalWidth, $terminalHeight)\r\n        $this.Header = [PmcScreenBounds]::new(0, 0, $terminalWidth, 3)  # Title + separator\r\n        $this.Input = [PmcScreenBounds]::new(0, $terminalHeight - 2, $terminalWidth, 2)  # Input line + separator\r\n        $this.Status = [PmcScreenBounds]::new($terminalWidth - 30, 1, 30, 1)  # Right side of header\r\n        $this.Content = [PmcScreenBounds]::new(0, 3, $terminalWidth, $terminalHeight - 5)  # Between header and input\r\n\r\n        if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n            Write-PmcDebug -Level 3 -Category 'ScreenManager' -Message \"Screen regions calculated\" -Data @{\r\n                Terminal = \"$terminalWidth x $terminalHeight\"\r\n                Header = $this.Header.ToString()\r\n                Content = $this.Content.ToString()\r\n                Status = $this.Status.ToString()\r\n                Input = $this.Input.ToString()\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass PmcScreenManager {\r\n    hidden [PmcScreenRegions]$_regions\r\n    hidden [string]$_lastContent = \"\"\r\n    hidden [bool]$_needsClear = $true\r\n    hidden [int]$_terminalWidth = 0\r\n    hidden [int]$_terminalHeight = 0\r\n\r\n    # VT100 sequences - adapted from praxis patterns\r\n    hidden [string]$_hideCursor = \"`e[?25l\"\r\n    hidden [string]$_showCursor = \"`e[?25h\"\r\n    hidden [string]$_clearScreen = \"`e[2J\"\r\n    hidden [string]$_home = \"`e[H\"\r\n\r\n    PmcScreenManager() {\r\n        $this.UpdateTerminalDimensions()\r\n    }\r\n\r\n    # Update terminal dimensions and recalculate regions\r\n    [void] UpdateTerminalDimensions() {\r\n        try {\r\n            $newWidth = [Math]::Max([Console]::WindowWidth, 80)\r\n            $newHeight = [Math]::Max([Console]::WindowHeight, 24)\r\n\r\n            if ($newWidth -ne $this._terminalWidth -or $newHeight -ne $this._terminalHeight) {\r\n                $this._terminalWidth = $newWidth\r\n                $this._terminalHeight = $newHeight\r\n                $this._regions = [PmcScreenRegions]::new($newWidth, $newHeight)\r\n                $this._needsClear = $true\r\n\r\n                if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n                    Write-PmcDebug -Level 2 -Category 'ScreenManager' -Message \"Terminal dimensions updated\" -Data @{\r\n                        Width = $newWidth\r\n                        Height = $newHeight\r\n                    }\r\n                }\r\n            }\r\n        } catch {\r\n            if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n                Write-PmcDebug -Level 1 -Category 'ScreenManager' -Message \"Failed to get terminal dimensions\" -Data @{ Error = $_.ToString() }\r\n            }\r\n            # Fallback to defaults\r\n            if ($this._terminalWidth -eq 0) {\r\n                $this._terminalWidth = 120\r\n                $this._terminalHeight = 30\r\n                $this._regions = [PmcScreenRegions]::new(120, 30)\r\n            }\r\n        }\r\n    }\r\n\r\n    # Get current screen regions\r\n    [PmcScreenRegions] GetRegions() {\r\n        $this.UpdateTerminalDimensions()\r\n        return $this._regions\r\n    }\r\n\r\n    # Clear entire screen and set up persistent layout\r\n    [void] ClearScreen() {\r\n        Write-Host $this._clearScreen -NoNewline\r\n        Write-Host $this._home -NoNewline\r\n        Write-Host $this._hideCursor -NoNewline\r\n        $this._needsClear = $false\r\n        $this._lastContent = \"\"\r\n\r\n        if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n            Write-PmcDebug -Level 3 -Category 'ScreenManager' -Message \"Screen cleared and cursor hidden\"\r\n        }\r\n    }\r\n\r\n    # Clear only the content region (preserves header/input/status)\r\n    [void] ClearContentRegion() {\r\n        if (-not $this._regions) { $this.UpdateTerminalDimensions() }\r\n\r\n        $content = $this._regions.Content\r\n        $clearLine = \" \" * $content.Width\r\n\r\n        for ($y = 0; $y -lt $content.Height; $y++) {\r\n            $this.MoveTo($content.X, $content.Y + $y)\r\n            Write-Host $clearLine -NoNewline\r\n        }\r\n\r\n        if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n            Write-PmcDebug -Level 3 -Category 'ScreenManager' -Message \"Content region cleared\" -Data @{\r\n                Bounds = $content.ToString()\r\n            }\r\n        }\r\n    }\r\n\r\n    # Position cursor at specific coordinates\r\n    [void] MoveTo([int]$x, [int]$y) {\r\n        Write-Host \"`e[$y;$($x)H\" -NoNewline\r\n    }\r\n\r\n    # Write text at specific position in a region\r\n    [void] WriteAtPosition([PmcScreenBounds]$region, [int]$offsetX, [int]$offsetY, [string]$text) {\r\n        $actualX = $region.X + $offsetX\r\n        $actualY = $region.Y + $offsetY\r\n\r\n        # Bounds checking\r\n        if ($actualX -ge ($region.X + $region.Width) -or $actualY -ge ($region.Y + $region.Height)) {\r\n            if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n                Write-PmcDebug -Level 2 -Category 'ScreenManager' -Message \"Text position out of bounds\" -Data @{\r\n                    RequestedX = $actualX\r\n                    RequestedY = $actualY\r\n                    RegionBounds = $region.ToString()\r\n                }\r\n            }\r\n            return\r\n        }\r\n\r\n        $this.MoveTo($actualX, $actualY)\r\n\r\n        # Truncate text if it would exceed region width\r\n        $maxWidth = $region.Width - $offsetX\r\n        if ($text.Length -gt $maxWidth) {\r\n            $text = $text.Substring(0, $maxWidth - 3) + \"...\"\r\n        }\r\n\r\n        Write-Host $text -NoNewline\r\n    }\r\n\r\n    # Render header with title and status\r\n    [void] RenderHeader([string]$title, [string]$status = \"\") {\r\n        if (-not $this._regions) { $this.UpdateTerminalDimensions() }\r\n\r\n        # Clear header region\r\n        $header = $this._regions.Header\r\n        $clearLine = \" \" * $header.Width\r\n        $this.MoveTo($header.X, $header.Y)\r\n        Write-Host $clearLine -NoNewline\r\n\r\n        # Write title\r\n        $this.WriteAtPosition($header, 0, 0, $title)\r\n\r\n        # Write status on right side\r\n        if ($status) {\r\n            $statusPos = $header.Width - $status.Length - 1\r\n            if ($statusPos -gt $title.Length + 2) {\r\n                $this.WriteAtPosition($header, $statusPos, 0, $status)\r\n            }\r\n        }\r\n\r\n        # Draw separator line\r\n        $this.MoveTo($header.X, $header.Y + 1)\r\n        Write-Host (\"─\" * $header.Width) -NoNewline\r\n\r\n        if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n            Write-PmcDebug -Level 3 -Category 'ScreenManager' -Message \"Header rendered\" -Data @{\r\n                Title = $title\r\n                Status = $status\r\n            }\r\n        }\r\n    }\r\n\r\n    # Render input prompt at bottom\r\n    [void] RenderInputPrompt([string]$prompt) {\r\n        if (-not $this._regions) { $this.UpdateTerminalDimensions() }\r\n\r\n        $input = $this._regions.Input\r\n\r\n        # Draw separator line above input\r\n        $this.MoveTo($input.X, $input.Y)\r\n        Write-Host (\"─\" * $input.Width) -NoNewline\r\n\r\n        # Clear input line\r\n        $this.MoveTo($input.X, $input.Y + 1)\r\n        $clearLine = \" \" * $input.Width\r\n        Write-Host $clearLine -NoNewline\r\n\r\n        # Write prompt\r\n        $this.WriteAtPosition($input, 0, 1, $prompt)\r\n\r\n        # Position cursor after prompt for input\r\n        $this.MoveTo($input.X + $prompt.Length, $input.Y + 1)\r\n        Write-Host $this._showCursor -NoNewline\r\n\r\n        if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n            Write-PmcDebug -Level 3 -Category 'ScreenManager' -Message \"Input prompt rendered\" -Data @{\r\n                Prompt = $prompt\r\n            }\r\n        }\r\n    }\r\n\r\n    # Show cursor for input\r\n    [void] ShowCursor() {\r\n        Write-Host $this._showCursor -NoNewline\r\n    }\r\n\r\n    # Hide cursor for display\r\n    [void] HideCursor() {\r\n        Write-Host $this._hideCursor -NoNewline\r\n    }\r\n\r\n    # Get content region for components to render into\r\n    [PmcScreenBounds] GetContentBounds() {\r\n        if (-not $this._regions) { $this.UpdateTerminalDimensions() }\r\n        return $this._regions.Content\r\n    }\r\n\r\n    # Set up initial screen layout\r\n    [void] Initialize([string]$title = \"PMC — Project Management Console\") {\r\n        $this.ClearScreen()\r\n        $this.RenderHeader($title, \"\")\r\n        $this.RenderInputPrompt(\"pmc> \")\r\n\r\n        if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n            Write-PmcDebug -Level 2 -Category 'ScreenManager' -Message \"Screen manager initialized\" -Data @{\r\n                Title = $title\r\n                Regions = $this._regions\r\n            }\r\n        }\r\n    }\r\n\r\n    # Cleanup on exit\r\n    [void] Cleanup() {\r\n        $this.ShowCursor()\r\n        $this.ClearScreen()\r\n        if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n            Write-PmcDebug -Level 2 -Category 'ScreenManager' -Message \"Screen manager cleanup completed\"\r\n        }\r\n    }\r\n}\r\n\r\n# Global screen manager instance\r\n$Script:PmcScreenManager = [PmcScreenManager]::new()\r\n\r\n# Public functions for screen management\r\nfunction Initialize-PmcScreen {\r\n    param(\r\n        [string]$Title = \"PMC — Project Management Console\"\r\n    )\r\n\r\n    $Script:PmcScreenManager.Initialize($Title)\r\n    if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n        Write-PmcDebug -Level 1 -Category 'ScreenManager' -Message \"PMC screen initialized\" -Data @{ Title = $Title }\r\n    }\r\n}\r\n\r\nfunction Clear-PmcContentArea {\r\n    $Script:PmcScreenManager.ClearContentRegion()\r\n    if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n        Write-PmcDebug -Level 2 -Category 'ScreenManager' -Message \"PMC content area cleared\"\r\n    }\r\n}\r\n\r\nfunction Get-PmcContentBounds {\r\n    return $Script:PmcScreenManager.GetContentBounds()\r\n}\r\n\r\nfunction Set-PmcHeader {\r\n    param(\r\n        [string]$Title,\r\n        [string]$Status = \"\"\r\n    )\r\n\r\n    $Script:PmcScreenManager.RenderHeader($Title, $Status)\r\n}\r\n\r\n# Update header with dynamic status chips (focus, debug, security)\r\nfunction Update-PmcHeaderStatus {\r\n    param(\r\n        [string]$Title = \"pmc — enhanced project management console\"\r\n    )\r\n\r\n    $statusParts = @()\r\n    try {\r\n        # Focus context\r\n        if (Get-Command Get-PmcCurrentContext -ErrorAction SilentlyContinue) {\r\n            $ctx = [string](Get-PmcCurrentContext)\r\n            if ($ctx -and $ctx.ToLower() -ne 'inbox') { $statusParts += (\"🎯 \" + $ctx) }\r\n        }\r\n    } catch {}\r\n\r\n    try {\r\n        # Debug level\r\n        if (Get-Command Get-PmcDebugStatus -ErrorAction SilentlyContinue) {\r\n            $dbg = Get-PmcDebugStatus\r\n            if ($dbg -and $dbg.Enabled) { $statusParts += (\"DBG:\" + ([string]$dbg.Level)) }\r\n        }\r\n    } catch {}\r\n\r\n    try {\r\n        # Security mode (simplified)\r\n        if (Get-Command Get-PmcSecurityStatus -ErrorAction SilentlyContinue) {\r\n            $sec = Get-PmcSecurityStatus\r\n            if ($sec) {\r\n                $secStr = $(if ($sec.PathWhitelistEnabled) { 'SEC:ON' } else { 'SEC:OFF' })\r\n                $statusParts += $secStr\r\n            }\r\n        }\r\n    } catch {}\r\n\r\n    $statusText = ($statusParts -join '  ')\r\n    Set-PmcHeader -Title $Title -Status $statusText\r\n}\r\n\r\nfunction Set-PmcInputPrompt {\r\n    param(\r\n        [string]$Prompt = \"pmc> \"\r\n    )\r\n\r\n    $Script:PmcScreenManager.RenderInputPrompt($Prompt)\r\n}\r\n\r\nfunction Hide-PmcCursor {\r\n    $Script:PmcScreenManager.HideCursor()\r\n}\r\n\r\nfunction Show-PmcCursor {\r\n    $Script:PmcScreenManager.ShowCursor()\r\n}\r\n\r\nfunction Reset-PmcScreen {\r\n    $Script:PmcScreenManager.Cleanup()\r\n}\r\n\r\nfunction Write-PmcAtPosition {\r\n    param(\r\n        [int]$X,\r\n        [int]$Y,\r\n        [string]$Text\r\n    )\r\n\r\n    $contentBounds = Get-PmcContentBounds\r\n    $Script:PmcScreenManager.WriteAtPosition($contentBounds, $X, $Y, $Text)\r\n}\r\n\r\nfunction Clear-CommandOutput {\r\n    Clear-PmcContentArea\r\n    if (Get-Command Write-PmcDebug -ErrorAction SilentlyContinue) {\r\n        Write-PmcDebug -Level 2 -Category 'ScreenManager' -Message \"Command output area cleared\"\r\n    }\r\n}\r\n\r\n# Export screen management functions\r\nExport-ModuleMember -Function Initialize-PmcScreen, Clear-PmcContentArea, Get-PmcContentBounds, Set-PmcHeader, Update-PmcHeaderStatus, Set-PmcInputPrompt, Hide-PmcCursor, Show-PmcCursor, Reset-PmcScreen, Write-PmcAtPosition, Clear-CommandOutput"}, {"path": "module/Pmc.Strict/src/Security.ps1", "content": "# Security and Safety Hardening for PMC\r\n# Input validation, path protection, resource limits, and execution safety\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Security system state - now managed by centralized state\r\n# State initialization moved to State.ps1\r\n\r\nfunction Initialize-PmcSecuritySystem {\r\n    <#\r\n    .SYNOPSIS\r\n    Initializes security system based on configuration\r\n    ##CLOSEBRACKET##\r\n\r\n    # Defer config loading to avoid circular dependency during initialization\r\n    # Configuration will be applied later via Update-PmcSecurityFromConfig\r\n\r\n    # Default allowed paths if none configured\r\n    $securityState = Get-PmcSecurityState\r\n\r\n    # Disable path whitelist for now to allow TUI to save tasks\r\n    Set-PmcState -Section 'Security' -Key 'PathWhitelistEnabled' -Value $false\r\n\r\n    if ($securityState.AllowedWritePaths.Count -eq 0) {\r\n        # $PSScriptRoot is /home/teej/pmc/module/Pmc.Strict/src\r\n        # We need to go up to /home/teej/pmc\r\n        $moduleRoot = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent\r\n        $pmcRoot = Split-Path $moduleRoot -Parent\r\n\r\n        $defaultPaths = @(\r\n            $pmcRoot                              # /home/teej/pmc\r\n            Join-Path $pmcRoot 'reports'\r\n            Join-Path $pmcRoot 'backups'\r\n            Join-Path $pmcRoot 'exports'\r\n            [System.IO.Path]::GetTempPath()\r\n        )\r\n        Set-PmcState -Section 'Security' -Key 'AllowedWritePaths' -Value $defaultPaths\r\n    }\r\n}\r\n\r\nfunction Test-PmcInputSafety {\r\n    <#\r\n    .SYNOPSIS\r\n    Validates input for potential security issues\r\n\r\n    .PARAMETER Input\r\n    User input to validate\r\n\r\n    .PARAMETER InputType\r\n    Type of input (command, text, path, etc.)\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [AllowEmptyString()]\r\n        [string]$Input,\r\n\r\n        [string]$InputType = 'general'\r\n    )\r\n\r\n    $securityState = Get-PmcSecurityState\r\n    if (-not $securityState.InputValidationEnabled) { return $true }\r\n\r\n    $threats = @()\r\n\r\n    try {\r\n        # Check for command injection patterns\r\n        $injectionPatterns = @(\r\n            ';.*(?:rm|del|format|shutdown|reboot)',\r\n            '\\|.*(?:nc|netcat|wget|curl|powershell|cmd)',\r\n            '&.*(?:ping|nslookup|whoami|net\\s)',\r\n            '`.*(?:Get-.*|Invoke-.*|Start-.*)',\r\n            '\\$\\(.*(?:Get-.*|Invoke-.*|Remove-.*)\\)',\r\n            '(?:>|>>).*(?:/etc/|C:\\\\Windows\\\\)',\r\n            '(?:\\.\\.[\\\\/]){3,}',  # Path traversal\r\n            '(?i)(?:javascript:|data:|vbscript:)',  # Script injection\r\n            '(?i)(?:<script|<iframe|<object|<embed)',  # HTML injection\r\n            'eval\\s*\\(',  # Code evaluation\r\n            '(?:exec|system|shell_exec|passthru)\\s*\\('  # System execution\r\n        )\r\n\r\n        foreach ($pattern in $injectionPatterns) {\r\n            if ($Input -match $pattern) {\r\n                $threats += \"Potential injection: $pattern\"\r\n            }\r\n        }\r\n\r\n        # Check for sensitive data exposure\r\n        if ($securityState.SensitiveDataScanEnabled) {\r\n            $sensitivePatterns = @(\r\n                '\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b',  # Credit card\r\n                '\\b\\d{3}-\\d{2}-\\d{4}\\b',  # SSN\r\n                '\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b',  # Email\r\n                '\\b[0-9a-fA-F]{32,}\\b',  # Long hex (potential secrets)\r\n                '(?i)(password|passwd|secret|token|key)\\s*[:=]\\s*\\S+',  # Credentials\r\n                'BEGIN\\s+(RSA\\s+)?PRIVATE\\s+KEY',  # Private keys\r\n                'sk_live_[0-9a-zA-Z]{24}',  # Stripe keys\r\n                'AIza[0-9A-Za-z\\\\-_]{35}',  # Google API keys\r\n                'ya29\\\\.[0-9A-Za-z\\\\-_]+',  # Google OAuth\r\n                'AKIA[0-9A-Z]{16}'  # AWS access keys\r\n            )\r\n\r\n            foreach ($pattern in $sensitivePatterns) {\r\n                if ($Input -match $pattern) {\r\n                    $threats += \"Potential sensitive data: $pattern\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Input length validation\r\n        if ($Input.Length -gt 10000) {\r\n            $threats += \"Input too long (${$Input.Length} chars, max 10000)\"\r\n        }\r\n\r\n        # Null byte injection\r\n        if ($Input.Contains(\"`0\")) {\r\n            $threats += \"Null byte injection detected\"\r\n        }\r\n\r\n        # Unicode normalization attacks\r\n        if ($Input -match '[\\u202A-\\u202E\\u2066-\\u2069]') {\r\n            $threats += \"Unicode direction override detected\"\r\n        }\r\n\r\n        if ($threats.Count -gt 0) {\r\n            Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Input validation failed\" -Data @{ Input = $Input.Substring(0, [Math]::Min($Input.Length, 100)); Threats = $threats; Type = $InputType }\r\n            return $false\r\n        }\r\n\r\n        Write-PmcDebug -Level 3 -Category 'SECURITY' -Message \"Input validation passed\" -Data @{ Length = $Input.Length; Type = $InputType }\r\n        return $true\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Input validation error: $_\"\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-PmcPathSafety {\r\n    <#\r\n    .SYNOPSIS\r\n    Validates that a file path is safe to write to\r\n\r\n    .PARAMETER Path\r\n    File path to validate\r\n\r\n    .PARAMETER Operation\r\n    Operation being performed (read, write, delete)\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Path,\r\n\r\n        [string]$Operation = 'write'\r\n    )\r\n\r\n    $securityState = Get-PmcSecurityState\r\n    # TEMPORARY: Disable whitelist to allow TUI saves\r\n    return $true\r\n    if (-not $securityState.PathWhitelistEnabled) { return $true }\r\n\r\n    try {\r\n        # Resolve path to absolute form\r\n        $resolvedPath = $null\r\n        try {\r\n            if ([System.IO.Path]::IsPathRooted($Path)) {\r\n                $resolvedPath = [System.IO.Path]::GetFullPath($Path)\r\n            } else {\r\n                $root = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent\r\n                $resolvedPath = [System.IO.Path]::GetFullPath((Join-Path $root $Path))\r\n            }\r\n        } catch {\r\n            Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Path resolution failed: $_\" -Data @{ Path = $Path }\r\n            return $false\r\n        }\r\n\r\n        # Check against whitelist for write operations\r\n        if ($Operation -eq 'write' -or $Operation -eq 'delete') {\r\n            $allowed = $false\r\n            Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Checking path against whitelist\" -Data @{ Path = $resolvedPath; AllowedPaths = ($securityState.AllowedWritePaths -join '; ') }\r\n            foreach ($allowedPath in $securityState.AllowedWritePaths) {\r\n                try {\r\n                    $allowedResolved = [System.IO.Path]::GetFullPath($allowedPath)\r\n                    Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Comparing paths\" -Data @{ Resolved = $resolvedPath; Allowed = $allowedResolved; Match = $resolvedPath.StartsWith($allowedResolved, [System.StringComparison]::OrdinalIgnoreCase) }\r\n                    if ($resolvedPath.StartsWith($allowedResolved, [System.StringComparison]::OrdinalIgnoreCase)) {\r\n                        $allowed = $true\r\n                        break\r\n                    }\r\n                } catch {\r\n                    # Path resolution failed - skip this allowed path\r\n                }\r\n            }\r\n\r\n            if (-not $allowed) {\r\n                Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Path not in whitelist\" -Data @{ Path = $resolvedPath; Operation = $Operation; AllowedPaths = $securityState.AllowedWritePaths }\r\n                return $false\r\n            }\r\n        }\r\n\r\n        # Check for dangerous paths\r\n        $dangerousPaths = @(\r\n            'C:\\Windows\\System32',\r\n            'C:\\Windows\\SysWOW64',\r\n            '/etc/',\r\n            '/bin/',\r\n            '/sbin/',\r\n            '/usr/bin/',\r\n            '/usr/sbin/',\r\n            '/boot/',\r\n            '/sys/',\r\n            '/proc/'\r\n        )\r\n\r\n        foreach ($dangerousPath in $dangerousPaths) {\r\n            if ($resolvedPath.StartsWith($dangerousPath, [System.StringComparison]::OrdinalIgnoreCase)) {\r\n                Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Dangerous path detected\" -Data @{ Path = $resolvedPath; DangerousPath = $dangerousPath }\r\n                return $false\r\n            }\r\n        }\r\n\r\n        # Log audit trail for file operations\r\n        if ($securityState.AuditLoggingEnabled) {\r\n            Write-PmcDebug -Level 2 -Category 'AUDIT' -Message \"File operation approved\" -Data @{ Path = $resolvedPath; Operation = $Operation; User = $env:USERNAME }\r\n        }\r\n\r\n        return $true\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Path safety check error: $_\"\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Invoke-PmcSecureFileOperation {\r\n    <#\r\n    .SYNOPSIS\r\n    Performs file operations with security checks and resource limits\r\n\r\n    .PARAMETER Path\r\n    File path for the operation\r\n\r\n    .PARAMETER Operation\r\n    Type of operation (read, write, delete)\r\n\r\n    .PARAMETER Content\r\n    Content to write (for write operations)\r\n\r\n    .PARAMETER ScriptBlock\r\n    Custom operation to perform within security context\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Path,\r\n\r\n        [Parameter(Mandatory)]\r\n        [ValidateSet('read', 'write', 'delete', 'custom')]\r\n        [string]$Operation,\r\n\r\n        [string]$Content = '',\r\n\r\n        [scriptblock]$ScriptBlock = $null\r\n    )\r\n\r\n    # Validate path safety\r\n    if (-not (Test-PmcPathSafety -Path $Path -Operation $Operation)) {\r\n        throw \"Path safety validation failed: $Path\"\r\n    }\r\n\r\n    # Check resource limits\r\n    $securityState = Get-PmcSecurityState\r\n    if ($securityState.ResourceLimitsEnabled) {\r\n        if ($Operation -eq 'write' -and $Content.Length -gt 0) {\r\n            $sizeBytes = [System.Text.Encoding]::UTF8.GetByteCount($Content)\r\n            if ($sizeBytes -gt $securityState.MaxFileSize) {\r\n                throw \"Content size ($sizeBytes bytes) exceeds maximum allowed ($($securityState.MaxFileSize) bytes)\"\r\n            }\r\n        }\r\n\r\n        # Check existing file size for read operations\r\n        if ($Operation -eq 'read' -and (Test-Path $Path)) {\r\n            $fileSize = (Get-Item $Path).Length\r\n            if ($fileSize -gt $securityState.MaxFileSize) {\r\n                throw \"File size ($fileSize bytes) exceeds maximum allowed ($($securityState.MaxFileSize) bytes)\"\r\n            }\r\n        }\r\n    }\r\n\r\n    # Audit log the operation\r\n    if ($securityState.AuditLoggingEnabled) {\r\n        Write-PmcDebug -Level 1 -Category 'AUDIT' -Message \"Secure file operation\" -Data @{\r\n            Path = $Path\r\n            Operation = $Operation\r\n            ContentSize = $Content.Length\r\n            User = $env:USERNAME\r\n            Timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n        }\r\n    }\r\n\r\n    try {\r\n        # Perform the operation within timeout\r\n        $result = Measure-PmcOperation -Name \"SecureFileOp:$Operation\" -Category 'SECURITY' -ScriptBlock {\r\n            switch ($Operation) {\r\n                'read' {\r\n                    return Get-Content -Path $Path -Raw -Encoding UTF8\r\n                }\r\n                'write' {\r\n                    return Set-Content -Path $Path -Value $Content -Encoding UTF8\r\n                }\r\n                'delete' {\r\n                    return Remove-Item -Path $Path -Force\r\n                }\r\n                'custom' {\r\n                    if ($ScriptBlock) {\r\n                        return & $ScriptBlock\r\n                    } else {\r\n                        throw \"Custom operation requires ScriptBlock parameter\"\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return $result\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Secure file operation failed: $_\" -Data @{ Path = $Path; Operation = $Operation }\r\n        throw\r\n    }\r\n}\r\n\r\nfunction Protect-PmcUserInput {\r\n    <#\r\n    .SYNOPSIS\r\n    Sanitizes user input for safe processing\r\n\r\n    .PARAMETER Input\r\n    User input to sanitize\r\n\r\n    .PARAMETER AllowHtml\r\n    Whether to allow HTML tags (default: false)\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [AllowEmptyString()]\r\n        [string]$Input,\r\n\r\n        [bool]$AllowHtml = $false\r\n    )\r\n\r\n    try {\r\n        $sanitized = $Input\r\n\r\n        # Remove null bytes\r\n        $sanitized = $sanitized -replace \"`0\", ''\r\n\r\n        # Remove Unicode direction overrides\r\n        $sanitized = $sanitized -replace '[\\u202A-\\u202E\\u2066-\\u2069]', ''\r\n\r\n        # Remove or escape HTML if not allowed\r\n        if (-not $AllowHtml) {\r\n            $sanitized = $sanitized -replace '<', '&lt;'\r\n            $sanitized = $sanitized -replace '>', '&gt;'\r\n            $sanitized = $sanitized -replace '\"', '&quot;'\r\n            $sanitized = $sanitized -replace \"'\", '&#39;'\r\n        }\r\n\r\n        # Limit length\r\n        if ($sanitized.Length -gt 10000) {\r\n            $sanitized = $sanitized.Substring(0, 10000)\r\n            Write-PmcDebug -Level 2 -Category 'SECURITY' -Message \"Input truncated to 10000 characters\"\r\n        }\r\n\r\n        Write-PmcDebug -Level 3 -Category 'SECURITY' -Message \"Input sanitized\" -Data @{\r\n            OriginalLength = $Input.Length\r\n            SanitizedLength = $sanitized.Length\r\n            Modified = ($Input -ne $sanitized)\r\n        }\r\n\r\n        return $sanitized\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Input sanitization failed: $_\"\r\n        return \"\"\r\n    }\r\n}\r\n\r\nfunction Test-PmcResourceLimits {\r\n    <#\r\n    .SYNOPSIS\r\n    Checks current resource usage against configured limits\r\n\r\n    .DESCRIPTION\r\n    Monitors memory usage, execution time, and other resource constraints\r\n    ##CLOSEBRACKET##\r\n\r\n    $securityState = Get-PmcSecurityState\r\n    if (-not $securityState.ResourceLimitsEnabled) { return $true }\r\n\r\n    try {\r\n        # Check memory usage\r\n        $process = Get-Process -Id $PID\r\n        $memoryUsage = $process.WorkingSet64\r\n\r\n        if ($memoryUsage -gt $securityState.MaxMemoryUsage) {\r\n            Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Memory limit exceeded\" -Data @{\r\n                CurrentUsage = $memoryUsage\r\n                Limit = $securityState.MaxMemoryUsage\r\n                UsagePercent = [Math]::Round(($memoryUsage / $securityState.MaxMemoryUsage) * 100, 2)\r\n            }\r\n            return $false\r\n        }\r\n\r\n        Write-PmcDebug -Level 3 -Category 'SECURITY' -Message \"Resource limits check passed\" -Data @{\r\n            MemoryUsage = $memoryUsage\r\n            MemoryLimit = $securityState.MaxMemoryUsage\r\n        }\r\n\r\n        return $true\r\n\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Resource limit check failed: $_\"\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Get-PmcSecurityStatus {\r\n    <#\r\n    .SYNOPSIS\r\n    Returns current security system status and configuration\r\n    ##CLOSEBRACKET##\r\n\r\n    $securityState = Get-PmcSecurityState\r\n    return [PSCustomObject]@{\r\n        InputValidationEnabled = $securityState.InputValidationEnabled\r\n        PathWhitelistEnabled = $securityState.PathWhitelistEnabled\r\n        ResourceLimitsEnabled = $securityState.ResourceLimitsEnabled\r\n        SensitiveDataScanEnabled = $securityState.SensitiveDataScanEnabled\r\n        AuditLoggingEnabled = $securityState.AuditLoggingEnabled\r\n        AllowedWritePaths = $securityState.AllowedWritePaths\r\n        MaxFileSize = $securityState.MaxFileSize\r\n        MaxMemoryUsage = $securityState.MaxMemoryUsage\r\n        MaxExecutionTime = $securityState.MaxExecutionTime\r\n        CurrentMemoryUsage = (Get-Process -Id $PID).WorkingSet64\r\n    }\r\n}\r\n\r\nfunction Set-PmcSecurityLevel {\r\n    <#\r\n    .SYNOPSIS\r\n    Configures security level with predefined profiles\r\n\r\n    .PARAMETER Level\r\n    Security level: 'permissive', 'balanced', 'strict'\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [ValidateSet('permissive', 'balanced', 'strict')]\r\n        [string]$Level\r\n    )\r\n\r\n    switch ($Level) {\r\n        'permissive' {\r\n            Update-PmcStateSection -Section 'Security' -Values @{\r\n                InputValidationEnabled = $false\r\n                PathWhitelistEnabled = $false\r\n                ResourceLimitsEnabled = $false\r\n                SensitiveDataScanEnabled = $false\r\n            }\r\n        }\r\n        'balanced' {\r\n            Update-PmcStateSection -Section 'Security' -Values @{\r\n                InputValidationEnabled = $true\r\n                PathWhitelistEnabled = $true\r\n                ResourceLimitsEnabled = $true\r\n                SensitiveDataScanEnabled = $true\r\n                MaxFileSize = 100MB\r\n                MaxMemoryUsage = 500MB\r\n            }\r\n        }\r\n        'strict' {\r\n            Update-PmcStateSection -Section 'Security' -Values @{\r\n                InputValidationEnabled = $true\r\n                PathWhitelistEnabled = $true\r\n                ResourceLimitsEnabled = $true\r\n                SensitiveDataScanEnabled = $true\r\n                AuditLoggingEnabled = $true\r\n                MaxFileSize = 50MB\r\n                MaxMemoryUsage = 256MB\r\n            }\r\n        }\r\n    }\r\n\r\n    Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Security level changed to: $Level\" -Data (Get-PmcSecurityState)\r\n}\r\n\r\nfunction Update-PmcSecurityFromConfig {\r\n    <#\r\n    .SYNOPSIS\r\n    Updates security settings from configuration after config provider is ready\r\n    ##CLOSEBRACKET##\r\n    try {\r\n        $cfg = Get-PmcConfig\r\n        if ($cfg.Security) {\r\n            if ($cfg.Security.AllowedWritePaths) {\r\n                Set-PmcState -Section 'Security' -Key 'AllowedWritePaths' -Value @($cfg.Security.AllowedWritePaths)\r\n            }\r\n            if ($cfg.Security.MaxFileSize) {\r\n                try {\r\n                    $sizeStr = [string]$cfg.Security.MaxFileSize\r\n                    if ($sizeStr -match '^(\\d+)(MB|GB)?$') {\r\n                        $num = [int64]$matches[1]\r\n                        $unit = $matches[2]\r\n                        $bytes = switch ($unit) {\r\n                            'GB' { $num * 1GB }\r\n                            'MB' { $num * 1MB }\r\n                            default { $num }\r\n                        }\r\n                        Set-PmcState -Section 'Security' -Key 'MaxFileSize' -Value $bytes\r\n                    }\r\n                } catch {\r\n                    # Size configuration parsing failed - keep default value\r\n                }\r\n            }\r\n            if ($cfg.Security.MaxMemoryUsage) {\r\n                try {\r\n                    $sizeStr = [string]$cfg.Security.MaxMemoryUsage\r\n                    if ($sizeStr -match '^(\\d+)(MB|GB)?$') {\r\n                        $num = [int64]$matches[1]\r\n                        $unit = $matches[2]\r\n                        $bytes = switch ($unit) {\r\n                            'GB' { $num * 1GB }\r\n                            'MB' { $num * 1MB }\r\n                            default { $num }\r\n                        }\r\n                        Set-PmcState -Section 'Security' -Key 'MaxMemoryUsage' -Value $bytes\r\n                    }\r\n                } catch {\r\n                    # Size configuration parsing failed - keep default value\r\n                }\r\n            }\r\n            if ($cfg.Security.RequirePathWhitelist -ne $null) {\r\n                Set-PmcState -Section 'Security' -Key 'PathWhitelistEnabled' -Value ([bool]$cfg.Security.RequirePathWhitelist)\r\n            }\r\n            if ($cfg.Security.ScanForSensitiveData -ne $null) {\r\n                Set-PmcState -Section 'Security' -Key 'SensitiveDataScanEnabled' -Value ([bool]$cfg.Security.ScanForSensitiveData)\r\n            }\r\n            if ($cfg.Security.AuditAllFileOps -ne $null) {\r\n                Set-PmcState -Section 'Security' -Key 'AuditLoggingEnabled' -Value ([bool]$cfg.Security.AuditAllFileOps)\r\n            }\r\n            if ($cfg.Security.AllowTemplateExecution -ne $null) {\r\n                Set-PmcState -Section 'Security' -Key 'TemplateExecutionEnabled' -Value ([bool]$cfg.Security.AllowTemplateExecution)\r\n            }\r\n        }\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Failed to load security config: $_\"\r\n    }\r\n}\r\n\r\n# Note: Security system is initialized by the root orchestrator after config providers are set\r\n\r\n#Export-ModuleMember -Function Initialize-PmcSecuritySystem, Test-PmcInputSafety, Test-PmcPathSafety, Invoke-PmcSecureFileOperation, Protect-PmcUserInput, Test-PmcResourceLimits, Get-PmcSecurityStatus, Set-PmcSecurityLevel, Update-PmcSecurityFromConfig"}, {"path": "module/Pmc.Strict/src/Shortcuts.ps1", "content": "# Workflow shortcuts\r\n\r\nfunction Invoke-PmcShortcut {\r\n    param([PmcCommandContext]$Context)\r\n    # Use: \"# 3\" to view item at index 3 from last task list\r\n    if ($Context.FreeText.Count -lt 1) { Write-PmcStyled -Style 'Warning' -Text \"Usage: # <index>\"; return }\r\n    $tok = $Context.FreeText[0]\r\n    if (-not ($tok -match '^\\d+$')) { Write-PmcStyled -Style 'Error' -Text \"Invalid index\"; return }\r\n    $n = [int]$tok\r\n    $indexMap = Get-PmcLastTaskListMap\r\n    if (-not $indexMap -or -not $indexMap.ContainsKey($n)) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"No recent list or index out of range\"\r\n        return\r\n    }\r\n    # Delegate to task view\r\n    $ctx = [PmcCommandContext]::new('task','view')\r\n    $ctx.FreeText = @([string]$n)\r\n    Show-PmcTask -Context $ctx\r\n}\r\n\r\n#Export-ModuleMember -Function Invoke-PmcShortcut"}, {"path": "module/Pmc.Strict/src/State.ps1", "content": "# Centralized State Management for PMC\r\n# Consolidates all scattered script variables into a thread-safe, organized system\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# =============================================================================\r\n# CENTRAL STATE CONTAINER\r\n# =============================================================================\r\n\r\n# Single master state object containing all global state\r\n$Script:PmcGlobalState = @{\r\n    # System & Core Configuration\r\n    Config = @{\r\n        ProviderGet = { @{} }\r\n        ProviderSet = $null\r\n    }\r\n\r\n    # Security System State\r\n    Security = @{\r\n        InputValidationEnabled = $true\r\n        PathWhitelistEnabled = $true\r\n        ResourceLimitsEnabled = $true\r\n        SensitiveDataScanEnabled = $true\r\n        AuditLoggingEnabled = $true\r\n        TemplateExecutionEnabled = $false\r\n        AllowedWritePaths = @()\r\n        MaxFileSize = 100MB\r\n        MaxMemoryUsage = 500MB\r\n        MaxExecutionTime = 300000  # 5 minutes in milliseconds\r\n    }\r\n\r\n    # Debug System State\r\n    Debug = @{\r\n        Level = 0                    # 0=off, 1-3=debug levels\r\n        LogPath = 'debug.log'        # Relative to PMC root\r\n        MaxSize = 10MB              # File size before rotation\r\n        RedactSensitive = $true     # Redact sensitive data\r\n        IncludePerformance = $false # Include timing information\r\n        SessionId = (New-Guid).ToString().Substring(0,8)\r\n        StartTime = Get-Date\r\n    }\r\n\r\n    # Display / Theme / UI State\r\n    Display = @{\r\n        Theme = @{ PaletteName='default'; Hex='#33aaff'; TrueColor=$true; HighContrast=$false; ColorBlindMode='none' }\r\n        Icons = @{ Mode='emoji' }\r\n        Capabilities = @{ AnsiSupport=$true; TrueColorSupport=$true; IsTTY=$true; NoColor=$false; Platform='unknown' }\r\n        Styles = @{}\r\n    }\r\n\r\n    # Help and UI System State\r\n    HelpUI = @{\r\n        # Interactive help browser state\r\n        HelpState = @{\r\n            CurrentCategory = 'All'\r\n            SelectedCommand = 0\r\n            SearchFilter = ''\r\n            ShowExamples = $false\r\n            ViewMode = 'Categories'  # Categories, Commands, Examples, Search\r\n        }\r\n        # Command categories for organized browsing (this will be populated from CommandMap)\r\n        CommandCategories = @{}\r\n    }\r\n\r\n    # Interactive Editor State\r\n    Interactive = @{\r\n        Editor = $null              # Will be initialized with PmcEditorState instance\r\n        CompletionCache = @{}       # Completion caching for performance\r\n        CompletionInfoMap = @{}     # Completion info mapping for interactive system\r\n        GhostTextEnabled = $true    # Enable/disable ghost text feature\r\n    }\r\n\r\n    # Focus / Context State\r\n    Focus = @{\r\n        Current = 'inbox'\r\n    }\r\n\r\n    # Undo/Redo System State\r\n    UndoRedo = @{\r\n        UndoStack = @()\r\n        RedoStack = @()\r\n        MaxUndoSteps = 5\r\n        DataCache = $null           # Cached data for performance\r\n    }\r\n\r\n    # Task and Time Mapping State (consolidated from multiple files)\r\n    ViewMappings = @{\r\n        LastTaskListMap = @{}       # Maps display numbers to task IDs\r\n        LastTimeListMap = @{}       # Maps display numbers to time entry IDs\r\n    }\r\n\r\n    # Command System State (schemas, maps, metadata)\r\n    Commands = @{\r\n        ParameterMap = @{}          # Parameter schemas from Schemas.ps1\r\n        CommandMap = @{}            # Command mappings from CommandMap.ps1\r\n        ShortcutMap = @{}           # Shortcut mappings from CommandMap.ps1\r\n        CommandMeta = @{}           # Command metadata from CommandMap.ps1\r\n    }\r\n\r\n    # State synchronization lock\r\n    _Lock = $false\r\n}\r\n\r\n# Convenience: repo root path\r\nfunction Get-PmcRootPath {\r\n    try {\r\n        return (Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent)\r\n    } catch { return (Get-Location).Path }\r\n}\r\n\r\n# =============================================================================\r\n# THREAD-SAFE STATE ACCESS FUNCTIONS\r\n# =============================================================================\r\n\r\nfunction Get-PmcState {\r\n    <#\r\n    .SYNOPSIS\r\n    Gets a specific state section or the entire state object\r\n\r\n    .PARAMETER Section\r\n    The state section to retrieve (Config, Security, Debug, etc.)\r\n\r\n    .PARAMETER Key\r\n    Optional specific key within the section\r\n\r\n    .EXAMPLE\r\n    Get-PmcState -Section 'Security'\r\n    Get-PmcState -Section 'Debug' -Key 'Level'\r\n    ##CLOSEBRACKET##\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Section,\r\n        [string]$Key\r\n    )\r\n\r\n    # Acquire lock to ensure a consistent read snapshot\r\n    while ($Script:PmcGlobalState._Lock) { Start-Sleep -Milliseconds 1 }\r\n    $Script:PmcGlobalState._Lock = $true\r\n\r\n    try {\r\n        if (-not $Section) {\r\n            # Return a shallow clone of the entire state without exposing the lock directly\r\n            $snapshot = @{}\r\n            foreach ($k in $Script:PmcGlobalState.Keys) {\r\n                if ($k -eq '_Lock') { continue }\r\n                $val = $Script:PmcGlobalState[$k]\r\n                if ($val -is [hashtable]) { $snapshot[$k] = $val.Clone() } else { $snapshot[$k] = $val }\r\n            }\r\n            return $snapshot\r\n        }\r\n\r\n        if (-not $Script:PmcGlobalState.ContainsKey($Section)) {\r\n            Write-Warning \"State section '$Section' does not exist\"\r\n            return $null\r\n        }\r\n\r\n        $sectionState = $Script:PmcGlobalState[$Section]\r\n\r\n        if ($Key) {\r\n            if ($sectionState -is [hashtable] -and $sectionState.ContainsKey($Key)) {\r\n                return $sectionState[$Key]\r\n            } else {\r\n                Write-Warning \"State key '$Key' does not exist in section '$Section'\"\r\n                return $null\r\n            }\r\n        }\r\n\r\n        # Return a copy to avoid external mutation of shared state\r\n        if ($sectionState -is [hashtable]) { return $sectionState.Clone() }\r\n        return $sectionState\r\n    }\r\n    finally {\r\n        $Script:PmcGlobalState._Lock = $false\r\n    }\r\n}\r\n\r\nfunction Set-PmcState {\r\n    <#\r\n    .SYNOPSIS\r\n    Sets a value in the centralized state system\r\n\r\n    .PARAMETER Section\r\n    The state section to modify\r\n\r\n    .PARAMETER Key\r\n    The key within the section to set\r\n\r\n    .PARAMETER Value\r\n    The value to set\r\n\r\n    .PARAMETER Merge\r\n    If true, merge hashtable values instead of replacing\r\n\r\n    .EXAMPLE\r\n    Set-PmcState -Section 'Debug' -Key 'Level' -Value 2\r\n    Set-PmcState -Section 'Security' -Key 'MaxFileSize' -Value 200MB\r\n    ##CLOSEBRACKET##\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [string]$Section,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        [string]$Key,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        $Value,\r\n\r\n        [switch]$Merge\r\n    )\r\n\r\n    # Acquire lock for thread safety\r\n    while ($Script:PmcGlobalState._Lock) {\r\n        Start-Sleep -Milliseconds 1\r\n    }\r\n    $Script:PmcGlobalState._Lock = $true\r\n\r\n    try {\r\n        if (-not $Script:PmcGlobalState.ContainsKey($Section)) {\r\n            Write-Warning \"State section '$Section' does not exist\"\r\n            return\r\n        }\r\n\r\n        $sectionState = $Script:PmcGlobalState[$Section]\r\n\r\n        if ($Merge -and $sectionState[$Key] -is [hashtable] -and $Value -is [hashtable]) {\r\n            # Merge hashtables\r\n            foreach ($k in $Value.Keys) {\r\n                $sectionState[$Key][$k] = $Value[$k]\r\n            }\r\n        } else {\r\n            # Direct assignment\r\n            $sectionState[$Key] = $Value\r\n        }\r\n\r\n        # Debug logging removed to avoid circular dependency during initialization\r\n    }\r\n    finally {\r\n        $Script:PmcGlobalState._Lock = $false\r\n    }\r\n}\r\n\r\n# Convenience helpers for common view mapping state\r\nfunction Get-PmcLastTaskListMap {\r\n    $map = Get-PmcState -Section 'ViewMappings' -Key 'LastTaskListMap'\r\n    if (-not $map) { $map = @{}; Set-PmcState -Section 'ViewMappings' -Key 'LastTaskListMap' -Value $map }\r\n    return $map\r\n}\r\n\r\nfunction Set-PmcLastTaskListMap {\r\n    param([hashtable]$Map)\r\n    if (-not $Map) { $Map = @{} }\r\n    Set-PmcState -Section 'ViewMappings' -Key 'LastTaskListMap' -Value $Map\r\n}\r\n\r\nfunction Get-PmcLastTimeListMap {\r\n    $map = Get-PmcState -Section 'ViewMappings' -Key 'LastTimeListMap'\r\n    if (-not $map) { $map = @{}; Set-PmcState -Section 'ViewMappings' -Key 'LastTimeListMap' -Value $map }\r\n    return $map\r\n}\r\n\r\nfunction Set-PmcLastTimeListMap {\r\n    param([hashtable]$Map)\r\n    if (-not $Map) { $Map = @{} }\r\n    Set-PmcState -Section 'ViewMappings' -Key 'LastTimeListMap' -Value $Map\r\n}\r\n\r\nfunction Update-PmcStateSection {\r\n    <#\r\n    .SYNOPSIS\r\n    Updates an entire state section\r\n\r\n    .PARAMETER Section\r\n    The state section to update\r\n\r\n    .PARAMETER Values\r\n    Hashtable of values to update in the section\r\n\r\n    .PARAMETER Replace\r\n    If true, replace entire section; if false, merge values\r\n\r\n    .EXAMPLE\r\n    Update-PmcStateSection -Section 'Security' -Values @{ MaxFileSize = 200MB; PathWhitelistEnabled = $false }\r\n    ##CLOSEBRACKET##\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$true)]\r\n        [string]$Section,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        [hashtable]$Values,\r\n\r\n        [switch]$Replace\r\n    )\r\n\r\n    # Acquire lock for thread safety\r\n    while ($Script:PmcGlobalState._Lock) {\r\n        Start-Sleep -Milliseconds 1\r\n    }\r\n    $Script:PmcGlobalState._Lock = $true\r\n\r\n    try {\r\n        if (-not $Script:PmcGlobalState.ContainsKey($Section)) {\r\n            Write-Warning \"State section '$Section' does not exist\"\r\n            return\r\n        }\r\n\r\n        if ($Replace) {\r\n            $Script:PmcGlobalState[$Section] = $Values\r\n        } else {\r\n            foreach ($key in $Values.Keys) {\r\n                $Script:PmcGlobalState[$Section][$key] = $Values[$key]\r\n            }\r\n        }\r\n\r\n        # Debug logging removed to avoid circular dependency during initialization\r\n    }\r\n    finally {\r\n        $Script:PmcGlobalState._Lock = $false\r\n    }\r\n}\r\n\r\n# =============================================================================\r\n# BACKWARD COMPATIBILITY LAYER\r\n# =============================================================================\r\n\r\n# These functions provide backward compatibility for existing code\r\n# They map old script variable access to the new centralized state\r\n\r\nfunction Get-PmcConfigProviders {\r\n    $config = Get-PmcState -Section 'Config'\r\n    return @{\r\n        Get = $config.ProviderGet\r\n        Set = $config.ProviderSet\r\n    }\r\n}\r\n\r\nfunction Set-PmcConfigProviders {\r\n    param($Get, $Set)\r\n    Set-PmcState -Section 'Config' -Key 'ProviderGet' -Value $Get\r\n    if ($Set) {\r\n        Set-PmcState -Section 'Config' -Key 'ProviderSet' -Value $Set\r\n    }\r\n}\r\n\r\nfunction Get-PmcSecurityState {\r\n    return Get-PmcState -Section 'Security'\r\n}\r\n\r\nfunction Get-PmcDebugState {\r\n    return Get-PmcState -Section 'Debug'\r\n}\r\n\r\nfunction Get-PmcHelpState {\r\n    return Get-PmcState -Section 'HelpUI' -Key 'HelpState'\r\n}\r\n\r\nfunction Get-PmcCommandCategories {\r\n    return Get-PmcState -Section 'HelpUI' -Key 'CommandCategories'\r\n}\r\n\r\nfunction Get-PmcTaskListMap {\r\n    return Get-PmcState -Section 'ViewMappings' -Key 'LastTaskListMap'\r\n}\r\n\r\nfunction Set-PmcTaskListMap {\r\n    param([hashtable]$Map)\r\n    Set-PmcState -Section 'ViewMappings' -Key 'LastTaskListMap' -Value $Map\r\n}\r\n\r\nfunction Get-PmcTimeListMap {\r\n    return Get-PmcState -Section 'ViewMappings' -Key 'LastTimeListMap'\r\n}\r\n\r\nfunction Set-PmcTimeListMap {\r\n    param([hashtable]$Map)\r\n    Set-PmcState -Section 'ViewMappings' -Key 'LastTimeListMap' -Value $Map\r\n}\r\n\r\nfunction Get-PmcUndoRedoState {\r\n    return Get-PmcState -Section 'UndoRedo'\r\n}\r\n\r\nfunction Get-PmcInteractiveState {\r\n    return Get-PmcState -Section 'Interactive'\r\n}\r\n\r\nfunction Get-PmcCommandMaps {\r\n    return Get-PmcState -Section 'Commands'\r\n}\r\n\r\n# =============================================================================\r\n# STATE INITIALIZATION AND MIGRATION\r\n# =============================================================================\r\n\r\nfunction Initialize-PmcCentralizedState {\r\n    <#\r\n    .SYNOPSIS\r\n    Initializes the centralized state system and migrates existing scattered state\r\n    ##CLOSEBRACKET##\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Debug logging removed to avoid circular dependency during initialization\r\n\r\n    # Initialize Interactive Editor if not already done\r\n    if (-not (Get-PmcState -Section 'Interactive' -Key 'Editor')) {\r\n        # Import the PmcEditorState class if it exists\r\n        try {\r\n            $editorState = [PmcEditorState]::new()\r\n            Set-PmcState -Section 'Interactive' -Key 'Editor' -Value $editorState\r\n            # Debug logging removed\r\n        } catch {\r\n            # Debug logging removed\r\n        }\r\n    }\r\n\r\n    # Migrate any existing command maps from the old system\r\n    try {\r\n        if (Get-Variable -Name 'PmcCommandMap' -Scope Script -ErrorAction SilentlyContinue) {\r\n            $oldCommandMap = Get-Variable -Name 'PmcCommandMap' -Scope Script -ValueOnly\r\n            Set-PmcState -Section 'Commands' -Key 'CommandMap' -Value $oldCommandMap\r\n            # Debug logging removed\r\n        }\r\n\r\n        if (Get-Variable -Name 'PmcParameterMap' -Scope Script -ErrorAction SilentlyContinue) {\r\n            $oldParameterMap = Get-Variable -Name 'PmcParameterMap' -Scope Script -ValueOnly\r\n            Set-PmcState -Section 'Commands' -Key 'ParameterMap' -Value $oldParameterMap\r\n            # Debug logging removed\r\n        }\r\n    } catch {\r\n        # Debug logging removed\r\n    }\r\n\r\n    # Debug logging removed\r\n}\r\n\r\nfunction Reset-PmcState {\r\n    <#\r\n    .SYNOPSIS\r\n    Resets the entire state system to defaults (useful for testing)\r\n    ##CLOSEBRACKET##\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $Script:PmcGlobalState._Lock = $true\r\n    try {\r\n        # Reset to initial state structure\r\n        $Script:PmcGlobalState = @{\r\n            Config = @{\r\n                ProviderGet = { @{} }\r\n                ProviderSet = $null\r\n            }\r\n            Security = @{\r\n                InputValidationEnabled = $true\r\n                PathWhitelistEnabled = $true\r\n                ResourceLimitsEnabled = $true\r\n                SensitiveDataScanEnabled = $true\r\n                AuditLoggingEnabled = $true\r\n                TemplateExecutionEnabled = $false\r\n                AllowedWritePaths = @()\r\n                MaxFileSize = 100MB\r\n                MaxMemoryUsage = 500MB\r\n                MaxExecutionTime = 300000\r\n            }\r\n            Debug = @{\r\n                Level = 0\r\n                LogPath = 'debug.log'\r\n                MaxSize = 10MB\r\n                RedactSensitive = $true\r\n                IncludePerformance = $false\r\n                SessionId = (New-Guid).ToString().Substring(0,8)\r\n                StartTime = Get-Date\r\n            }\r\n            HelpUI = @{\r\n                HelpState = @{\r\n                    CurrentCategory = 'All'\r\n                    SelectedCommand = 0\r\n                    SearchFilter = ''\r\n                    ShowExamples = $false\r\n                    ViewMode = 'Categories'\r\n                }\r\n                CommandCategories = @{}\r\n            }\r\n            Interactive = @{\r\n                Editor = $null\r\n                CompletionCache = @{}\r\n                GhostTextEnabled = $true\r\n            }\r\n            UndoRedo = @{\r\n                UndoStack = @()\r\n                RedoStack = @()\r\n                MaxUndoSteps = 5\r\n                DataCache = $null\r\n            }\r\n            ViewMappings = @{\r\n                LastTaskListMap = @{}\r\n                LastTimeListMap = @{}\r\n            }\r\n            Commands = @{\r\n                ParameterMap = @{}\r\n                CommandMap = @{}\r\n                ShortcutMap = @{}\r\n                CommandMeta = @{}\r\n            }\r\n            _Lock = $false\r\n        }\r\n\r\n        # Debug logging removed\r\n    }\r\n    finally {\r\n        $Script:PmcGlobalState._Lock = $false\r\n    }\r\n}\r\n\r\nfunction Get-PmcStateSnapshot {\r\n    <#\r\n    .SYNOPSIS\r\n    Gets a snapshot of the current state for debugging or backup purposes\r\n    ##CLOSEBRACKET##\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Create a deep copy of the state (excluding the lock)\r\n    $snapshot = @{}\r\n    foreach ($section in $Script:PmcGlobalState.Keys) {\r\n        if ($section -ne '_Lock') {\r\n            $snapshot[$section] = $Script:PmcGlobalState[$section].Clone()\r\n        }\r\n    }\r\n\r\n    return $snapshot\r\n}\r\n\r\n# =============================================================================\r\n# MODULE INITIALIZATION\r\n# =============================================================================\r\n\r\n# Auto-initialize the state system when this module is loaded\r\nInitialize-PmcCentralizedState\r\n\r\n# Debug logging removed to avoid circular dependency during initialization\r\n\r\nExport-ModuleMember -Function Get-PmcRootPath, Get-PmcState, Set-PmcState, Get-PmcLastTaskListMap, Set-PmcLastTaskListMap, Get-PmcLastTimeListMap, Set-PmcLastTimeListMap, Update-PmcStateSection, Get-PmcConfigProviders, Set-PmcConfigProviders, Get-PmcSecurityState, Get-PmcDebugState, Get-PmcHelpState, Get-PmcCommandCategories, Get-PmcTaskListMap, Set-PmcTaskListMap, Get-PmcTimeListMap, Set-PmcTimeListMap, Get-PmcUndoRedoState, Get-PmcInteractiveState, Get-PmcCommandMaps, Initialize-PmcCentralizedState, Reset-PmcState, Get-PmcStateSnapshot"}, {"path": "module/Pmc.Strict/src/Storage.ps1", "content": "# Storage and schema for strict engine (self-contained)\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nfunction Add-PmcUndoEntry {\r\n    param(\r\n        [string]$file,\r\n        [object]$data\r\n    )\r\n\r\n    # Create undo entry for the current data state before modification\r\n    try {\r\n        if (-not (Test-Path $file)) {\r\n            # No existing file to backup\r\n            return\r\n        }\r\n\r\n        $undoFile = $file + '.undo'\r\n        $currentContent = Get-Content $file -Raw -ErrorAction SilentlyContinue\r\n\r\n        if ($currentContent) {\r\n            # Save current state for undo capability\r\n            $undoEntry = @{\r\n                timestamp = (Get-Date).ToString('o')\r\n                file = $file\r\n                content = $currentContent\r\n            }\r\n\r\n            $undoJson = $undoEntry | ConvertTo-Json -Compress\r\n            Add-Content -Path $undoFile -Value $undoJson -ErrorAction SilentlyContinue\r\n\r\n            # Keep only last 3 undo entries to prevent file growth\r\n            $undoLines = Get-Content $undoFile -ErrorAction SilentlyContinue\r\n            if ($undoLines -and $undoLines.Count -gt 3) {\r\n                $undoLines[-3..-1] | Set-Content $undoFile -ErrorAction SilentlyContinue\r\n            }\r\n        }\r\n    } catch {\r\n        # Undo functionality is non-critical, don't fail the main operation\r\n        Write-PmcDebug -Level 2 -Category 'STORAGE' -Message \"Undo entry creation failed: $_\"\r\n    }\r\n}\r\n\r\nfunction Get-PmcTaskFilePath {\r\n    $cfg = Get-PmcConfig\r\n    $path = $null\r\n    try { if ($cfg.Paths -and $cfg.Paths.TaskFile) { $path = [string]$cfg.Paths.TaskFile } } catch {\r\n        # Configuration access failed - use default path\r\n    }\r\n    if (-not $path -or [string]::IsNullOrWhiteSpace($path)) {\r\n        # Default to pmc/tasks.json (three levels up from module dir)\r\n        # FIX: Use module path instead of $PSScriptRoot (which can be wrong in scriptblock context)\r\n        $moduleBase = (Get-Module -Name 'Pmc.Strict').ModuleBase\r\n        if ($moduleBase) {\r\n            $root = Split-Path (Split-Path $moduleBase -Parent) -Parent\r\n        } else {\r\n            # Fallback to $PSScriptRoot\r\n            $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent\r\n        }\r\n        $path = Join-Path $root 'tasks.json'\r\n    }\r\n    return $path\r\n}\r\n\r\nfunction Initialize-PmcDataSchema {\r\n    param($data)\r\n    if (-not $data) { return $data }\r\n    if (-not $data.PSObject.Properties['schema_version']) { $data | Add-Member -NotePropertyName schema_version -NotePropertyValue 1 -Force }\r\n    foreach ($k in @('tasks','deleted','completed','projects','timelogs','activityLog','templates','recurringTemplates','aliases')) {\r\n        if (-not $data.PSObject.Properties[$k] -or -not $data.$k) { $data | Add-Member -NotePropertyName $k -NotePropertyValue @() -Force }\r\n    }\r\n    # Normalize aliases to hashtable for reliable access\r\n    try {\r\n        if ($data.PSObject.Properties['aliases']) {\r\n            $al = $data.aliases\r\n            if ($al -is [pscustomobject]) {\r\n                $ht = @{}\r\n                foreach ($p in $al.PSObject.Properties) { $ht[$p.Name] = $p.Value }\r\n                $data.aliases = $ht\r\n            } elseif ($al -is [array]) {\r\n                # Convert array of pairs into hashtable if possible\r\n                $ht = @{}\r\n                foreach ($item in $al) { try { $ht[$item.Name] = $item.Value } catch {\r\n                    # Array item property access failed - skip this item\r\n                } }\r\n                $data.aliases = $ht\r\n            } elseif (-not ($al -is [hashtable])) {\r\n                $data.aliases = @{}\r\n            }\r\n        } else {\r\n            $data | Add-Member -NotePropertyName aliases -NotePropertyValue @{} -Force\r\n        }\r\n    } catch {\r\n        # Data schema normalization failed - continue with what we have\r\n    }\r\n    if (-not $data.PSObject.Properties['currentContext'] -or -not $data.currentContext) { $data | Add-Member -NotePropertyName currentContext -NotePropertyValue 'inbox' -Force }\r\n    if (-not $data.PSObject.Properties['preferences']) { $data | Add-Member -NotePropertyName preferences -NotePropertyValue @{ autoBackup = $true } -Force }\r\n\r\n    # Normalize task properties to prevent \"property cannot be found\" errors\r\n    if ($data.tasks -and $data.tasks.Count -gt 0) {\r\n        foreach ($task in $data.tasks) {\r\n            if ($null -eq $task) { continue }\r\n            try {\r\n                # Check if Pmc-HasProp function exists before using it\r\n                $hasPmcHasProp = Get-Command -Name 'Pmc-HasProp' -ErrorAction SilentlyContinue\r\n                if (-not $hasPmcHasProp) {\r\n                    Write-PmcDebug -Level 2 -Category 'STORAGE' -Message \"Pmc-HasProp function not available, skipping task property normalization\"\r\n                    continue\r\n                }\r\n\r\n                # Ensure critical properties exist with defaults - wrap each in try-catch\r\n                try { if (-not (Pmc-HasProp $task 'depends')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'depends' -NotePropertyValue @() -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.depends: $_\" }\r\n                try { if (-not (Pmc-HasProp $task 'tags')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'tags' -NotePropertyValue @() -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.tags: $_\" }\r\n                try { if (-not (Pmc-HasProp $task 'notes')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'notes' -NotePropertyValue @() -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.notes: $_\" }\r\n                try { if (-not (Pmc-HasProp $task 'recur')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'recur' -NotePropertyValue $null -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.recur: $_\" }\r\n                try { if (-not (Pmc-HasProp $task 'estimatedMinutes')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'estimatedMinutes' -NotePropertyValue $null -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.estimatedMinutes: $_\" }\r\n                try { if (-not (Pmc-HasProp $task 'status')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'status' -NotePropertyValue 'pending' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.status: $_\" }\r\n                try { if (-not (Pmc-HasProp $task 'priority')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'priority' -NotePropertyValue 0 -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.priority: $_\" }\r\n                try { if (-not (Pmc-HasProp $task 'project')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'project' -NotePropertyValue 'inbox' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.project: $_\" }\r\n                try { if (-not (Pmc-HasProp $task 'due')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'due' -NotePropertyValue $null -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.due: $_\" }\r\n                try { if (-not (Pmc-HasProp $task 'nextSuggestedCount')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'nextSuggestedCount' -NotePropertyValue 3 -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.nextSuggestedCount: $_\" }\r\n                try { if (-not (Pmc-HasProp $task 'lastNextShown')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'lastNextShown' -NotePropertyValue (Get-Date).ToString('yyyy-MM-dd') -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.lastNextShown: $_\" }\r\n                try { if (-not (Pmc-HasProp $task 'created')) { Add-Member -InputObject $task -MemberType NoteProperty -Name 'created' -NotePropertyValue (Get-Date).ToString('yyyy-MM-dd HH:mm:ss') -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize task.created: $_\" }\r\n            } catch {\r\n                # Individual task property normalization failed - log and continue\r\n                Write-PmcDebug -Level 2 -Category 'STORAGE' -Message \"Failed to normalize task properties: $_\"\r\n            }\r\n        }\r\n    }\r\n    # Ensure timelog entries have taskId (optional linkage to tasks)\r\n    if ($data.timelogs -and $data.timelogs.Count -gt 0) {\r\n        foreach ($log in $data.timelogs) {\r\n            if ($null -eq $log) { continue }\r\n            if (-not (Pmc-HasProp $log 'taskId')) {\r\n                try { Add-Member -InputObject $log -MemberType NoteProperty -Name 'taskId' -NotePropertyValue $null -Force } catch {}\r\n            }\r\n        }\r\n    }\r\n\r\n    # Normalize project properties\r\n    if ($data.projects -and $data.projects.Count -gt 0) {\r\n        foreach ($project in $data.projects) {\r\n            if ($null -eq $project) { continue }\r\n            try {\r\n                # Check if Pmc-HasProp function exists before using it\r\n                $hasPmcHasProp = Get-Command -Name 'Pmc-HasProp' -ErrorAction SilentlyContinue\r\n                if (-not $hasPmcHasProp) {\r\n                    Write-PmcDebug -Level 2 -Category 'STORAGE' -Message \"Pmc-HasProp function not available, skipping project property normalization\"\r\n                    continue\r\n                }\r\n\r\n                # Ensure critical properties exist with defaults - wrap each in try-catch\r\n                try { if (-not (Pmc-HasProp $project 'name')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'name' -NotePropertyValue '' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.name: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'description')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'description' -NotePropertyValue '' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.description: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'aliases')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'aliases' -NotePropertyValue @() -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.aliases: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'created')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'created' -NotePropertyValue (Get-Date).ToString('yyyy-MM-dd HH:mm:ss') -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.created: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'isArchived')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'isArchived' -NotePropertyValue $false -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.isArchived: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'color')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'color' -NotePropertyValue 'Gray' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.color: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'icon')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'icon' -NotePropertyValue '📁' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.icon: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'sortOrder')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'sortOrder' -NotePropertyValue 0 -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.sortOrder: $_\" }\r\n                # Extended fields (t2 parity)\r\n                try { if (-not (Pmc-HasProp $project 'ID1')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'ID1' -NotePropertyValue '' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.ID1: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'ID2')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'ID2' -NotePropertyValue '' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.ID2: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'ProjFolder')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'ProjFolder' -NotePropertyValue '' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.ProjFolder: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'AssignedDate')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'AssignedDate' -NotePropertyValue '' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.AssignedDate: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'DueDate')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'DueDate' -NotePropertyValue '' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.DueDate: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'BFDate')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'BFDate' -NotePropertyValue '' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.BFDate: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'CAAName')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'CAAName' -NotePropertyValue '' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.CAAName: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'RequestName')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'RequestName' -NotePropertyValue '' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.RequestName: $_\" }\r\n                try { if (-not (Pmc-HasProp $project 'T2020')) { Add-Member -InputObject $project -MemberType NoteProperty -Name 'T2020' -NotePropertyValue '' -Force } } catch { Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"Failed to normalize project.T2020: $_\" }\r\n            } catch {\r\n                # Individual project property normalization failed - log and continue\r\n                Write-PmcDebug -Level 2 -Category 'STORAGE' -Message \"Failed to normalize project properties: $_\"\r\n            }\r\n        }\r\n    }\r\n\r\n    return $data\r\n}\r\n\r\n# Normalize data to consistent shapes (fail-fast for irrecoverable cases)\r\nfunction Normalize-PmcData {\r\n    param($data)\r\n    if (-not $data) { throw 'Data is null' }\r\n    foreach ($k in @('tasks','deleted','completed','projects','timelogs','activityLog','templates','recurringTemplates')) {\r\n        if (-not (Pmc-HasProp $data $k) -or -not $data.$k) { $data | Add-Member -NotePropertyName $k -NotePropertyValue @() -Force }\r\n        elseif (-not ($data.$k -is [System.Collections.IEnumerable])) { throw \"Data section '$k' is not a list\" }\r\n    }\r\n    # Coerce hashtable entries to PSCustomObject for tasks/projects/timelogs\r\n    $coerce = {\r\n        param($arrRef)\r\n        $new = @()\r\n        foreach ($it in @($arrRef)) {\r\n            if ($null -eq $it) { continue }\r\n            if ($it -is [hashtable]) { $new += [pscustomobject]$it }\r\n            else { $new += $it }\r\n        }\r\n        return ,$new\r\n    }\r\n    $data.tasks = & $coerce $data.tasks\r\n    $data.projects = & $coerce $data.projects\r\n    $data.timelogs = & $coerce $data.timelogs\r\n    return $data\r\n}\r\n\r\n# Alias for backward compatibility - defined after Get-PmcData below\r\n\r\n# Data provider for display system\r\nfunction Get-PmcDataProvider {\r\n    param([string]$ProviderType = 'Storage')\r\n\r\n    # Return an object with GetData method\r\n    return [PSCustomObject]@{\r\n        GetData = { Get-PmcData }\r\n    }\r\n}\r\n\r\n# Alias for backward compatibility - critical for Tasks/Time/Projects\r\nfunction Set-PmcAllData {\r\n    param($Data)\r\n    Save-PmcData -Data $Data\r\n}\r\n\r\n# Enhanced Query Engine data providers\r\nfunction Get-PmcTasksData {\r\n    $data = Get-PmcData\r\n    return $(if ($data -and $data.tasks) { @($data.tasks) } else { @() })\r\n}\r\n\r\nfunction Get-PmcProjectsData {\r\n    $data = Get-PmcData\r\n    return $(if ($data -and $data.projects) { @($data.projects) } else { @() })\r\n}\r\n\r\nfunction Get-PmcTimeLogsData {\r\n    $data = Get-PmcData\r\n    return $(if ($data -and $data.timelogs) { @($data.timelogs) } else { @() })\r\n}\r\n\r\nfunction Get-PmcData {\r\n    $file = Get-PmcTaskFilePath\r\n    if (-not (Test-Path $file)) {\r\n        $root = Split-Path $file -Parent\r\n        try { if (-not (Test-Path $root)) { New-Item -ItemType Directory -Path $root -Force | Out-Null } } catch {\r\n            # Directory creation failed - may cause subsequent save failures\r\n        }\r\n        $init = @{\r\n            tasks=@(); deleted=@(); completed=@(); timelogs=@(); activityLog=@(); projects=@(@{ name='inbox'; description='Default inbox'; aliases=@(); created=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss') });\r\n            currentContext='inbox'; schema_version=1; preferences=@{ autoBackup=$true }\r\n        } | ConvertTo-Json -Depth 10\r\n        $init | Set-Content -Path $file -Encoding UTF8\r\n    }\r\n    # Load with optional strict recovery policy\r\n    # KR-M1 FIX: Add type validation before casting JSON boolean field\r\n    $cfg = Get-PmcConfig; $strict = $true\r\n    try {\r\n        if ($cfg.Behavior -and $cfg.Behavior.StrictDataMode -ne $null) {\r\n            # Validate and safely convert to boolean\r\n            if ($cfg.Behavior.StrictDataMode -is [bool]) {\r\n                $strict = $cfg.Behavior.StrictDataMode\r\n            } elseif ($cfg.Behavior.StrictDataMode -is [string]) {\r\n                $strict = $cfg.Behavior.StrictDataMode -eq 'true'\r\n            } elseif ($cfg.Behavior.StrictDataMode -is [int]) {\r\n                $strict = $cfg.Behavior.StrictDataMode -ne 0\r\n            } else {\r\n                $strict = [bool]$cfg.Behavior.StrictDataMode\r\n            }\r\n        }\r\n    } catch {}\r\n    try {\r\n        $raw = Get-Content $file -Raw\r\n        $data = $raw | ConvertFrom-Json\r\n        # Coerce collections before adding default properties to ensure NoteProperty attaches to PSCustomObject\r\n        $data = Normalize-PmcData $data\r\n        $data = Initialize-PmcDataSchema $data\r\n        return $data\r\n    } catch {\r\n        if ($strict) { throw }\r\n        # Non-strict: Try .tmp\r\n        $tmp = \"$file.tmp\"\r\n        try {\r\n            if (Test-Path $tmp) {\r\n                $raw = Get-Content $tmp -Raw\r\n                $data = $raw | ConvertFrom-Json\r\n                Write-PmcDebug -Level 1 -Category 'STORAGE' -Message 'Recovered data from tmp'\r\n                return (Initialize-PmcDataSchema $data)\r\n            }\r\n        } catch {\r\n            # Temporary file recovery failed - try backup files\r\n        }\r\n        # Try rotating backups .bak1..bak9\r\n        for ($i=1; $i -le 9; $i++) {\r\n            $bak = \"$file.bak$i\"\r\n            if (-not (Test-Path $bak)) { continue }\r\n            try {\r\n                $raw = Get-Content $bak -Raw\r\n                $data = $raw | ConvertFrom-Json\r\n                Write-PmcDebug -Level 1 -Category 'STORAGE' -Message (\"Recovered data from backup: {0}\" -f (Split-Path $bak -Leaf))\r\n                return (Initialize-PmcDataSchema $data)\r\n            } catch {\r\n                # Backup file recovery failed - try next backup\r\n            }\r\n        }\r\n        throw \"Failed to load or recover data\"\r\n    }\r\n}\r\n\r\nfunction Get-PmcSafePath {\r\n    param([string]$Path)\r\n    $cfg = Get-PmcConfig\r\n    $strict = $true; $allowed=@()\r\n    try { if ($cfg.Behavior -and $cfg.Behavior.SafePathsStrict -ne $null) { $strict = [bool]$cfg.Behavior.SafePathsStrict } } catch {\r\n        # Configuration access failed - use default strict mode\r\n    }\r\n    try { if ($cfg.Paths -and $cfg.Paths.AllowedWriteDirs) { $allowed = @($cfg.Paths.AllowedWriteDirs) } } catch {\r\n        # Configuration access failed - use empty allowed paths list\r\n    }\r\n    $root = Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent\r\n    if ([string]::IsNullOrWhiteSpace($Path)) { return (Join-Path $root 'output.txt') }\r\n    try {\r\n        $baseFull = [System.IO.Path]::GetFullPath($root)\r\n        $isAbs = [System.IO.Path]::IsPathRooted($Path)\r\n        if (-not $isAbs) {\r\n            $combined = Join-Path $root $Path\r\n            $full = [System.IO.Path]::GetFullPath($combined)\r\n            if (-not $full.StartsWith($baseFull, [System.StringComparison]::OrdinalIgnoreCase)) {\r\n                return (Join-Path $baseFull ([System.IO.Path]::GetFileName($Path)))\r\n            }\r\n            return $full\r\n        }\r\n        # Absolute path\r\n        $fullAbs = [System.IO.Path]::GetFullPath($Path)\r\n        if ($fullAbs.StartsWith($baseFull, [System.StringComparison]::OrdinalIgnoreCase)) { return $fullAbs }\r\n        if (-not $strict) { return $fullAbs }\r\n        foreach ($dir in $allowed) {\r\n            if ([string]::IsNullOrWhiteSpace($dir)) { continue }\r\n            # Allowlist entries are relative to base unless absolute\r\n            $dirFull = $(if ([System.IO.Path]::IsPathRooted($dir)) { [System.IO.Path]::GetFullPath($dir) } else { [System.IO.Path]::GetFullPath((Join-Path $root $dir)) })\r\n            if ($fullAbs.StartsWith($dirFull, [System.StringComparison]::OrdinalIgnoreCase)) { return $fullAbs }\r\n        }\r\n        return (Join-Path $baseFull ([System.IO.Path]::GetFileName($Path)))\r\n    } catch {\r\n        return (Join-Path $root ([System.IO.Path]::GetFileName($Path)))\r\n    }\r\n}\r\n\r\nfunction Lock-PmcFile {\r\n    param([string]$file)\r\n    $lockPath = $file + '.lock'\r\n    $maxRetries = 20; $delay = 100\r\n    for ($i=0; $i -lt $maxRetries; $i++) {\r\n        try { return [System.IO.File]::Open($lockPath, [System.IO.FileMode]::OpenOrCreate, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None) } catch {\r\n            # File lock acquisition failed - will retry\r\n        }\r\n        try { $info = Get-Item $lockPath -ErrorAction SilentlyContinue; if ($info -and ((Get-Date) - $info.LastWriteTime).TotalMinutes -gt 2) { Remove-Item $lockPath -Force -ErrorAction SilentlyContinue } } catch {\r\n            # Stale lock cleanup failed - continue trying\r\n        }\r\n        Start-Sleep -Milliseconds $delay\r\n    }\r\n    throw \"Could not acquire lock for $file\"\r\n}\r\n\r\nfunction Unlock-PmcFile { param($lock,$file) try { if ($lock) { $lock.Close() } } catch {\r\n        # Lock file close failed - file handle may remain open\r\n    } ; try { Remove-Item ($file + '.lock') -Force -ErrorAction SilentlyContinue } catch {\r\n        # Lock file removal failed - may cause future lock conflicts\r\n    } }\r\n\r\nfunction Invoke-PmcBackupRotation {\r\n    param([string]$file,[int]$count=3)\r\n    # Make backup retention configurable via Behavior.MaxBackups\r\n    try { $cfg=Get-PmcConfig; if ($cfg.Behavior -and $cfg.Behavior.MaxBackups) { $count = [int]$cfg.Behavior.MaxBackups } } catch {\r\n        # Configuration access failed - use default backup count\r\n    }\r\n    for ($i=$count-1; $i -ge 1; $i--) {\r\n        $src = \"$file.bak$i\"; $dst = \"$file.bak$($i+1)\"; if (Test-Path $src) { Move-Item -Force $src $dst }\r\n    }\r\n    if (Test-Path $file) { Copy-Item $file \"$file.bak1\" -Force }\r\n}\r\n\r\nfunction Add-PmcUndoState {\r\n    param([string]$file,[object]$data)\r\n    $undoFile = $file + '.undo'\r\n    $stack = @(); if (Test-Path $undoFile) { try { $stack = Get-Content $undoFile -Raw | ConvertFrom-Json } catch { $stack=@() } }\r\n    $stack += ($data | ConvertTo-Json -Depth 10)\r\n    $max = 10; try { $cfg=Get-PmcConfig; if ($cfg.Behavior -and $cfg.Behavior.MaxUndoLevels) { $max = [int]$cfg.Behavior.MaxUndoLevels } } catch {\r\n        # Configuration access failed - use default undo levels\r\n    }\r\n    if (@($stack).Count -gt $max) { $stack = $stack[-$max..-1] }\r\n    $stack | ConvertTo-Json -Depth 10 | Set-Content $undoFile -Encoding UTF8\r\n}\r\n\r\nfunction Get-PmcUndoRedoStacks {\r\n    param([string]$file)\r\n    $undoFile = $file + '.undo'\r\n    $redoFile = $file + '.redo'\r\n    $undo = @(); $redo = @()\r\n    if (Test-Path $undoFile) { try { $undo = Get-Content $undoFile -Raw | ConvertFrom-Json } catch { $undo=@() } }\r\n    if (Test-Path $redoFile) { try { $redo = Get-Content $redoFile -Raw | ConvertFrom-Json } catch { $redo=@() } }\r\n    return @{ undo=$undo; redo=$redo; undoFile=$undoFile; redoFile=$redoFile }\r\n}\r\n\r\nfunction Save-PmcUndoRedoStacks {\r\n    param([array]$Undo,[array]$Redo,[string]$UndoFile,[string]$RedoFile)\r\n    try { $Undo | ConvertTo-Json -Depth 10 | Set-Content $UndoFile -Encoding UTF8 } catch {\r\n        # Undo stack save failed - undo functionality may be impaired\r\n    }\r\n    try { $Redo | ConvertTo-Json -Depth 10 | Set-Content $RedoFile -Encoding UTF8 } catch {\r\n        # Redo stack save failed - redo functionality may be impaired\r\n    }\r\n}\r\n\r\nfunction Add-PmcActivity {\r\n    param([object]$data,[string]$action)\r\n    if (-not $data.PSObject.Properties['activityLog']) { $data | Add-Member -NotePropertyName activityLog -NotePropertyValue @() -Force }\r\n\r\n    # Add new entry\r\n    $data.activityLog += @{ timestamp=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss'); action=$action; user=$env:USERNAME }\r\n\r\n    # Enforce limit IMMEDIATELY to prevent in-memory growth\r\n    $currentCount = @($data.activityLog).Count\r\n    if ($currentCount -gt 1000) {\r\n        $data.activityLog = $data.activityLog[-1000..-1]\r\n    }\r\n}\r\n\r\nfunction Save-PmcData {\r\n    param(\r\n        [Parameter(Mandatory=$true)][object]$data,\r\n        [string]$Action=''\r\n    )\r\n\r\n    # CRITICAL FIX: Test-PmcResourceLimits function doesn't exist, causing all saves to fail\r\n    # Commenting out until function is implemented\r\n    # if (-not (Test-PmcResourceLimits)) {\r\n    #     throw \"Resource limits exceeded - cannot save data\"\r\n    # }\r\n\r\n    $cfg = Get-PmcConfig; $whatIf=$false; try { if ($cfg.Behavior -and $cfg.Behavior.WhatIf) { $whatIf = [bool]$cfg.Behavior.WhatIf } } catch {\r\n        # Configuration access failed - whatIf remains false\r\n    }\r\n    if ($whatIf) { Write-Host 'WhatIf: changes not saved' -ForegroundColor DarkYellow; return }\r\n\r\n    $file = Get-PmcTaskFilePath\r\n\r\n    # Validate file path security\r\n    if (-not (Test-PmcPathSafety -Path $file -Operation 'write')) {\r\n        throw \"Path safety validation failed for: $file\"\r\n    }\r\n\r\n    Write-PmcDebugStorage -Operation 'SaveData' -File $file -Data @{ Action = $Action; WhatIf = $whatIf }\r\n\r\n    $lock = $null\r\n    try {\r\n        $lock = Lock-PmcFile $file\r\n\r\n        Write-PmcDebugStorage -Operation 'AcquiredLock' -File $file\r\n\r\n        Invoke-PmcBackupRotation -file $file -count 3\r\n        Add-PmcUndoEntry -file $file -data $data\r\n        if ($Action) { Add-PmcActivity -data $data -action $Action }\r\n\r\n        $tmp = \"$file.tmp\"\r\n\r\n        # Use secure file operation for the actual write\r\n        $jsonContent = $data | ConvertTo-Json -Depth 10\r\n\r\n        # CRITICAL: Validate content safety BEFORE writing\r\n        if (-not (Test-PmcInputSafety -Input $jsonContent -InputType 'json')) {\r\n            Write-PmcDebug -Level 1 -Category 'SECURITY' -Message \"Data content failed safety validation - aborting save\"\r\n            throw \"Data content failed safety validation - refusing to save potentially unsafe data\"\r\n        }\r\n\r\n        Invoke-PmcSecureFileOperation -Path $tmp -Operation 'write' -Content $jsonContent\r\n\r\n        # Atomic rename operation - if this fails, lock will prevent corruption\r\n        try {\r\n            Move-Item -Force -Path $tmp -Destination $file -ErrorAction Stop\r\n        } catch {\r\n            # If move fails, ensure temp file is cleaned up\r\n            if (Test-Path $tmp) {\r\n                Remove-Item $tmp -Force -ErrorAction SilentlyContinue\r\n            }\r\n            throw  # Rethrow to be caught by outer try-catch\r\n        }\r\n\r\n        # Verify that the written file is valid JSON\r\n        try {\r\n            $verifyContent = Get-Content $file -Raw -ErrorAction Stop\r\n            $null = $verifyContent | ConvertFrom-Json -ErrorAction Stop\r\n            Write-PmcDebug -Level 3 -Category 'STORAGE' -Message \"File verification successful after save\"\r\n        } catch {\r\n            Write-PmcDebug -Level 1 -Category 'STORAGE' -Message \"WARNING: Saved file failed JSON validation: $_\"\r\n            # Try to restore from backup\r\n            if (Test-Path \"$file.bak1\") {\r\n                Write-PmcDebug -Level 1 -Category 'STORAGE' -Message \"Attempting to restore from backup\"\r\n                try {\r\n                    Copy-Item \"$file.bak1\" $file -Force\r\n                    Write-PmcDebug -Level 2 -Category 'STORAGE' -Message \"Successfully restored from backup\"\r\n                } catch {\r\n                    Write-PmcDebug -Level 1 -Category 'STORAGE' -Message \"Failed to restore from backup: $_\"\r\n                }\r\n            }\r\n            throw \"Saved file validation failed - data may be corrupted\"\r\n        }\r\n\r\n        Write-PmcDebugStorage -Operation 'SaveCompleted' -File $file -Data @{ Size = $jsonContent.Length }\r\n\r\n    } catch {\r\n        Write-PmcDebugStorage -Operation 'SaveFailed' -File $file -Data @{ Error = $_.ToString() }\r\n        Write-Host \"Failed to save data: $_\" -ForegroundColor Red\r\n        throw\r\n    } finally {\r\n        Unlock-PmcFile $lock $file\r\n    }\r\n}\r\n\r\nfunction Get-PmcDataAlias { return Get-PmcData }\r\n\r\n# Alias for backward compatibility - now that Get-PmcData is defined\r\nfunction Get-PmcAllData {\r\n    return Get-PmcData\r\n}\r\n\r\nfunction Get-PmcNextTaskId {\r\n    param($data)\r\n    try { $ids = @($data.tasks | ForEach-Object { try { [int]$_.id } catch { 0 } }); $max = ($ids | Measure-Object -Maximum).Maximum; return ([int]$max + 1) } catch { return 1 }\r\n}\r\n\r\nfunction Get-PmcNextTimeLogId {\r\n    param($data)\r\n    try { $ids = @($data.timelogs | ForEach-Object { try { [int]$_.id } catch { 0 } }); $max = ($ids | Measure-Object -Maximum).Maximum; return ([int]$max + 1) } catch { return 1 }\r\n}\r\n\r\n# Functions will be exported by main module file\r\n# Export-ModuleMember removed to avoid conflicts with main module exports"}, {"path": "module/Pmc.Strict/src/TaskEditor.ps1", "content": "# TaskEditor.ps1 - Interactive task editing with full-screen editor\r\n# Provides rich editing experience for PMC tasks with multi-line support and metadata editing\r\n\r\nclass PmcTaskEditor {\r\n    [string]$TaskId\r\n    [hashtable]$TaskData\r\n    [string[]]$DescriptionLines\r\n    [string]$Project\r\n    [string]$Priority\r\n    [string]$DueDate\r\n    [string[]]$Tags\r\n    [int]$CurrentLine\r\n    [int]$CursorColumn\r\n    [bool]$IsEditing\r\n    [string]$Mode  # 'description', 'metadata', 'preview'\r\n    [hashtable]$OriginalData\r\n    [int]$StartRow\r\n    [int]$EndRow\r\n\r\n    PmcTaskEditor([string]$taskId) {\r\n        $this.TaskId = $taskId\r\n        $this.LoadTask()\r\n        $this.InitializeEditor()\r\n    }\r\n\r\n    [void] LoadTask() {\r\n        try {\r\n            # Load task data from PMC data store\r\n            $taskDataResult = Invoke-PmcCommand \"task show $($this.TaskId)\" -Raw\r\n\r\n            if (-not $taskDataResult) {\r\n                throw \"Task $($this.TaskId) not found\"\r\n            }\r\n\r\n            $this.TaskData = $taskDataResult\r\n            $this.OriginalData = $taskDataResult.Clone()\r\n\r\n            # Parse task fields\r\n            $this.DescriptionLines = @($taskDataResult.description -split \"`n\")\r\n            $this.Project = $(if ($taskDataResult.project) { $taskDataResult.project } else { \"\" })\r\n            $this.Priority = $(if ($taskDataResult.priority) { $taskDataResult.priority } else { \"\" })\r\n            $this.DueDate = $(if ($taskDataResult.due) { $taskDataResult.due } else { \"\" })\r\n            $this.Tags = @($(if ($taskDataResult.tags) { $taskDataResult.tags } else { @() }))\r\n\r\n        } catch {\r\n            throw \"Failed to load task: $_\"\r\n        }\r\n    }\r\n\r\n    [void] InitializeEditor() {\r\n        $this.CurrentLine = 0\r\n        $this.CursorColumn = 0\r\n        $this.IsEditing = $false\r\n        $this.Mode = 'description'\r\n\r\n        # Calculate screen regions\r\n        $this.StartRow = 3\r\n        $this.EndRow = [PmcTerminalService]::GetHeight() - 8\r\n    }\r\n\r\n    [void] Show() {\r\n        try {\r\n            # Clear screen and setup editor\r\n            [Console]::Clear()\r\n            $this.DrawHeader()\r\n            $this.DrawTaskContent()\r\n            $this.DrawFooter()\r\n            $this.DrawStatusLine()\r\n\r\n            # Start editor loop\r\n            $this.EditorLoop()\r\n\r\n        } catch {\r\n            Write-PmcStyled -Style 'Error' -Text (\"Editor error: {0}\" -f $_)\r\n        } finally {\r\n            # Restore normal screen\r\n            [Console]::Clear()\r\n        }\r\n    }\r\n\r\n    [void] DrawHeader() {\r\n        $palette = Get-PmcColorPalette\r\n        $headerColor = Get-PmcColorSequence $palette.Header\r\n        $resetColor = [PmcVT]::Reset()\r\n\r\n        [Console]::SetCursorPosition(0, 0)\r\n        $title = \"PMC Task Editor - Task #$($this.TaskId)\"\r\n        $separator = \"═\" * [PmcTerminalService]::GetWidth()\r\n\r\n        Write-Host \"$headerColor$title$resetColor\"\r\n        Write-Host \"$headerColor$separator$resetColor\"\r\n        Write-Host \"\"\r\n    }\r\n\r\n    [void] DrawTaskContent() {\r\n        $startRowPos = $this.StartRow\r\n\r\n        # Mode indicator\r\n        $modeIndicator = switch ($this.Mode) {\r\n            'description' { \"[F1] Description Editor\" }\r\n            'metadata' { \"[F2] Metadata Editor\" }\r\n            'preview' { \"[F3] Preview Mode\" }\r\n        }\r\n\r\n        [Console]::SetCursorPosition(0, $startRowPos - 1)\r\n        Write-PmcStyled -Style 'Warning' -Text $modeIndicator\r\n\r\n        switch ($this.Mode) {\r\n            'description' { $this.DrawDescriptionEditor($startRowPos) }\r\n            'metadata' { $this.DrawMetadataEditor($startRowPos) }\r\n            'preview' { $this.DrawPreviewMode($startRowPos) }\r\n        }\r\n    }\r\n\r\n    [void] DrawDescriptionEditor([int]$startRow) {\r\n        $palette = Get-PmcColorPalette\r\n        $textColor = Get-PmcColorSequence $palette.Text\r\n        $resetColor = [PmcVT]::Reset()\r\n        $cursorColor = Get-PmcColorSequence $palette.Cursor\r\n\r\n        # Clear content area\r\n        for ($i = $startRow; $i -le $this.EndRow; $i++) {\r\n            [Console]::SetCursorPosition(0, $i)\r\n            Write-Host (' ' * [PmcTerminalService]::GetWidth()) -NoNewline\r\n        }\r\n\r\n        # Draw description lines\r\n        $maxLines = $this.EndRow - $startRow + 1\r\n        $visibleLines = [Math]::Min($this.DescriptionLines.Count, $maxLines)\r\n\r\n        for ($i = 0; $i -lt $visibleLines; $i++) {\r\n            [Console]::SetCursorPosition(0, $startRow + $i)\r\n\r\n            $line = $this.DescriptionLines[$i]\r\n            $lineNumber = ($i + 1).ToString().PadLeft(3)\r\n\r\n            if ($i -eq $this.CurrentLine) {\r\n                # Highlight current line\r\n                Write-Host \"$cursorColor$lineNumber │ $line$resetColor\" -NoNewline\r\n            } else {\r\n                Write-Host \"$textColor$lineNumber │ $line$resetColor\" -NoNewline\r\n            }\r\n        }\r\n\r\n        # Show cursor position\r\n        if ($this.CurrentLine -lt $visibleLines) {\r\n            $cursorRow = $startRow + $this.CurrentLine\r\n            $cursorCol = 6 + $this.CursorColumn  # Account for line number prefix\r\n            [Console]::SetCursorPosition($cursorCol, $cursorRow)\r\n        }\r\n    }\r\n\r\n    [void] DrawMetadataEditor([int]$startRow) {\r\n        $palette = Get-PmcColorPalette\r\n        $labelColor = Get-PmcColorSequence $palette.Label\r\n        $valueColor = Get-PmcColorSequence $palette.Text\r\n        $resetColor = [PmcVT]::Reset()\r\n\r\n        # Clear area\r\n        for ($i = $startRow; $i -le $this.EndRow; $i++) {\r\n            [Console]::SetCursorPosition(0, $i)\r\n            Write-Host (' ' * [PmcTerminalService]::GetWidth()) -NoNewline\r\n        }\r\n\r\n        $row = $startRow\r\n\r\n        # Project field\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$labelColor  Project:$resetColor $valueColor$($this.Project)$resetColor\"\r\n\r\n        # Priority field\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$labelColor Priority:$resetColor $valueColor$($this.Priority)$resetColor\"\r\n\r\n        # Due date field\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$labelColor Due Date:$resetColor $valueColor$($this.DueDate)$resetColor\"\r\n\r\n        # Tags field\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        $tagsStr = $(if ($this.Tags.Count -gt 0) { $this.Tags -join \", \" } else { \"(none)\" })\r\n        Write-Host \"$labelColor     Tags:$resetColor $valueColor$tagsStr$resetColor\"\r\n\r\n        $row++\r\n\r\n        # Metadata editing instructions\r\n        [Console]::SetCursorPosition(0, $row)\r\n        Write-PmcStyled -Style 'Muted' -Text \"Press Enter to edit a field, Tab/Shift+Tab to navigate\"\r\n    }\r\n\r\n    [void] DrawPreviewMode([int]$startRow) {\r\n        $palette = Get-PmcColorPalette\r\n        $headerColor = Get-PmcColorSequence $palette.Header\r\n        $textColor = Get-PmcColorSequence $palette.Text\r\n        $metaColor = Get-PmcColorSequence $palette.Muted\r\n        $resetColor = [PmcVT]::Reset()\r\n\r\n        # Clear area\r\n        for ($i = $startRow; $i -le $this.EndRow; $i++) {\r\n            [Console]::SetCursorPosition(0, $i)\r\n            Write-Host (' ' * [PmcTerminalService]::GetWidth()) -NoNewline\r\n        }\r\n\r\n        $row = $startRow\r\n\r\n        # Task header\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$headerColor╭─ Task Preview ─────────────────────────$resetColor\"\r\n\r\n        # Description\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$textColor│ Description:$resetColor\"\r\n\r\n        foreach ($line in $this.DescriptionLines) {\r\n            [Console]::SetCursorPosition(0, $row++)\r\n            Write-Host \"$textColor│   $line$resetColor\"\r\n        }\r\n\r\n        # Metadata\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$textColor│$resetColor\"\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$textColor│ Metadata:$resetColor\"\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$metaColor│   Project: $($this.Project)$resetColor\"\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$metaColor│   Priority: $($this.Priority)$resetColor\"\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$metaColor│   Due: $($this.DueDate)$resetColor\"\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$metaColor│   Tags: $($this.Tags -join ', ')$resetColor\"\r\n\r\n        [Console]::SetCursorPosition(0, $row++)\r\n        Write-Host \"$headerColor╰────────────────────────────────────────$resetColor\"\r\n    }\r\n\r\n    [void] DrawFooter() {\r\n        $footerRow = [PmcTerminalService]::GetHeight() - 4\r\n        $palette = Get-PmcColorPalette\r\n        $footerColor = Get-PmcColorSequence $palette.Footer\r\n        $resetColor = [PmcVT]::Reset()\r\n\r\n        [Console]::SetCursorPosition(0, $footerRow)\r\n        Write-Host \"$footerColor$('─' * [PmcTerminalService]::GetWidth())$resetColor\"\r\n\r\n        [Console]::SetCursorPosition(0, $footerRow + 1)\r\n        Write-Host \"$footerColor F1:Description  F2:Metadata  F3:Preview  Ctrl+S:Save  Esc:Cancel$resetColor\"\r\n    }\r\n\r\n    [void] DrawStatusLine() {\r\n        $statusRow = [PmcTerminalService]::GetHeight() - 2\r\n        $palette = Get-PmcColorPalette\r\n        $statusColor = Get-PmcColorSequence $palette.Status\r\n        $resetColor = [PmcVT]::Reset()\r\n\r\n        [Console]::SetCursorPosition(0, $statusRow)\r\n\r\n        $status = switch ($this.Mode) {\r\n            'description' { \"Line $($this.CurrentLine + 1), Column $($this.CursorColumn + 1)\" }\r\n            'metadata' { \"Metadata Editor - Use Enter to edit fields\" }\r\n            'preview' { \"Preview Mode - Read-only view\" }\r\n        }\r\n\r\n        $hasChanges = $this.HasUnsavedChanges()\r\n        $changeIndicator = $(if ($hasChanges) { \" [Modified]\" } else { \"\" })\r\n\r\n        Write-Host \"$statusColor$status$changeIndicator$resetColor\" -NoNewline\r\n    }\r\n\r\n    [bool] HasUnsavedChanges() {\r\n        # Compare current state with original\r\n        $currentDescription = $this.DescriptionLines -join \"`n\"\r\n        $originalDescription = $this.OriginalData.description\r\n\r\n        return ($currentDescription -ne $originalDescription) -or\r\n               ($this.Project -ne $this.OriginalData.project) -or\r\n               ($this.Priority -ne $this.OriginalData.priority) -or\r\n               ($this.DueDate -ne $this.OriginalData.due)\r\n    }\r\n\r\n    [void] EditorLoop() {\r\n        while ($true) {\r\n            $key = [Console]::ReadKey($true)\r\n\r\n            switch ($key.Key) {\r\n                'F1' {\r\n                    $this.Mode = 'description'\r\n                    $this.DrawTaskContent()\r\n                    $this.DrawStatusLine()\r\n                }\r\n                'F2' {\r\n                    $this.Mode = 'metadata'\r\n                    $this.DrawTaskContent()\r\n                    $this.DrawStatusLine()\r\n                }\r\n                'F3' {\r\n                    $this.Mode = 'preview'\r\n                    $this.DrawTaskContent()\r\n                    $this.DrawStatusLine()\r\n                }\r\n                'Escape' {\r\n                    if ($this.ConfirmDoExit()) { return }\r\n                }\r\n                'S' {\r\n                    if ($key.Modifiers -band [ConsoleModifiers]::Control) {\r\n                        $this.SaveTask()\r\n                        return\r\n                    }\r\n                }\r\n                default {\r\n                    $this.HandleModeSpecificInput($key)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    [void] HandleModeSpecificInput([ConsoleKeyInfo]$key) {\r\n        switch ($this.Mode) {\r\n            'description' { $this.HandleDescriptionInput($key) }\r\n            'metadata' { $this.HandleMetadataInput($key) }\r\n            # Preview mode is read-only\r\n        }\r\n\r\n        $this.DrawTaskContent()\r\n        $this.DrawStatusLine()\r\n    }\r\n\r\n    [void] HandleDescriptionInput([ConsoleKeyInfo]$key) {\r\n        switch ($key.Key) {\r\n            'UpArrow' {\r\n                if ($this.CurrentLine -gt 0) {\r\n                    $this.CurrentLine--\r\n                    $this.CursorColumn = [Math]::Min($this.CursorColumn, $this.DescriptionLines[$this.CurrentLine].Length)\r\n                }\r\n            }\r\n            'DownArrow' {\r\n                if ($this.CurrentLine -lt ($this.DescriptionLines.Count - 1)) {\r\n                    $this.CurrentLine++\r\n                    $this.CursorColumn = [Math]::Min($this.CursorColumn, $this.DescriptionLines[$this.CurrentLine].Length)\r\n                }\r\n            }\r\n            'LeftArrow' {\r\n                if ($this.CursorColumn -gt 0) {\r\n                    $this.CursorColumn--\r\n                }\r\n            }\r\n            'RightArrow' {\r\n                if ($this.CursorColumn -lt $this.DescriptionLines[$this.CurrentLine].Length) {\r\n                    $this.CursorColumn++\r\n                }\r\n            }\r\n            'Enter' {\r\n                # Split current line at cursor position\r\n                $currentLineText = $this.DescriptionLines[$this.CurrentLine]\r\n                $beforeCursor = $currentLineText.Substring(0, $this.CursorColumn)\r\n                $afterCursor = $currentLineText.Substring($this.CursorColumn)\r\n\r\n                $this.DescriptionLines[$this.CurrentLine] = $beforeCursor\r\n                $this.DescriptionLines = $this.DescriptionLines[0..$this.CurrentLine] + @($afterCursor) + $this.DescriptionLines[($this.CurrentLine + 1)..($this.DescriptionLines.Count - 1)]\r\n\r\n                $this.CurrentLine++\r\n                $this.CursorColumn = 0\r\n            }\r\n            'Backspace' {\r\n                if ($this.CursorColumn -gt 0) {\r\n                    $currentLineText = $this.DescriptionLines[$this.CurrentLine]\r\n                    $newLine = $currentLineText.Substring(0, $this.CursorColumn - 1) + $currentLineText.Substring($this.CursorColumn)\r\n                    $this.DescriptionLines[$this.CurrentLine] = $newLine\r\n                    $this.CursorColumn--\r\n                } elseif ($this.CurrentLine -gt 0) {\r\n                    # Join with previous line\r\n                    $prevLine = $this.DescriptionLines[$this.CurrentLine - 1]\r\n                    $currentLineText = $this.DescriptionLines[$this.CurrentLine]\r\n                    $this.CursorColumn = $prevLine.Length\r\n                    $this.DescriptionLines[$this.CurrentLine - 1] = $prevLine + $currentLineText\r\n                    $this.DescriptionLines = $this.DescriptionLines[0..($this.CurrentLine - 1)] + $this.DescriptionLines[($this.CurrentLine + 1)..($this.DescriptionLines.Count - 1)]\r\n                    $this.CurrentLine--\r\n                }\r\n            }\r\n            default {\r\n                # Regular character input\r\n                if ([char]::IsControl($key.KeyChar)) { return }\r\n\r\n                $currentLineText = $this.DescriptionLines[$this.CurrentLine]\r\n                $newLine = $currentLineText.Substring(0, $this.CursorColumn) + $key.KeyChar + $currentLineText.Substring($this.CursorColumn)\r\n                $this.DescriptionLines[$this.CurrentLine] = $newLine\r\n                $this.CursorColumn++\r\n            }\r\n        }\r\n    }\r\n\r\n    [void] HandleMetadataInput([ConsoleKeyInfo]$key) {\r\n        # Metadata editing would be implemented here\r\n        # For now, just basic navigation\r\n    }\r\n\r\n    [bool] ConfirmDoExit() {\r\n        if (-not $this.HasUnsavedChanges()) {\r\n            return $true\r\n        }\r\n\r\n        [Console]::SetCursorPosition(0, [PmcTerminalService]::GetHeight() - 1)\r\n        Write-PmcStyled -Style 'Warning' -Text \"Unsaved changes! Exit anyway? (y/N): \" -NoNewline\r\n\r\n        $response = [Console]::ReadKey($true)\r\n        return ($response.Key -eq 'Y')\r\n    }\r\n\r\n    [void] SaveTask() {\r\n        try {\r\n            # Update task data\r\n            $this.TaskData.description = $this.DescriptionLines -join \"`n\"\r\n            $this.TaskData.project = $this.Project\r\n            $this.TaskData.priority = $this.Priority\r\n            $this.TaskData.due = $this.DueDate\r\n\r\n            # Save via PMC command\r\n            $updateCmd = \"task edit $($this.TaskId) '$($this.TaskData.description)'\"\r\n            if ($this.Project) { $updateCmd += \" @$($this.Project)\" }\r\n            if ($this.Priority) { $updateCmd += \" $($this.Priority)\" }\r\n            if ($this.DueDate) { $updateCmd += \" due:$($this.DueDate)\" }\r\n\r\n            Invoke-PmcCommand $updateCmd\r\n\r\n            [Console]::SetCursorPosition(0, [PmcTerminalService]::GetHeight() - 1)\r\n            Write-PmcStyled -Style 'Success' -Text \"[OK] Task saved successfully!\"\r\n            Start-Sleep -Seconds 1\r\n\r\n        } catch {\r\n            [Console]::SetCursorPosition(0, [PmcTerminalService]::GetHeight() - 1)\r\n            Write-PmcStyled -Style 'Error' -Text (\"[ERROR] Error saving task: {0}\" -f $_)\r\n            Start-Sleep -Seconds 2\r\n        }\r\n    }\r\n}\r\n\r\nfunction Invoke-PmcTaskEditor {\r\n    <#\r\n    .SYNOPSIS\r\n    Opens the interactive task editor for a specific task\r\n\r\n    .PARAMETER TaskId\r\n    The ID of the task to edit\r\n\r\n    .EXAMPLE\r\n    Invoke-PmcTaskEditor -TaskId \"123\"\r\n    Opens the full-screen editor for task 123\r\n    ##CLOSEBRACKET##\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$TaskId\r\n    )\r\n\r\n    try {\r\n        $editor = [PmcTaskEditor]::new($TaskId)\r\n        $editor.Show()\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text (\"Error opening task editor: {0}\" -f $_)\r\n    }\r\n}\r\n\r\n# Export for module use\r\n#Export-ModuleMember -Function Invoke-PmcTaskEditor"}, {"path": "module/Pmc.Strict/src/Tasks.ps1", "content": "# Tasks.ps1 - Core task management functions\r\n\r\nfunction Add-PmcTask {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: task add <description>\"\r\n        return\r\n    }\r\n\r\n    $taskText = ($Context.FreeText -join ' ').Trim()\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n\r\n        # Create new task\r\n        $newTask = @{\r\n            id = Get-PmcNextTaskId $allData\r\n            text = $taskText\r\n            project = $allData.currentContext\r\n            priority = 0\r\n            completed = $false\r\n            created = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n            status = 'pending'\r\n            tags = @()\r\n            depends = @()\r\n            notes = @()\r\n            subtasks = @()\r\n            recur = $null\r\n            estimatedMinutes = $null\r\n            due = $null\r\n            nextSuggestedCount = 3\r\n            lastNextShown = (Get-Date).ToString('yyyy-MM-dd')\r\n        }\r\n\r\n        # Add to tasks\r\n        if (-not $allData.tasks) { $allData.tasks = @() }\r\n        $allData.tasks += $newTask\r\n\r\n        # Save data\r\n        Set-PmcAllData $allData\r\n\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Task added: $taskText\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error adding task: $_\"\r\n    }\r\n}\r\n\r\nfunction Add-PmcSubtask {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -lt 2) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: subtask add <taskid> <description>\"\r\n        return\r\n    }\r\n\r\n    $taskId = $Context.FreeText[0]\r\n    $subtaskText = ($Context.FreeText | Select-Object -Skip 1) -join ' '\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $task = $allData.tasks | Where-Object { $_.id -eq $taskId }\r\n\r\n        if (-not $task) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Task #$taskId not found\"\r\n            return\r\n        }\r\n\r\n        # Ensure subtasks array exists\r\n        if (-not $task.subtasks) {\r\n            $task.subtasks = @()\r\n        }\r\n\r\n        # Add subtask as simple string\r\n        $task.subtasks += $subtaskText\r\n\r\n        Set-PmcAllData $allData\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Subtask added to task #${taskId}: $subtaskText\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error adding subtask: $_\"\r\n    }\r\n}\r\n\r\nfunction Get-PmcTaskListOld {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $tasks = $allData.tasks | Where-Object { -not $_.completed }\r\n\r\n        # Apply project filter if specified\r\n        Write-Host \"DEBUG TASK LIST: Context.Args = $($Context.Args | ConvertTo-Json -Compress)\"\r\n        Write-Host \"DEBUG TASK LIST: Context.Args type = $($Context.Args.GetType().Name)\"\r\n        Write-Host \"DEBUG TASK LIST: ContainsKey check = $($Context.Args.ContainsKey('project'))\"\r\n\r\n        if ($Context.Args -and $Context.Args.ContainsKey('project')) {\r\n            $projectFilter = $Context.Args['project']\r\n            Write-Host \"DEBUG: Filtering tasks by project '$projectFilter'\"\r\n            $originalCount = $tasks.Count\r\n            $tasks = $tasks | Where-Object { $_.project -eq $projectFilter }\r\n            Write-Host \"DEBUG: Filtered from $originalCount to $($tasks.Count) tasks\"\r\n        } else {\r\n            Write-Host \"DEBUG: No project filter applied\"\r\n        }\r\n\r\n        if (-not $tasks) {\r\n            $filterMsg = $(if ($Context.Args -and $Context.Args.ContainsKey('project')) { \" for project '$($Context.Args['project'])'\" } else { \"\" })\r\n            Write-PmcStyled -Style 'Info' -Text \"No active tasks found$filterMsg\"\r\n            return\r\n        }\r\n\r\n        # Use universal display\r\n        $title = $(if ($Context.Args -and $Context.Args.ContainsKey('project')) { \"Active Tasks — @$($Context.Args['project'])\" } else { \"Active Tasks\" })\r\n        Show-PmcCustomGrid -Domain 'task' -Data $tasks -Title $title\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error listing tasks: $_\"\r\n    }\r\n}\r\n\r\nfunction Complete-PmcTask {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: task done <id>\"\r\n        return\r\n    }\r\n\r\n    $taskId = $Context.FreeText[0]\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $task = $allData.tasks | Where-Object { $_.id -eq $taskId }\r\n\r\n        if (-not $task) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Task '$taskId' not found\"\r\n            return\r\n        }\r\n\r\n        $task.completed = $true\r\n        $task.status = 'completed'\r\n\r\n        Set-PmcAllData $allData\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Task completed: $($task.text)\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error completing task: $_\"\r\n    }\r\n}\r\n\r\nfunction Remove-PmcTask {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: task delete <id>\"\r\n        return\r\n    }\r\n\r\n    $taskId = $Context.FreeText[0]\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $task = $allData.tasks | Where-Object { $_.id -eq $taskId }\r\n\r\n        if (-not $task) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Task '$taskId' not found\"\r\n            return\r\n        }\r\n\r\n        # Move to deleted\r\n        if (-not $allData.deleted) { $allData.deleted = @() }\r\n        $allData.deleted += $task\r\n\r\n        # Remove from tasks\r\n        $allData.tasks = $allData.tasks | Where-Object { $_.id -ne $taskId }\r\n\r\n        Set-PmcAllData $allData\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Task deleted: $($task.text)\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error deleting task: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcTask {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: task view <id>\"\r\n        return\r\n    }\r\n\r\n    $taskId = $Context.FreeText[0]\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $task = $allData.tasks | Where-Object { $_.id -eq $taskId }\r\n\r\n        if (-not $task) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Task '$taskId' not found\"\r\n            return\r\n        }\r\n\r\n        Write-PmcStyled -Style 'Header' -Text \"`nTask: $($task.text)\"\r\n        Write-PmcStyled -Style 'Body' -Text \"ID: $($task.id)\"\r\n        Write-PmcStyled -Style 'Body' -Text \"Project: $($task.project)\"\r\n        Write-PmcStyled -Style 'Body' -Text \"Priority: $($task.priority)\"\r\n        Write-PmcStyled -Style 'Body' -Text \"Status: $($task.status)\"\r\n        Write-PmcStyled -Style 'Body' -Text \"Created: $($task.created)\"\r\n        if ($task.due) { Write-PmcStyled -Style 'Body' -Text \"Due: $($task.due)\" }\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error viewing task: $_\"\r\n    }\r\n}\r\n\r\nfunction Set-PmcTask {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -lt 3) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: task update <id> <field> <value>\"\r\n        return\r\n    }\r\n\r\n    $taskId = $Context.FreeText[0]\r\n    $field = $Context.FreeText[1]\r\n    $value = ($Context.FreeText[2..($Context.FreeText.Count-1)] -join ' ')\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $task = $allData.tasks | Where-Object { $_.id -eq $taskId }\r\n\r\n        if (-not $task) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Task '$taskId' not found\"\r\n            return\r\n        }\r\n\r\n        switch ($field.ToLower()) {\r\n            'text' { $task.text = $value }\r\n            'priority' { $task.priority = [int]$value }\r\n            'project' { $task.project = $value }\r\n            'due' { $task.due = $value }\r\n            default {\r\n                Write-PmcStyled -Style 'Error' -Text \"Unknown field '$field'. Available: text, priority, project, due\"\r\n                return\r\n            }\r\n        }\r\n\r\n        Set-PmcAllData $allData\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Task updated\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error updating task: $_\"\r\n    }\r\n}\r\n\r\n# Export all task functions\r\nExport-ModuleMember -Function Add-PmcTask, Complete-PmcTask, Remove-PmcTask, Show-PmcTask, Set-PmcTask"}, {"path": "module/Pmc.Strict/src/TemplateDisplay.ps1", "content": "# Template-Based Universal Display System for PMC\r\n# Simple, fast, customizable display without TUI complexity\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Template specification and renderer - class moved to main module file for proper export\r\n\r\n# Built-in templates - initialized lazily to avoid class loading issues\r\n$Script:PmcTemplates = $null\r\n\r\nfunction Initialize-PmcTemplates {\r\n    if ($Script:PmcTemplates) { return }\r\n\r\n    $Script:PmcTemplates = @{\r\n        'task-grid' = [PmcTemplate]::new('task-grid', @{\r\n            type = 'grid'\r\n            header = 'ID    Project      Task                                  Due        Pri'\r\n            row = '{id,-4} {project,-12} {text,-36} {due,-10} {priority,-3}'\r\n            settings = @{ separator = '─'; minWidth = 60 }\r\n        })\r\n\r\n        'task-list' = [PmcTemplate]::new('task-list', @{\r\n            type = 'list'\r\n            row = '[{id}] {text} (@{project}, due: {due}, {priority})'\r\n        })\r\n\r\n        'task-summary' = [PmcTemplate]::new('task-summary', @{\r\n            type = 'summary'\r\n            header = 'Tasks Summary'\r\n            row = '• {text} ({project})'\r\n            footer = 'Total: {count} tasks'\r\n        })\r\n\r\n        'project-card' = [PmcTemplate]::new('project-card', @{\r\n            type = 'card'\r\n            row = @'\r\n┌─ Project: {name} ─────────────────────────\r\n│ Tasks: {task_count} | Completion: {completion}%\r\n│ {description}\r\n└─────────────────────────────────────────\r\n'@\r\n        })\r\n\r\n        'project-list' = [PmcTemplate]::new('project-list', @{\r\n            type = 'list'\r\n            row = '{name,-20} {task_count,3} tasks  {completion,3}%'\r\n        })\r\n\r\n        'time-report' = [PmcTemplate]::new('time-report', @{\r\n            type = 'grid'\r\n            header = 'Date       Project      Hours  Description'\r\n            row = '{date,-10} {project,-12} {hours,5}h {description}'\r\n        })\r\n\r\n        'help-categories' = [PmcTemplate]::new('help-categories', @{\r\n            type = 'grid'\r\n            header = 'Category                    Items  Description'\r\n            row = '{Category,-26} {Items,5}  {Description}'\r\n            settings = @{ separator = '─'; minWidth = 60 }\r\n        })\r\n    }\r\n}\r\n\r\n# Default templates by data type\r\n$Script:PmcDefaultTemplates = @{\r\n    'task' = 'task-grid'\r\n    'project' = 'project-list'\r\n    'time' = 'time-report'\r\n    'timelog' = 'time-report'\r\n    'help' = 'help-categories'\r\n}\r\n\r\n# Universal template renderer\r\nfunction Show-PmcDataWithTemplate {\r\n    param(\r\n        [object[]]$Data,\r\n        [string]$DataType,\r\n        [string]$Template = '',\r\n        [string]$Title = '',\r\n        [hashtable]$Filters = @{}\r\n    )\r\n\r\n    if (-not $Data -or $Data.Count -eq 0) {\r\n        $filterDesc = $(if ($Filters.Count -gt 0) { \" with filters\" } else { \"\" })\r\n        Write-PmcStyled -Style 'Info' -Text \"No $DataType data found$filterDesc\"\r\n        return\r\n    }\r\n\r\n    # Ensure templates are initialized\r\n    Initialize-PmcTemplates\r\n\r\n    # Determine template to use\r\n    $templateName = $Template\r\n    if (-not $templateName) {\r\n        $templateName = $(if ($Script:PmcDefaultTemplates.ContainsKey($DataType)) { $Script:PmcDefaultTemplates[$DataType] } else { 'task-list' })\r\n    }\r\n\r\n    $tmpl = $Script:PmcTemplates[$templateName]\r\n    if (-not $tmpl) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"Template '$templateName' not found, using default\"\r\n        $tmpl = $Script:PmcTemplates['task-list']\r\n    }\r\n\r\n    # Render based on template type\r\n    switch ($tmpl.Type) {\r\n        'grid' { Render-GridTemplate -Data $Data -Template $tmpl -Title $Title }\r\n        'list' { Render-ListTemplate -Data $Data -Template $tmpl -Title $Title }\r\n        'card' { Render-CardTemplate -Data $Data -Template $tmpl -Title $Title }\r\n        'summary' { Render-SummaryTemplate -Data $Data -Template $tmpl -Title $Title }\r\n        default { Render-ListTemplate -Data $Data -Template $tmpl -Title $Title }\r\n    }\r\n}\r\n\r\n# Grid renderer (table-like)\r\nfunction Render-GridTemplate {\r\n    param([object[]]$Data, [PmcTemplate]$Template, [string]$Title)\r\n\r\n    if ($Title) {\r\n        Write-PmcStyled -Style 'Header' -Text $Title\r\n        $sepChar = $(if ($Template.Settings.ContainsKey('separator')) { $Template.Settings.separator } else { '─' })\r\n        Write-Host ($sepChar * 50)\r\n    }\r\n\r\n    # Header\r\n    if ($Template.Header) {\r\n        Write-Host $Template.Header\r\n        $sepChar = $(if ($Template.Settings.ContainsKey('separator')) { $Template.Settings.separator } else { '─' })\r\n        Write-Host ($sepChar * $Template.Header.Length)\r\n    }\r\n\r\n    # Data rows\r\n    foreach ($item in $Data) {\r\n        $rendered = Expand-TemplateString -Template $Template.Row -Data $item\r\n        Write-Host $rendered\r\n    }\r\n}\r\n\r\n# List renderer (simple lines)\r\nfunction Render-ListTemplate {\r\n    param([object[]]$Data, [PmcTemplate]$Template, [string]$Title)\r\n\r\n    if ($Title) {\r\n        Write-PmcStyled -Style 'Header' -Text $Title\r\n        Write-Host ''\r\n    }\r\n\r\n    foreach ($item in $Data) {\r\n        $rendered = Expand-TemplateString -Template $Template.Row -Data $item\r\n        Write-Host $rendered\r\n    }\r\n}\r\n\r\n# Card renderer (multi-line blocks)\r\nfunction Render-CardTemplate {\r\n    param([object[]]$Data, [PmcTemplate]$Template, [string]$Title)\r\n\r\n    if ($Title) {\r\n        Write-PmcStyled -Style 'Header' -Text $Title\r\n        Write-Host ''\r\n    }\r\n\r\n    foreach ($item in $Data) {\r\n        $rendered = Expand-TemplateString -Template $Template.Row -Data $item\r\n        Write-Host $rendered\r\n        Write-Host ''\r\n    }\r\n}\r\n\r\n# Summary renderer (with totals)\r\nfunction Render-SummaryTemplate {\r\n    param([object[]]$Data, [PmcTemplate]$Template, [string]$Title)\r\n\r\n    if ($Title -or $Template.Header) {\r\n        $headerText = $(if ($Title) { $Title } else { $Template.Header })\r\n        Write-PmcStyled -Style 'Header' -Text $headerText\r\n        Write-Host ''\r\n    }\r\n\r\n    foreach ($item in $Data) {\r\n        $rendered = Expand-TemplateString -Template $Template.Row -Data $item\r\n        Write-Host $rendered\r\n    }\r\n\r\n    if ($Template.Footer) {\r\n        Write-Host ''\r\n        $footerData = @{ count = $Data.Count }\r\n        $rendered = Expand-TemplateString -Template $Template.Footer -Data $footerData\r\n        Write-Host $rendered\r\n    }\r\n}\r\n\r\n# Template string expansion with data substitution\r\nfunction Expand-TemplateString {\r\n    param([string]$Template, [object]$Data)\r\n\r\n    $result = $Template\r\n\r\n    # Handle PSCustomObject and hashtables\r\n    $properties = @{}\r\n    if ($Data -is [hashtable]) {\r\n        $properties = $Data\r\n    } elseif ($Data.PSObject) {\r\n        foreach ($prop in $Data.PSObject.Properties) {\r\n            $properties[$prop.Name] = $prop.Value\r\n        }\r\n    }\r\n\r\n    # Replace {field} and {field,width} patterns\r\n    $result = [regex]::Replace($result, '\\{([^}]+)\\}', {\r\n        param($match)\r\n        $fieldSpec = $match.Groups[1].Value\r\n\r\n        # Parse field name and formatting\r\n        $parts = $fieldSpec -split ','\r\n        $fieldName = $parts[0].Trim()\r\n        $format = $(if ($parts.Length -gt 1) { $parts[1].Trim() } else { '' })\r\n\r\n        # Get field value\r\n        $value = $(if ($properties.ContainsKey($fieldName)) { $properties[$fieldName] } else { '' })\r\n        $value = [string]$value\r\n\r\n        # Apply formatting\r\n        if ($format) {\r\n            if ($format -match '^(-?\\d+)$') {\r\n                # Width formatting: {field,10} or {field,-10}\r\n                $width = [int]$format\r\n                if ($width -lt 0) {\r\n                    # Left-align\r\n                    $value = $value.PadRight([Math]::Abs($width))\r\n                } else {\r\n                    # Right-align\r\n                    $value = $value.PadLeft($width)\r\n                }\r\n                # Truncate if too long\r\n                if ($value.Length -gt [Math]::Abs($width)) {\r\n                    $value = $value.Substring(0, [Math]::Abs($width))\r\n                }\r\n            }\r\n        }\r\n\r\n        return $value\r\n    })\r\n\r\n    return $result\r\n}\r\n\r\n# Get available templates\r\nfunction Get-PmcTemplates {\r\n    param([string]$DataType = '')\r\n\r\n    Initialize-PmcTemplates\r\n\r\n    if ($DataType) {\r\n        return $Script:PmcTemplates.Keys | Where-Object { $_ -like \"$DataType-*\" }\r\n    }\r\n\r\n    return $Script:PmcTemplates.Keys\r\n}\r\n\r\n# Add or update template\r\nfunction Set-PmcTemplate {\r\n    param(\r\n        [string]$Name,\r\n        [hashtable]$Config\r\n    )\r\n\r\n    Initialize-PmcTemplates\r\n    $Script:PmcTemplates[$Name] = [PmcTemplate]::new($Name, $Config)\r\n}\r\n\r\n# Template management functions for CommandMap compatibility\r\nfunction Save-PmcTemplate {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    $args = $Context.Args\r\n    if (-not $args.name -or -not $args.type) {\r\n        Write-PmcStyled -Style 'Error' -Text 'Usage: template save name=<name> type=<type> [header=<header>] [row=<row>]'\r\n        return\r\n    }\r\n\r\n    $config = @{\r\n        type = $args.type\r\n    }\r\n    if ($args.header) { $config.header = $args.header }\r\n    if ($args.row) { $config.row = $args.row }\r\n    if ($args.footer) { $config.footer = $args.footer }\r\n\r\n    Set-PmcTemplate -Name $args.name -Config $config\r\n    Write-PmcStyled -Style 'Success' -Text \"Template '$($args.name)' saved\"\r\n}\r\n\r\nfunction Invoke-PmcTemplate {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    $name = ($Context.FreeText -join ' ').Trim()\r\n    if (-not $name) {\r\n        Write-PmcStyled -Style 'Error' -Text 'Usage: template apply <name>'\r\n        return\r\n    }\r\n\r\n    Initialize-PmcTemplates\r\n    if ($Script:PmcTemplates.ContainsKey($name)) {\r\n        Write-PmcStyled -Style 'Success' -Text \"Template '$name' applied\"\r\n    } else {\r\n        Write-PmcStyled -Style 'Error' -Text \"Template '$name' not found\"\r\n    }\r\n}\r\n\r\nfunction Get-PmcTemplateList {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    Initialize-PmcTemplates\r\n    Write-PmcStyled -Style 'Header' -Text 'Available Templates:'\r\n    foreach ($name in $Script:PmcTemplates.Keys | Sort-Object) {\r\n        $template = $Script:PmcTemplates[$name]\r\n        Write-PmcStyled -Style 'Info' -Text \"  $name ($($template.Type))\"\r\n    }\r\n}\r\n\r\nfunction Remove-PmcTemplate {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    $name = ($Context.FreeText -join ' ').Trim()\r\n    if (-not $name) {\r\n        Write-PmcStyled -Style 'Error' -Text 'Usage: template remove <name>'\r\n        return\r\n    }\r\n\r\n    Initialize-PmcTemplates\r\n    if ($Script:PmcTemplates.ContainsKey($name)) {\r\n        $Script:PmcTemplates.Remove($name)\r\n        Write-PmcStyled -Style 'Success' -Text \"Template '$name' removed\"\r\n    } else {\r\n        Write-PmcStyled -Style 'Error' -Text \"Template '$name' not found\"\r\n    }\r\n}\r\n\r\n# Main display function - replaces the complex Show-PmcData\r\nfunction Show-PmcSimpleData {\r\n    param(\r\n        [string]$DataType,\r\n        [hashtable]$Filters = @{},\r\n        [string]$Template = '',\r\n        [string]$Title = ''\r\n    )\r\n\r\n    Write-PmcDebug -Level 2 -Category 'TemplateDisplay' -Message \"Simple data display\" -Data @{\r\n        DataType = $DataType\r\n        Template = $Template\r\n        FilterCount = $Filters.Keys.Count\r\n    }\r\n\r\n    # Get filtered data using existing system\r\n    $data = Get-PmcFilteredData -Domains @($DataType) -Filters $Filters\r\n\r\n    # Generate title if not provided\r\n    if (-not $Title) {\r\n        $Title = $DataType.Substring(0,1).ToUpper() + $DataType.Substring(1) + \"s\"\r\n        if ($Filters.ContainsKey('project')) {\r\n            $Title += \" — @$($Filters.project)\"\r\n        }\r\n    }\r\n\r\n    # Use template renderer\r\n    Show-PmcDataWithTemplate -Data $data -DataType $DataType -Template $Template -Title $Title -Filters $Filters\r\n}\r\n\r\nExport-ModuleMember -Function Show-PmcSimpleData, Show-PmcDataWithTemplate, Get-PmcTemplates, Set-PmcTemplate, Expand-TemplateString, Render-GridTemplate, Render-ListTemplate, Render-CardTemplate, Render-SummaryTemplate, Initialize-PmcTemplates, Save-PmcTemplate, Invoke-PmcTemplate, Get-PmcTemplateList, Remove-PmcTemplate"}, {"path": "module/Pmc.Strict/src/TerminalDimensions.ps1", "content": "# TerminalDimensions.ps1 - Centralized terminal dimension service for PMC\r\n# Provides consistent screen dimension handling across all components\r\n# OPTIMIZED: Reduced cache validity, added resize events, StringBuilder for O(n) performance\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass PmcTerminalService {\r\n    static [int] $CachedWidth = 0\r\n    static [int] $CachedHeight = 0\r\n    static [datetime] $LastUpdate = [datetime]::MinValue\r\n    static [int] $CacheValidityMs = 100  # Reduced from 500ms for snappier resize detection\r\n    \r\n    # Track previous dimensions for resize detection\r\n    static [int] $PreviousWidth = 0\r\n    static [int] $PreviousHeight = 0\r\n    \r\n    # Resize event callbacks\r\n    static [System.Collections.Generic.List[scriptblock]] $OnResizeCallbacks = [System.Collections.Generic.List[scriptblock]]::new()\r\n\r\n    static [hashtable] GetDimensions() {\r\n        $now = [datetime]::Now\r\n        $elapsed = ($now - [PmcTerminalService]::LastUpdate).TotalMilliseconds\r\n        \r\n        # Use cached values if still valid\r\n        if ($elapsed -lt [PmcTerminalService]::CacheValidityMs -and\r\n            [PmcTerminalService]::CachedWidth -gt 0 -and [PmcTerminalService]::CachedHeight -gt 0) {\r\n            return @{\r\n                Width = [PmcTerminalService]::CachedWidth\r\n                Height = [PmcTerminalService]::CachedHeight\r\n                MinWidth = 40\r\n                MinHeight = 10\r\n                IsCached = $true\r\n            }\r\n        }\r\n\r\n        # Refresh cache\r\n        try {\r\n            $newWidth = [Console]::WindowWidth\r\n            $newHeight = [Console]::WindowHeight\r\n            \r\n            # Check for resize\r\n            $resized = ($newWidth -ne [PmcTerminalService]::CachedWidth -or \r\n                       $newHeight -ne [PmcTerminalService]::CachedHeight) -and\r\n                       [PmcTerminalService]::CachedWidth -gt 0\r\n            \r\n            [PmcTerminalService]::PreviousWidth = [PmcTerminalService]::CachedWidth\r\n            [PmcTerminalService]::PreviousHeight = [PmcTerminalService]::CachedHeight\r\n            [PmcTerminalService]::CachedWidth = $newWidth\r\n            [PmcTerminalService]::CachedHeight = $newHeight\r\n            [PmcTerminalService]::LastUpdate = $now\r\n            \r\n            # Fire resize callbacks if dimensions changed\r\n            if ($resized -and [PmcTerminalService]::OnResizeCallbacks.Count -gt 0) {\r\n                foreach ($callback in [PmcTerminalService]::OnResizeCallbacks) {\r\n                    try { & $callback $newWidth $newHeight } catch { }\r\n                }\r\n            }\r\n        } catch {\r\n            # Fallback values if console access fails\r\n            if ([PmcTerminalService]::CachedWidth -eq 0) {\r\n                [PmcTerminalService]::CachedWidth = 80\r\n                [PmcTerminalService]::CachedHeight = 24\r\n            }\r\n        }\r\n\r\n        # Apply minimum constraints\r\n        if ([PmcTerminalService]::CachedWidth -lt 40) { [PmcTerminalService]::CachedWidth = 80 }\r\n        if ([PmcTerminalService]::CachedHeight -lt 10) { [PmcTerminalService]::CachedHeight = 24 }\r\n\r\n        return @{\r\n            Width = [PmcTerminalService]::CachedWidth\r\n            Height = [PmcTerminalService]::CachedHeight\r\n            MinWidth = 40\r\n            MinHeight = 10\r\n            IsCached = $false\r\n        }\r\n    }\r\n\r\n    static [int] GetWidth() {\r\n        return [PmcTerminalService]::GetDimensions().Width\r\n    }\r\n\r\n    static [int] GetHeight() {\r\n        return [PmcTerminalService]::GetDimensions().Height\r\n    }\r\n\r\n    static [void] InvalidateCache() {\r\n        [PmcTerminalService]::LastUpdate = [datetime]::MinValue\r\n    }\r\n    \r\n    # Check for resize without full dimension refresh (for polling in main loop)\r\n    static [bool] CheckForResize() {\r\n        try {\r\n            $currentWidth = [Console]::WindowWidth\r\n            $currentHeight = [Console]::WindowHeight\r\n            if ($currentWidth -ne [PmcTerminalService]::CachedWidth -or \r\n                $currentHeight -ne [PmcTerminalService]::CachedHeight) {\r\n                [PmcTerminalService]::InvalidateCache()\r\n                return $true\r\n            }\r\n        } catch { }\r\n        return $false\r\n    }\r\n    \r\n    # Register a callback for resize events\r\n    static [void] RegisterOnResize([scriptblock]$callback) {\r\n        if ($callback) {\r\n            [PmcTerminalService]::OnResizeCallbacks.Add($callback)\r\n        }\r\n    }\r\n    \r\n    # Unregister a resize callback\r\n    static [void] UnregisterOnResize([scriptblock]$callback) {\r\n        if ($callback) {\r\n            [PmcTerminalService]::OnResizeCallbacks.Remove($callback)\r\n        }\r\n    }\r\n\r\n    static [bool] ValidateContent([string]$Content, [int]$MaxWidth = 0, [int]$MaxHeight = 0) {\r\n        $dims = [PmcTerminalService]::GetDimensions()\r\n        $actualMaxWidth = $(if ($MaxWidth -gt 0) { [Math]::Min($MaxWidth, $dims.Width) } else { $dims.Width })\r\n        $actualMaxHeight = $(if ($MaxHeight -gt 0) { [Math]::Min($MaxHeight, $dims.Height) } else { $dims.Height })\r\n\r\n        $lines = $Content -split \"`n\"\r\n        if (@($lines).Count -gt $actualMaxHeight) { return $false }\r\n\r\n        foreach ($line in $lines) {\r\n            # Strip ANSI codes for accurate width measurement\r\n            $cleanLine = $line -replace '\\e\\[[0-9;]*m', ''\r\n            if ($cleanLine.Length -gt $actualMaxWidth) { return $false }\r\n        }\r\n\r\n        return $true\r\n    }\r\n\r\n    static [string] EnforceContentBounds([string]$Content, [int]$MaxWidth = 0, [int]$MaxHeight = 0) {\r\n        $dims = [PmcTerminalService]::GetDimensions()\r\n        $actualMaxWidth = $(if ($MaxWidth -gt 0) { [Math]::Min($MaxWidth, $dims.Width) } else { $dims.Width })\r\n        $actualMaxHeight = $(if ($MaxHeight -gt 0) { [Math]::Min($MaxHeight, $dims.Height) } else { $dims.Height })\r\n\r\n        $lines = $Content -split \"`n\"\r\n        # Use List instead of array += for O(n) performance\r\n        $resultLines = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Truncate height if needed\r\n        $linesToProcess = $(if (@($lines).Count -gt $actualMaxHeight) {\r\n            $lines[0..($actualMaxHeight - 1)]\r\n        } else {\r\n            $lines\r\n        })\r\n\r\n        # Truncate width for each line\r\n        foreach ($line in $linesToProcess) {\r\n            if ($line.Length -le $actualMaxWidth) {\r\n                $resultLines.Add($line)\r\n            } else {\r\n                # Check if line contains ANSI codes\r\n                if ($line -match '\\e\\[[0-9;]*m') {\r\n                    # Complex truncation preserving ANSI codes\r\n                    $resultLines.Add([PmcTerminalService]::TruncateWithAnsi($line, $actualMaxWidth))\r\n                } else {\r\n                    # Simple truncation\r\n                    $resultLines.Add($line.Substring(0, [Math]::Min($line.Length, $actualMaxWidth - 3)) + \"...\")\r\n                }\r\n            }\r\n        }\r\n\r\n        return ($resultLines -join \"`n\")\r\n    }\r\n\r\n    static [string] TruncateWithAnsi([string]$Text, [int]$MaxWidth) {\r\n        # Preserve ANSI codes while truncating visible text\r\n        # OPTIMIZED: Using StringBuilder for O(n) instead of O(n²) string concatenation\r\n        $ansiPattern = '\\e\\[[0-9;]*m'\r\n        $parts = $Text -split \"($ansiPattern)\"\r\n        $sb = [System.Text.StringBuilder]::new($Text.Length)\r\n        $visibleLength = 0\r\n\r\n        foreach ($part in $parts) {\r\n            if ($part -match $ansiPattern) {\r\n                # ANSI code - add without counting length\r\n                [void]$sb.Append($part)\r\n            } else {\r\n                # Regular text - check length\r\n                $remainingSpace = $MaxWidth - $visibleLength\r\n                if ($remainingSpace -le 0) { break }\r\n\r\n                if ($part.Length -le $remainingSpace) {\r\n                    [void]$sb.Append($part)\r\n                    $visibleLength += $part.Length\r\n                } else {\r\n                    [void]$sb.Append($part.Substring(0, [Math]::Max(0, $remainingSpace - 3)))\r\n                    [void]$sb.Append(\"...\")\r\n                    break\r\n                }\r\n            }\r\n        }\r\n\r\n        return $sb.ToString()\r\n    }\r\n}\r\n\r\n# Convenience functions for backward compatibility\r\nfunction Get-PmcTerminalWidth { return [PmcTerminalService]::GetWidth() }\r\nfunction Get-PmcTerminalHeight { return [PmcTerminalService]::GetHeight() }\r\nfunction Get-PmcTerminalDimensions { return [PmcTerminalService]::GetDimensions() }\r\nfunction Test-PmcContentBounds { param([string]$Content, [int]$MaxWidth = 0, [int]$MaxHeight = 0) return [PmcTerminalService]::ValidateContent($Content, $MaxWidth, $MaxHeight) }\r\nfunction Set-PmcContentBounds { param([string]$Content, [int]$MaxWidth = 0, [int]$MaxHeight = 0) return [PmcTerminalService]::EnforceContentBounds($Content, $MaxWidth, $MaxHeight) }\r\n\r\n#Export-ModuleMember -Function Get-PmcTerminalWidth, Get-PmcTerminalHeight, Get-PmcTerminalDimensions, Test-PmcContentBounds, Set-PmcContentBounds"}, {"path": "module/Pmc.Strict/src/Theme.ps1", "content": "# Theme and Preferences management\n\nfunction Initialize-PmcThemeSystem {\n    # OPTIMIZATION: Initialization guard - skip if already initialized\n    # (unless force flag is set)\n    param([switch]$Force)\n\n    $existingTheme = Get-PmcState -Section 'Display' -Key 'Theme' -ErrorAction SilentlyContinue\n    if ($existingTheme -and -not $Force) {\n        # Already initialized, skip redundant work\n        Write-PmcDebug -Level 3 -Category 'Theme' -Message \"Theme system already initialized (use -Force to re-initialize)\"\n        return\n    }\n\n    # Force VT/ANSI capabilities; no fallbacks\n    $caps = @{ AnsiSupport=$true; TrueColorSupport=$true; IsTTY=$true; NoColor=$false; Platform='forced' }\n    Set-PmcState -Section 'Display' -Key 'Capabilities' -Value $caps\n\n    try {\n        # Normalize theme from config\n        $cfg = Get-PmcConfig\n        $theme = @{ PaletteName='default'; Hex='#33aaff'; TrueColor=$true; HighContrast=$false; ColorBlindMode='none' }\n        \n        try {\n                    if ($cfg.Display -and $cfg.Display.Theme) {\n                        if ($cfg.Display.Theme.Hex) { \n                            $theme.Hex = ($cfg.Display.Theme.Hex.ToString()) \n                        } elseif ($cfg.Display.Theme.Active) {\n                            if ((Test-Path variable:global:PmcDebug) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\n                                Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [Theme] Initialize-PmcThemeSystem: Hex missing, attempting recovery for '$($cfg.Display.Theme.Active)'\"\n                            }\n                            # RECOVERY: Hex missing but Active theme set (e.g. from broken config)\n                            # Attempt to load hex from theme file directly\n                            try {\n                                $themeName = $cfg.Display.Theme.Active\n                                \n                                # Search for themes directory\n                                $searchPaths = @(\n                                    $global:PmcAppRoot,\n                                    $PSScriptRoot,\n                                    (Split-Path $PSScriptRoot -Parent),\n                                    (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent),\n                                    (Split-Path (Split-Path (Split-Path $PSScriptRoot -Parent) -Parent) -Parent)\n                                )\n                                \n                                $jsonPath = $null\n                                foreach ($path in $searchPaths) {\n                                    if ($path -and (Test-Path (Join-Path $path \"themes/$($themeName).json\"))) {\n                                        $jsonPath = Join-Path $path \"themes/$($themeName).json\"\n                                        break\n                                    }\n                                }\n            \n                                if ($jsonPath -and (Test-Path $jsonPath)) {\n                                    $json = Get-Content $jsonPath -Raw | ConvertFrom-Json\n                                    if ($json.Hex) { \n                                        $theme.Hex = $json.Hex \n                                        if ((Test-Path variable:global:PmcDebug) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\n                                            Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [Theme] Initialize-PmcThemeSystem: Recovered Hex '$($theme.Hex)' from $jsonPath\"\n                                        }\n                                    }\n                                }\n                            } catch { }\n                        }\n                        if ($cfg.Display.Theme.Properties) { $theme.Properties = $cfg.Display.Theme.Properties }\n                        if ($cfg.Display.Theme.Enabled -ne $null) { } # reserved for future toggles\n                    }            if ($cfg.Display -and $cfg.Display.Icons -and $cfg.Display.Icons.Mode) {\n                Set-PmcState -Section 'Display' -Key 'Icons' -Value @{ Mode = ($cfg.Display.Icons.Mode.ToString()) }\n            }\n        } catch { }\n        Set-PmcState -Section 'Display' -Key 'Theme' -Value $theme\n\n        # Compute style tokens from theme hex\n        $palette = Get-PmcColorPalette\n        $styles = @{\n            Title    = @{ Fg=$theme.Hex }\n            Header   = @{ Fg=$theme.Hex }\n            Body     = @{ Fg=(Format-Hex-RGB $palette.Text) }\n            Muted    = @{ Fg=(Format-Hex-RGB $palette.Muted) }\n            Success  = @{ Fg=(Format-Hex-RGB $palette.Success) }\n            Warning  = @{ Fg=(Format-Hex-RGB $palette.Warning) }\n            Error    = @{ Fg=(Format-Hex-RGB $palette.Error) }\n            Info     = @{ Fg=$theme.Hex }\n            Prompt   = @{ Fg=(Format-Hex-RGB $palette.Muted) }\n            Border   = @{ Fg=(Format-Hex-RGB $palette.Border) }\n            Highlight= @{ Fg=(Format-Hex-RGB $palette.Bright) }\n            Editing  = @{ Bg=$theme.Hex; Fg='White'; Bold=$true }\n            Selected = @{ Bg=$theme.Hex; Fg='White' }\n            Subheader= @{ Fg=(Format-Hex-RGB $palette.Muted) }\n        }\n        Set-PmcState -Section 'Display' -Key 'Styles' -Value $styles\n\n        # CRITICAL FIX: Ensure PmcThemeManager is initialized to configure PmcThemeEngine\n        # The engine has no properties until the manager calls Configure() on it.\n        try {\n            if (([System.Management.Automation.PSTypeName]'PmcThemeManager').Type) {\n                [void][PmcThemeManager]::GetInstance()\n                # NOTE: Do NOT call Reload() here - it causes issues during initialization\n                # The manager will be properly initialized via Start-PmcTUI.ps1's Theme service registration\n            }\n        } catch {\n            # PmcThemeManager may not be loaded yet (e.g., during module import)\n            if ((Test-Path variable:global:PmcDebug) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\n                Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [Theme] PmcThemeManager init failed: $_\"\n            }\n        }\n    } catch {\n        # Safety catch-all to prevent startup crashes\n        if ((Test-Path variable:global:PmcDebug) -and $global:PmcDebug -and $global:PmcTuiLogFile) {\n            Add-Content $global:PmcTuiLogFile \"[$(Get-Date -F 'HH:mm:ss.fff')] [Theme] Initialize-PmcThemeSystem FATAL ERROR: $_\"\n        }\n    }\n}\n\nfunction Format-Hex-RGB {\n    param($rgb)\n    if (-not $rgb -or -not $rgb.R) { return '#FFFFFF' }\n    return \"#{0:X2}{1:X2}{2:X2}\" -f $rgb.R,$rgb.G,$rgb.B\n}\n\nfunction Set-PmcTheme {\n    param([PmcCommandContext]$Context)\n    Write-PmcDebug -Level 1 -Category \"Theme\" -Message \"Starting theme set\" -Data @{ FreeText = $Context.FreeText }\n    $cfg = Get-PmcConfig\n    $color = ($Context.FreeText -join ' ').Trim()\n    if ([string]::IsNullOrWhiteSpace($color)) {\n        Write-PmcStyled -Style 'Warning' -Text \"Usage: theme <#RRGGBB> | <preset>\"\n        Write-PmcStyled -Style 'Muted' -Text \"Presets: ocean, lime, purple, slate\"\n        return\n    }\n    $hex = $null\n    switch -Regex ($color.ToLower()) {\n        '^#?[0-9a-f]{6}$' { $hex = $(if ($color.StartsWith('#')) { $color } else { '#'+$color }); break }\n        '^ocean$'   { $hex = '#33aaff'; break }\n        '^lime$'    { $hex = '#33cc66'; break }\n        '^purple$'  { $hex = '#9966ff'; break }\n        '^slate$'   { $hex = '#8899aa'; break }\n        default     { }\n    }\n    if (-not $hex) { Write-PmcStyled -Style 'Error' -Text \"Invalid color. Use #RRGGBB or a preset.\"; return }\n    try {\n        if (-not $cfg.Display) { $cfg.Display = @{} }\n        if (-not $cfg.Display.Theme) { $cfg.Display.Theme = @{} }\n        $cfg.Display.Theme.Hex = $hex\n        $cfg.Display.Theme.Enabled = $true\n        Save-PmcConfig $cfg\n        Write-PmcStyled -Style 'Success' -Text (\"Theme color set to {0}\" -f $hex)\n    } catch {\n        Write-PmcStyled -Style 'Error' -Text \"Failed to save theme\"\n    }\n}\n\nfunction Reset-PmcTheme {\n    param($Context = $null)\n    try {\n        $cfg = Get-PmcConfig\n        if (-not $cfg) { $cfg = @{} }\n        if (-not (Pmc-HasProp $cfg 'Display')) { $cfg | Add-Member -NotePropertyName 'Display' -NotePropertyValue @{} -Force }\n        if (-not (Pmc-HasProp $cfg.Display 'Theme')) { $cfg.Display | Add-Member -NotePropertyName 'Theme' -NotePropertyValue @{} -Force }\n        $cfg.Display.Theme.Hex = '#33aaff'\n        $cfg.Display.Theme.Enabled = $true\n        Save-PmcConfig $cfg\n        Write-PmcStyled -Style 'Success' -Text \"Theme reset to default (#33aaff)\"\n    } catch {\n        Write-PmcStyled -Style 'Warning' -Text \"Theme reset completed (config may be read-only)\"\n    }\n}\n\nfunction Set-PmcIconMode {\n    param([PmcCommandContext]$Context)\n    $mode = ($Context.FreeText -join ' ').Trim().ToLower()\n    if ([string]::IsNullOrWhiteSpace($mode)) {\n        Write-PmcStyled -Style 'Warning' -Text \"Usage: config icons ascii|emoji\"\n        return\n    }\n    if ($mode -notin @('ascii','emoji')) { Write-PmcStyled -Style 'Error' -Text \"Invalid mode. Use ascii or emoji.\"; return }\n    $cfg = Get-PmcConfig\n    if (-not $cfg.Display) { $cfg.Display = @{} }\n    if (-not $cfg.Display.Icons) { $cfg.Display.Icons = @{} }\n    $cfg.Display.Icons.Mode = $mode\n    Save-PmcConfig $cfg\n    Write-PmcStyled -Style 'Success' -Text (\"Icon mode set to {0}\" -f $mode)\n}\n\nfunction Edit-PmcTheme {\n    param([PmcCommandContext]$Context)\n\n    # Read current theme\n    $cfg = Get-PmcConfig\n    $hex = try { if ($cfg.Display -and $cfg.Display.Theme -and $cfg.Display.Theme.Hex) { [string]$cfg.Display.Theme.Hex } else { '#33aaff' } } catch { '#33aaff' }\n    if (-not $hex.StartsWith('#')) { $hex = '#'+$hex }\n    $rgb = ConvertFrom-PmcHex $hex\n    $r = [int]$rgb.R; $g=[int]$rgb.G; $b=[int]$rgb.B\n    $chan = 0  # 0=R,1=G,2=B\n\n    $done = $false\n    while (-not $done) {\n        # Render UI\n        Write-Host ([PraxisVT]::ClearScreen())\n        Show-PmcHeader -Title 'THEME ADJUSTER' -Icon '🎨'\n        Write-Host ''\n\n        # Preview box\n        $preview = [PmcVT]::BgRGB($r,$g,$b) + '          ' + [PmcVT]::Reset() + (\"  #{0:X2}{1:X2}{2:X2}\" -f $r,$g,$b)\n        Write-Host (\"  Preview: \" + $preview)\n        Write-Host ''\n\n        # Sliders\n        Show-Slider -Label 'R' -Value $r -Selected:($chan -eq 0)\n        Show-Slider -Label 'G' -Value $g -Selected:($chan -eq 1)\n        Show-Slider -Label 'B' -Value $b -Selected:($chan -eq 2)\n\n        Write-Host ''\n        Write-Host '  Use ↑/↓ to select channel, ←/→ to adjust, PgUp/PgDn for ±10, Enter to save, Esc to cancel' -ForegroundColor DarkGray\n\n        # Read key\n        $k = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')\n        switch ($k.VirtualKeyCode) {\n            38 { $chan = [Math]::Max(0, $chan - 1) }       # Up\n            40 { $chan = [Math]::Min(2, $chan + 1) }       # Down\n            37 { if ($chan -eq 0) { $r = [Math]::Max(0,$r-1) } elseif ($chan -eq 1) { $g=[Math]::Max(0,$g-1) } else { $b=[Math]::Max(0,$b-1) } }  # Left\n            39 { if ($chan -eq 0) { $r = [Math]::Min(255,$r+1) } elseif ($chan -eq 1) { $g=[Math]::Min(255,$g+1) } else { $b=[Math]::Min(255,$b+1) } } # Right\n            33 { if ($chan -eq 0) { $r = [Math]::Min(255,$r+10) } elseif ($chan -eq 1) { $g=[Math]::Min(255,$g+10) } else { $b=[Math]::Min(255,$b+10) } } # PgUp\n            34 { if ($chan -eq 0) { $r = [Math]::Max(0,$r-10) } elseif ($chan -eq 1) { $g=[Math]::Max(0,$g-10) } else { $b=[Math]::Max(0,$b-10) } } # PgDn\n            13 {\n                # Enter: save and exit\n                $newHex = (\"#{0:X2}{1:X2}{2:X2}\" -f $r,$g,$b)\n                if (-not $cfg.Display) { $cfg.Display=@{} }\n                if (-not $cfg.Display.Theme) { $cfg.Display.Theme=@{} }\n                $cfg.Display.Theme.Hex = $newHex\n                Save-PmcConfig $cfg\n                Write-Host \"Saved theme: $newHex\" -ForegroundColor Green\n                Start-Sleep -Milliseconds 400\n                $done = $true\n            }\n            27 { $done = $true } # Esc: cancel\n            default {}\n        }\n    }\n}\n\nfunction Show-Slider {\n    param(\n        [string]$Label,\n        [int]$Value,\n        [switch]$Selected\n    )\n    $width = 32\n    $filled = [int]([Math]::Round(($Value / 255.0) * $width))\n    $bar = ('#' * $filled) + ('-' * ($width - $filled))\n    $sel = $(if ($Selected) { '▶' } else { ' ' })\n    $fg = $(if ($Selected) { 'White' } else { 'Gray' })\n    Write-Host (\"  {0} {1}: [{2}] {3,3}\" -f $sel, $Label, $bar, $Value) -ForegroundColor $fg\n}\n\nfunction Show-PmcPreferences {\n    param([PmcCommandContext]$Context)\n    $cfg = Get-PmcConfig\n    Write-Host \"\\nPREFERENCES\" -ForegroundColor Cyan\n    Write-PmcStyled -Style 'Border' -Text \"───────────\"\n    Write-Host (\"1) Theme color: {0}\" -f $(if ($null -ne $cfg.Display.Theme.Hex) { $cfg.Display.Theme.Hex } else { '#33aaff' }))\n    Write-Host (\"2) Icons: {0}\" -f $(if ($null -ne $cfg.Display.Icons.Mode) { $cfg.Display.Icons.Mode } else { 'emoji' }))\n    Write-Host (\"3) CSV ledger: {0}\" -f $(if ($null -ne $cfg.Behavior.EnableCsvLedger) { $cfg.Behavior.EnableCsvLedger } else { $true }))\n    Write-Host \"q) Quit\"\n    while ($true) {\n        $sel = Read-Host \"Select option (1/2/3/q)\"\n        switch ($sel) {\n            '1' {\n                # Launch interactive adjuster with preview and sliders\n                $ctx = [PmcCommandContext]::new('theme','adjust')\n                Edit-PmcTheme -Context $ctx\n            }\n            '2' {\n                $m = Read-Host \"Enter icons mode (ascii/emoji)\"\n                $ctx = [PmcCommandContext]::new('config','icons'); $ctx.FreeText = @($m)\n                Set-PmcIconMode -Context $ctx\n            }\n            '3' {\n                $v = Read-Host \"Enable CSV ledger? (y/n)\"\n                $flag = ($v -match '^(?i)y')\n                if (-not $cfg.Behavior) { $cfg.Behavior=@{} }\n                $cfg.Behavior.EnableCsvLedger = $flag\n                Save-PmcConfig $cfg\n                Write-Host (\"CSV ledger set to {0}\" -f $flag) -ForegroundColor Green\n            }\n            'q' { break }\n            default { Write-Host 'Invalid choice' -ForegroundColor Yellow }\n        }\n    }\n}\n\n# Additional theme utilities and commands\nfunction Get-PmcThemeList { [PmcCommandContext]$Context | Out-Null; @('default','ocean','#33aaff','lime','#33cc66','purple','#9966ff','slate','#8899aa','high-contrast') | ForEach-Object { Write-Host $_ } }\n\nfunction Apply-PmcTheme {\n    param([PmcCommandContext]$Context)\n    $arg = ($Context.FreeText -join ' ').Trim()\n    if (-not $arg) { Write-Host \"Usage: theme apply <name|#RRGGBB>\" -ForegroundColor Yellow; return }\n    $hex = $null\n    switch -Regex ($arg.ToLower()) {\n        '^#?[0-9a-f]{6}$' { $hex = $(if ($arg.StartsWith('#')) { $arg } else { '#'+$arg }); break }\n        '^(default|ocean)$' { $hex = '#33aaff'; break }\n        '^lime$'    { $hex = '#33cc66'; break }\n        '^purple$'  { $hex = '#9966ff'; break }\n        '^slate$'   { $hex = '#8899aa'; break }\n        '^high-contrast$' { $hex = '#00ffff'; break }\n        default {}\n    }\n    if (-not $hex) { Write-Host \"Unknown theme; see 'theme list'\" -ForegroundColor Yellow; return }\n    $cfg = Get-PmcConfig\n    if (-not $cfg.Display) { $cfg.Display=@{} }\n    if (-not $cfg.Display.Theme) { $cfg.Display.Theme=@{} }\n    $cfg.Display.Theme.Hex = $hex\n    Save-PmcConfig $cfg\n    Initialize-PmcThemeSystem\n    Write-Host (\"Theme applied: {0}\" -f $hex) -ForegroundColor Green\n}\n\nfunction Show-PmcThemeInfo { param([PmcCommandContext]$Context)\n    $disp = Get-PmcState -Section 'Display'\n    $theme = $disp.Theme\n    Write-Host \"Theme: $($theme.PaletteName) $($theme.Hex)  TrueColor=$($theme.TrueColor) HighContrast=$($theme.HighContrast)\" -ForegroundColor Cyan\n}\n\nfunction Reload-PmcConfig { param([PmcCommandContext]$Context)\n    # Re-apply runtime from config (providers already return latest on read)\n    $cfg = Get-PmcConfig\n    $lvl = try { [int]$cfg.Debug.Level } catch { 0 }\n    Initialize-PmcDebugSystem -Level $lvl\n    Initialize-PmcSecuritySystem\n    Initialize-PmcThemeSystem\n    Ensure-PmcUniversalDisplay\n    Write-Host \"Configuration reloaded and systems re-initialized\" -ForegroundColor Green\n}\n\nExport-ModuleMember -Function Initialize-PmcThemeSystem, Set-PmcTheme, Reset-PmcTheme, Set-PmcIconMode, Edit-PmcTheme, Show-Slider, Show-PmcPreferences, Get-PmcThemeList, Apply-PmcTheme, Show-PmcThemeInfo\n"}, {"path": "module/Pmc.Strict/src/Time.ps1", "content": "# Time.ps1 - Time tracking and timer functions\r\n\r\nfunction Add-PmcTimeEntry {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n\r\n        # Default values for new time entry\r\n        $entry = @{\r\n            id = Get-PmcNextTimeId $allData\r\n            project = $allData.currentContext\r\n            id1 = $null\r\n            id2 = $null\r\n            date = (Get-Date).ToString('yyyy-MM-dd')\r\n            minutes = 0\r\n            description = \"\"\r\n            created = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n        }\r\n\r\n        # Parse free text for time entry details\r\n        if ($Context.FreeText.Count -gt 0) {\r\n            $text = ($Context.FreeText -join ' ').Trim()\r\n\r\n            # Parse minutes from text (look for numbers followed by 'm' or 'min')\r\n            if ($text -match '(\\d+)m(?:in)?') {\r\n                $entry.minutes = [int]$matches[1]\r\n                $text = $text -replace '\\d+m(?:in)?', ''\r\n            }\r\n\r\n            # Parse indirect code from #code syntax (2-5 digits)\r\n            if ($text -match '#(\\d{2,5})') {\r\n                $entry.id1 = $matches[1]\r\n                $entry.project = $null  # Indirect means no project\r\n                $text = $text -replace '#\\d{2,5}', ''\r\n            }\r\n            # Parse project from @project syntax (only if no indirect code)\r\n            elseif ($text -match '@(\\w+)') {\r\n                $entry.project = $matches[1]\r\n                $text = $text -replace '@\\w+', ''\r\n            }\r\n\r\n            # Parse date - enhanced with +/- relative dates\r\n            $dateSet = $false\r\n\r\n            # Check for relative dates: today, tomorrow, +N, -N\r\n            if ($text -match '\\b(today)\\b') {\r\n                $entry.date = (Get-Date).ToString('yyyy-MM-dd')\r\n                $text = $text -replace '\\btoday\\b', ''\r\n                $dateSet = $true\r\n            } elseif ($text -match '\\b(tomorrow)\\b') {\r\n                $entry.date = (Get-Date).AddDays(1).ToString('yyyy-MM-dd')\r\n                $text = $text -replace '\\btomorrow\\b', ''\r\n                $dateSet = $true\r\n            } elseif ($text -match '\\+(\\d+)\\b') {\r\n                $daysAhead = [int]$matches[1]\r\n                $entry.date = (Get-Date).AddDays($daysAhead).ToString('yyyy-MM-dd')\r\n                $text = $text -replace '\\+\\d+\\b', ''\r\n                $dateSet = $true\r\n            } elseif ($text -match '\\-(\\d+)\\b') {\r\n                $daysAgo = [int]$matches[1]\r\n                $entry.date = (Get-Date).AddDays(-$daysAgo).ToString('yyyy-MM-dd')\r\n                $text = $text -replace '\\-\\d+\\b', ''\r\n                $dateSet = $true\r\n            }\r\n\r\n            # If no relative date, check for YYYYMMDD or MMDD format\r\n            if (-not $dateSet -and $text -match '\\b(?:(\\d{4})(\\d{2})(\\d{2})|(\\d{2})(\\d{2}))\\b') {\r\n                if ($matches[1]) {\r\n                    # YYYYMMDD format\r\n                    $year = [int]$matches[1]\r\n                    $month = [int]$matches[2]\r\n                    $day = [int]$matches[3]\r\n                } else {\r\n                    # MMDD format - assume current year\r\n                    $year = (Get-Date).Year\r\n                    $month = [int]$matches[4]\r\n                    $day = [int]$matches[5]\r\n                }\r\n                try {\r\n                    $entry.date = (Get-Date -Year $year -Month $month -Day $day).ToString('yyyy-MM-dd')\r\n                    $text = $text -replace '\\b(?:\\d{4}\\d{2}\\d{2}|\\d{2}\\d{2})\\b', ''\r\n                } catch {\r\n                    # Invalid date, keep default\r\n                }\r\n            }\r\n\r\n            # Rest is description\r\n            $entry.description = $text.Trim()\r\n        }\r\n\r\n        # Add to time entries\r\n        if (-not $allData.timelogs) { $allData.timelogs = @() }\r\n        $allData.timelogs += $entry\r\n\r\n        Set-PmcAllData $allData\r\n        $target = $(if ($entry.id1) { \"#$($entry.id1)\" } else { \"@$($entry.project)\" })\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Time entry added: $($entry.minutes)m $target - $($entry.description)\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error adding time entry: $_\"\r\n    }\r\n}\r\n\r\nfunction Get-PmcTimeReport {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $timelogs = $allData.timelogs | Where-Object { $_ }\r\n\r\n        if (-not $timelogs) {\r\n            Write-PmcStyled -Style 'Info' -Text \"No time entries found\"\r\n            return\r\n        }\r\n\r\n        # Determine week to display (current week default)\r\n        $weekOffset = 0\r\n        if ($Context.Args.ContainsKey('week')) {\r\n            try { $weekOffset = [int]$Context.Args['week'] } catch {}\r\n        }\r\n\r\n        Show-PmcWeeklyTimeReport -TimeLogs $timelogs -WeekOffset $weekOffset\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error generating time report: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcWeeklyTimeReport {\r\n    param([array]$TimeLogs, [int]$WeekOffset = 0)\r\n\r\n    # Calculate week start (Monday)\r\n    $today = Get-Date\r\n    $daysFromMonday = ($today.DayOfWeek.value__ + 6) % 7  # Monday = 0\r\n    $thisMonday = $today.AddDays(-$daysFromMonday).Date\r\n    $weekStart = $thisMonday.AddDays($WeekOffset * 7)\r\n    $weekEnd = $weekStart.AddDays(4)  # Friday\r\n\r\n    # Week header\r\n    $weekHeader = \"Week of {0} - {1}\" -f $weekStart.ToString('MMM dd'), $weekEnd.ToString('MMM dd, yyyy')\r\n\r\n    Write-Host \"\"\r\n    Write-PmcStyled -Style 'Header' -Text \"TIME REPORT\"\r\n    Write-PmcStyled -Style 'Header' -Text $weekHeader\r\n    Write-PmcStyled -Style 'Muted' -Text \"Use '=' next week, '-' previous week\"\r\n    Write-Host \"\"\r\n\r\n    # Filter logs for the week\r\n    $weekLogs = @()\r\n    for ($d = 0; $d -lt 5; $d++) {\r\n        $dayDate = $weekStart.AddDays($d).ToString('yyyy-MM-dd')\r\n        $dayLogs = $TimeLogs | Where-Object { $_.date -eq $dayDate }\r\n        $weekLogs += $dayLogs\r\n    }\r\n\r\n    if ($weekLogs.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Warning' -Text \"No time entries for this week\"\r\n        return\r\n    }\r\n\r\n    # Group by project/indirect code\r\n    $grouped = @{}\r\n    foreach ($log in $weekLogs) {\r\n        $key = $(if ($log.id1) {\r\n            \"#$($log.id1)\"\r\n        } else {\r\n            if ($null -ne $log.project) { $log.project } else { 'Unknown' }\r\n        })\r\n\r\n        if (-not $grouped.ContainsKey($key)) {\r\n            $grouped[$key] = @{\r\n                Name = $(if ($log.id1) { \"\" } else { if ($null -ne $log.project) { $log.project } else { 'Unknown' } })\r\n                ID1 = $(if ($log.id1) { $log.id1 } else { '' })\r\n                ID2 = $(if ($log.id1) { '' } else { '' })\r\n                Mon = 0; Tue = 0; Wed = 0; Thu = 0; Fri = 0; Total = 0\r\n            }\r\n        }\r\n\r\n        # Add minutes to appropriate day\r\n        $logDate = [datetime]$log.date\r\n        $dayIndex = ($logDate.DayOfWeek.value__ + 6) % 7  # Monday = 0\r\n        $hours = [Math]::Round($log.minutes / 60.0, 1)\r\n\r\n        switch ($dayIndex) {\r\n            0 { $grouped[$key].Mon += $hours }\r\n            1 { $grouped[$key].Tue += $hours }\r\n            2 { $grouped[$key].Wed += $hours }\r\n            3 { $grouped[$key].Thu += $hours }\r\n            4 { $grouped[$key].Fri += $hours }\r\n        }\r\n        $grouped[$key].Total += $hours\r\n    }\r\n\r\n    # Get theme styles and build color codes\r\n    $headerStyle = Get-PmcStyle 'Header'\r\n    $bodyStyle = Get-PmcStyle 'Body'\r\n    $borderStyle = Get-PmcStyle 'Border'\r\n    $highlightStyle = Get-PmcStyle 'Highlight'\r\n    $mutedStyle = Get-PmcStyle 'Muted'\r\n\r\n    # Convert hex colors to VT sequences\r\n    $headerColor = $(if ($headerStyle.Fg -match '^#') { $rgb = ConvertFrom-PmcHex $headerStyle.Fg; [PmcVT]::FgRGB($rgb.R, $rgb.G, $rgb.B) } else { \"\" })\r\n    $bodyColor = $(if ($bodyStyle.Fg -match '^#') { $rgb = ConvertFrom-PmcHex $bodyStyle.Fg; [PmcVT]::FgRGB($rgb.R, $rgb.G, $rgb.B) } else { \"\" })\r\n    $borderColor = $(if ($borderStyle.Fg -match '^#') { $rgb = ConvertFrom-PmcHex $borderStyle.Fg; [PmcVT]::FgRGB($rgb.R, $rgb.G, $rgb.B) } else { \"\" })\r\n    $highlightColor = $(if ($highlightStyle.Fg -match '^#') { $rgb = ConvertFrom-PmcHex $highlightStyle.Fg; [PmcVT]::FgRGB($rgb.R, $rgb.G, $rgb.B) } else { \"\" })\r\n    $mutedColor = $(if ($mutedStyle.Fg -match '^#') { $rgb = ConvertFrom-PmcHex $mutedStyle.Fg; [PmcVT]::FgRGB($rgb.R, $rgb.G, $rgb.B) } else { \"\" })\r\n    $reset = [PmcVT]::Reset()\r\n\r\n    # Display table\r\n    $headerFormat = \"{0,-20} {1,-5} {2,-5} {3,6} {4,6} {5,6} {6,6} {7,6} {8,8}\"\r\n    $rowFormat = \"{0,-20} {1,-5} {2,-5} {3,6:F1} {4,6:F1} {5,6:F1} {6,6:F1} {7,6:F1} {8,8:F1}\"\r\n\r\n    Write-Host \"$headerColor\" + ($headerFormat -f \"Name\", \"ID1\", \"ID2\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Total\") + \"$reset\"\r\n    Write-Host \"$borderColor\" + (\"─\" * 80) + \"$reset\"\r\n\r\n    $grandTotal = 0\r\n    foreach ($entry in ($grouped.GetEnumerator() | Sort-Object Key)) {\r\n        $data = $entry.Value\r\n        Write-Host \"$bodyColor\" + ($rowFormat -f $data.Name, $data.ID1, $data.ID2, $data.Mon, $data.Tue, $data.Wed, $data.Thu, $data.Fri, $data.Total) + \"$reset\"\r\n        $grandTotal += $data.Total\r\n    }\r\n\r\n    Write-Host \"$borderColor\" + (\"─\" * 80) + \"$reset\"\r\n    Write-Host \"$highlightColor\" + ($headerFormat -f \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"Total:\", $grandTotal.ToString('F1')) + \"$reset\"\r\n\r\n    # Interactive week navigation\r\n    Write-Host \"`n$mutedColor\" + \"Press '=' for next week, '-' for previous week, any other key to exit\" + \"$reset\"\r\n\r\n    while ($true) {\r\n        if (-not $Host.UI.RawUI.KeyAvailable) {\r\n            Start-Sleep -Milliseconds 50\r\n            continue\r\n        }\r\n        $key = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')\r\n        if ($key.Character -eq '=') {\r\n            Show-PmcWeeklyTimeReport -TimeLogs $TimeLogs -WeekOffset ($WeekOffset + 1)\r\n            return\r\n        } elseif ($key.Character -eq '-') {\r\n            Show-PmcWeeklyTimeReport -TimeLogs $TimeLogs -WeekOffset ($WeekOffset - 1)\r\n            return\r\n        } else {\r\n            return\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-PmcTimeList {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $timelogs = $allData.timelogs | Where-Object { $_ }\r\n\r\n        if (-not $timelogs) {\r\n            Write-PmcStyled -Style 'Info' -Text \"No time entries found\"\r\n            return\r\n        }\r\n\r\n        # Filter recent entries (last 30 days)\r\n        $recent = $timelogs | Where-Object {\r\n            [datetime]$_.date -ge (Get-Date).AddDays(-30)\r\n        } | Sort-Object date -Descending\r\n\r\n        # Use template display\r\n        $timeTemplate = [PmcTemplate]::new('time-list', @{\r\n            type = 'grid'\r\n            header = 'ID     Date       Project/Code  Hours   Description'\r\n            row = '{id,-6} {date,-10} {target,-12} {hours,6:F1} {description}'\r\n            settings = @{ separator = '─'; minWidth = 60 }\r\n        })\r\n\r\n        # Format data for display\r\n        $displayData = @()\r\n        foreach ($log in $recent) {\r\n            $target = $(if ($log.id1) { \"#$($log.id1)\" } else { if ($null -ne $log.project) { $log.project } else { 'Unknown' } })\r\n            $hours = [Math]::Round($log.minutes / 60.0, 1)\r\n            $displayData += [pscustomobject]@{\r\n                id = $log.id\r\n                date = $log.date\r\n                target = $target\r\n                hours = $hours\r\n                description = $(if ($null -ne $log.description) { $log.description } else { '' })\r\n            }\r\n        }\r\n\r\n        Write-PmcStyled -Style 'Header' -Text \"`nRECENT TIME ENTRIES`n\"\r\n        Render-GridTemplate -Data $displayData -Template $timeTemplate\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error listing time entries: $_\"\r\n    }\r\n}\r\n\r\nfunction Edit-PmcTimeEntry {\r\n    param($Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: time edit <id>\"\r\n        return\r\n    }\r\n\r\n    $entryId = $Context.FreeText[0]\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $entry = $allData.timelogs | Where-Object { $_.id -eq $entryId }\r\n\r\n        if (-not $entry) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Time entry '$entryId' not found\"\r\n            return\r\n        }\r\n\r\n        Write-PmcStyled -Style 'Info' -Text \"Time entry editing not yet implemented\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error editing time entry: $_\"\r\n    }\r\n}\r\n\r\nfunction Remove-PmcTimeEntry {\r\n    param($Context)\r\n\r\n    if (-not $Context -or $Context.FreeText.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Error' -Text \"Usage: time delete <id>\"\r\n        return\r\n    }\r\n\r\n    $entryId = $Context.FreeText[0]\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $entry = $allData.timelogs | Where-Object { $_.id -eq $entryId }\r\n\r\n        if (-not $entry) {\r\n            Write-PmcStyled -Style 'Error' -Text \"Time entry '$entryId' not found\"\r\n            return\r\n        }\r\n\r\n        # Remove from time logs\r\n        $allData.timelogs = $allData.timelogs | Where-Object { $_.id -ne $entryId }\r\n\r\n        Set-PmcAllData $allData\r\n        Write-PmcStyled -Style 'Success' -Text \"[OK] Time entry deleted\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error deleting time entry: $_\"\r\n    }\r\n}\r\n\r\nfunction Start-PmcTimer {\r\n    param($Context)\r\n\r\n    try {\r\n        $project = $(if ($Context.FreeText.Count -gt 0) {\r\n            $Context.FreeText[0]\r\n        } else {\r\n            $allData = Get-PmcAllData\r\n            $allData.currentContext\r\n        })\r\n\r\n        Set-PmcState -Section 'Timer' -Key 'Running' -Value $true\r\n        Set-PmcState -Section 'Timer' -Key 'Project' -Value $project\r\n        Set-PmcState -Section 'Timer' -Key 'StartTime' -Value (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n\r\n        Write-PmcStyled -Style 'Success' -Text \"Timer started for project: $project\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error starting timer: $_\"\r\n    }\r\n}\r\n\r\nfunction Stop-PmcTimer {\r\n    param($Context)\r\n\r\n    try {\r\n        $running = Get-PmcState -Section 'Timer' -Key 'Running'\r\n        if (-not $running) {\r\n            Write-PmcStyled -Style 'Warning' -Text \"No timer is currently running\"\r\n            return\r\n        }\r\n\r\n        $project = Get-PmcState -Section 'Timer' -Key 'Project'\r\n        $startTime = [datetime](Get-PmcState -Section 'Timer' -Key 'StartTime')\r\n        $endTime = Get-Date\r\n        $minutes = [Math]::Round(($endTime - $startTime).TotalMinutes, 0)\r\n\r\n        # Create time entry\r\n        $allData = Get-PmcAllData\r\n        $entry = @{\r\n            id = Get-PmcNextTimeId $allData\r\n            project = $project\r\n            date = $startTime.ToString('yyyy-MM-dd')\r\n            minutes = $minutes\r\n            description = \"Timer session\"\r\n            created = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n        }\r\n\r\n        if (-not $allData.timelogs) { $allData.timelogs = @() }\r\n        $allData.timelogs += $entry\r\n        Set-PmcAllData $allData\r\n\r\n        # Clear timer state\r\n        Set-PmcState -Section 'Timer' -Key 'Running' -Value $false\r\n\r\n        Write-PmcStyled -Style 'Success' -Text \"Timer stopped. Logged $minutes minutes to $project\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error stopping timer: $_\"\r\n    }\r\n}\r\n\r\nfunction Get-PmcTimerStatus {\r\n    param($Context)\r\n\r\n    try {\r\n        $running = Get-PmcState -Section 'Timer' -Key 'Running'\r\n\r\n        if (-not $running) {\r\n        Write-PmcStyled -Style 'Info' -Text \"No timer is currently running\"\r\n            return\r\n        }\r\n\r\n        $project = Get-PmcState -Section 'Timer' -Key 'Project'\r\n        $startTime = [datetime](Get-PmcState -Section 'Timer' -Key 'StartTime')\r\n        $elapsed = (Get-Date) - $startTime\r\n        $minutes = [Math]::Round($elapsed.TotalMinutes, 0)\r\n\r\n        Write-PmcStyled -Style 'Warning' -Text \"Timer running for $project ($minutes minutes elapsed)\"\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error checking timer status: $_\"\r\n    }\r\n}\r\n\r\nfunction Get-PmcNextTimeId {\r\n    param($data)\r\n\r\n    if (-not $data.timelogs -or $data.timelogs.Count -eq 0) {\r\n        return \"T001\"\r\n    }\r\n\r\n    $maxId = 0\r\n    foreach ($entry in $data.timelogs) {\r\n        if ($entry.id -match '^T(\\d+)$') {\r\n            $num = [int]$matches[1]\r\n            if ($num -gt $maxId) { $maxId = $num }\r\n        }\r\n    }\r\n\r\n    return \"T{0:000}\" -f ($maxId + 1)\r\n}\r\n\r\nExport-ModuleMember -Function Add-PmcTimeEntry, Get-PmcTimeReport, Get-PmcTimeList, Edit-PmcTimeEntry, Remove-PmcTimeEntry, Start-PmcTimer, Stop-PmcTimer, Get-PmcTimerStatus, Show-PmcWeeklyTimeReport"}, {"path": "module/Pmc.Strict/src/Types.ps1", "content": "# Types and context for the strict engine\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass PmcCommandContext {\r\n    [string] $Domain\r\n    [string] $Action\r\n    [hashtable] $Args = @{}\r\n    [string[]] $FreeText = @()\r\n    [string] $Raw = ''\r\n\r\n    PmcCommandContext([string]$domain, [string]$action) {\r\n        $this.Domain = $domain\r\n        $this.Action = $action\r\n    }\r\n}\r\n\r\nfunction ConvertTo-PmcTokens {\r\n    param([string]$Buffer)\r\n\r\n    # Always return an array, even for empty input\r\n    if ([string]::IsNullOrWhiteSpace($Buffer)) {\r\n        return ,[string[]]@()\r\n    }\r\n\r\n    # Simple split preserving quoted strings\r\n    $pattern = '\"([^\"]*)\"|(\\S+)'\r\n    $tokens = [string[]]@()\r\n\r\n    foreach ($m in [regex]::Matches($Buffer, $pattern)) {\r\n        if ($m.Groups[1].Success) {\r\n            $tokens += $m.Groups[1].Value\r\n        } elseif ($m.Groups[2].Success) {\r\n            $tokens += $m.Groups[2].Value\r\n        }\r\n    }\r\n\r\n    # Ensure we always return an array type with Count property\r\n    return ,[string[]]$tokens\r\n}\r\n\r\n# Property helpers (consistent across PSCustomObject/Hashtable)\r\nfunction Pmc-HasProp {\r\n    param($Object, [string]$Name)\r\n    if ($null -eq $Object -or [string]::IsNullOrWhiteSpace($Name)) { return $false }\r\n    try {\r\n        if ($Object -is [hashtable]) { return $Object.ContainsKey($Name) }\r\n        $psobj = $Object.PSObject\r\n        if ($null -eq $psobj) { return $false }\r\n        return ($psobj.Properties[$Name] -ne $null)\r\n    } catch { return $false }\r\n}\r\n\r\nfunction Pmc-GetProp {\r\n    param($Object, [string]$Name, $Default=$null)\r\n    if (-not (Pmc-HasProp $Object $Name)) { return $Default }\r\n    try { return $Object.$Name } catch { return $Default }\r\n}\r\n\r\nfunction Ensure-PmcTaskProperties {\r\n    <#\r\n    .SYNOPSIS\r\n    Ensures all required properties exist on a task object with proper defaults\r\n\r\n    .DESCRIPTION\r\n    Normalizes task objects by adding missing properties with appropriate default values.\r\n    This prevents \"property cannot be found\" errors when accessing task properties.\r\n\r\n    .PARAMETER Task\r\n    The task object to normalize\r\n    ##CLOSEBRACKET##\r\n    param($Task)\r\n\r\n    if ($null -eq $Task) { return }\r\n\r\n    # Required task properties with their default values\r\n    $requiredProperties = @{\r\n        'depends' = @()\r\n        'tags' = @()\r\n        'notes' = @()\r\n        'recur' = $null\r\n        'estimatedMinutes' = $null\r\n        'nextSuggestedCount' = 3\r\n        'lastNextShown' = (Get-Date).ToString('yyyy-MM-dd')\r\n        'status' = 'pending'\r\n        'priority' = 0\r\n        'created' = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n        'project' = 'inbox'\r\n        'due' = $null\r\n    }\r\n\r\n    foreach ($propName in $requiredProperties.Keys) {\r\n        if (-not (Pmc-HasProp $Task $propName)) {\r\n            try {\r\n                Add-Member -InputObject $Task -MemberType NoteProperty -Name $propName -NotePropertyValue $requiredProperties[$propName] -Force\r\n            } catch {\r\n                # Ignore errors - property may already exist or object may be read-only\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction Ensure-PmcProjectProperties {\r\n    <#\r\n    .SYNOPSIS\r\n    Ensures all required properties exist on a project object\r\n    ##CLOSEBRACKET##\r\n    param($Project)\r\n\r\n    if ($null -eq $Project) { return }\r\n\r\n    $requiredProperties = @{\r\n        'name' = ''\r\n        'description' = ''\r\n        'aliases' = @()\r\n        'created' = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n        'isArchived' = $false\r\n        'color' = 'Gray'\r\n        'icon' = '📁'\r\n        'sortOrder' = 0\r\n    }\r\n\r\n    foreach ($propName in $requiredProperties.Keys) {\r\n        if (-not (Pmc-HasProp $Project $propName)) {\r\n            try {\r\n                Add-Member -InputObject $Project -MemberType NoteProperty -Name $propName -NotePropertyValue $requiredProperties[$propName] -Force\r\n            } catch {\r\n                # Ignore errors\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function ConvertTo-PmcTokens, Pmc-HasProp, Pmc-GetProp, Ensure-PmcTaskProperties, Ensure-PmcProjectProperties"}, {"path": "module/Pmc.Strict/src/UI.ps1", "content": "# Pmc UI primitives with centralized style tokens and sanitization\r\n\r\nSet-StrictMode -Version Latest\r\n\r\nclass PmcVT {\r\n    static [string] MoveTo([int]$x, [int]$y) { return \"`e[$($y + 1);$($x + 1)H\" }\r\n    static [string] Clear() { return \"`e[2J`e[H\" }\r\n    static [string] ClearLine() { return \"`e[2K\" }\r\n    static [string] Hide() { return \"`e[?25l\" }\r\n    static [string] Show() { return \"`e[?25h\" }\r\n    static [string] FgRGB([int]$r, [int]$g, [int]$b) { return \"`e[38;2;$r;$g;${b}m\" }\r\n    static [string] BgRGB([int]$r, [int]$g, [int]$b) { return \"`e[48;2;$r;$g;${b}m\" }\r\n    static [string] Reset() { return \"`e[0m\" }\r\n    static [string] Bold() { return \"`e[1m\" }\r\n}\r\n\r\nfunction Sanitize-PmcOutput {\r\n    param([string]$Text)\r\n    if (-not $Text) { return '' }\r\n    # Strip ANSI escape sequences and control chars\r\n    $t = $Text -replace \"`e\\[[0-9;]*[A-Za-z]\", ''\r\n    $t = ($t.ToCharArray() | Where-Object { [int]$_ -ge 32 -or [int]$_ -eq 10 -or [int]$_ -eq 13 } ) -join ''\r\n    return $t\r\n}\r\n\r\nfunction Get-PmcStyle {\r\n    param([string]$Token)\r\n    $styles = Get-PmcState -Section 'Display' -Key 'Styles'\r\n    if (-not $styles) { return @{ Fg='White' } }\r\n    if ($styles.ContainsKey($Token)) { return $styles[$Token] }\r\n    return @{ Fg='White' }\r\n}\r\n\r\nfunction Write-PmcStyled {\r\n    param(\r\n        [Parameter(Mandatory)] [string]$Style,\r\n        [Parameter(Mandatory)] [string]$Text,\r\n        [switch]$NoNewline\r\n    )\r\n    $sty = Get-PmcStyle $Style\r\n    $fg = $sty.Fg\r\n    $safe = Sanitize-PmcOutput $Text\r\n\r\n    if ($fg) {\r\n        # Check if Fg is a hex color (#RRGGBB)\r\n        if ($fg -match '^#([0-9A-Fa-f]{6})$') {\r\n            $rgb = ConvertFrom-PmcHex $fg\r\n            $colorSeq = \"`e[38;2;$($rgb.R);$($rgb.G);$($rgb.B)m\"\r\n            $reset = \"`e[0m\"\r\n            if ($NoNewline) { Write-Host -NoNewline \"$colorSeq$safe$reset\" } else { Write-Host \"$colorSeq$safe$reset\" }\r\n        } else {\r\n            # Standard PowerShell color name\r\n            if ($NoNewline) { Write-Host -NoNewline $safe -ForegroundColor $fg } else { Write-Host $safe -ForegroundColor $fg }\r\n        }\r\n    } else {\r\n        if ($NoNewline) { Write-Host -NoNewline $safe } else { Write-Host $safe }\r\n    }\r\n}\r\n\r\nfunction ConvertFrom-PmcHex {\r\n    param([string]$Hex)\r\n    $h = $(if ($Hex) { $Hex.Trim() } else { '#33aaff' })\r\n    if ($h.StartsWith('#')) { $h = $h.Substring(1) }\r\n    if ($h.Length -eq 3) { $h = ($h[0]+$h[0]+$h[1]+$h[1]+$h[2]+$h[2]) }\r\n    if ($h.Length -ne 6) { $h = '33aaff' }\r\n    return @{\r\n        R = [Convert]::ToInt32($h.Substring(0,2),16)\r\n        G = [Convert]::ToInt32($h.Substring(2,2),16)\r\n        B = [Convert]::ToInt32($h.Substring(4,2),16)\r\n    }\r\n}\r\n\r\nfunction Get-PmcColorPalette {\r\n    $cfg = Get-PmcConfig\r\n    $hex = '#33aaff'\r\n    try { if ($cfg.Display -and $cfg.Display.Theme -and $cfg.Display.Theme.Hex) { $hex = [string]$cfg.Display.Theme.Hex } } catch {\r\n        # Theme configuration access failed - use default hex color\r\n    }\r\n    $rgb = ConvertFrom-PmcHex $hex\r\n    # Derive all colors from the theme hex\r\n    $dim = @{\r\n        R = [int]([Math]::Max(0, $rgb.R * 0.7)); G = [int]([Math]::Max(0, $rgb.G * 0.7)); B = [int]([Math]::Max(0, $rgb.B * 0.7))\r\n    }\r\n    $bright = @{\r\n        R = [int]([Math]::Min(255, $rgb.R * 1.3)); G = [int]([Math]::Min(255, $rgb.G * 1.3)); B = [int]([Math]::Min(255, $rgb.B * 1.3))\r\n    }\r\n    $text = @{\r\n        R = [int]([Math]::Min(255, $rgb.R * 0.4 + 180)); G = [int]([Math]::Min(255, $rgb.G * 0.4 + 180)); B = [int]([Math]::Min(255, $rgb.B * 0.4 + 180))\r\n    }\r\n    $muted = @{\r\n        R = [int]($rgb.R * 0.5 + 75); G = [int]($rgb.G * 0.5 + 75); B = [int]($rgb.B * 0.5 + 75)\r\n    }\r\n    # Warning: shift toward yellow-ish in the theme's color space\r\n    $warning = @{\r\n        R = [int]([Math]::Min(255, $rgb.R * 0.8 + 100)); G = [int]([Math]::Min(255, $rgb.G * 0.6 + 120)); B = [int]($rgb.B * 0.3)\r\n    }\r\n    # Error: shift toward red-ish\r\n    $error = @{\r\n        R = [int]([Math]::Min(255, $rgb.R * 0.3 + 180)); G = [int]($rgb.G * 0.3); B = [int]($rgb.B * 0.3)\r\n    }\r\n    # Success: use the theme color as-is or slightly brighter\r\n    $success = $bright\r\n\r\n    # Provide all tokens used by interactive UIs (wizard/editor)\r\n    return @{\r\n        Primary  = $rgb\r\n        Border   = $dim\r\n        Text     = $text\r\n        Muted    = $muted\r\n        Error    = $error\r\n        Warning  = $warning\r\n        Success  = $success\r\n        Bright   = $bright\r\n        # Additional expected tokens\r\n        Header   = $rgb\r\n        Label    = $muted\r\n        Highlight= $rgb\r\n        Footer   = $dim\r\n        Cursor   = $rgb\r\n        Status   = $muted\r\n    }\r\n}\r\n\r\nfunction Get-PmcColorSequence {\r\n    param($rgb)\r\n    try {\r\n        if ($rgb -and $rgb.PSObject -and $rgb.PSObject.Properties['R'] -and $rgb.PSObject.Properties['G'] -and $rgb.PSObject.Properties['B']) {\r\n            $r = [int]$rgb.R\r\n            $g = [int]$rgb.G\r\n            $b = [int]$rgb.B\r\n            return \"`e[38;2;${r};${g};${b}m\"\r\n        }\r\n    } catch { }\r\n    return ''\r\n}\r\n\r\n# Cell-level theming hook for grid renderer (Stage 1.3)\r\nfunction Get-PmcCellStyle {\r\n    param([object]$RowData, [string]$Column, [object]$Value)\r\n\r\n    if (-not $RowData) { return Get-PmcStyle 'Body' }\r\n\r\n    # Priority-based coloring (1=highest)\r\n    if ($Column -eq 'priority' -and $RowData.PSObject.Properties['priority'] -and $RowData.priority) {\r\n        $p = [string]$RowData.priority\r\n        switch ($p) {\r\n            '1' { return @{ Fg = 'Red';    Bold = $true } }\r\n            '2' { return @{ Fg = 'Yellow'; Bold = $true } }\r\n            '3' { return @{ Fg = 'Green' } }\r\n        }\r\n    }\r\n\r\n    # Due date warnings (expects yyyy-MM-dd)\r\n    if ($Column -eq 'due' -and $RowData.PSObject.Properties['due'] -and $RowData.due) {\r\n        $dstr = [string]$RowData.due\r\n        try {\r\n            $dt = [DateTime]::ParseExact($dstr, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)\r\n            $ok = $true\r\n        } catch {\r\n            $ok = $false\r\n        }\r\n        if ($ok) {\r\n            $today = (Get-Date).Date\r\n            if ($dt.Date -lt $today) { return @{ Fg = 'Red'; Bold = $true } }\r\n            if ($dt.Date -le $today.AddDays(1)) { return @{ Fg = 'Yellow'; Bold = $true } }\r\n        }\r\n    }\r\n\r\n    return Get-PmcStyle 'Body'\r\n}\r\n\r\nfunction Show-PmcHeader {\r\n    param([string]$Title,[string]$Icon='')\r\n    $t = $(if ($Icon) { \" $Icon $Title\" } else { \" $Title\" })\r\n    Write-PmcStyled -Style 'Title' -Text $t\r\n    $width = [Math]::Max(8, $t.Length)\r\n    Write-PmcStyled -Style 'Border' -Text ('-' * $width)\r\n}\r\n\r\nfunction Show-PmcTip { param([string]$Text) Write-PmcStyled -Style 'Muted' -Text ('  ' + $Text) }\r\n\r\nfunction Get-PmcIcon {\r\n    param([string]$Name)\r\n    $mode = 'emoji'\r\n    try { $cfg = Get-PmcConfig; if ($cfg.Display -and $cfg.Display.Icons -and $cfg.Display.Icons.Mode) { $mode = [string]$cfg.Display.Icons.Mode } } catch {\r\n        # Icon configuration access failed - use default mode\r\n    }\r\n    switch ($Name) {\r\n        'notice' { if ($mode -eq 'ascii') { return '*' } else { return '•' } }\r\n        'warn'   { if ($mode -eq 'ascii') { return '!' } else { return '[WARN]' } }\r\n        'error'  { if ($mode -eq 'ascii') { return 'X' } else { return '✖' } }\r\n        'ok'     { if ($mode -eq 'ascii') { return '+' } else { return '[OK]' } }\r\n        default  { return '' }\r\n    }\r\n}\r\n\r\nfunction Show-PmcNotice { param([string]$Text) $i=(Get-PmcIcon 'notice'); Write-PmcStyled -Style 'Body' -Text ($i + ' ' + $Text) }\r\nfunction Show-PmcWarning { param([string]$Text) $i=(Get-PmcIcon 'warn'); Write-PmcStyled -Style 'Warning' -Text ($i + ' ' + $Text) }\r\nfunction Show-PmcError { param([string]$Text) $i=(Get-PmcIcon 'error'); Write-PmcStyled -Style 'Error' -Text ($i + ' ' + $Text) }\r\nfunction Show-PmcSuccess { param([string]$Text) $i=(Get-PmcIcon 'ok'); Write-PmcStyled -Style 'Success' -Text ($i + ' ' + $Text) }\r\nfunction Show-PmcSeparator { param([int]$Width=40) Write-PmcStyled -Style 'Border' -Text ('─' * [Math]::Max(8,$Width)) }\r\n\r\nfunction Show-PmcTable {\r\n    param(\r\n        [array]$Columns,\r\n        [array]$Rows,\r\n        [string]$Title=''\r\n    )\r\n    throw \"Show-PmcTable is DEPRECATED and should not be used! All views must use Show-PmcCustomGrid. Function called with Title: '$Title'\"\r\n}\r\n\r\nExport-ModuleMember -Function Sanitize-PmcOutput, Get-PmcStyle, Write-PmcStyled, ConvertFrom-PmcHex, Get-PmcColorPalette, Get-PmcColorSequence, Get-PmcCellStyle, Show-PmcHeader, Show-PmcTip, Get-PmcIcon"}, {"path": "module/Pmc.Strict/src/UndoRedo.ps1", "content": "# Undo/Redo System Implementation\r\n# Based on t2.ps1 undo/redo functionality\r\n\r\n# Global variables for undo/redo stacks\r\n$Script:PmcUndoStack = @()\r\n$Script:PmcRedoStack = @()\r\n$Script:PmcMaxUndoSteps = 5\r\n\r\nfunction Invoke-PmcUndo {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"System\" -Message \"Starting undo operation\"\r\n    $file = Get-PmcTaskFilePath\r\n    $stacks = Get-PmcUndoRedoStacks $file\r\n    $undo = @($stacks.undo); $redo = @($stacks.redo)\r\n    if (@($undo).Count -eq 0) { Write-PmcStyled -Style 'Muted' -Text 'Nothing to undo'; return }\r\n    try {\r\n        $current = Get-PmcData\r\n        $redo += ($current | ConvertTo-Json -Depth 10)\r\n    } catch {\r\n        # Undo state push failed - undo history may be incomplete\r\n    }\r\n    $snap = $undo[-1]; if (@($undo).Count -gt 1) { $undo = $undo[0..($undo.Count-2)] } else { $undo=@() }\r\n    try {\r\n        $state = $snap | ConvertFrom-Json\r\n        $tmp = \"$file.tmp\"; $state | ConvertTo-Json -Depth 10 | Set-Content -Path $tmp -Encoding UTF8; Move-Item -Force -Path $tmp -Destination $file\r\n        Save-PmcUndoRedoStacks -Undo $undo -Redo $redo -UndoFile $stacks.undoFile -RedoFile $stacks.redoFile\r\n        Write-PmcStyled -Style 'Success' -Text 'Undid last action'\r\n        Write-PmcDebug -Level 2 -Category 'System' -Message 'Undo completed' -Data @{ UndoCount=@($undo).Count; RedoCount=@($redo).Count }\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text (\"Undo failed: {0}\" -f $_)\r\n    }\r\n}\r\n\r\nfunction Invoke-PmcRedo {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"System\" -Message \"Starting redo operation\"\r\n    $file = Get-PmcTaskFilePath\r\n    $stacks = Get-PmcUndoRedoStacks $file\r\n    $undo = @($stacks.undo); $redo = @($stacks.redo)\r\n    if (@($redo).Count -eq 0) { Write-PmcStyled -Style 'Muted' -Text 'Nothing to redo'; return }\r\n    $snap = $redo[-1]; if (@($redo).Count -gt 1) { $redo = $redo[0..($redo.Count-2)] } else { $redo=@() }\r\n    try {\r\n        $current = Get-PmcData\r\n        $undo += ($current | ConvertTo-Json -Depth 10)\r\n    } catch {\r\n        # Undo state push failed - undo history may be incomplete\r\n    }\r\n    try {\r\n        $state = $snap | ConvertFrom-Json\r\n        $tmp = \"$file.tmp\"; $state | ConvertTo-Json -Depth 10 | Set-Content -Path $tmp -Encoding UTF8; Move-Item -Force -Path $tmp -Destination $file\r\n        Save-PmcUndoRedoStacks -Undo $undo -Redo $redo -UndoFile $stacks.undoFile -RedoFile $stacks.redoFile\r\n        Write-PmcStyled -Style 'Success' -Text 'Redid last action'\r\n        Write-PmcDebug -Level 2 -Category 'System' -Message 'Redo completed' -Data @{ UndoCount=@($undo).Count; RedoCount=@($redo).Count }\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text (\"Redo failed: {0}\" -f $_)\r\n    }\r\n}\r\n\r\nfunction New-PmcBackup {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"System\" -Message \"Starting manual backup\"\r\n\r\n    try {\r\n        $data = Get-PmcDataAlias\r\n        $timestamp = Get-Date -Format \"yyyy-MM-dd_HH-mm-ss\"\r\n\r\n        # Create backups directory if it doesn't exist\r\n        $backupDir = \"backups\"\r\n        if (-not (Test-Path $backupDir)) {\r\n            New-Item -ItemType Directory -Path $backupDir -Force | Out-Null\r\n        }\r\n\r\n        $backupFile = Join-Path $backupDir \"pmc_backup_$timestamp.json\"\r\n\r\n        # Export data to backup file\r\n        $data | ConvertTo-Json -Depth 10 | Set-Content -Path $backupFile -Encoding UTF8\r\n\r\n        Write-PmcStyled -Style 'Success' -Text (\"Backup created: {0}\" -f $backupFile)\r\n\r\n        # Clean up old backups (keep last 2)\r\n        $backupFiles = Get-ChildItem -Path $backupDir -Filter \"pmc_backup_*.json\" | Sort-Object LastWriteTime -Descending\r\n        if ($backupFiles.Count -gt 2) {\r\n            $oldBackups = $backupFiles | Select-Object -Skip 2\r\n            foreach ($oldBackup in $oldBackups) {\r\n                Remove-Item $oldBackup.FullName -Force\r\n                Write-PmcStyled -Style 'Muted' -Text (\"Removed old backup: {0}\" -f $oldBackup.Name)\r\n            }\r\n        }\r\n\r\n        Write-PmcDebug -Level 2 -Category \"System\" -Message \"Manual backup completed successfully\" -Data @{ BackupFile = $backupFile }\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text (\"Backup failed: {0}\" -f $_)\r\n        Write-PmcDebug -Level 1 -Category \"System\" -Message \"Manual backup failed\" -Data @{ Error = $_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Clear-PmcBackups {\r\n    param([PmcCommandContext]$Context)\r\n    Write-PmcDebug -Level 1 -Category \"System\" -Message \"Starting system clean\"\r\n\r\n    $data = Get-PmcDataAlias\r\n    $completedTasks = @($data.tasks | Where-Object { $_.status -eq 'completed' })\r\n\r\n    if ($completedTasks.Count -eq 0) {\r\n        Write-PmcStyled -Style 'Muted' -Text \"No completed tasks to clean\"\r\n        return\r\n    }\r\n\r\n    Write-PmcStyled -Style 'Warning' -Text (\"Found {0} completed tasks\" -f $completedTasks.Count)\r\n\r\n    # Show sample of what will be cleaned\r\n    $sample = $completedTasks | Select-Object -First 5\r\n    foreach ($task in $sample) {\r\n        $completedDate = $(if ($task.completed) { $task.completed } else { 'unknown' })\r\n        Write-PmcStyled -Style 'Muted' -Text (\"  #$($task.id) - $($task.text) (completed: $completedDate)\")\r\n    }\r\n\r\n    if ($completedTasks.Count -gt 5) {\r\n        Write-PmcStyled -Style 'Muted' -Text (\"  ... and {0} more\" -f ($completedTasks.Count - 5))\r\n    }\r\n\r\n    # Ask for confirmation\r\n    $response = Read-Host \"`nProceed with cleaning? This will permanently remove completed tasks. (y/N)\"\r\n\r\n    if ($response -match '^[Yy]') {\r\n        # Record current state for undo\r\n        Record-PmcUndoState $data 'system clean'\r\n\r\n        # Remove completed tasks\r\n        $data.tasks = @($data.tasks | Where-Object { $_.status -ne 'completed' })\r\n\r\n        # Save cleaned data\r\n        Save-StrictData $data 'system clean'\r\n\r\n        Write-PmcStyled -Style 'Success' -Text (\"Cleaned {0} completed tasks\" -f $completedTasks.Count)\r\n\r\n        Write-PmcDebug -Level 2 -Category \"System\" -Message \"System clean completed successfully\" -Data @{ RemovedTasks = $completedTasks.Count }\r\n    } else {\r\n        Write-PmcStyled -Style 'Muted' -Text \"Clean operation cancelled\"\r\n    }\r\n}\r\n\r\n# Initialize undo system - integrate with existing Add-PmcUndoEntry mechanism\r\nfunction Initialize-PmcUndoSystem {\r\n    $taskFile = Get-PmcTaskFilePath\r\n    $undoFile = $taskFile + '.undo'\r\n\r\n    if (-not $Script:PmcUndoStack -or $Script:PmcUndoStack.Count -eq 0) {\r\n        if (Test-Path $undoFile) {\r\n            try {\r\n                $undoStack = Get-Content $undoFile -Raw | ConvertFrom-Json\r\n                $Script:PmcUndoStack = @($undoStack)\r\n\r\n                Write-PmcDebug -Level 3 -Category \"System\" -Message \"Undo system initialized from existing file\" -Data @{\r\n                    UndoSteps = $Script:PmcUndoStack.Count\r\n                    RedoSteps = $Script:PmcRedoStack.Count\r\n                }\r\n            } catch {\r\n                $Script:PmcUndoStack = @()\r\n                $Script:PmcRedoStack = @()\r\n                Write-PmcDebug -Level 1 -Category \"System\" -Message \"Failed to load undo data\" -Data @{ Error = $_.Exception.Message }\r\n            }\r\n        } else {\r\n            $Script:PmcUndoStack = @()\r\n            $Script:PmcRedoStack = @()\r\n        }\r\n    }\r\n}\r\n\r\n# Record state for undo\r\nfunction Record-PmcUndoState {\r\n    param($data, [string]$action)\r\n\r\n    if (-not $data) { return }\r\n\r\n    # Add current state to undo stack\r\n    $Script:PmcUndoStack += ($data | ConvertTo-Json -Depth 10)\r\n\r\n    # Limit undo stack size\r\n    if ($Script:PmcUndoStack.Count -gt $Script:PmcMaxUndoSteps) {\r\n        $Script:PmcUndoStack = $Script:PmcUndoStack[1..($Script:PmcUndoStack.Count-1)]\r\n    }\r\n\r\n    # Clear redo stack when new action is performed\r\n    $Script:PmcRedoStack = @()\r\n\r\n    # Save undo stack\r\n    Save-PmcUndoStack\r\n\r\n    Write-PmcDebug -Level 3 -Category \"System\" -Message \"Undo state recorded\" -Data @{\r\n        Action = $action\r\n        UndoStackSize = $Script:PmcUndoStack.Count\r\n    }\r\n}\r\n\r\n# Save undo stack to disk\r\nfunction Save-PmcUndoStack {\r\n    $undoFile = \"pmc_undo.json\"\r\n\r\n    try {\r\n        $undoData = @{\r\n            undoStack = $Script:PmcUndoStack\r\n            redoStack = $Script:PmcRedoStack\r\n            lastUpdated = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')\r\n        }\r\n\r\n        $undoData | ConvertTo-Json -Depth 10 | Set-Content -Path $undoFile -Encoding UTF8\r\n\r\n        Write-PmcDebug -Level 3 -Category \"System\" -Message \"Undo stack saved to disk\"\r\n    } catch {\r\n        Write-PmcDebug -Level 1 -Category \"System\" -Message \"Failed to save undo stack\" -Data @{ Error = $_.Exception.Message }\r\n    }\r\n}\r\n\r\n# Save data directly without recording undo state\r\nfunction Save-PmcDataDirect {\r\n    param($data)\r\n\r\n    $dataFile = \"pmc_data.json\"\r\n    $data | ConvertTo-Json -Depth 10 | Set-Content -Path $dataFile -Encoding UTF8\r\n\r\n    # Update in-memory cache if it exists\r\n    if (Get-Variable -Name 'Script:PmcDataCache' -Scope Script -ErrorAction SilentlyContinue) {\r\n        $Script:PmcDataCache = $data\r\n    }\r\n}\r\n\r\n# Get undo/redo status\r\nfunction Get-PmcUndoStatus {\r\n    Initialize-PmcUndoSystem\r\n\r\n    return @{\r\n        UndoSteps = $Script:PmcUndoStack.Count\r\n        RedoSteps = $Script:PmcRedoStack.Count\r\n        MaxSteps = $Script:PmcMaxUndoSteps\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-PmcUndo, Invoke-PmcRedo, New-PmcBackup, Clear-PmcBackups, Initialize-PmcUndoSystem, Record-PmcUndoState, Save-PmcUndoStack, Save-PmcDataDirect, Get-PmcUndoStatus"}, {"path": "module/Pmc.Strict/src/UniversalDisplay.ps1", "content": "# Universal Display System - Command routing for unified grid interface\r\n# Replaces all fragmented Show-Pmc* functions with grid-based equivalents\r\n\r\nSet-StrictMode -Version Latest\r\n\r\n# Main universal data display dispatcher\r\nfunction Show-PmcData {\r\n    param(\r\n        [string]$DataType,              # \"tasks\", \"projects\", \"timelog\", \"stats\"\r\n        [hashtable]$Filters = @{},      # Data filters\r\n        [hashtable]$Columns = @{},      # Column configuration\r\n        [string]$Title = \"\",            # Display title\r\n        [hashtable]$Theme = @{},        # Theme overrides\r\n        [switch]$Interactive,           # Start interactive mode (overridden by -i flag in Context)\r\n        [PmcCommandContext]$Context = $null  # PMC command context\r\n    )\r\n\r\n    Write-PmcDebug -Level 2 -Category \"UniversalDisplay\" -Message \"Universal data display\" -Data @{\r\n        DataType = $DataType\r\n        Interactive = $Interactive.IsPresent\r\n        FilterCount = $Filters.Keys.Count\r\n    }\r\n\r\n    # Default column configurations for different data types\r\n    if ($Columns.Keys.Count -eq 0) {\r\n        $Columns = Get-PmcDefaultColumns -DataType $DataType\r\n    }\r\n\r\n    # Add help navigation callback if this is help data\r\n    $additionalParams = @{}\r\n    if ($DataType -eq \"help\" -and $Interactive) {\r\n        $additionalParams.OnSelectCallback = {\r\n            param($selectedItem)\r\n            Show-PmcHelpCategory -Category $selectedItem.Category -Context $Context\r\n        }\r\n    }\r\n\r\n    # Call the enhanced grid system\r\n    Write-PmcDebug -Level 2 -Category 'UniversalDisplay' -Message 'Show-PmcData calling Show-PmcDataGrid' -Data @{ DataType = $DataType; Interactive = $Interactive.IsPresent }\r\n    # Determine interactive based on explicit param or Context -i flag\r\n    $startInteractive = $Interactive.IsPresent\r\n    try { if (-not $startInteractive -and $Context -and $Context.Args.ContainsKey('interactive') -and $Context.Args['interactive']) { $startInteractive = $true } } catch {}\r\n\r\n    Show-PmcDataGrid -Domains @($DataType) -Columns $Columns -Filters $Filters -Title $Title -Theme $Theme -Interactive:$startInteractive @additionalParams\r\n}\r\n\r\nfunction Get-PmcDefaultColumns {\r\n    param([string]$DataType)\r\n\r\n    switch ($DataType) {\r\n        \"task\" {\r\n            return @{\r\n                \"id\" = @{ Header = \"#\"; Width = 4; Alignment = \"Right\"; Editable = $false; Sensitive = $true }\r\n                \"text\" = @{ Header = \"Task\"; Width = 40; Alignment = \"Left\"; Editable = $true }\r\n                \"project\" = @{ Header = \"Project\"; Width = 12; Alignment = \"Left\"; Truncate = $true; Editable = $false; Sensitive = $true }\r\n                \"due\" = @{ Header = \"Due\"; Width = 8; Alignment = \"Center\"; Editable = $true }\r\n                \"priority\" = @{ Header = \"P\"; Width = 3; Alignment = \"Center\"; Editable = $true }\r\n            }\r\n        }\r\n        \"help\" {\r\n            return @{\r\n                \"Category\" = @{ Header = \"Category\"; Width = 25; Alignment = \"Left\"; Editable = $false }\r\n                \"CommandCount\" = @{ Header = \"Commands\"; Width = 10; Alignment = \"Right\"; Editable = $false }\r\n                \"Description\" = @{ Header = \"Description\"; Width = 50; Alignment = \"Left\"; Editable = $false }\r\n            }\r\n        }\r\n        \"project\" {\r\n            return @{\r\n                \"name\" = @{ Header = \"Project\"; Width = 20; Alignment = \"Left\" }\r\n                \"description\" = @{ Header = \"Description\"; Width = 30; Alignment = \"Left\"; Truncate = $true }\r\n                \"task_count\" = @{ Header = \"Tasks\"; Width = 6; Alignment = \"Right\" }\r\n                \"completion\" = @{ Header = \"%\"; Width = 6; Alignment = \"Right\" }\r\n            }\r\n        }\r\n        \"timelog\" {\r\n            return @{\r\n                \"date\" = @{ Header = \"Date\"; Width = 10; Alignment = \"Center\" }\r\n                \"project\" = @{ Header = \"Project\"; Width = 15; Alignment = \"Left\" }\r\n                \"duration\" = @{ Header = \"Duration\"; Width = 8; Alignment = \"Right\" }\r\n                \"description\" = @{ Header = \"Description\"; Width = 35; Alignment = \"Left\"; Truncate = $true }\r\n            }\r\n        }\r\n        default {\r\n            return @{\r\n                \"id\" = @{ Header = \"#\"; Width = 6; Alignment = \"Right\" }\r\n                \"name\" = @{ Header = \"Item\"; Width = 30; Alignment = \"Left\" }\r\n                \"value\" = @{ Header = \"Value\"; Width = 20; Alignment = \"Left\" }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n# Enhanced task view functions using universal system\r\nfunction Show-PmcTodayTasksInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    $today = (Get-Date).Date\r\n    $title = \"📅 TASKS DUE TODAY - {0}\" -f $today.ToString('yyyy-MM-dd')\r\n\r\n    Show-PmcData -DataType \"task\" -Filters @{\r\n        \"status\" = \"pending\"\r\n        \"due_range\" = \"today\"\r\n    } -Title $title -Interactive -Context $Context\r\n}\r\n\r\nfunction Show-PmcOverdueTasksInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    Show-PmcData -DataType \"task\" -Filters @{\r\n        \"status\" = \"pending\"\r\n        \"due_range\" = \"overdue\"\r\n    } -Title \"[WARN]️  OVERDUE TASKS\" -Interactive -Context $Context\r\n}\r\n\r\nfunction Show-PmcAgendaInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    $today = (Get-Date).Date\r\n    $title = \"🗓️ AGENDA - {0}\" -f $today.ToString('yyyy-MM-dd')\r\n\r\n    Show-PmcData -DataType \"task\" -Filters @{\r\n        \"status\" = \"pending\"\r\n        \"due_range\" = \"overdue_and_today\"\r\n    } -Title $title -Interactive -Context $Context\r\n}\r\n\r\nfunction Show-PmcProjectsInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    Show-PmcData -DataType \"project\" -Filters @{\r\n        \"archived\" = $false\r\n    } -Title \"📊 PROJECTS DASHBOARD\" -Interactive -Context $Context\r\n}\r\n\r\n# Static list of projects (no screen takeover)\r\nfunction Get-PmcProjectList {\r\n    param([PmcCommandContext]$Context)\r\n    $filters = @{ archived = $false }\r\n\r\n    # Use simple template-based display\r\n    if (Get-Command Show-PmcSimpleData -ErrorAction SilentlyContinue) {\r\n        Show-PmcSimpleData -DataType \"project\" -Filters $filters\r\n    } else {\r\n        # Fallback to old system\r\n        Show-PmcData -DataType \"project\" -Filters $filters -Title \"Projects\" -Context $Context\r\n    }\r\n}\r\n\r\nfunction Show-PmcAllTasksInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    Show-PmcData -DataType \"task\" -Filters @{\r\n        \"status\" = \"pending\"\r\n    } -Title \"📋 ALL TASKS\" -Interactive -Context $Context\r\n}\r\n\r\n# Static list of tasks (pending by default; honors @project when provided)\r\nfunction Get-PmcTaskList {\r\n    param($Context)\r\n\r\n    $filters = @{ status = 'pending' }\r\n    try {\r\n        if ($Context -and $Context.Args -and $Context.Args.ContainsKey('project')) {\r\n            $filters['project'] = [string]$Context.Args['project']\r\n        }\r\n        if ($Context -and $Context.Args -and $Context.Args.ContainsKey('due')) {\r\n            $dv = ([string]$Context.Args['due']).ToLower()\r\n            switch ($dv) {\r\n                'today'   { $filters['due_range'] = 'today' }\r\n                'overdue' { $filters['due_range'] = 'overdue' }\r\n                'upcoming'{ $filters['due_range'] = 'upcoming' }\r\n            }\r\n        }\r\n    } catch {}\r\n\r\n    # Use simple template-based display instead of complex TUI\r\n    if (Get-Command Show-PmcSimpleData -ErrorAction SilentlyContinue) {\r\n        Show-PmcSimpleData -DataType \"task\" -Filters $filters\r\n    } else {\r\n        # Fallback to old system if template system not loaded\r\n        $title = \"Tasks\"\r\n        if ($filters.ContainsKey('project')) { $title = \"Tasks — @\" + $filters['project'] }\r\n        Show-PmcData -DataType \"task\" -Filters $filters -Title $title -Context $Context\r\n    }\r\n}\r\n\r\nfunction Show-PmcTomorrowTasksInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    $tomorrow = (Get-Date).Date.AddDays(1)\r\n    $title = \"📅 TASKS DUE TOMORROW - {0}\" -f $tomorrow.ToString('yyyy-MM-dd')\r\n\r\n    Show-PmcData -DataType \"task\" -Filters @{\r\n        \"status\" = \"pending\"\r\n        \"due_range\" = \"tomorrow\"\r\n    } -Title $title -Interactive -Context $Context\r\n}\r\n\r\nfunction Show-PmcUpcomingTasksInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    Show-PmcData -DataType \"task\" -Filters @{\r\n        \"status\" = \"pending\"\r\n        \"due_range\" = \"upcoming\"\r\n    } -Title \"📆 UPCOMING TASKS (7 days)\" -Interactive -Context $Context\r\n}\r\n\r\nfunction Show-PmcBlockedTasksInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    Show-PmcData -DataType \"task\" -Filters @{\r\n        \"status\" = \"pending\"\r\n        \"has_dependencies\" = $true\r\n    } -Title \"🚫 BLOCKED TASKS\" -Interactive -Context $Context\r\n}\r\n\r\nfunction Show-PmcTasksWithoutDueDateInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    Show-PmcData -DataType \"task\" -Filters @{\r\n        \"status\" = \"pending\"\r\n        \"no_due_date\" = $true\r\n    } -Title \"📋 TASKS WITHOUT DUE DATE\" -Interactive -Context $Context\r\n}\r\n\r\nfunction Show-PmcNextTasksInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    Show-PmcData -DataType \"task\" -Filters @{\r\n        \"status\" = \"pending\"\r\n        \"next_actions\" = $true\r\n    } -Title \"⏭️ NEXT ACTIONS\" -Interactive -Context $Context\r\n}\r\n\r\nfunction Show-PmcWeekTasksInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    Show-PmcData -DataType \"task\" -Filters @{\r\n        \"status\" = \"pending\"\r\n        \"due_range\" = \"week\"\r\n    } -Title \"📅 THIS WEEK'S TASKS\" -Interactive -Context $Context\r\n}\r\n\r\nfunction Show-PmcMonthTasksInteractive {\r\n    param([PmcCommandContext]$Context)\r\n\r\n    Show-PmcData -DataType \"task\" -Filters @{\r\n        \"status\" = \"pending\"\r\n        \"due_range\" = \"month\"\r\n    } -Title \"📅 THIS MONTH'S TASKS\" -Interactive -Context $Context\r\n}\r\n\r\n# Command shortcuts that route to unified display system\r\nfunction Get-PmcUniversalCommands {\r\n    return @{\r\n        # Interactive shortcuts (using function names for PMC compatibility)\r\n        \"tasks\"     = 'Show-PmcAllTasksInteractive'\r\n        \"today\"     = 'Show-PmcTodayTasksInteractive'\r\n        \"overdue\"   = 'Show-PmcOverdueTasksInteractive'\r\n        \"agenda\"    = 'Show-PmcAgendaInteractive'\r\n        \"projects\"  = 'Show-PmcProjectsInteractive'\r\n\r\n        # Enhanced static views (preserve existing functionality)\r\n        \"tomorrow\"  = 'Show-PmcTomorrowTasks'\r\n        \"upcoming\"  = 'Show-PmcUpcomingTasks'\r\n        \"blocked\"   = 'Show-PmcBlockedTasks'\r\n        \"noduedate\" = 'Show-PmcTasksWithoutDueDate'\r\n        \"next\"      = 'Show-PmcNextTasks'\r\n        \"week\"      = 'Show-PmcWeekTasks'\r\n        \"month\"     = 'Show-PmcMonthTasks'\r\n\r\n        # Interactive mode aliases\r\n        \"itasks\"    = 'Show-PmcAllTasksInteractive'\r\n        \"itoday\"    = 'Show-PmcTodayTasksInteractive'\r\n        \"ioverdue\"  = 'Show-PmcOverdueTasksInteractive'\r\n        \"iagenda\"   = 'Show-PmcAgendaInteractive'\r\n        \"iprojects\" = 'Show-PmcProjectsInteractive'\r\n    }\r\n}\r\n\r\n# Integration with PMC's command system\r\nfunction Register-PmcUniversalCommands {\r\n    $commands = Get-PmcUniversalCommands\r\n\r\n    # Register each command with PMC's shortcut system\r\n    foreach ($cmdName in $commands.Keys) {\r\n        try {\r\n            # Override existing shortcuts in PMC's shortcut map\r\n            if ($Script:PmcShortcutMap.ContainsKey($cmdName)) {\r\n                Write-PmcDebug -Level 1 -Category \"UniversalDisplay\" -Message \"Overriding existing shortcut\" -Data @{ Command = $cmdName }\r\n            }\r\n\r\n            # Update the global shortcut map to use our interactive functions\r\n            $Script:PmcShortcutMap[$cmdName] = $commands[$cmdName]\r\n\r\n            Write-PmcDebug -Level 3 -Category \"UniversalDisplay\" -Message \"Registered universal command\" -Data @{ Command = $cmdName }\r\n        } catch {\r\n            Write-PmcDebug -Level 1 -Category \"UniversalDisplay\" -Message \"Failed to register command\" -Data @{\r\n                Command = $cmdName\r\n                Error = $_.Exception.Message\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n# Enhanced view functions that preserve existing behavior but add interactive options\r\nfunction Show-PmcDataWithMode {\r\n    param(\r\n        [string]$ViewName,\r\n        [hashtable]$ViewConfig,\r\n        [PmcCommandContext]$Context,\r\n        [switch]$Interactive\r\n    )\r\n\r\n    if ($Interactive) {\r\n        Show-PmcData @ViewConfig -Interactive -Context $Context\r\n    } else {\r\n        # Call original function if it exists\r\n        $originalCommand = \"Show-Pmc$ViewName\"\r\n        if (Get-Command $originalCommand -ErrorAction SilentlyContinue) {\r\n            & $originalCommand $Context\r\n        } else {\r\n            Show-PmcData @ViewConfig -Context $Context\r\n        }\r\n    }\r\n}\r\n\r\n# Theme enhancements for better visual feedback\r\nfunction Get-PmcUniversalTheme {\r\n    param([string]$ViewType)\r\n\r\n    $baseTheme = @{\r\n        Default = @{ Style = \"Body\" }\r\n        Columns = @{}\r\n        Rows = @{\r\n            Header = @{ Style = \"Header\" }\r\n            Separator = @{ Style = \"Border\" }\r\n        }\r\n        Cells = @()\r\n    }\r\n\r\n    switch ($ViewType) {\r\n        \"today\" {\r\n            $baseTheme.Cells += @{\r\n                Column = \"due\"\r\n                Condition = { param($item) $item.due -eq (Get-Date).ToString('yyyy-MM-dd') }\r\n                Style = @{ Fg = \"Yellow\"; Bold = $true }\r\n            }\r\n        }\r\n        \"overdue\" {\r\n            $baseTheme.Cells += @{\r\n                Column = \"due\"\r\n                Condition = { param($item)\r\n                    if (-not $item.due) { return $false }\r\n                    try {\r\n                        $dueDate = [DateTime]$item.due\r\n                        return $dueDate -lt (Get-Date).Date\r\n                    } catch { return $false }\r\n                }\r\n                Style = @{ Fg = \"Red\"; Bold = $true }\r\n            }\r\n        }\r\n        \"projects\" {\r\n            $baseTheme.Cells += @{\r\n                Column = \"completion\"\r\n                Condition = { param($item)\r\n                    if (-not $item.completion) { return $false }\r\n                    $pct = [int]($item.completion -replace '%', '')\r\n                    return $pct -ge 80\r\n                }\r\n                Style = @{ Fg = \"Green\"; Bold = $true }\r\n            }\r\n        }\r\n    }\r\n\r\n    return $baseTheme\r\n}\r\n\r\n# Help category drill-down function\r\nfunction Show-PmcHelpCategory {\r\n    param(\r\n        [string]$Category,\r\n        [PmcCommandContext]$Context\r\n    )\r\n\r\n    Write-PmcDebug -Level 1 -Category 'Help' -Message \"Showing help category\" -Data @{ Category = $Category }\r\n\r\n    # Get help content for this category\r\n    if (-not $Script:PmcHelpContent.ContainsKey($Category)) {\r\n        Write-Host \"[WARN]️  Category '$Category' not found in help content\" -ForegroundColor Yellow\r\n        return\r\n    }\r\n\r\n    $categoryData = $Script:PmcHelpContent[$Category]\r\n    $helpItems = @()\r\n    $id = 1\r\n\r\n    # Convert help items to display format\r\n    foreach ($item in $categoryData.Items) {\r\n        $helpItems += [PSCustomObject]@{\r\n            id = $id++\r\n            Type = $item.Type\r\n            Command = $item.Command\r\n            Description = $item.Description\r\n        }\r\n    }\r\n\r\n    # Use universal display system for detailed help\r\n    $columns = @{\r\n        \"Type\" = @{ Header = \"Type\"; Width = 12; Alignment = \"Left\"; Editable = $false }\r\n        \"Command\" = @{ Header = \"Command\"; Width = 35; Alignment = \"Left\"; Editable = $false }\r\n        \"Description\" = @{ Header = \"Description\"; Width = 50; Alignment = \"Left\"; Editable = $false }\r\n    }\r\n\r\n    $title = \"📚 {0} - {1}\" -f $Category, $categoryData.Description\r\n\r\n    # Display with interactive mode for further navigation\r\n    Show-PmcDataGrid -Data $helpItems -Columns $columns -Title $title -Interactive\r\n}\r\n\r\nExport-ModuleMember -Function Get-PmcTaskList, Get-PmcProjectList, Show-PmcData, Show-PmcTodayTasksInteractive, Show-PmcOverdueTasksInteractive, Show-PmcAgendaInteractive, Show-PmcProjectsInteractive, Show-PmcAllTasksInteractive, Show-PmcTomorrowTasksInteractive, Show-PmcUpcomingTasksInteractive, Show-PmcBlockedTasksInteractive, Show-PmcTasksWithoutDueDateInteractive, Show-PmcNextTasksInteractive, Show-PmcWeekTasksInteractive, Show-PmcMonthTasksInteractive, Register-PmcUniversalCommands, Get-PmcUniversalCommands"}, {"path": "module/Pmc.Strict/src/Views.ps1", "content": "# Views.ps1 - Task view functions updated for current PMC system\r\n\r\nfunction Show-PmcTodayTasks {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $today = (Get-Date).Date\r\n\r\n        # Filter tasks due today\r\n        $todayTasks = @($allData.tasks | Where-Object {\r\n            $_.status -eq 'pending' -and $_.due -and\r\n            [datetime]::ParseExact($_.due, 'yyyy-MM-dd', $null).Date -eq $today\r\n        })\r\n\r\n        Show-PmcCustomGrid -Domain 'task' -Data $todayTasks -Title \"📅 Tasks Due Today\" -Interactive\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error showing today's tasks: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcTomorrowTasks {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $tomorrow = (Get-Date).Date.AddDays(1)\r\n\r\n        # Filter tasks due tomorrow\r\n        $tomorrowTasks = @($allData.tasks | Where-Object {\r\n            $_.status -eq 'pending' -and $_.due -and\r\n            [datetime]::ParseExact($_.due, 'yyyy-MM-dd', $null).Date -eq $tomorrow\r\n        })\r\n\r\n        Show-PmcCustomGrid -Domain 'task' -Data $tomorrowTasks -Title \"📅 Tasks Due Tomorrow\" -Interactive\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error showing tomorrow's tasks: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcOverdueTasks {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $today = (Get-Date).Date\r\n\r\n        # Filter overdue tasks\r\n        $overdueTasks = @($allData.tasks | Where-Object {\r\n            $_.status -eq 'pending' -and $_.due -and\r\n            [datetime]::ParseExact($_.due, 'yyyy-MM-dd', $null).Date -lt $today\r\n        })\r\n\r\n        Show-PmcCustomGrid -Domain 'task' -Data $overdueTasks -Title \"[WARN]️ Overdue Tasks\" -Interactive\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error showing overdue tasks: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcUpcomingTasks {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $today = (Get-Date).Date\r\n        $nextWeek = $today.AddDays(7)\r\n\r\n        # Filter upcoming tasks (next 7 days)\r\n        $upcomingTasks = @($allData.tasks | Where-Object {\r\n            $_.status -eq 'pending' -and $_.due -and {\r\n                $dueDate = [datetime]::ParseExact($_.due, 'yyyy-MM-dd', $null).Date\r\n                $dueDate -gt $today -and $dueDate -le $nextWeek\r\n            }\r\n        })\r\n\r\n        Show-PmcCustomGrid -Domain 'task' -Data $upcomingTasks -Title \"📆 Upcoming Tasks (Next 7 Days)\" -Interactive\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error showing upcoming tasks: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcBlockedTasks {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n\r\n        # Filter blocked tasks (tasks with dependencies)\r\n        $blockedTasks = @($allData.tasks | Where-Object {\r\n            $_.status -eq 'pending' -and $_.depends -and $_.depends.Count -gt 0\r\n        })\r\n\r\n        Show-PmcCustomGrid -Domain 'task' -Data $blockedTasks -Title \"🚫 Blocked Tasks\" -Interactive\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error showing blocked tasks: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcNoDueDateTasks {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n\r\n        # Filter tasks with no due date\r\n        $noDueTasks = @($allData.tasks | Where-Object {\r\n            $_.status -eq 'pending' -and (-not $_.due -or $_.due -eq '')\r\n        })\r\n\r\n        Show-PmcCustomGrid -Domain 'task' -Data $noDueTasks -Title \"📋 Tasks Without Due Date\" -Interactive\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error showing tasks without due date: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcWeekTasksInteractive {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $today = (Get-Date).Date\r\n        $endOfWeek = $today.AddDays(6)\r\n\r\n        # Filter tasks for this week\r\n        $weekTasks = @($allData.tasks | Where-Object {\r\n            $_.status -eq 'pending' -and $_.due -and {\r\n                $dueDate = [datetime]::ParseExact($_.due, 'yyyy-MM-dd', $null).Date\r\n                $dueDate -ge $today -and $dueDate -le $endOfWeek\r\n            }\r\n        })\r\n\r\n        Show-PmcCustomGrid -Domain 'task' -Data $weekTasks -Title \"📆 This Week's Tasks\" -Interactive\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error showing week's tasks: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcMonthTasksInteractive {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $today = (Get-Date).Date\r\n        $endOfMonth = $today.AddDays(29)\r\n\r\n        # Filter tasks for this month\r\n        $monthTasks = @($allData.tasks | Where-Object {\r\n            $_.status -eq 'pending' -and $_.due -and {\r\n                $dueDate = [datetime]::ParseExact($_.due, 'yyyy-MM-dd', $null).Date\r\n                $dueDate -ge $today -and $dueDate -le $endOfMonth\r\n            }\r\n        })\r\n\r\n        Show-PmcCustomGrid -Domain 'task' -Data $monthTasks -Title \"📅 This Month's Tasks\" -Interactive\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error showing month's tasks: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcProjectList {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n        $projects = $allData.projects | Where-Object { -not $_.isArchived }\r\n\r\n        Show-PmcCustomGrid -Domain 'project' -Data $projects -Title \"📁 Active Projects\" -Interactive\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error showing projects: $_\"\r\n    }\r\n}\r\n\r\nfunction Show-PmcNextActions {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n\r\n        # Get high priority pending tasks\r\n        $nextActions = @($allData.tasks | Where-Object {\r\n            $_.status -eq 'pending' -and $_.priority -gt 0\r\n        } | Sort-Object priority -Descending | Select-Object -First 10)\r\n\r\n        Show-PmcCustomGrid -Domain 'task' -Data $nextActions -Title \"⭐ Next Actions (Top 10)\" -Interactive\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error showing next actions: $_\"\r\n    }\r\n}\r\n\r\n# Add Interactive aliases for CommandMap compatibility\r\nfunction Show-PmcTodayTasksInteractive { param($Context); Show-PmcTodayTasks -Context $Context }\r\nfunction Show-PmcTomorrowTasksInteractive { param($Context); Show-PmcTomorrowTasks -Context $Context }\r\nfunction Show-PmcOverdueTasksInteractive { param($Context); Show-PmcOverdueTasks -Context $Context }\r\nfunction Show-PmcUpcomingTasksInteractive { param($Context); Show-PmcUpcomingTasks -Context $Context }\r\nfunction Show-PmcBlockedTasksInteractive { param($Context); Show-PmcBlockedTasks -Context $Context }\r\nfunction Show-PmcTasksWithoutDueDateInteractive { param($Context); Show-PmcNoDueDateTasks -Context $Context }\r\nfunction Show-PmcProjectsInteractive { param($Context); Show-PmcProjectList -Context $Context }\r\nfunction Show-PmcNextTasksInteractive { param($Context); Show-PmcNextActions -Context $Context }\r\n\r\n# Direct aliases for CommandMap compatibility\r\nfunction Show-PmcTasksWithoutDueDate { param($Context); Show-PmcNoDueDateTasks -Context $Context }\r\n\r\nfunction Show-PmcKanban {\r\n    param($Context)\r\n\r\n    try {\r\n        $allData = Get-PmcAllData\r\n\r\n        # Group tasks by status into columns\r\n        $todoTasks = @($allData.tasks | Where-Object { $_.status -eq 'pending' -and (-not $_.due -or (Get-Date $_.due) -gt (Get-Date)) })\r\n        $doingTasks = @($allData.tasks | Where-Object { $_.status -eq 'active' })\r\n        $doneTasks = @($allData.tasks | Where-Object { $_.status -eq 'completed' } | Select-Object -First 10)\r\n\r\n        Write-PmcStyled -Style 'Header' -Text \"`n🗂️  PMC Kanban Board`n\"\r\n\r\n        # Display columns side by side\r\n        Write-PmcStyled -Style 'Subheader' -Text \"📝 TODO ($($todoTasks.Count))\"\r\n        Write-PmcStyled -Style 'Info' -Text \"────────────────────\"\r\n        foreach ($task in $todoTasks) {\r\n            $priority = $(if ($task.priority -gt 0) { \"⭐\" } else { \"  \" })\r\n            $due = $(if ($task.due) { \" 📅$($task.due)\" } else { \"\" })\r\n            Write-PmcStyled -Style 'Task' -Text \"$priority $($task.title)$due\"\r\n        }\r\n\r\n        Write-PmcStyled -Style 'Subheader' -Text \"`n🔄 DOING ($($doingTasks.Count))\"\r\n        Write-PmcStyled -Style 'Info' -Text \"────────────────────\"\r\n        foreach ($task in $doingTasks) {\r\n            $priority = $(if ($task.priority -gt 0) { \"⭐\" } else { \"  \" })\r\n            Write-PmcStyled -Style 'ActiveTask' -Text \"$priority $($task.title)\"\r\n        }\r\n\r\n        Write-PmcStyled -Style 'Subheader' -Text \"`n✅ DONE ($($doneTasks.Count))\"\r\n        Write-PmcStyled -Style 'Info' -Text \"────────────────────\"\r\n        foreach ($task in $doneTasks) {\r\n            Write-PmcStyled -Style 'CompletedTask' -Text \"   $($task.title)\"\r\n        }\r\n\r\n    } catch {\r\n        Write-PmcStyled -Style 'Error' -Text \"Error showing Kanban board: $_\"\r\n    }\r\n}\r\n\r\n# Export view functions\r\nExport-ModuleMember -Function Show-PmcTodayTasks, Show-PmcTomorrowTasks, Show-PmcOverdueTasks, Show-PmcUpcomingTasks, Show-PmcBlockedTasks, Show-PmcNoDueDateTasks, Show-PmcWeekTasksInteractive, Show-PmcMonthTasksInteractive, Show-PmcProjectList, Show-PmcNextActions, Show-PmcTodayTasksInteractive, Show-PmcTomorrowTasksInteractive, Show-PmcOverdueTasksInteractive, Show-PmcUpcomingTasksInteractive, Show-PmcBlockedTasksInteractive, Show-PmcTasksWithoutDueDateInteractive, Show-PmcProjectsInteractive, Show-PmcNextTasksInteractive, Show-PmcTasksWithoutDueDate, Show-PmcKanban"}, {"path": "themes/cyberpunk.json", "content": "{\n    \"Name\": \"Cyberpunk\",\n    \"Hex\": \"#00f3ff\",\n    \"Description\": \"NEON: CYAN / PINK / DARK\",\n    \"Properties\": {\n        \"Background.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#050510\"\n        },\n        \"Background.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a0b2e\"\n        },\n        \"Background.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#050510\"\n        },\n        \"Background.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2d004d\"\n        },\n        \"Background.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#332200\"\n        },\n        \"Background.MenuBar\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a0a1a\"\n        },\n        \"Background.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2d004d\"\n        },\n        \"Background.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#050510\"\n        },\n        \"Background.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#050510\"\n        },\n        \"Background.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a0a1a\"\n        },\n        \"Background.Panel\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a0a1a\"\n        },\n        \"Background.Header\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a0a1a\"\n        },\n        \"Background.Footer\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a0a1a\"\n        },\n        \"Foreground.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#00f3ff\"\n        },\n        \"Foreground.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#00f3ff\"\n        },\n        \"Foreground.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff00ff\"\n        },\n        \"Foreground.Title\": {\n            \"Type\": \"Gradient\",\n            \"Start\": \"#ff00ff\",\n            \"End\": \"#00f3ff\"\n        },\n        \"Foreground.Muted\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#5e4b8b\"\n        },\n        \"Foreground.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#fcee0a\"\n        },\n        \"Foreground.Error\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff0055\"\n        },\n        \"Foreground.Success\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#00ff9f\"\n        },\n        \"Foreground.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff00ff\"\n        },\n        \"Foreground.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#5e4b8b\"\n        },\n        \"Foreground.Primary\": {\n            \"Type\": \"Gradient\",\n            \"Start\": \"#00f3ff\",\n            \"End\": \"#bf00ff\"\n        },\n        \"Border.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#bf00ff\"\n        },\n        \"Foreground.Secondary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#5e4b8b\"\n        },\n        \"Foreground.Accent\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff00ff\"\n        },\n        \"Background.Accent\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2d004d\"\n        },\n        \"Foreground.Border\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#bf00ff\"\n        },\n        \"Foreground.Selection\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff00ff\"\n        },\n        \"Background.Selection\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2d004d\"\n        }\n    }\n}"}, {"path": "themes/default.json", "content": "{\n    \"Name\": \"Default\",\n    \"Hex\": \"#33aaff\",\n    \"Description\": \"Classic blue\",\n    \"Properties\": {\n        \"Background.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#000000\"\n        },\n        \"Background.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a3d5c\"\n        },\n        \"Background.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#000000\"\n        },\n        \"Background.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a3d5c\"\n        },\n        \"Background.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#332200\"\n        },\n        \"Background.MenuBar\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a2a3a\"\n        },\n        \"Background.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a3d5c\"\n        },\n        \"Background.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a1520\"\n        },\n        \"Background.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#000000\"\n        },\n        \"Background.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a1520\"\n        },\n        \"Background.Panel\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a1520\"\n        },\n        \"Background.Header\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a2a3a\"\n        },\n        \"Background.Footer\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a2a3a\"\n        },\n        \"Foreground.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ccddee\"\n        },\n        \"Foreground.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ccddee\"\n        },\n        \"Foreground.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Title\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33aaff\"\n        },\n        \"Foreground.Muted\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#667788\"\n        },\n        \"Foreground.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa00\"\n        },\n        \"Foreground.Error\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff3333\"\n        },\n        \"Foreground.Success\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33ff88\"\n        },\n        \"Foreground.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#667788\"\n        },\n        \"Foreground.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33aaff\"\n        },\n        \"Border.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2266aa\"\n        },\n        \"Foreground.Secondary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#667788\"\n        },\n        \"Foreground.Accent\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Background.Accent\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a3d5c\"\n        },\n        \"Foreground.Border\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2266aa\"\n        },\n        \"Foreground.Selection\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Background.Selection\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a3d5c\"\n        }\n    }\n}"}, {"path": "themes/forest.json", "content": "{\n    \"Name\": \"Forest\",\n    \"Hex\": \"#228844\",\n    \"Description\": \"Deep forest green\",\n    \"Properties\": {\n        \"Background.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#051008\"\n        },\n        \"Background.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a2515\"\n        },\n        \"Background.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#051008\"\n        },\n        \"Background.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a2515\"\n        },\n        \"Background.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#332200\"\n        },\n        \"Background.MenuBar\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#081a0f\"\n        },\n        \"Background.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a2515\"\n        },\n        \"Background.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#030a05\"\n        },\n        \"Background.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#051008\"\n        },\n        \"Background.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#030a05\"\n        },\n        \"Background.Panel\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#030a05\"\n        },\n        \"Background.Header\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#081a0f\"\n        },\n        \"Background.Footer\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#081a0f\"\n        },\n        \"Foreground.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aaddbb\"\n        },\n        \"Foreground.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aaddbb\"\n        },\n        \"Foreground.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Title\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#228844\"\n        },\n        \"Foreground.Muted\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#446655\"\n        },\n        \"Foreground.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa00\"\n        },\n        \"Foreground.Error\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff3333\"\n        },\n        \"Foreground.Success\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33ff88\"\n        },\n        \"Foreground.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#446655\"\n        },\n        \"Foreground.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#228844\"\n        },\n        \"Border.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#116633\"\n        }\n    }\n}"}, {"path": "themes/gold.json", "content": "{\n    \"Name\": \"Gold\",\n    \"Hex\": \"#ffaa33\",\n    \"Description\": \"Rich golden yellow\",\n    \"Properties\": {\n        \"Background.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a1005\"\n        },\n        \"Background.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#3d2a0a\"\n        },\n        \"Background.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a1005\"\n        },\n        \"Background.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#3d2a0a\"\n        },\n        \"Background.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#332200\"\n        },\n        \"Background.MenuBar\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a1a08\"\n        },\n        \"Background.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#3d2a0a\"\n        },\n        \"Background.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#100a03\"\n        },\n        \"Background.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a1005\"\n        },\n        \"Background.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#100a03\"\n        },\n        \"Background.Panel\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#100a03\"\n        },\n        \"Background.Header\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a1a08\"\n        },\n        \"Background.Footer\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a1a08\"\n        },\n        \"Foreground.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffeecc\"\n        },\n        \"Foreground.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffeecc\"\n        },\n        \"Foreground.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Title\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa33\"\n        },\n        \"Foreground.Muted\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aa8855\"\n        },\n        \"Foreground.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa00\"\n        },\n        \"Foreground.Error\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff3333\"\n        },\n        \"Foreground.Success\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33ff88\"\n        },\n        \"Foreground.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aa8855\"\n        },\n        \"Foreground.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa33\"\n        },\n        \"Border.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#cc8822\"\n        }\n    }\n}"}, {"path": "themes/lime.json", "content": "{\n    \"Name\": \"Lime\",\n    \"Hex\": \"#33cc66\",\n    \"Description\": \"Fresh lime green\",\n    \"Properties\": {\n        \"Background.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#001a0d\"\n        },\n        \"Background.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a3d1f\"\n        },\n        \"Background.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#001a0d\"\n        },\n        \"Background.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a3d1f\"\n        },\n        \"Background.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#332200\"\n        },\n        \"Background.MenuBar\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#052a14\"\n        },\n        \"Background.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a3d1f\"\n        },\n        \"Background.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#021a0a\"\n        },\n        \"Background.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#001a0d\"\n        },\n        \"Background.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#021a0a\"\n        },\n        \"Background.Panel\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#021a0a\"\n        },\n        \"Background.Header\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#052a14\"\n        },\n        \"Background.Footer\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#052a14\"\n        },\n        \"Foreground.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aaffcc\"\n        },\n        \"Foreground.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aaffcc\"\n        },\n        \"Foreground.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Title\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33cc66\"\n        },\n        \"Foreground.Muted\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#558866\"\n        },\n        \"Foreground.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa00\"\n        },\n        \"Foreground.Error\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff3333\"\n        },\n        \"Foreground.Success\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33ff88\"\n        },\n        \"Foreground.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#558866\"\n        },\n        \"Foreground.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33cc66\"\n        },\n        \"Border.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#229944\"\n        }\n    }\n}"}, {"path": "themes/ocean.json", "content": "{\n    \"Name\": \"Ocean\",\n    \"Hex\": \"#33aaff\",\n    \"Description\": \"Cool ocean blue\",\n    \"Properties\": {\n        \"Background.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#001020\"\n        },\n        \"Background.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#003050\"\n        },\n        \"Background.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#001020\"\n        },\n        \"Background.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#003050\"\n        },\n        \"Background.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#332200\"\n        },\n        \"Background.MenuBar\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#002040\"\n        },\n        \"Background.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#003050\"\n        },\n        \"Background.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#001525\"\n        },\n        \"Background.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#001020\"\n        },\n        \"Background.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#001525\"\n        },\n        \"Background.Panel\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#001525\"\n        },\n        \"Background.Header\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#002040\"\n        },\n        \"Background.Footer\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#002040\"\n        },\n        \"Foreground.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aaddff\"\n        },\n        \"Foreground.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aaddff\"\n        },\n        \"Foreground.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Title\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33aaff\"\n        },\n        \"Foreground.Muted\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#5588aa\"\n        },\n        \"Foreground.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa00\"\n        },\n        \"Foreground.Error\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff3333\"\n        },\n        \"Foreground.Success\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33ff88\"\n        },\n        \"Foreground.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#5588aa\"\n        },\n        \"Foreground.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33aaff\"\n        },\n        \"Border.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2277bb\"\n        }\n    }\n}"}, {"path": "themes/purple.json", "content": "{\n    \"Name\": \"Purple\",\n    \"Hex\": \"#9966ff\",\n    \"Description\": \"Vibrant purple\",\n    \"Properties\": {\n        \"Background.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0d0a1a\"\n        },\n        \"Background.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a1f4d\"\n        },\n        \"Background.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0d0a1a\"\n        },\n        \"Background.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a1f4d\"\n        },\n        \"Background.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#332200\"\n        },\n        \"Background.MenuBar\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a1433\"\n        },\n        \"Background.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a1f4d\"\n        },\n        \"Background.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a0815\"\n        },\n        \"Background.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0d0a1a\"\n        },\n        \"Background.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a0815\"\n        },\n        \"Background.Panel\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a0815\"\n        },\n        \"Background.Header\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a1433\"\n        },\n        \"Background.Footer\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a1433\"\n        },\n        \"Foreground.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ddccff\"\n        },\n        \"Foreground.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ddccff\"\n        },\n        \"Foreground.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Title\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#9966ff\"\n        },\n        \"Foreground.Muted\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#7755aa\"\n        },\n        \"Foreground.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa00\"\n        },\n        \"Foreground.Error\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff3333\"\n        },\n        \"Foreground.Success\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33ff88\"\n        },\n        \"Foreground.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#7755aa\"\n        },\n        \"Foreground.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#9966ff\"\n        },\n        \"Border.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#6644cc\"\n        }\n    }\n}"}, {"path": "themes/rose.json", "content": "{\n    \"Name\": \"Rose\",\n    \"Hex\": \"#ff6699\",\n    \"Description\": \"Soft rose pink\",\n    \"Properties\": {\n        \"Background.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a0d12\"\n        },\n        \"Background.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#3d1f2a\"\n        },\n        \"Background.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a0d12\"\n        },\n        \"Background.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#3d1f2a\"\n        },\n        \"Background.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#332200\"\n        },\n        \"Background.MenuBar\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a151c\"\n        },\n        \"Background.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#3d1f2a\"\n        },\n        \"Background.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#10080a\"\n        },\n        \"Background.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a0d12\"\n        },\n        \"Background.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#10080a\"\n        },\n        \"Background.Panel\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#10080a\"\n        },\n        \"Background.Header\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a151c\"\n        },\n        \"Background.Footer\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a151c\"\n        },\n        \"Foreground.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffccdd\"\n        },\n        \"Foreground.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffccdd\"\n        },\n        \"Foreground.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Title\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff6699\"\n        },\n        \"Foreground.Muted\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aa6677\"\n        },\n        \"Foreground.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa00\"\n        },\n        \"Foreground.Error\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff3333\"\n        },\n        \"Foreground.Success\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33ff88\"\n        },\n        \"Foreground.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aa6677\"\n        },\n        \"Foreground.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff6699\"\n        },\n        \"Border.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#cc4477\"\n        }\n    }\n}"}, {"path": "themes/sky.json", "content": "{\n    \"Name\": \"Sky\",\n    \"Hex\": \"#66ccff\",\n    \"Description\": \"Bright sky blue\",\n    \"Properties\": {\n        \"Background.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a1520\"\n        },\n        \"Background.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a3050\"\n        },\n        \"Background.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a1520\"\n        },\n        \"Background.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a3050\"\n        },\n        \"Background.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#332200\"\n        },\n        \"Background.MenuBar\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#102030\"\n        },\n        \"Background.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a3050\"\n        },\n        \"Background.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#050a10\"\n        },\n        \"Background.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0a1520\"\n        },\n        \"Background.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#050a10\"\n        },\n        \"Background.Panel\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#050a10\"\n        },\n        \"Background.Header\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#102030\"\n        },\n        \"Background.Footer\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#102030\"\n        },\n        \"Foreground.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#cceeff\"\n        },\n        \"Foreground.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#cceeff\"\n        },\n        \"Foreground.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Title\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#66ccff\"\n        },\n        \"Foreground.Muted\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#5599bb\"\n        },\n        \"Foreground.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa00\"\n        },\n        \"Foreground.Error\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff3333\"\n        },\n        \"Foreground.Success\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33ff88\"\n        },\n        \"Foreground.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#5599bb\"\n        },\n        \"Foreground.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#66ccff\"\n        },\n        \"Border.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#4499cc\"\n        }\n    }\n}"}, {"path": "themes/slate.json", "content": "{\n    \"Name\": \"Slate\",\n    \"Hex\": \"#8899aa\",\n    \"Description\": \"Cool blue-gray\",\n    \"Properties\": {\n        \"Background.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#101215\"\n        },\n        \"Background.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#252a30\"\n        },\n        \"Background.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#101215\"\n        },\n        \"Background.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#252a30\"\n        },\n        \"Background.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#332200\"\n        },\n        \"Background.MenuBar\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a1d22\"\n        },\n        \"Background.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#252a30\"\n        },\n        \"Background.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0d0f12\"\n        },\n        \"Background.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#101215\"\n        },\n        \"Background.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0d0f12\"\n        },\n        \"Background.Panel\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#0d0f12\"\n        },\n        \"Background.Header\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a1d22\"\n        },\n        \"Background.Footer\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a1d22\"\n        },\n        \"Foreground.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ccd0d8\"\n        },\n        \"Foreground.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ccd0d8\"\n        },\n        \"Foreground.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Title\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#8899aa\"\n        },\n        \"Foreground.Muted\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#667080\"\n        },\n        \"Foreground.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa00\"\n        },\n        \"Foreground.Error\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff3333\"\n        },\n        \"Foreground.Success\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33ff88\"\n        },\n        \"Foreground.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#667080\"\n        },\n        \"Foreground.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#8899aa\"\n        },\n        \"Border.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#556677\"\n        }\n    }\n}"}, {"path": "themes/sunset.json", "content": "{\n    \"Name\": \"Sunset\",\n    \"Hex\": \"#ff8833\",\n    \"Description\": \"Warm sunset orange\",\n    \"Properties\": {\n        \"Background.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a0d05\"\n        },\n        \"Background.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#3d1f0a\"\n        },\n        \"Background.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a0d05\"\n        },\n        \"Background.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#3d1f0a\"\n        },\n        \"Background.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#332200\"\n        },\n        \"Background.MenuBar\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a1508\"\n        },\n        \"Background.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#3d1f0a\"\n        },\n        \"Background.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#100805\"\n        },\n        \"Background.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#1a0d05\"\n        },\n        \"Background.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#100805\"\n        },\n        \"Background.Panel\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#100805\"\n        },\n        \"Background.Header\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a1508\"\n        },\n        \"Background.Footer\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#2a1508\"\n        },\n        \"Foreground.Field\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffddbb\"\n        },\n        \"Foreground.FieldFocused\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Row\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffddbb\"\n        },\n        \"Foreground.RowSelected\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.Title\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff8833\"\n        },\n        \"Foreground.Muted\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aa7755\"\n        },\n        \"Foreground.Warning\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffaa00\"\n        },\n        \"Foreground.Error\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff3333\"\n        },\n        \"Foreground.Success\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#33ff88\"\n        },\n        \"Foreground.TabActive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ffffff\"\n        },\n        \"Foreground.TabInactive\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#aa7755\"\n        },\n        \"Foreground.Primary\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#ff8833\"\n        },\n        \"Border.Widget\": {\n            \"Type\": \"Solid\",\n            \"Color\": \"#cc5522\"\n        }\n    }\n}"}, {"path": "themes/synthwave.json", "content": "{\n  \"Name\": \"Synthwave\",\n  \"Hex\": \"#ff00ff\",\n  \"Description\": \"GRADIENT: MAGENTA → CYAN\",\n  \"Properties\": {\n    \"Background.Field\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#0a0015\"\n    },\n    \"Background.FieldFocused\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#2a0040\"\n    },\n    \"Background.Row\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#0a0015\"\n    },\n    \"Background.RowSelected\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#2a0040\"\n    },\n    \"Background.Warning\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#332200\"\n    },\n    \"Background.MenuBar\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#1a0030\"\n    },\n    \"Background.TabActive\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#2a0040\"\n    },\n    \"Background.TabInactive\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#0f001a\"\n    },\n    \"Background.Primary\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#0a0015\"\n    },\n    \"Background.Widget\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#0f001a\"\n    },\n    \"Background.Panel\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#0f001a\"\n    },\n    \"Background.Header\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#1a0030\"\n    },\n    \"Background.Footer\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#1a0030\"\n    },\n    \"Foreground.Field\": {\n      \"Type\": \"Gradient\",\n      \"Start\": \"#ff00ff\",\n      \"End\": \"#00ffff\"\n    },\n    \"Foreground.FieldFocused\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#ffffff\"\n    },\n    \"Foreground.Row\": {\n      \"Type\": \"Gradient\",\n      \"Start\": \"#ff00ff\",\n      \"End\": \"#00ffff\"\n    },\n    \"Foreground.RowSelected\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#ffffff\"\n    },\n    \"Foreground.Title\": {\n      \"Type\": \"Gradient\",\n      \"Start\": \"#ff00ff\",\n      \"End\": \"#00ffff\"\n    },\n    \"Foreground.Muted\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#b366ff\"\n    },\n    \"Foreground.Warning\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#ffaa00\"\n    },\n    \"Foreground.Error\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#ff3333\"\n    },\n    \"Foreground.Success\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#33ff88\"\n    },\n    \"Foreground.TabActive\": {\n      \"Type\": \"Gradient\",\n      \"Start\": \"#ff00ff\",\n      \"End\": \"#00ffff\"\n    },\n    \"Foreground.TabInactive\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#b366ff\"\n    },\n    \"Foreground.Primary\": {\n      \"Type\": \"Gradient\",\n      \"Start\": \"#ff00ff\",\n      \"End\": \"#00ffff\"\n    },\n    \"Border.Widget\": {\n      \"Type\": \"Solid\",\n      \"Color\": \"#ff00ff\"\n    }\n  }\n}"}]
___END_PMC_DATA___
#>
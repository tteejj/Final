# V3 Upgrade Master Plan: "Pro" Editor & Native Theming

This document details the exact steps and code required to bring the V3 NoteEditor to 100% parity with the legacy editor (and beyond) while maintaining strict performance.

---

## Part 1: Native Theming System
**Goal**: Remove hardcoded color constants without introducing slow hashtable lookups.

### 1. The Theme Service (`ThemeService.ps1`)
Create a new singleton service that holds the current palette in strict fields.

```powershell
using namespace System.Collections.Generic

class PmcPalette {
    # Strictly typed properties for maximum JIT optimization
    [int] $Foreground
    [int] $Background
    [int] $PanelBg
    [int] $PanelBorder
    [int] $Accent
    [int] $SelectionBg
    [int] $SelectionFg
    [int] $Error
    [int] $Success
    [int] $Warning
    
    PmcPalette() {
        # Default Fallback (VS Code Dark style)
        $this.Foreground = 0xD4D4D4
        $this.Background = 0x1E1E1E
        $this.PanelBg = 0x252526
        $this.PanelBorder = 0x3E3E42
        $this.Accent = 0x007ACC
    }
}

class ThemeService {
    static [PmcPalette] $Current
    
    static [void] Initialize() {
        if ($null -eq [ThemeService]::Current) {
            [ThemeService]::Current = [PmcPalette]::new()
        }
    }
    
    static [void] LoadTheme([hashtable]$themeData) {
        # Parse incoming JSON/Hash into strict object
        $p = [ThemeService]::Current
        if ($themeData.Foreground) { $p.Foreground = $themeData.Foreground }
        if ($themeData.Background) { $p.Background = $themeData.Background }
        # ... map all properties ...
    }
}
```

### 2. The Bridge (`Colors` Class Update)
Modify `v3/Enums.ps1` to redirect the `Colors` class to the Service. This is the "Magic" that allows us to keep using `[Colors]::Foreground` syntax but making it dynamic.

```powershell
class Colors {
    # These become getters instead of static fields
    static [int] get_Foreground() { return [ThemeService]::Current.Foreground }
    static [int] get_Background() { return [ThemeService]::Current.Background }
    static [int] get_PanelBg()    { return [ThemeService]::Current.PanelBg }
    
    # Common colors can remain static if they never change (e.g., pure Black/White)
    static [int] $Black = 0x000000
    static [int] $White = 0xFFFFFF
}
```

**Performance Impact**: Minimal. A Static Getter is an extremely cheap method call in .NET. It avoids the heavy dictionary lookup of the legacy `ThemeManager`.

---

## Part 2: Editor Feature Parity
**Goal**: Add Undo/Redo, Block Selection, and Word Nav to V3 NoteEditor.

### 1. Robust Selection System
Legacy editor used `SelectionMode`. We need that enum back.

```powershell
enum SelectionMode {
    None
    Stream  # Character by character
    Block   # Rectangular (Columnar)
}

# In NoteEditor class:
hidden [SelectionMode]$_selectionMode = [SelectionMode]::None
hidden [int]$_selectionAnchorX
hidden [int]$_selectionAnchorY
```

#### Block Selection Logic
When rendering, we must check if a character falls inside the "visual rectangle".

```powershell
# In RenderAndEdit() loop:

# Calculate visual selection bounds
$selMinX = [Math]::Min($this._selectionAnchorX, $this._cursorX)
$selMaxX = [Math]::Max($this._selectionAnchorX, $this._cursorX)
$selMinY = [Math]::Min($this._selectionAnchorY, $this._cursorY)
$selMaxY = [Math]::Max($this._selectionAnchorY, $this._cursorY)

# Inside character loop (Line $i, Col $j):
$isSelected = $false
if ($this._selectionMode -eq [SelectionMode]::Block) {
    if ($i -ge $selMinY -and $i -le $selMaxY) {
        if ($j -ge $selMinX -and $j -lt $selMaxX) {
            $isSelected = $true
        }
    }
} else {
    # ... existing Stream selection logic ...
}
```

### 2. Word Navigation (`Ctrl+Left/Right`)

```powershell
# Usage: Ctrl+Left
hidden [void] _MoveWordLeft() {
    $text = $this._buffer.GetText()
    if ($this._cursorPos -eq 0) { return }
    
    $pos = $this._cursorPos
    
    # scan back over whitespace
    while ($pos -gt 0 -and [char]::IsWhiteSpace($text[$pos-1])) { $pos-- }
    
    # scan back over word chars
    while ($pos -gt 0 -and -not [char]::IsWhiteSpace($text[$pos-1])) { $pos-- }
    
    $this._cursorPos = $pos
}
```

### 3. Undo/Redo System
Implement a lightweight state tracker.

```powershell
class EditorState {
    [string] $Text
    [int] $CursorPos
}

class NoteEditor {
    hidden [System.Collections.Generic.Stack[EditorState]] $_undoStack
    hidden [System.Collections.Generic.Stack[EditorState]] $_redoStack
    
    # Call this BEFORE any edit
    hidden [void] _SaveUndo() {
        $state = [EditorState]::new()
        $state.Text = $this._buffer.GetText()
        $state.CursorPos = $this._cursorPos
        $this._undoStack.Push($state)
        $this._redoStack.Clear() # New edit invalidates redo
        
        # Cap stack size to prevent memory bloat
        if ($this._undoStack.Count -gt 50) { 
            # Note: Stack doesn't support RemoveLast easily, 
            # often better to implement a RingBuffer or just let GC handle it for now.
        }
    }
    
    hidden [void] _Undo() {
        if ($this._undoStack.Count -gt 0) {
            # Save current state to Redo
            $current = [EditorState]::new()
            $current.Text = $this._buffer.GetText()
            $current.CursorPos = $this._cursorPos
            $this._redoStack.Push($current)
            
            # Application Undo
            $prev = $this._undoStack.Pop()
            $this._buffer = [GapBuffer]::new($prev.Text)
            $this._cursorPos = $prev.CursorPos
        }
    }
}
```

## Implementation Checklist
1.  **Create** `v3/ThemeService.ps1` with the classes above.
2.  **Modify** `v3/Enums.ps1` to convert `Colors` to use getters.
3.  **Bootstrap**: Add `. "$PSScriptRoot/ThemeService.ps1"` to `start-v3.ps1` and call `[ThemeService]::Initialize()`.
4.  **Modify** `v3/NoteEditor.ps1`:
    *   Add `Undo/Redo` stacks.
    *   Add `Ctrl+Z` / `Ctrl+Y` handlers.
    *   Add `Ctrl+Left/Right` word navigation methods.
